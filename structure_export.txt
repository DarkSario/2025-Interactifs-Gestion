# === Fichier: ./export_structure_Version3.py ===

```python
import os

# Dossiers/racine Ã  inclure (adapte si besoin)
ROOTS = [
    ".",               # racine (main.py, README.md, etc.)
    "club_manager",
    "resources",
    "modules",
    "scripts",
    "tests"
]

# Extensions de fichiers Ã  inclure
INCLUDE_EXT = {".py", ".md", ".txt", ".toml", ".ini", ".csv", ".yml", ".yaml", ".ui" ".db"}

# Fichiers/dossiers Ã  exclure
EXCLUDE_FILES = {".gitignore", "structure_export.txt", "export_structure.py", "__pycache__"}
EXCLUDE_DIRS = {".git", "__pycache__", "build", "dist", ".mypy_cache"}

EXPORT_FILE = "structure_export.txt"
SPLIT_MARKER = "\n\n# ===== FICHIER SUIVANT =====\n\n"

def is_valid_file(path):
    base = os.path.basename(path)
    ext = os.path.splitext(base)[1].lower()
    if base in EXCLUDE_FILES:
        return False
    if ext not in INCLUDE_EXT:
        return False
    return True

def walk_files():
    for root in ROOTS:
        if not os.path.exists(root):
            continue
        for dirpath, dirnames, filenames in os.walk(root):
            dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]
            for fname in filenames:
                fpath = os.path.join(dirpath, fname)
                if is_valid_file(fpath):
                    yield fpath.replace("\\", "/")

def export_structure():
    parts = []
    for fpath in walk_files():
        try:
            with open(fpath, encoding="utf-8") as f:
                content = f.read()
        except Exception as e:
            content = f"# ERREUR DE LECTURE : {e}"
        part = f"# === Fichier: {fpath} ===\n\n"
        ext = os.path.splitext(fpath)[1].lower()
        if ext == ".py":
            part += f"```python\n{content}\n```\n"
        elif ext == ".md":
            part += f"````markdown\n{content}\n````\n"
        elif ext in (".yml", ".yaml"):
            part += f"```yaml\n{content}\n```\n"
        elif ext in (".toml", ".ini"):
            part += f"```toml\n{content}\n```\n"
        else:
            part += f"```\n{content}\n```\n"
        parts.append(part)
    with open(EXPORT_FILE, "w", encoding="utf-8") as out:
        out.write(SPLIT_MARKER.join(parts))
    print(f"Export terminÃ© dans {EXPORT_FILE} ({len(parts)} fichiers).")

if __name__ == "__main__":
    export_structure()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./init_db.py ===

```python
import sqlite3

SCHEMA = """
CREATE TABLE IF NOT EXISTS events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    date TEXT NOT NULL,
    lieu TEXT,
    commentaire TEXT
);

CREATE TABLE IF NOT EXISTS event_modules (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_id INTEGER NOT NULL,
    nom_module TEXT NOT NULL,
    FOREIGN KEY(event_id) REFERENCES events(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS event_module_fields (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    module_id INTEGER NOT NULL,
    nom_champ TEXT NOT NULL,
    type_champ TEXT NOT NULL,
    FOREIGN KEY(module_id) REFERENCES event_modules(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS event_module_data (
    module_id INTEGER NOT NULL,
    row_index INTEGER NOT NULL,
    field_id INTEGER NOT NULL,
    valeur TEXT,
    PRIMARY KEY (module_id, row_index, field_id),
    FOREIGN KEY(module_id) REFERENCES event_modules(id) ON DELETE CASCADE,
    FOREIGN KEY(field_id) REFERENCES event_module_fields(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS members (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    prenom TEXT NOT NULL,
    email TEXT,
    classe TEXT,
    cotisation REAL,
    commentaire TEXT
);

CREATE TABLE IF NOT EXISTS dons_subventions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    donateur TEXT NOT NULL,
    montant REAL NOT NULL,
    date TEXT NOT NULL,
    commentaire TEXT
);

CREATE TABLE IF NOT EXISTS depenses_regulieres (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    libelle TEXT NOT NULL,
    montant REAL NOT NULL,
    date TEXT NOT NULL,
    categorie TEXT,
    commentaire TEXT
);

CREATE TABLE IF NOT EXISTS depenses_diverses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    libelle TEXT NOT NULL,
    montant REAL NOT NULL,
    date TEXT NOT NULL,
    categorie TEXT,
    commentaire TEXT
);

CREATE TABLE IF NOT EXISTS journal (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    date TEXT NOT NULL,
    libelle TEXT NOT NULL,
    montant REAL NOT NULL,
    type TEXT NOT NULL,
    categorie TEXT,
    commentaire TEXT
);

CREATE TABLE IF NOT EXISTS categories (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    parent_id INTEGER
);

CREATE TABLE IF NOT EXISTS stock (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    categorie_id INTEGER,
    quantite INTEGER NOT NULL,
    seuil_alerte INTEGER NOT NULL,
    date_peremption TEXT,
    lot TEXT,
    commentaire TEXT,
    FOREIGN KEY(categorie_id) REFERENCES categories(id)
);
"""

def main():
    conn = sqlite3.connect("association.db")
    conn.executescript(SCHEMA)
    conn.commit()
    conn.close()
    print("Base de donnÃ©es initialisÃ©e avec succÃ¨s.")

if __name__ == "__main__":
    main()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./main.py ===

```python
import tkinter as tk
import os
import sys
from tkinter import messagebox, Toplevel, Label, Button
from tkcalendar import DateEntry

from db.db import (
    init_db, is_first_launch, save_init_info, get_connection,
    upgrade_db_structure, get_db_file
)
from ui import startup_schema_check
from modules.events import EventsWindow
from modules.stock import StockModule
from modules.buvette import BuvetteModule
from modules.members import MembersModule
from modules.dons_subventions import DonsSubventionsModule
from modules.depenses_regulieres import DepensesRegulieresModule
from modules.depenses_diverses import DepensesDiversesModule
from modules.journal import JournalModule
from modules.cloture_exercice import ClotureExerciceModule
from modules.exports import ExportsWindow
from dashboard.dashboard import DashboardModule
from modules.fournisseurs import FournisseursWindow
from utils import backup_restore
from modules.depots_retraits_banque import DepotsRetraitsBanqueModule
from modules.solde_ouverture import SoldeOuvertureDialog
from modules.historique_clotures import HistoriqueCloturesModule
from modules.retrocessions_ecoles import RetrocessionsEcolesModule
from utils.error_handler import handle_errors

DB_FILE = "association.db"

if not os.path.exists(DB_FILE):
    init_db()

# ==== Logique mÃ©tier isolÃ©e ====

def get_current_exercice_info():
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("SELECT exercice, date FROM config ORDER BY id DESC LIMIT 1")
    row = cur.fetchone()
    conn.close()
    if row:
        return row["exercice"], row["date"]
    else:
        return None, None

def update_exercice_info(exercice, date, disponible_banque):
    conn = get_connection()
    cur = conn.cursor()
    cur.execute(
        "UPDATE config SET exercice=?, date=?, disponible_banque=? WHERE id=(SELECT id FROM config ORDER BY id DESC LIMIT 1)",
        (exercice, date, disponible_banque)
    )
    conn.commit()
    conn.close()

# ==== Main Application UI ====

class MainApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Gestion Association Les Interactifs des Ecoles")
        if is_first_launch():
            self.init_first_launch()
        
        # VÃ©rification automatique du schÃ©ma de base de donnÃ©es
        if os.path.exists(DB_FILE):
            try:
                startup_schema_check.run_check(self, DB_FILE)
            except Exception as e:
                print(f"Warning: Schema check failed: {e}")
        
        self.create_menu()
        self.create_home_buttons()

        # Status bar
        self.status_var = tk.StringVar()
        self.status_label = tk.Label(self, textvariable=self.status_var, anchor="e")
        self.status_label.pack(side=tk.BOTTOM, fill=tk.X)
        self.update_dbfile_status()
        backup_restore.set_status_callback(self.update_dbfile_status)

    def update_dbfile_status(self):
        dbfile = get_db_file()
        self.status_var.set(f"Base de donnÃ©es : {dbfile}")
        self.title(f"Gestion Association Les Interactifs des Ecoles [{dbfile}]")

    def init_first_launch(self):
        dialog = Toplevel(self)
        dialog.title("Initialisation")
        dialog.grab_set()
        dialog.resizable(False, False)

        Label(dialog, text="Name de l'exercice (ex: 2024-2025) :").pack(padx=10, pady=(12,2), anchor="w")
        exercice_var = tk.StringVar()
        tk.Entry(dialog, textvariable=exercice_var).pack(padx=10, pady=2, anchor="w")

        Label(dialog, text="Date de dÃ©but de l'exercice :").pack(padx=10, pady=(12,2), anchor="w")
        date_var = tk.StringVar()
        date_entry = DateEntry(dialog, textvariable=date_var, date_pattern='yyyy-mm-dd', width=18)
        date_entry.pack(padx=10, pady=2, anchor="w")

        Label(dialog, text="Disponible sur le compte bancaire (â‚¬) :").pack(padx=10, pady=(12,2), anchor="w")
        banque_var = tk.DoubleVar()
        tk.Entry(dialog, textvariable=banque_var).pack(padx=10, pady=2, anchor="w")

        def valider():
            exercice = exercice_var.get()
            date = date_var.get()
            try:
                disponible_banque = float(banque_var.get())
            except Exception:
                disponible_banque = None
            if exercice and date and disponible_banque is not None:
                save_init_info(exercice, date, None, disponible_banque)
                dialog.destroy()
                messagebox.showinfo("Bienvenue", "Initialisation effectuÃ©e !")
            else:
                messagebox.showwarning("Attention", "Toutes les informations doivent Ãªtre saisies pour l'initialisation.")

        btn_frame = tk.Frame(dialog)
        btn_frame.pack(pady=10)
        Button(btn_frame, text="OK", command=valider, width=10).pack(side="left", padx=10)
        Button(btn_frame, text="Annuler", command=dialog.destroy, width=10).pack(side="right", padx=10)
        dialog.wait_window()

    @handle_errors
    def edit_exercice(self):
        conn = get_connection()
        cur = conn.cursor()
        cur.execute("SELECT * FROM config ORDER BY id DESC LIMIT 1")
        row = cur.fetchone()
        conn.close()

        if not row:
            messagebox.showwarning("Aucun exercice", "Aucune information d'exercice trouvÃ©e.")
            return

        dialog = Toplevel(self)
        dialog.title("Modifier l'exercice")
        dialog.grab_set()
        dialog.resizable(False, False)

        Label(dialog, text="Name de l'exercice (ex: 2024-2025) :").pack(padx=10, pady=(12,2), anchor="w")
        exercice_var = tk.StringVar(value=row["exercice"])
        tk.Entry(dialog, textvariable=exercice_var).pack(padx=10, pady=2, anchor="w")

        Label(dialog, text="Date de dÃ©but de l'exercice :").pack(padx=10, pady=(12,2), anchor="w")
        date_var = tk.StringVar(value=row["date"])
        date_entry = DateEntry(dialog, textvariable=date_var, date_pattern='yyyy-mm-dd', width=18)
        date_entry.pack(padx=10, pady=2, anchor="w")

        Label(dialog, text="Disponible sur le compte bancaire (â‚¬) :").pack(padx=10, pady=(12,2), anchor="w")
        banque_var = tk.DoubleVar(value=row["disponible_banque"] if row["disponible_banque"] is not None else 0)
        tk.Entry(dialog, textvariable=banque_var).pack(padx=10, pady=2, anchor="w")

        def valider():
            exercice = exercice_var.get()
            date = date_var.get()
            try:
                disponible_banque = float(banque_var.get())
            except Exception:
                disponible_banque = None
            if exercice and date and disponible_banque is not None:
                update_exercice_info(exercice, date, disponible_banque)
                dialog.destroy()
                messagebox.showinfo("SuccÃ¨s", "Exercice modifiÃ© !")
                self.create_home_buttons()
            else:
                messagebox.showwarning("Attention", "Toutes les informations doivent Ãªtre saisies pour la modification.")

        btn_frame = tk.Frame(dialog)
        btn_frame.pack(pady=10)
        Button(btn_frame, text="Enregistrer", command=valider, width=12).pack(side="left", padx=10)
        Button(btn_frame, text="Annuler", command=dialog.destroy, width=12).pack(side="right", padx=10)
        dialog.wait_window()

    def create_menu(self):
        menubar = tk.Menu(self)
        self.config(menu=menubar)

        modules_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Modules", menu=modules_menu)
        modules_menu.add_command(label="Ã‰vÃ©nements", command=handle_errors(lambda: EventsWindow(self)))
        modules_menu.add_command(label="Stock", command=handle_errors(lambda: StockModule(self)))
        modules_menu.add_command(label="Buvette", command=handle_errors(lambda: BuvetteModule(self)))
        modules_menu.add_command(label="Membres", command=handle_errors(lambda: MembersModule(self)))
        modules_menu.add_command(label="Dons/Subventions", command=handle_errors(lambda: DonsSubventionsModule(self)))
        modules_menu.add_command(label="DÃ©penses RÃ©guliÃ¨res", command=handle_errors(lambda: DepensesRegulieresModule(self)))
        modules_menu.add_command(label="DÃ©penses Diverses", command=handle_errors(lambda: DepensesDiversesModule(self)))
        modules_menu.add_separator()
        modules_menu.add_command(label="RÃ©trocessions aux Ã©coles", command=handle_errors(lambda: RetrocessionsEcolesModule(self)))
        modules_menu.add_separator()
        modules_menu.add_command(label="GÃ©rer les fournisseurs", command=handle_errors(lambda: FournisseursWindow(self)))
        modules_menu.add_separator()
        modules_menu.add_command(label="ClÃ´ture Exercice", command=handle_errors(lambda: ClotureExerciceModule(self)))

        menubar.add_command(label="Exports", command=handle_errors(lambda: ExportsWindow(self)))
        menubar.add_command(label="Tableau de Bord", command=handle_errors(lambda: DashboardModule(self)))
        menubar.add_command(label="Journal GÃ©nÃ©ral", command=handle_errors(lambda: JournalModule(self)))

        # Sous-menu Administration
        params_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Administration", menu=params_menu)
        params_menu.add_command(label="Ã‰diter exercice", command=self.edit_exercice)
        params_menu.add_command(label="Solde d'ouverture bancaire", command=handle_errors(lambda: SoldeOuvertureDialog(self)))
        params_menu.add_command(label="Gestion des clÃ´tures", command=handle_errors(lambda: HistoriqueCloturesModule(self)))
        params_menu.add_command(label="Sauvegarder la base...", command=handle_errors(backup_restore.backup_database))
        params_menu.add_command(label="Restaurer la base...", command=handle_errors(backup_restore.restore_database))
        params_menu.add_command(label="Ouvrir une autre base...", command=handle_errors(backup_restore.open_database))
        params_menu.add_separator()
        params_menu.add_command(label="RÃ©initialiser les donnÃ©es", command=handle_errors(self.reset_data))
        params_menu.add_command(label="Mettre Ã  jour la structure de la base", command=handle_errors(self.menu_upgrade_db_structure))

        menubar.add_command(label="Quitter", command=self.quit)

    @handle_errors
    def menu_upgrade_db_structure(self):
        # Message d'information pour la migration
        migration_message = (
            "Voulez-vous mettre Ã  jour/adapter la structure de la base de donnÃ©es ?\n\n"
            "Cette opÃ©ration va :\n"
            "- CrÃ©er une sauvegarde automatique timestampÃ©e\n"
            "- Ajouter les colonnes manquantes sans perte de donnÃ©es\n"
            "- Optimiser la base de donnÃ©es (WAL mode)\n"
            "- GÃ©nÃ©rer un rapport dÃ©taillÃ©\n\n"
            "Souhaitez-vous continuer ?"
        )
        
        if messagebox.askyesno("Mise Ã  jour", migration_message):
            # Utiliser le nouveau script de migration sÃ»r
            try:
                import subprocess
                db_path = get_db_file()
                result = subprocess.run(
                    [sys.executable, "scripts/update_db_structure.py", "--db-path", db_path],
                    capture_output=True,
                    text=True,
                    cwd=os.path.dirname(os.path.abspath(__file__))
                )
                
                if result.returncode == 0:
                    messagebox.showinfo(
                        "SuccÃ¨s",
                        "Mise Ã  jour de la structure terminÃ©e avec succÃ¨s !\n\n"
                        "Un rapport dÃ©taillÃ© a Ã©tÃ© gÃ©nÃ©rÃ© dans le rÃ©pertoire scripts/.\n"
                        "Une sauvegarde de votre base a Ã©tÃ© crÃ©Ã©e automatiquement."
                    )
                else:
                    messagebox.showerror(
                        "Erreur",
                        f"La mise Ã  jour a Ã©chouÃ©.\n\nDÃ©tails :\n{result.stderr[:500]}"
                    )
            except Exception as e:
                messagebox.showerror("Erreur", f"Impossible d'exÃ©cuter la mise Ã  jour : {e}")

    @handle_errors
    def reset_data(self):
        confirm = messagebox.askyesno(
            "Confirmation",
            "Voulez-vous vraiment rÃ©initialiser toutes les donnÃ©es ?\nCette action est irrÃ©versible."
        )
        if confirm:
            if os.path.exists(DB_FILE):
                os.remove(DB_FILE)
            messagebox.showinfo(
                "RÃ©initialisation",
                "DonnÃ©es effacÃ©es. L'application va redÃ©marrer pour une nouvelle initialisation."
            )
            self.destroy()
            os.execl(sys.executable, sys.executable, *os.sys.argv)

    def create_home_buttons(self):
        for widget in self.winfo_children():
            if not isinstance(widget, tk.Menu) and not (hasattr(self, "status_label") and widget is self.status_label):
                widget.destroy()
        tk.Label(self, text="Les Interactifs des Ecoles", font=("Arial", 18, "bold")).pack(pady=(25,2))

        # Ajoute l'exercice en cours et sa date de dÃ©but
        exercice, date = get_current_exercice_info()
        if exercice and date:
            info_exercice = f"Exercice en cours : {exercice} (DÃ©but : {date})"
        else:
            info_exercice = "Aucun exercice en cours"
        tk.Label(self, text=info_exercice, font=("Arial", 13, "italic"), fg="blue").pack(pady=(2,20))

        # Frame pour les boutons
        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=15)

        buttons = [
            ("Ã‰vÃ©nements", lambda: EventsWindow(self)),
            ("Stock", lambda: StockModule(self)),
            ("Buvette", lambda: BuvetteModule(self)),
            ("Membres", lambda: MembersModule(self)),
            ("Dons/Subventions", lambda: DonsSubventionsModule(self)),
            ("DÃ©penses RÃ©guliÃ¨res", lambda: DepensesRegulieresModule(self)),
            ("DÃ©penses Diverses", lambda: DepensesDiversesModule(self)),
            ("RÃ©trocessions aux Ã©coles", lambda: RetrocessionsEcolesModule(self)),
            ("DÃ©pÃ´ts/Retraits Banque", lambda: DepotsRetraitsBanqueModule(self)),
            ("ClÃ´ture Exercice", lambda: ClotureExerciceModule(self)),
            ("Exports / Bilans", lambda: ExportsWindow(self)),
        ]

        cols = 3
        for idx, (label, action) in enumerate(buttons):
            btn = tk.Button(
                btn_frame, text=label, command=handle_errors(action),
                width=20, height=3, font=("Arial", 12, "bold")
            )
            row, col = divmod(idx, cols)
            btn.grid(row=row, column=col, padx=12, pady=12)

        self.update_idletasks()
        self.geometry("")

if __name__ == "__main__":
    app = MainApp()
    app.mainloop()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./README.md ===

````markdown
# Gestion Association â€“ Application Desktop

Un logiciel libre, multiplateforme, pour gÃ©rer la vie et la comptabilitÃ© dâ€™une association scolaire ou Ã©quivalent.

## FonctionnalitÃ©s principales

- **Membres** : gestion des adhÃ©rents (contact, statut, cotisation)
- **Ã‰vÃ©nements** : gestion des manifestations, modules dynamiques associÃ©s, recettes, dÃ©penses, paiements, caisses
- **Finances** : suivi des dons, subventions, dÃ©penses rÃ©guliÃ¨res/diverses, mouvements bancaires, journal gÃ©nÃ©ral, clÃ´ture annuelle
- **Stock** : gestion des articles, seuils dâ€™alerte, mouvements, inventaires, statistiques
- **Exports** : extraction de toutes les donnÃ©es en CSV, Excel, PDF ; crÃ©ation dâ€™archives ZIP pour lâ€™historique
- **Dashboard** : synthÃ¨se visuelle, graphiques, opÃ©rations rÃ©centes, solde global
- **Sauvegarde/Restauration** : manipulation aisÃ©e de la base SQLite, import/export

## Installation

1. Cloner ce dÃ©pÃ´t
2. Installer les dÃ©pendances Python :
   ```sh
   pip install -r requirements.txt
   ```
3. (Optionnel) Pour lâ€™export PDF :
   ```sh
   pip install reportlab
   ```
4. Lancer lâ€™application :
   ```sh
   python main.py
   ```

## Structure du projet

| Dossier/fichier | RÃ´le |
|-----------------|------|
| `main.py` | Point dâ€™entrÃ©e (UI principale) |
| `modules/` | Modules mÃ©tiers (membres, Ã©vÃ©nements, stockâ€¦) |
| `dialogs/` | Dialogues dâ€™Ã©dition/saisie divers |
| `dashboard/` | Tableau de bord/statistiques |
| `exports/` | Fonctions dâ€™export (CSV, Excel, PDF, ZIP) |
| `utils/` | Fonctions utilitaires (validation, logger, etc.) |
| `ui/` | Helpers dâ€™UI gÃ©nÃ©riques |
| `db/` | AccÃ¨s et structure de la base SQLite |
| `tests/` | Tests unitaires |
| `docs/` | Documentation utilisateur |

## Sauvegarde et restauration

- Menu Â« Administration Â» : sauvegarde, restauration, ouverture dâ€™une autre base
- Les donnÃ©es sont stockÃ©es localement dans un fichier SQLite (par dÃ©faut : `association.db`)

## ClÃ´ture dâ€™exercice

- Permet dâ€™exporter une archive ZIP de toutes les donnÃ©es, de gÃ©nÃ©rer un bilan PDF, puis de rÃ©initialiser la base pour un nouvel exercice.

## Licence

MIT â€“ projet libre, contributions bienvenues.

---

Pour plus de dÃ©tails ou un guide utilisateurâ€¯: voir [docs/UTILISATEUR.md](docs/UTILISATEUR.md)# Log-Interactif-treso-V2

Logiciel libre, multiplateforme, pour la gestion de la vie associative et la comptabilitÃ© dâ€™une association scolaire ou Ã©quivalente.

---

## FonctionnalitÃ©s principales

- **Gestion des membres**â€¯: adhÃ©sions, contacts, cotisations, statuts, historiques
- **Ã‰vÃ©nements**â€¯: gestion des manifestations, modules dynamiques, recettes/dÃ©penses, paiements, caisses
- **Finances**â€¯: suivi des dons, subventions, dÃ©penses rÃ©guliÃ¨res/diverses, mouvements bancaires, journal gÃ©nÃ©ral, clÃ´ture annuelle
- **Stock**â€¯: gestion des articles et inventaires, seuils dâ€™alerte, mouvements, statistiques
- **Exports**â€¯: extraction des donnÃ©es en CSV, Excel, PDF, ZIP de lâ€™historique
- **Dashboard**â€¯: synthÃ¨se visuelle, graphiques, opÃ©rations rÃ©centes, solde global
- **Sauvegarde / Restauration**â€¯: manipulation facilitÃ©e de la base SQLite, import/export
- **SÃ©curitÃ©**â€¯: sauvegarde/restauration manuelle, changement de base, initialisation/effacement sÃ©curisÃ©

---

## Installation

### 1. Cloner le dÃ©pÃ´t

```sh
git clone https://github.com/DarkSario/Log-Interactif-treso-V2.git
cd Log-Interactif-treso-V2
```

### 2. Installer les dÃ©pendances Python

**Python 3.9+ requis**

```sh
pip install -r requirements.txt
```

### 3. (Optionnel) Pour lâ€™export PDFâ€¯:

```sh
pip install reportlab
```

### 4. Lancer lâ€™application

```sh
python main.py
```

---

## Structure du projet

| Dossier/fichier              | RÃ´le / Description                                           |
|------------------------------|-------------------------------------------------------------|
| `main.py`                    | Point dâ€™entrÃ©e (UI principale)                              |
| `modules/`                   | Modules mÃ©tier (membres, Ã©vÃ©nements, stock, buvetteâ€¦)       |
| `dialogs/`                   | Dialogues dâ€™Ã©dition/saisie divers                           |
| `dashboard/dashboard.py`     | Tableau de bord, statistiques, synthÃ¨ses visuelles          |
| `exports/`                   | Fonctions dâ€™export (CSV, Excel, PDF, ZIP)                   |
| `utils/`                     | Fonctions utilitaires (logger, backup, helpers divers)      |
| `db/db.py`                   | AccÃ¨s et structure de la base SQLite                        |
| `init_db.py`                 | (Ã€ fusionner/refactorer) Initiation de la base              |
| `tests/`                     | Tests unitaires et dâ€™intÃ©gration                            |
| `docs/`                      | Documentation utilisateur et dÃ©veloppeur                    |
| `arborescence.txt`           | Version textuelle de lâ€™arbo du projet                       |
| `.env.example`               | Exemple de configuration (paramÃ©trage avancÃ©, chemins, etc.)|
| `requirements.txt`           | DÃ©pendances Python du projet                                |
| `scripts/migration.py`       | (Ã€ crÃ©er) Script de migration de la base (MAJ structure)    |

---

## DÃ©marrage rapide

1. **Premier lancement**â€¯: lâ€™application crÃ©e et initialise automatiquement la base `association.db` si besoin.
2. **Navigation**â€¯: tous les modules sont accessibles via le menu principal ou la page dâ€™accueil.
3. **Sauvegarde/Restauration**â€¯: menu Â«â€¯Administrationâ€¯Â» pour sauvegarder, restaurer, changer de base.
4. **ClÃ´ture dâ€™exercice**â€¯: export ZIP complet + bilan PDF + rÃ©initialisation guidÃ©e (optionnel).

---

## Contribution

- Respecter la structure de sÃ©paration logique mÃ©tier / UI / DB / helpers
- Proposer un test unitaire pour chaque nouvelle fonctionnalitÃ© ou correction majeure
- Documenter toute nouvelle fonctionnalitÃ© ou module dans ce README et/ou dans `docs/`
- Merci de signaler tout bug ou suggestion via les issues GitHub

---

## Roadmap de refonte

Le projet est en cours de refonteâ€¯: voir le fichier Excel `Plan_de_correction_Log-Interactif-treso-V2.xlsx` pour suivre lâ€™avancement prÃ©cis fichier par fichier.

---

## FAQ

**Qâ€¯: OÃ¹ sont stockÃ©es les donnÃ©esâ€¯?**  
Râ€¯: Dans un fichier SQLite local (par dÃ©fautâ€¯: `association.db`).

**Qâ€¯: Puis-je changer de base de donnÃ©esâ€¯?**  
Râ€¯: Oui, via le menu Administration.

**Qâ€¯: La suppression ou la rÃ©initialisation de la base est-elle risquÃ©eâ€¯?**  
Râ€¯: Ouiâ€¯! Toujours faire une sauvegarde via le menu avant une telle opÃ©ration.

---

## Licence

Projet sous licence MIT.  
(C) 2025, Les Interactifs des Ecoles / DarkSario

---
````


# ===== FICHIER SUIVANT =====

# === Fichier: ./requirements.txt ===

```
# Python >= 3.9 recommandÃ©
tkcalendar>=1.6.1
pandas>=1.5.0
matplotlib>=3.7.0
openpyxl>=3.0.0
python-docx>=0.8.11
reportlab>=3.6.0      # Optionnel, pour export PDF
# Pour prise en charge des CSV/ZIP natifs, rien Ã  ajouter (standard Python)
# Pour SQLite, inclus dans Python standard
pytest>=7.0.0         # Pour tests unitaires
# Logging, datetime, os, sys sont standards

# (Optionnel) Pour dÃ©veloppement et packaging
# black           # Formatage de code
# flake8          # Linting
# coverage        # Analyse de couverture de tests
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./run_app.py ===

```python
import logging
import os
import runpy

# Optional dotenv
try:
    from dotenv import load_dotenv
    load_dotenv()
except Exception:
    pass

LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL.upper(), logging.INFO),
    format='%(asctime)s %(levelname)s %(name)s: %(message)s'
)
logger = logging.getLogger('run_app')

def main():
    try:
        logger.info('Starting application via runpy (module: main)')
        # Run main.py as a module so existing if __name__ guard still applies.
        runpy.run_module('main', run_name='__main__')
    except SystemExit as e:
        logger.info('Process exited with code %s', e.code)
        raise
    except Exception:
        logger.exception('Unhandled exception while running application')
        raise

if __name__ == '__main__':
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./verify_row_conversions.py ===

```python
#!/usr/bin/env python3
"""
Verification script to ensure all database modules properly convert rows to dicts.
"""
import sys
import os
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from modules import buvette_db, buvette_inventaire_db, buvette_bilan_db
from modules.db_row_utils import _row_to_dict, _rows_to_dicts

def test_buvette_functions():
    """Test that buvette functions return dicts."""
    print("Testing buvette_db functions...")
    
    try:
        # Test list_articles returns dicts
        articles = buvette_db.list_articles()
        if articles:
            first = articles[0]
            assert isinstance(first, dict), f"Expected dict, got {type(first)}"
            # Test .get() method works
            first.get("name", "default")
            print("  âœ“ list_articles() returns dicts with .get() support")
        else:
            print("  â„¹ list_articles() returned empty list (no test data)")
            
        # Test list_articles_names returns dicts
        names = buvette_db.list_articles_names()
        if names:
            first = names[0]
            assert isinstance(first, dict), f"Expected dict, got {type(first)}"
            first.get("name", "default")
            print("  âœ“ list_articles_names() returns dicts with .get() support")
        else:
            print("  â„¹ list_articles_names() returned empty list (no test data)")
            
    except Exception as e:
        print(f"  âœ— Error: {e}")
        return False
    
    return True

def test_buvette_inventaire_functions():
    """Test that buvette inventaire functions return dicts."""
    print("\nTesting buvette_inventaire_db functions...")
    
    try:
        # Test list_inventaires returns dicts
        inventaires = buvette_inventaire_db.list_inventaires()
        if inventaires:
            first = inventaires[0]
            assert isinstance(first, dict), f"Expected dict, got {type(first)}"
            first.get("id", "default")
            print("  âœ“ list_inventaires() returns dicts with .get() support")
        else:
            print("  â„¹ list_inventaires() returned empty list (no test data)")
            
    except Exception as e:
        print(f"  âœ— Error: {e}")
        return False
    
    return True

def test_buvette_bilan_functions():
    """Test that buvette bilan functions return dicts."""
    print("\nTesting buvette_bilan_db functions...")
    
    try:
        # Test list_evenements returns dicts
        evenements = buvette_bilan_db.list_evenements()
        if evenements:
            first = evenements[0]
            assert isinstance(first, dict), f"Expected dict, got {type(first)}"
            first.get("name", "default")
            print("  âœ“ list_evenements() returns dicts with .get() support")
        else:
            print("  â„¹ list_evenements() returned empty list (no test data)")
            
    except Exception as e:
        print(f"  âœ— Error: {e}")
        return False
    
    return True

if __name__ == "__main__":
    print("=" * 70)
    print("Row to Dict Conversion Verification")
    print("=" * 70)
    
    all_passed = True
    all_passed &= test_buvette_functions()
    all_passed &= test_buvette_inventaire_functions()
    all_passed &= test_buvette_bilan_functions()
    
    print("\n" + "=" * 70)
    if all_passed:
        print("âœ“ All verification checks passed!")
        print("  All database functions properly return dicts with .get() support")
        sys.exit(0)
    else:
        print("âœ— Some verification checks failed")
        sys.exit(1)

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dashboard/dashboard.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
import pandas as pd
from db.db import get_df_or_sql, get_connection
try:
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
    import matplotlib.pyplot as plt
except ModuleNotFoundError:
    print("Le module 'matplotlib' est requis pour le tableau de bord. Installe-le : python -m pip install matplotlib")
    print("Note: Si tu utilises tkinter, assure-toi qu'il est installÃ© : sur Linux, tu peux avoir besoin de 'python3-tk'")
    raise

class DashboardModule:
    def __init__(self, master, visualisation_mode=False):
        self.master = master
        self.visualisation_mode = visualisation_mode
        self.top = tk.Toplevel(master)
        self.top.title("Tableau de bord")
        self.top.geometry("1100x650")
        self.create_widgets()
        self.refresh_dashboard()

    def create_widgets(self):
        self.tabs = ttk.Notebook(self.top)
        self.tab_resume = tk.Frame(self.tabs)
        self.tab_evenements = tk.Frame(self.tabs)
        self.tab_finances = tk.Frame(self.tabs)
        self.tab_graphs = tk.Frame(self.tabs)
        self.tabs.add(self.tab_resume, text="RÃ©sumÃ©")
        self.tabs.add(self.tab_evenements, text="Ã‰vÃ©nements")
        self.tabs.add(self.tab_finances, text="Finances")
        self.tabs.add(self.tab_graphs, text="Graphiques")
        self.tabs.pack(fill=tk.BOTH, expand=True)

        self.text_resume = tk.Text(self.tab_resume, height=10, font=("Arial", 11))
        self.text_resume.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        tk.Label(self.tab_resume, text="5 derniÃ¨res opÃ©rations :", font=("Arial", 10, "bold")).pack()
        self.tree_last_ops = ttk.Treeview(self.tab_resume, columns=("date", "type", "libelle", "montant"), show="headings")
        for col, w in zip(("date", "type", "libelle", "montant"), [90, 120, 250, 95]):
            self.tree_last_ops.heading(col, text=col.capitalize())
            self.tree_last_ops.column(col, width=w)
        self.tree_last_ops.pack(fill=tk.X, expand=False, padx=10, pady=3)

        self.tree_evenements = ttk.Treeview(self.tab_evenements, columns=("evenement", "recettes", "depenses", "solde"), show="headings")
        for col, w in zip(("evenement", "recettes", "depenses", "solde"), [220, 90, 90, 90]):
            self.tree_evenements.heading(col, text=col.capitalize())
            self.tree_evenements.column(col, width=w)
        self.tree_evenements.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        self.tree_finances = ttk.Treeview(self.tab_finances, columns=("categorie", "total"), show="headings")
        for col, w in zip(("categorie", "total"), [300, 120]):
            self.tree_finances.heading(col, text=col.capitalize())
            self.tree_finances.column(col, width=w)
        self.tree_finances.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        self.graph_frame = tk.Frame(self.tab_graphs)
        self.graph_frame.pack(fill=tk.BOTH, expand=True)

    def refresh_dashboard(self):
        self.text_resume.delete("1.0", tk.END)
        self.tree_evenements.delete(*self.tree_evenements.get_children())
        self.tree_finances.delete(*self.tree_finances.get_children())
        self.tree_last_ops.delete(*self.tree_last_ops.get_children())
        for widget in self.graph_frame.winfo_children():
            widget.destroy()

        total_membres = len(get_df_or_sql("membres"))
        total_events = len(get_df_or_sql("events"))
        total_stock = len(get_df_or_sql("stock"))
        df_dons = get_df_or_sql("dons_subventions")
        df_evt_recettes = get_df_or_sql("event_recettes")
        total_dons = df_dons["montant"].sum() if not df_dons.empty else 0
        total_evt_recettes = df_evt_recettes["montant"].sum() if not df_evt_recettes.empty else 0
        total_recettes = total_dons + total_evt_recettes

        df_reg = get_df_or_sql("depenses_regulieres")
        df_div = get_df_or_sql("depenses_diverses")
        df_evtdep = get_df_or_sql("event_depenses")
        total_depenses = (
            df_reg["montant"].sum() if not df_reg.empty else 0
        ) + (
            df_div["montant"].sum() if not df_div.empty else 0
        ) + (
            df_evtdep["montant"].sum() if not df_evtdep.empty else 0
        )

        solde = total_recettes - total_depenses
        resume = (
            f"ðŸ§‘ Membres : {total_membres}\n"
            f"ðŸŽ‰ Ã‰vÃ©nements : {total_events}\n"
            f"ðŸ“¦ Articles en stock : {total_stock}\n"
            f"ðŸ’° Dons/subventions : {total_dons:.2f} â‚¬\n"
            f"ðŸ’° Recettes Ã©vÃ©nements : {total_evt_recettes:.2f} â‚¬\n"
            f"ðŸ’° Total recettes : {total_recettes:.2f} â‚¬\n"
            f"ðŸ’¸ Total dÃ©penses : {total_depenses:.2f} â‚¬\n"
            f"ðŸ’¼ Solde actuel : {solde:.2f} â‚¬\n"
        )
        self.text_resume.insert("1.0", resume)

        # DerniÃ¨res opÃ©rations (journal gÃ©nÃ©ral synthÃ©tique)
        try:
            conn = get_connection()
            df_ops = pd.read_sql_query(
                """
                SELECT date, 'Recette' as type, source as libelle, montant FROM dons_subventions
                UNION ALL
                SELECT e.date as date, 'Recette Ã©vÃ¨nement', er.source, er.montant
                    FROM event_recettes er
                    JOIN events e ON er.event_id = e.id
                UNION ALL
                SELECT date_depense as date, 'DÃ©pense rÃ©guliÃ¨re', categorie, -montant FROM depenses_regulieres
                UNION ALL
                SELECT date_depense as date, 'DÃ©pense diverse', commentaire, -montant FROM depenses_diverses
                UNION ALL
                SELECT e.date as date, 'DÃ©pense Ã©vÃ¨nement', ed.categorie, -ed.montant
                    FROM event_depenses ed
                    JOIN events e ON ed.event_id = e.id
                ORDER BY date DESC
                LIMIT 5
                """, conn
            )
            conn.close()
            for _, row in df_ops.iterrows():
                self.tree_last_ops.insert("", "end", values=(row["date"], row["type"], row["libelle"], f"{row['montant']:.2f}"))
        except Exception:
            pass

        # Ã‰vÃ©nements (synthÃ¨se)
        df_evt = get_df_or_sql("events")
        for _, row in df_evt.iterrows():
            name = row["name"] if "name" in row else row.get("evenement", "")
            try:
                id_evt = row["id"]
                recettes = get_df_or_sql(f"SELECT SUM(montant) FROM event_recettes WHERE event_id={id_evt}")["SUM(montant)"].iloc[0] or 0
                depenses = get_df_or_sql(f"SELECT SUM(montant) FROM event_depenses WHERE event_id={id_evt}")["SUM(montant)"].iloc[0] or 0
            except Exception:
                recettes = depenses = 0
            solde_evt = recettes - depenses
            self.tree_evenements.insert("", "end", values=(name, f"{recettes:.2f}", f"{depenses:.2f}", f"{solde_evt:.2f}"))

        # Finances par donateur/source/catÃ©gorie (dons + recettes Ã©vÃ¨nement)
        if not df_dons.empty:
            dons_by_type = df_dons.groupby("source")["montant"].sum().reset_index()
            for _, row in dons_by_type.iterrows():
                self.tree_finances.insert("", "end", values=(row["source"], f"{row['montant']:.2f}"))
        if not df_evt_recettes.empty:
            evt_by_type = df_evt_recettes.groupby("source")["montant"].sum().reset_index()
            for _, row in evt_by_type.iterrows():
                self.tree_finances.insert("", "end", values=(f"Evt: {row['source']}", f"{row['montant']:.2f}"))

        self.display_graphs(
            total_dons, total_evt_recettes, total_depenses,
            df_dons, df_evt_recettes, df_reg, df_div, df_evtdep
        )

    def display_graphs(self, total_dons, total_evt_recettes, total_depenses, df_dons, df_evt_recettes, df_reg, df_div, df_evtdep):
        fig, axes = plt.subplots(1, 2, figsize=(12, 5))

        recettes_labels = []
        recettes_vals = []
        if not df_dons.empty:
            dons_by_source = df_dons.groupby("source")["montant"].sum()
            for s, v in dons_by_source.items():
                label = s if len(str(s)) <= 28 else str(s)[:25] + "..."
                recettes_labels.append(label)
                recettes_vals.append(v)
        if not df_evt_recettes.empty:
            evt_by_source = df_evt_recettes.groupby("source")["montant"].sum()
            for s, v in evt_by_source.items():
                label = f"Evt: {s}" if len(str(s)) <= 23 else f"Evt: {str(s)[:20]}..."
                recettes_labels.append(label)
                recettes_vals.append(v)
        if not recettes_labels:
            recettes_labels = ["Aucune"]
            recettes_vals = [1]

        wedges1, _, autotexts1 = axes[0].pie(
            recettes_vals, labels=None, autopct='%1.1f%%', startangle=90
        )
        axes[0].set_title("RÃ©partition Recettes")
        axes[0].legend(wedges1, recettes_labels, loc='center left', bbox_to_anchor=(1, 0.5), fontsize=9)

        depenses_labels = []
        depenses_vals = []
        if not df_reg.empty:
            depenses_labels.append("DÃ©penses rÃ©guliÃ¨res")
            depenses_vals.append(df_reg["montant"].sum())
        if not df_div.empty:
            depenses_labels.append("DÃ©penses diverses")
            depenses_vals.append(df_div["montant"].sum())
        if not df_evtdep.empty:
            depenses_labels.append("DÃ©penses Ã©vÃ©nements")
            depenses_vals.append(df_evtdep["montant"].sum())
        if not depenses_labels:
            depenses_labels = ["Aucune"]
            depenses_vals = [1]
        wedges2, _, autotexts2 = axes[1].pie(
            depenses_vals, labels=None, autopct='%1.1f%%', startangle=90
        )
        axes[1].set_title("RÃ©partition DÃ©penses")
        axes[1].legend(wedges2, depenses_labels, loc='center left', bbox_to_anchor=(1, 0.5), fontsize=9)

        plt.tight_layout()
        canvas = FigureCanvasTkAgg(fig, master=self.graph_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./db/db.py ===

```python
"""
Module de gestion de la base de donnÃ©es SQLite pour l'application.

MODIFICATIONS APPLIQUÃ‰ES (PR copilot/auto-fix-buvette):
- Ajout de la colonne 'stock' (INTEGER DEFAULT 0) au schÃ©ma buvette_articles
  pour suivre les quantitÃ©s en stock de chaque article.
- Migration non destructive dans upgrade_db_structure() pour ajouter la colonne
  'stock' aux bases de donnÃ©es existantes sans perte de donnÃ©es.
- Ajout de la colonne 'commentaire' Ã  buvette_inventaire_lignes si absente.
"""

import sqlite3
import os
import pandas as pd
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

DB_FILE = "association.db"
_db_file = DB_FILE  # Pour gestion dynamique du fichier DB

logger = get_logger("db")

def set_db_file(path):
    """Change dynamiquement le fichier DB Ã  utiliser."""
    global _db_file
    _db_file = path
    logger.info(f"Database file set to: {_db_file}")

def get_db_file():
    return _db_file

def get_connection():
    """Renvoie une connexion SQLite prÃªte Ã  l'emploi, journal_mode=WAL, gestion des erreurs.
    
    Note: Does NOT set a global dict row_factory to avoid breaking code that uses 
    positional indexing (e.g., row[0]). Instead, code should convert rows to dicts 
    explicitly using modules/db_row_utils helpers when needed for .get() access.
    
    Pragmas set to reduce locking:
    - PRAGMA journal_mode=WAL (Write-Ahead Logging for better concurrency)
    - PRAGMA busy_timeout=5000 (Wait up to 5 seconds if DB is locked)
    """
    try:
        conn = sqlite3.connect(_db_file, timeout=10, detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)
        # Use sqlite3.Row for named access via row['column'], but not dict() for compatibility
        conn.row_factory = sqlite3.Row
        try:
            conn.execute("PRAGMA journal_mode=WAL;")
            conn.execute("PRAGMA busy_timeout=5000;")
        except Exception as pragma_exc:
            logger.warning(f"Impossible de dÃ©finir les PRAGMAs: {pragma_exc}")
        return conn
    except Exception as e:
        logger.error(f"Erreur lors de la connexion Ã  la base: {e}")
        raise

def drop_tables(conn):
    """Supprime toutes les tables principales du projet (action irrÃ©versible)."""
    tables = [
        "config", "comptes", "membres", "events", "stock", "categories",
        "dons_subventions", "depenses_regulieres", "depenses_diverses",
        "inventaires", "inventaire_lignes", "mouvements_stock", "event_modules",
        "event_module_fields", "event_module_data", "event_payments",
        "event_caisses", "event_caisse_details", "event_recettes",
        "event_depenses", "fournisseurs", "colonnes_modeles",
        "valeurs_modeles_colonnes", "depots_retraits_banque",
        "historique_clotures", "retrocessions_ecoles",
        "buvette_articles", "buvette_achats", "buvette_inventaires",
        "buvette_inventaire_lignes", "buvette_mouvements", "buvette_recettes"
    ]
    cur = conn.cursor()
    for table in tables:
        try:
            cur.execute(f"DROP TABLE IF EXISTS {table};")
            logger.debug(f"Table '{table}' supprimÃ©e.")
        except Exception as e:
            logger.warning(f"Impossible de supprimer {table}: {e}")
    conn.commit()

def upgrade_db_structure():
    """Migration douce : assure la prÃ©sence de toutes les colonnes/tables attendues sans perte de donnÃ©es."""
    from tkinter import messagebox
    try:
        conn = get_connection()
        c = conn.cursor()

        # Table comptes
        c.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='comptes'")
        if not c.fetchone():
            c.execute("""
                CREATE TABLE IF NOT EXISTS comptes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL UNIQUE,
                    solde REAL DEFAULT 0
                )
            """)
        c.execute("SELECT COUNT(*) as n FROM comptes")
        if c.fetchone()["n"] == 0:
            c.execute("SELECT solde_report FROM config ORDER BY id DESC LIMIT 1")
            row = c.fetchone()
            if row and row["solde_report"] is not None:
                c.execute("INSERT INTO comptes (name, solde) VALUES (?, ?)", ("Banque Principale", row["solde_report"]))
                conn.commit()

        def add_column_if_not_exists(table, column, definition):
            try:
                c.execute(f"PRAGMA table_info({table});")
                cols = [r[1] for r in c.fetchall()]
                if column not in cols:
                    c.execute(f"ALTER TABLE {table} ADD COLUMN {column} {definition};")
                    logger.info(f"Ajout colonne '{column}' Ã  la table '{table}'.")
            except Exception as e:
                logger.warning(f"Impossible d'ajouter la colonne {column} Ã  {table}: {e}")

        for col, typ in [("cotisation", "TEXT"), ("commentaire", "TEXT"), ("statut", "TEXT"), ("date_adhesion", "TEXT")]:
            add_column_if_not_exists("membres", col, typ)
        for col, typ in [("cloture", "INTEGER DEFAULT 0"), ("solde_report", "REAL DEFAULT 0"), ("but_asso", "TEXT DEFAULT ''")]:
            add_column_if_not_exists("config", col, typ)
        add_column_if_not_exists("event_modules", "id_col_total", "INTEGER")
        for col, typ in [("prix_unitaire", "REAL"), ("modele_colonne", "TEXT")]:
            add_column_if_not_exists("event_module_fields", col, typ)

        advanced_cols = [
            ("fournisseur", "TEXT"), ("date_depense", "TEXT"), ("paye_par", "TEXT"),
            ("membre_id", "INTEGER"), ("statut_remboursement", "TEXT"),
            ("statut_reglement", "TEXT"), ("moyen_paiement", "TEXT"),
            ("numero_cheque", "TEXT"), ("numero_facture", "TEXT")
        ]
        for col, typ in advanced_cols:
            add_column_if_not_exists("event_depenses", col, typ)
        dep_cols = [
            ("categorie", "TEXT"), ("module_id", "INTEGER"), ("montant", "REAL"), ("fournisseur", "TEXT"),
            ("date_depense", "TEXT"), ("paye_par", "TEXT"), ("membre_id", "INTEGER"), ("statut_remboursement", "TEXT"),
            ("statut_reglement", "TEXT"), ("moyen_paiement", "TEXT"), ("numero_cheque", "TEXT"),
            ("numero_facture", "TEXT"), ("commentaire", "TEXT"),
        ]
        for t in ["depenses_regulieres", "depenses_diverses"]:
            for col, typ in dep_cols:
                add_column_if_not_exists(t, col, typ)

        # Migration non destructive : ajouter la colonne 'stock' Ã  buvette_articles si elle n'existe pas
        add_column_if_not_exists("buvette_articles", "stock", "INTEGER DEFAULT 0")
        
        # Ajouter la colonne 'commentaire' Ã  buvette_inventaire_lignes si elle n'existe pas
        add_column_if_not_exists("buvette_inventaire_lignes", "commentaire", "TEXT")
        
        # Ajouter la colonne 'purchase_price' Ã  buvette_articles si elle n'existe pas
        add_column_if_not_exists("buvette_articles", "purchase_price", "REAL")

        def create_table_if_not_exists(name, sql):
            try:
                c.execute(f"SELECT name FROM sqlite_master WHERE type='table' AND name='{name}'")
                if not c.fetchone():
                    c.execute(sql)
                    logger.info(f"Table '{name}' crÃ©Ã©e.")
            except Exception as e:
                logger.warning(f"Impossible de crÃ©er la table {name}: {e}")

        create_table_if_not_exists("retrocessions_ecoles", """
            CREATE TABLE IF NOT EXISTS retrocessions_ecoles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT,
                montant REAL,
                ecole TEXT,
                commentaire TEXT
            )
        """)
        create_table_if_not_exists("fournisseurs", """
            CREATE TABLE IF NOT EXISTS fournisseurs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE
            )
        """)
        create_table_if_not_exists("colonnes_modeles", """
            CREATE TABLE IF NOT EXISTS colonnes_modeles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                type_modele TEXT NOT NULL
            )
        """)
        create_table_if_not_exists("valeurs_modeles_colonnes", """
            CREATE TABLE IF NOT EXISTS valeurs_modeles_colonnes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                modele_id INTEGER,
                valeur TEXT NOT NULL,
                FOREIGN KEY (modele_id) REFERENCES colonnes_modeles(id)
            )
        """)
        create_table_if_not_exists("depots_retraits_banque", """
            CREATE TABLE IF NOT EXISTS depots_retraits_banque (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT NOT NULL,
                type TEXT NOT NULL,
                montant REAL NOT NULL,
                reference TEXT,
                banque TEXT,
                pointe INTEGER DEFAULT 0,
                commentaire TEXT
            )
        """)
        create_table_if_not_exists("historique_clotures", """
            CREATE TABLE IF NOT EXISTS historique_clotures (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date_cloture TEXT NOT NULL
            )
        """)
        create_table_if_not_exists("buvette_articles", """
            CREATE TABLE IF NOT EXISTS buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                unite TEXT,
                contenance TEXT,
                commentaire TEXT,
                stock INTEGER DEFAULT 0,
                purchase_price REAL
            )
        """)
        create_table_if_not_exists("buvette_achats", """
            CREATE TABLE IF NOT EXISTS buvette_achats (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                article_id INTEGER,
                date_achat DATE,
                quantite INTEGER,
                prix_unitaire REAL,
                fournisseur TEXT,
                facture TEXT,
                exercice TEXT,
                FOREIGN KEY (article_id) REFERENCES buvette_articles(id)
            )
        """)
        create_table_if_not_exists("buvette_inventaires", """
            CREATE TABLE IF NOT EXISTS buvette_inventaires (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date_inventaire DATE,
                event_id INTEGER,
                type_inventaire TEXT CHECK(type_inventaire IN ('avant', 'apres', 'hors_evenement')),
                commentaire TEXT,
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        """)
        create_table_if_not_exists("buvette_inventaire_lignes", """
            CREATE TABLE IF NOT EXISTS buvette_inventaire_lignes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                inventaire_id INTEGER,
                article_id INTEGER,
                quantite INTEGER,
                FOREIGN KEY (inventaire_id) REFERENCES buvette_inventaires(id),
                FOREIGN KEY (article_id) REFERENCES buvette_articles(id)
            )
        """)
        create_table_if_not_exists("buvette_mouvements", """
            CREATE TABLE IF NOT EXISTS buvette_mouvements (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                article_id INTEGER,
                date_mouvement DATE,
                type_mouvement TEXT,
                quantite INTEGER,
                motif TEXT,
                event_id INTEGER,
                FOREIGN KEY (article_id) REFERENCES buvette_articles(id),
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        """)
        create_table_if_not_exists("buvette_recettes", """
            CREATE TABLE IF NOT EXISTS buvette_recettes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id INTEGER,
                montant REAL,
                date_recette DATE,
                commentaire TEXT,
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        """)

        conn.commit()
        conn.close()
        messagebox.showinfo("Base de donnÃ©es", "La structure de la base a Ã©tÃ© mise Ã  jour avec succÃ¨s.")
        logger.info("Structure de la base migrÃ©e.")
    except Exception as e:
        handle_exception(e, "Erreur lors de la migration de la base")
        from tkinter import messagebox
        messagebox.showerror("Erreur base", f"Erreur lors de la migration: {e}")

def init_db():
    """CrÃ©e toutes les tables du projet si elles sont absentes (pour une base vierge)."""
    try:
        conn = get_connection()
        c = conn.cursor()
        # SchÃ©ma complet : Toutes les tables du projet
        c.execute("""
            CREATE TABLE IF NOT EXISTS config (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                exercice TEXT,
                date TEXT,
                date_fin TEXT,
                disponible_banque REAL,
                cloture INTEGER DEFAULT 0,
                solde_report REAL DEFAULT 0,
                but_asso TEXT DEFAULT ''
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS comptes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                solde REAL DEFAULT 0
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS retrocessions_ecoles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT,
                montant REAL,
                ecole TEXT,
                commentaire TEXT
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS categories (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                parent_id INTEGER,
                UNIQUE(name),
                FOREIGN KEY (parent_id) REFERENCES categories(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS membres (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                prenom TEXT NOT NULL,
                email TEXT,
                telephone TEXT,
                cotisation TEXT,
                commentaire TEXT,
                statut TEXT,
                date_adhesion TEXT
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                date TEXT,
                lieu TEXT,
                description TEXT
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS stock (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie_id INTEGER,
                quantite INTEGER,
                seuil_alerte INTEGER,
                date_peremption TEXT,
                lot TEXT,
                commentaire TEXT,
                FOREIGN KEY (categorie_id) REFERENCES categories(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS dons_subventions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT NOT NULL,
                source TEXT,
                montant REAL,
                type TEXT,
                justificatif TEXT
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS depenses_regulieres (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                categorie TEXT,
                module_id INTEGER,
                montant REAL,
                fournisseur TEXT,
                date_depense TEXT,
                paye_par TEXT,
                membre_id INTEGER,
                statut_remboursement TEXT,
                statut_reglement TEXT,
                moyen_paiement TEXT,
                numero_cheque TEXT,
                numero_facture TEXT,
                commentaire TEXT
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS depenses_diverses (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                categorie TEXT,
                module_id INTEGER,
                montant REAL,
                fournisseur TEXT,
                date_depense TEXT,
                paye_par TEXT,
                membre_id INTEGER,
                statut_remboursement TEXT,
                statut_reglement TEXT,
                moyen_paiement TEXT,
                numero_cheque TEXT,
                numero_facture TEXT,
                commentaire TEXT
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS inventaires (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date_inventaire TEXT NOT NULL,
                event_id INTEGER,
                commentaire TEXT,
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS inventaire_lignes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                inventaire_id INTEGER NOT NULL,
                stock_id INTEGER NOT NULL,
                quantite_constatee INTEGER NOT NULL,
                FOREIGN KEY (inventaire_id) REFERENCES inventaires(id),
                FOREIGN KEY (stock_id) REFERENCES stock(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS mouvements_stock (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                stock_id INTEGER,
                date TEXT,
                type TEXT,
                quantite INTEGER,
                prix_achat_total REAL,
                prix_unitaire REAL,
                date_peremption TEXT,
                commentaire TEXT,
                FOREIGN KEY(stock_id) REFERENCES stock(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS event_modules (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id INTEGER,
                nom_module TEXT,
                id_col_total INTEGER,
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS event_module_fields (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                module_id INTEGER,
                nom_champ TEXT,
                type_champ TEXT,
                prix_unitaire REAL,
                modele_colonne TEXT,
                FOREIGN KEY (module_id) REFERENCES event_modules(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS colonnes_modeles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                type_modele TEXT NOT NULL
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS valeurs_modeles_colonnes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                modele_id INTEGER,
                valeur TEXT NOT NULL,
                FOREIGN KEY (modele_id) REFERENCES colonnes_modeles(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS event_module_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                module_id INTEGER,
                row_index INTEGER,
                field_id INTEGER,
                valeur TEXT,
                FOREIGN KEY (module_id) REFERENCES event_modules(id),
                FOREIGN KEY (field_id) REFERENCES event_module_fields(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS event_payments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id INTEGER,
                nom_payeuse TEXT,
                classe TEXT,
                mode_paiement TEXT,
                banque TEXT,
                numero_cheque TEXT,
                montant REAL,
                commentaire TEXT,
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS event_caisses (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id INTEGER,
                nom_caisse TEXT,
                commentaire TEXT,
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS event_caisse_details (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                caisse_id INTEGER,
                moment TEXT,
                type TEXT,
                valeur REAL,
                quantite INTEGER,
                FOREIGN KEY (caisse_id) REFERENCES event_caisses(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS event_recettes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id INTEGER,
                source TEXT,
                montant REAL,
                commentaire TEXT,
                module_id INTEGER,
                FOREIGN KEY (event_id) REFERENCES events(id),
                FOREIGN KEY (module_id) REFERENCES event_modules(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS event_depenses (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id INTEGER,
                categorie TEXT,
                montant REAL,
                commentaire TEXT,
                module_id INTEGER,
                fournisseur TEXT,
                date_depense TEXT,
                paye_par TEXT,
                membre_id INTEGER,
                statut_remboursement TEXT,
                statut_reglement TEXT,
                moyen_paiement TEXT,
                numero_cheque TEXT,
                numero_facture TEXT,
                FOREIGN KEY (event_id) REFERENCES events(id),
                FOREIGN KEY (module_id) REFERENCES event_modules(id),
                FOREIGN KEY (membre_id) REFERENCES membres(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS fournisseurs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS depots_retraits_banque (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT NOT NULL,
                type TEXT NOT NULL,
                montant REAL NOT NULL,
                reference TEXT,
                banque TEXT,
                pointe INTEGER DEFAULT 0,
                commentaire TEXT
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS historique_clotures (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date_cloture TEXT NOT NULL
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                unite TEXT,
                contenance TEXT,
                commentaire TEXT,
                stock INTEGER DEFAULT 0,
                purchase_price REAL
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS buvette_achats (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                article_id INTEGER,
                date_achat DATE,
                quantite INTEGER,
                prix_unitaire REAL,
                fournisseur TEXT,
                facture TEXT,
                exercice TEXT,
                FOREIGN KEY (article_id) REFERENCES buvette_articles(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS buvette_inventaires (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date_inventaire DATE,
                event_id INTEGER,
                type_inventaire TEXT CHECK(type_inventaire IN ('avant', 'apres', 'hors_evenement')),
                commentaire TEXT,
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS buvette_inventaire_lignes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                inventaire_id INTEGER,
                article_id INTEGER,
                quantite INTEGER,
                FOREIGN KEY (inventaire_id) REFERENCES buvette_inventaires(id),
                FOREIGN KEY (article_id) REFERENCES buvette_articles(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS buvette_mouvements (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                article_id INTEGER,
                date_mouvement DATE,
                type_mouvement TEXT,
                quantite INTEGER,
                motif TEXT,
                event_id INTEGER,
                FOREIGN KEY (article_id) REFERENCES buvette_articles(id),
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        """)
        c.execute("""
            CREATE TABLE IF NOT EXISTS buvette_recettes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id INTEGER,
                montant REAL,
                date_recette DATE,
                commentaire TEXT,
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        """)
        c.execute("DROP TABLE IF EXISTS members;")
        conn.commit()
        conn.close()
        logger.info("Tables crÃ©Ã©es/mises Ã  jour.")
    except Exception as e:
        handle_exception(e, "Erreur lors de l'initialisation de la base")

def is_first_launch():
    """Retourne True si la table config est vide (premier lancement).
    
    Uses positional access res[0] which works with both sqlite3.Row and tuples.
    """
    try:
        conn = get_connection()
        c = conn.cursor()
        c.execute("SELECT COUNT(*) FROM config")
        res = c.fetchone()
        conn.close()
        if res is None:
            return True
        return res[0] == 0
    except Exception as e:
        handle_exception(e, "Erreur lors du test de premier lancement")
        return False

def save_init_info(exercice, date, date_fin, disponible_banque):
    """Enregistre les infos dâ€™initialisation dâ€™un nouvel exercice."""
    try:
        conn = get_connection()
        c = conn.cursor()
        c.execute(
            "INSERT INTO config (exercice, date, date_fin, disponible_banque) VALUES (?, ?, ?, ?)",
            (exercice, date, date_fin, disponible_banque)
        )
        conn.commit()
        c.execute("SELECT solde_report FROM config ORDER BY id DESC LIMIT 1")
        row = c.fetchone()
        if row and row["solde_report"] is not None:
            c.execute("INSERT OR IGNORE INTO comptes (name, solde) VALUES (?, ?)", ("Banque Principale", row["solde_report"]))
        conn.commit()
        conn.close()
        logger.info(f"Initialisation exercice {exercice} enregistrÃ©e.")
    except Exception as e:
        handle_exception(e, "Erreur lors de l'enregistrement de l'initialisation")

def get_df_or_sql(table_or_query):
    """Retourne un DataFrame pandas depuis une table ou une requÃªte SQL."""
    conn = None
    try:
        conn = get_connection()
        # Si c'est une requÃªte SELECT, exÃ©cute directement
        if "select" in table_or_query.lower():
            df = pd.read_sql_query(table_or_query, conn)
        else:
            # VÃ©rifie que la table existe
            tables = [row[0] for row in conn.execute("SELECT name FROM sqlite_master WHERE type='table';")]
            if table_or_query not in tables:
                raise Exception(f"La table '{table_or_query}' n'existe pas dans la base.")
            df = pd.read_sql_query(f"SELECT * FROM {table_or_query}", conn)
        return df
    except Exception as e:
        handle_exception(e, f"Erreur lors de la rÃ©cupÃ©ration des donnÃ©es via pandas/sql (table ou requÃªte: {table_or_query})")
        return pd.DataFrame()
    finally:
        if conn:
            try:
                conn.close()
            except Exception:
                pass

if __name__ == "__main__":
    init_db()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./db/schema_hints.yaml ===

```yaml
# Schema Hints for Database Migration
# Generated by analyze_modules_columns.py
#
# This file contains expected columns extracted from SQL queries in the code.
# You can manually add overrides or aliases in the 'manual_overrides' section.
#
# Format:
#   tables:
#     table_name:
#       expected_columns:
#         column_name:
#           type: TEXT|INTEGER|REAL|DATE
#           inferred: true|false
#
# Manual overrides example:
#   manual_overrides:
#     table_name:
#       column_aliases:
#         old_name: new_name
#       forced_types:
#         column_name: REAL

schema_version: "1.0"
generated_by: "analyze_modules_columns.py"

tables:
  buvette_achats:
    expected_columns:
      article_id:
        type: INTEGER
        inferred: true
      date_achat:
        type: DATE
        inferred: true
      exercice:
        type: TEXT
        inferred: true
      facture:
        type: TEXT
        inferred: true
      fournisseur:
        type: TEXT
        inferred: true
      prix_unitaire:
        type: REAL
        inferred: true
      quantite:
        type: REAL
        inferred: true
  buvette_articles:
    expected_columns:
      categorie:
        type: TEXT
        inferred: true
      commentaire:
        type: TEXT
        inferred: true
      contenance:
        type: REAL
        inferred: true
      id:
        type: INTEGER
        inferred: true
      name:
        type: TEXT
        inferred: true
      purchase_price:
        type: TEXT
        inferred: true
      quantite:
        type: REAL
        inferred: true
      stock:
        type: INTEGER
        inferred: true
      unite:
        type: TEXT
        inferred: true
  buvette_inventaire_lignes:
    expected_columns:
      article_id:
        type: INTEGER
        inferred: true
      commentaire:
        type: TEXT
        inferred: true
      id:
        type: INTEGER
        inferred: true
      inventaire_id:
        type: INTEGER
        inferred: true
      quantite:
        type: REAL
        inferred: true
  buvette_inventaires:
    expected_columns:
      commentaire:
        type: TEXT
        inferred: true
      date_inventaire:
        type: DATE
        inferred: true
      event_id:
        type: INTEGER
        inferred: true
      type_inventaire:
        type: TEXT
        inferred: true
  buvette_mouvements:
    expected_columns:
      article_id:
        type: INTEGER
        inferred: true
      date_mouvement:
        type: DATE
        inferred: true
      event_id:
        type: INTEGER
        inferred: true
      motif:
        type: TEXT
        inferred: true
      quantite:
        type: REAL
        inferred: true
      type_mouvement:
        type: TEXT
        inferred: true
  buvette_recettes:
    expected_columns:
      montant:
        type: REAL
        inferred: true
      recette:
        type: TEXT
        inferred: true
  categories:
    expected_columns:
      c:
        type: TEXT
        inferred: true
      id:
        type: INTEGER
        inferred: true
      name:
        type: TEXT
        inferred: true
      p:
        type: TEXT
        inferred: true
      parent:
        type: TEXT
        inferred: true
      parent_id:
        type: INTEGER
        inferred: true
  colonnes_modeles:
    expected_columns:
      id:
        type: INTEGER
        inferred: true
      master:
        type: TEXT
        inferred: true
      modele_id:
        type: INTEGER
        inferred: true
      name:
        type: TEXT
        inferred: true
      typ:
        type: TEXT
        inferred: true
      type_modele:
        type: TEXT
        inferred: true
      valeur:
        type: TEXT
        inferred: true
  comptes:
    expected_columns:
      column:
        type: TEXT
        inferred: true
      id:
        type: INTEGER
        inferred: true
      name:
        type: TEXT
        inferred: true
      solde:
        type: REAL
        inferred: true
  config:
    expected_columns:
      date:
        type: DATE
        inferred: true
      date_fin:
        type: DATE
        inferred: true
      disponible_banque:
        type: REAL
        inferred: true
      exercice:
        type: TEXT
        inferred: true
      id:
        type: INTEGER
        inferred: true
      solde_report:
        type: REAL
        inferred: true
  depenses_diverses:
    expected_columns:
      categorie:
        type: TEXT
        inferred: true
      commentaire:
        type: TEXT
        inferred: true
      date_depense:
        type: DATE
        inferred: true
      fournisseur:
        type: TEXT
        inferred: true
      id:
        type: INTEGER
        inferred: true
      membre_id:
        type: INTEGER
        inferred: true
      module_id:
        type: INTEGER
        inferred: true
      montant:
        type: REAL
        inferred: true
      moyen_paiement:
        type: TEXT
        inferred: true
      numero_cheque:
        type: TEXT
        inferred: true
      numero_facture:
        type: TEXT
        inferred: true
      paye_par:
        type: TEXT
        inferred: true
      statut_reglement:
        type: TEXT
        inferred: true
      statut_remboursement:
        type: TEXT
        inferred: true
  depenses_regulieres:
    expected_columns:
      categorie:
        type: TEXT
        inferred: true
      commentaire:
        type: TEXT
        inferred: true
      date_depense:
        type: DATE
        inferred: true
      fournisseur:
        type: TEXT
        inferred: true
      id:
        type: INTEGER
        inferred: true
      membre_id:
        type: INTEGER
        inferred: true
      module_id:
        type: INTEGER
        inferred: true
      montant:
        type: REAL
        inferred: true
      moyen_paiement:
        type: TEXT
        inferred: true
      numero_cheque:
        type: TEXT
        inferred: true
      numero_facture:
        type: TEXT
        inferred: true
      paye_par:
        type: TEXT
        inferred: true
      statut_reglement:
        type: TEXT
        inferred: true
      statut_remboursement:
        type: TEXT
        inferred: true
  depots_retraits_banque:
    expected_columns:
      banque:
        type: TEXT
        inferred: true
      commentaire:
        type: TEXT
        inferred: true
      date:
        type: DATE
        inferred: true
      montant:
        type: REAL
        inferred: true
      pointe:
        type: TEXT
        inferred: true
      reference:
        type: TEXT
        inferred: true
      type:
        type: TEXT
        inferred: true
  dons_subventions:
    expected_columns:
      date:
        type: DATE
        inferred: true
      id:
        type: INTEGER
        inferred: true
      justificatif:
        type: TEXT
        inferred: true
      montant:
        type: REAL
        inferred: true
      source:
        type: TEXT
        inferred: true
      type:
        type: TEXT
        inferred: true
  event_caisse_details:
    expected_columns:
      caisse_id:
        type: INTEGER
        inferred: true
      date:
        type: DATE
        inferred: true
      description:
        type: TEXT
        inferred: true
      justificatif:
        type: TEXT
        inferred: true
      montant:
        type: REAL
        inferred: true
      type_op:
        type: TEXT
        inferred: true
  event_caisses:
    expected_columns:
      commentaire:
        type: TEXT
        inferred: true
      event_id:
        type: INTEGER
        inferred: true
      id:
        type: INTEGER
        inferred: true
      nom:
        type: TEXT
        inferred: true
      nom_caisse:
        type: TEXT
        inferred: true
      responsable:
        type: TEXT
        inferred: true
      solde_initial:
        type: REAL
        inferred: true
  event_depenses:
    expected_columns:
      COALESCE:
        type: TEXT
        inferred: true
      categorie:
        type: TEXT
        inferred: true
      commentaire:
        type: TEXT
        inferred: true
      date:
        type: DATE
        inferred: true
      date_depense:
        type: DATE
        inferred: true
      description:
        type: TEXT
        inferred: true
      event_id:
        type: INTEGER
        inferred: true
      fournisseur:
        type: TEXT
        inferred: true
      justificatif:
        type: TEXT
        inferred: true
      membre_id:
        type: INTEGER
        inferred: true
      montant:
        type: REAL
        inferred: true
      paye_par:
        type: TEXT
        inferred: true
  event_module_data:
    expected_columns:
      field_id:
        type: INTEGER
        inferred: true
      id:
        type: INTEGER
        inferred: true
      module_id:
        type: INTEGER
        inferred: true
      mx:
        type: TEXT
        inferred: true
      row_index:
        type: TEXT
        inferred: true
      valeur:
        type: REAL
        inferred: true
  event_module_fields:
    expected_columns:
      id:
        type: INTEGER
        inferred: true
      modele_colonne:
        type: TEXT
        inferred: true
      module_id:
        type: INTEGER
        inferred: true
      nom_champ:
        type: TEXT
        inferred: true
      prix_unitaire:
        type: REAL
        inferred: true
      type_champ:
        type: TEXT
        inferred: true
  event_modules:
    expected_columns:
      event_id:
        type: INTEGER
        inferred: true
      id:
        type: INTEGER
        inferred: true
      id_col_total:
        type: REAL
        inferred: true
      nom_module:
        type: TEXT
        inferred: true
  event_payments:
    expected_columns:
      banque:
        type: TEXT
        inferred: true
      classe:
        type: TEXT
        inferred: true
      commentaire:
        type: TEXT
        inferred: true
      event_id:
        type: INTEGER
        inferred: true
      mode_paiement:
        type: TEXT
        inferred: true
      montant:
        type: REAL
        inferred: true
      nom_payeuse:
        type: TEXT
        inferred: true
      numero_cheque:
        type: TEXT
        inferred: true
  event_recettes:
    expected_columns:
      COALESCE:
        type: TEXT
        inferred: true
      commentaire:
        type: TEXT
        inferred: true
      event_id:
        type: INTEGER
        inferred: true
      id:
        type: INTEGER
        inferred: true
      module_id:
        type: INTEGER
        inferred: true
      montant:
        type: REAL
        inferred: true
      source:
        type: TEXT
        inferred: true
  events:
    expected_columns:
      date:
        type: DATE
        inferred: true
      description:
        type: TEXT
        inferred: true
      id:
        type: INTEGER
        inferred: true
      lieu:
        type: TEXT
        inferred: true
      name:
        type: TEXT
        inferred: true
  fournisseurs:
    expected_columns:
      name:
        type: TEXT
        inferred: true
  historique_clotures:
    expected_columns:
      date_cloture:
        type: DATE
        inferred: true
      id:
        type: INTEGER
        inferred: true
  inventaire_lignes:
    expected_columns:
      c:
        type: TEXT
        inferred: true
      categorie:
        type: TEXT
        inferred: true
      inventaire_id:
        type: INTEGER
        inferred: true
      l:
        type: TEXT
        inferred: true
      name:
        type: TEXT
        inferred: true
      quantite_constatee:
        type: REAL
        inferred: true
      s:
        type: TEXT
        inferred: true
      stock_id:
        type: INTEGER
        inferred: true
  inventaires:
    expected_columns:
      commentaire:
        type: TEXT
        inferred: true
      date_inventaire:
        type: DATE
        inferred: true
      event_id:
        type: INTEGER
        inferred: true
  membres:
    expected_columns:
      commentaire:
        type: TEXT
        inferred: true
      cotisation:
        type: TEXT
        inferred: true
      date_adhesion:
        type: DATE
        inferred: true
      email:
        type: TEXT
        inferred: true
      id:
        type: INTEGER
        inferred: true
      name:
        type: TEXT
        inferred: true
      prenom:
        type: TEXT
        inferred: true
      statut:
        type: TEXT
        inferred: true
      telephone:
        type: TEXT
        inferred: true
  mouvements_stock:
    expected_columns:
      commentaire:
        type: TEXT
        inferred: true
      date:
        type: DATE
        inferred: true
      date_peremption:
        type: DATE
        inferred: true
      id:
        type: INTEGER
        inferred: true
      m:
        type: TEXT
        inferred: true
      name:
        type: TEXT
        inferred: true
      prix_achat_total:
        type: REAL
        inferred: true
      prix_unitaire:
        type: REAL
        inferred: true
      quantite:
        type: REAL
        inferred: true
      s:
        type: TEXT
        inferred: true
      type:
        type: TEXT
        inferred: true
  retrocessions_ecoles:
    expected_columns:
      article_id:
        type: INTEGER
        inferred: true
      banque:
        type: TEXT
        inferred: true
      but_asso:
        type: TEXT
        inferred: true
      caisse_id:
        type: INTEGER
        inferred: true
      categorie:
        type: TEXT
        inferred: true
      categorie_id:
        type: INTEGER
        inferred: true
      classe:
        type: TEXT
        inferred: true
      cloture:
        type: INTEGER
        inferred: true
      commentaire:
        type: TEXT
        inferred: true
      contenance:
        type: TEXT
        inferred: true
      cotisation:
        type: TEXT
        inferred: true
      date:
        type: TEXT
        inferred: true
      date_achat:
        type: TEXT
        inferred: true
      date_adhesion:
        type: TEXT
        inferred: true
      date_cloture:
        type: TEXT
        inferred: true
      date_depense:
        type: TEXT
        inferred: true
      date_fin:
        type: TEXT
        inferred: true
      date_inventaire:
        type: TEXT
        inferred: true
      date_mouvement:
        type: TEXT
        inferred: true
      date_peremption:
        type: TEXT
        inferred: true
      date_recette:
        type: TEXT
        inferred: true
      description:
        type: TEXT
        inferred: true
      disponible_banque:
        type: REAL
        inferred: true
      ecole:
        type: TEXT
        inferred: true
      email:
        type: TEXT
        inferred: true
      event_id:
        type: INTEGER
        inferred: true
      exercice:
        type: TEXT
        inferred: true
      facture:
        type: TEXT
        inferred: true
      field_id:
        type: INTEGER
        inferred: true
      fournisseur:
        type: TEXT
        inferred: true
      id:
        type: INTEGER
        inferred: true
      id_col_total:
        type: INTEGER
        inferred: true
      inventaire_id:
        type: INTEGER
        inferred: true
      justificatif:
        type: TEXT
        inferred: true
      lieu:
        type: TEXT
        inferred: true
      lot:
        type: TEXT
        inferred: true
      membre_id:
        type: INTEGER
        inferred: true
      mode_paiement:
        type: TEXT
        inferred: true
      modele_colonne:
        type: TEXT
        inferred: true
      modele_id:
        type: INTEGER
        inferred: true
      module_id:
        type: INTEGER
        inferred: true
      moment:
        type: TEXT
        inferred: true
      montant:
        type: REAL
        inferred: true
      motif:
        type: TEXT
        inferred: true
      moyen_paiement:
        type: TEXT
        inferred: true
      name:
        type: TEXT
        inferred: true
      nom_caisse:
        type: TEXT
        inferred: true
      nom_champ:
        type: TEXT
        inferred: true
      nom_module:
        type: TEXT
        inferred: true
      nom_payeuse:
        type: TEXT
        inferred: true
      numero_cheque:
        type: TEXT
        inferred: true
      numero_facture:
        type: TEXT
        inferred: true
      parent_id:
        type: INTEGER
        inferred: true
      paye_par:
        type: TEXT
        inferred: true
      pointe:
        type: INTEGER
        inferred: true
      prenom:
        type: TEXT
        inferred: true
      prix_achat_total:
        type: REAL
        inferred: true
      prix_unitaire:
        type: REAL
        inferred: true
      purchase_price:
        type: REAL
        inferred: true
      quantite:
        type: INTEGER
        inferred: true
      quantite_constatee:
        type: INTEGER
        inferred: true
      reference:
        type: TEXT
        inferred: true
      row_index:
        type: INTEGER
        inferred: true
      seuil_alerte:
        type: INTEGER
        inferred: true
      solde:
        type: REAL
        inferred: true
      solde_report:
        type: REAL
        inferred: true
      source:
        type: TEXT
        inferred: true
      statut:
        type: TEXT
        inferred: true
      statut_reglement:
        type: TEXT
        inferred: true
      statut_remboursement:
        type: TEXT
        inferred: true
      stock:
        type: INTEGER
        inferred: true
      stock_id:
        type: INTEGER
        inferred: true
      telephone:
        type: TEXT
        inferred: true
      type:
        type: TEXT
        inferred: true
      type_champ:
        type: TEXT
        inferred: true
      type_inventaire:
        type: TEXT
        inferred: true
      type_modele:
        type: TEXT
        inferred: true
      type_mouvement:
        type: TEXT
        inferred: true
      unite:
        type: TEXT
        inferred: true
      valeur:
        type: REAL
        inferred: true
  sqlite_master:
    expected_columns:
      name:
        type: TEXT
        inferred: true
  stock:
    expected_columns:
      c:
        type: TEXT
        inferred: true
      categorie:
        type: TEXT
        inferred: true
      categorie_id:
        type: INTEGER
        inferred: true
      commentaire:
        type: TEXT
        inferred: true
      date_peremption:
        type: DATE
        inferred: true
      id:
        type: INTEGER
        inferred: true
      lot:
        type: TEXT
        inferred: true
      name:
        type: TEXT
        inferred: true
      nb_articles:
        type: TEXT
        inferred: true
      quantite:
        type: REAL
        inferred: true
      s:
        type: TEXT
        inferred: true
      seuil_alerte:
        type: TEXT
        inferred: true
      stock_id:
        type: INTEGER
        inferred: true
      total_qte:
        type: REAL
        inferred: true
  table_name:
    expected_columns:
      col1:
        type: TEXT
        inferred: true
      col2:
        type: TEXT
        inferred: true
      col3:
        type: TEXT
        inferred: true
      pattern:
        type: TEXT
        inferred: true
  valeurs_modeles_colonnes:
    expected_columns:
      modele_id:
        type: INTEGER
        inferred: true
      valeur:
        type: REAL
        inferred: true

# Manual overrides (edit this section to add custom mappings)
manual_overrides: {}

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dialogs/add_row_dialog.py ===

```python
import tkinter as tk
from tkinter import ttk
from utils.error_handler import handle_errors

class AddRowDialog(tk.Toplevel):
    def __init__(self, master, fields, get_choices_func):
        super().__init__(master)
        self.title("Ajouter une ligne")
        self.result = None
        self.entries = {}
        self.geometry(f"400x{100+40*len(fields)}")
        frm = tk.Frame(self)
        frm.pack(padx=12, pady=12, fill="both", expand=True)
        for i, f in enumerate(fields):
            tk.Label(frm, text=f["nom_champ"]).grid(row=i, column=0, sticky="w", pady=6, padx=3)
            if f.get("modele_colonne"):
                try:
                    choix = get_choices_func(f["modele_colonne"])
                except Exception as e:
                    choix = []
                var = tk.StringVar()
                cb = ttk.Combobox(frm, textvariable=var, values=choix, state="readonly")
                cb.grid(row=i, column=1, sticky="ew", padx=3)
                if choix:
                    cb.current(0)
                self.entries[f["id"]] = var
            else:
                var = tk.StringVar()
                e = tk.Entry(frm, textvariable=var)
                e.grid(row=i, column=1, sticky="ew", padx=3)
                self.entries[f["id"]] = var
            frm.columnconfigure(1, weight=1)
        btnf = tk.Frame(self)
        btnf.pack(pady=8)
        tk.Button(btnf, text="Ajouter", command=self.validate).pack(side="left", padx=8)
        tk.Button(btnf, text="Annuler", command=self.destroy).pack(side="right", padx=8)
        self.bind("<Return>", lambda e: self.validate())
        self.grab_set()
        self.focus_set()
        self.wait_window(self)

    @handle_errors
    def validate(self):
        vals = {fid: var.get() for fid, var in self.entries.items()}
        self.result = vals
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dialogs/cloture_confirm_dialog.py ===

```python
import tkinter as tk
from tkinter import messagebox
from db.db import get_connection
from utils.error_handler import handle_errors

class ClotureConfirmDialog(tk.Toplevel):
    def __init__(self, master):
        super().__init__(master)
        self.title("Confirmer la rÃ©initialisation")
        self.geometry("400x210")
        tk.Label(self, text="âš ï¸ ÃŠtes-vous sÃ»r de vouloir rÃ©initialiser la base ?", fg="red", font=("Arial", 13, "bold")).pack(pady=18)
        tk.Label(self, text="Toutes les donnÃ©es de l'exercice courant seront supprimÃ©es.\nCette action est IRRÃ‰VERSIBLE.", fg="red").pack(pady=8)
        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=24)
        tk.Button(btn_frame, text="Oui, rÃ©initialiser", fg="red", command=self.do_cloture).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

    @handle_errors
    def do_cloture(self):
        conn = get_connection()
        to_truncate = [
            "events", "event_modules", "event_module_fields", "event_module_data",
            "members", "dons_subventions", "depenses_regulieres", "depenses_diverses",
            "journal", "stock"
        ]
        for tab in to_truncate:
            try:
                conn.execute(f"DELETE FROM {tab}")
            except Exception as e:
                # On continue malgrÃ© l'Ã©chec sur une table (ex: si elle n'existe pas)
                pass
        conn.commit()
        conn.close()
        messagebox.showinfo("ClÃ´ture", "DonnÃ©es rÃ©initialisÃ©es. Nouvel exercice prÃªt.")
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dialogs/depense_dialog.py ===

```python
import tkinter as tk
import sqlite3
from tkinter import ttk, messagebox
from db.db import get_connection
from utils.error_handler import handle_errors

class DepenseDialog(tk.Toplevel):
    """
    FenÃªtre gÃ©nÃ©rique d'ajout/Ã©dition de dÃ©pense, ultra-paramÃ©trable.
    Voir l'exemple d'utilisation dans les modules.
    """
    def __init__(self, master, table, depense_id=None, event_id=None, on_save=None, fields=None,
                 module_choices=None, fournisseur_choices=None, membre_choices=None):
        super().__init__(master)
        self.title("DÃ©pense" if depense_id is None else "Ã‰diter la dÃ©pense")
        self.table = table
        self.depense_id = depense_id
        self.event_id = event_id
        self.on_save = on_save
        self.fields = fields or {}
        self.module_choices = module_choices or [("", "Aucun")]
        self.fournisseur_choices = fournisseur_choices or []
        self.membre_choices = membre_choices or []
        self.geometry("600x520")
        self.resizable(False, False)

        frame = tk.Frame(self)
        frame.pack(padx=18, pady=12, fill="both", expand=True)
        self.vars = {}

        row = 0
        if self.fields.get("categorie", False):
            tk.Label(frame, text="CatÃ©gorie :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["categorie"] = tk.StringVar()
            tk.Entry(frame, textvariable=self.vars["categorie"], width=32).grid(row=row, column=1, sticky="ew"); row += 1
        if self.fields.get("description", False):
            tk.Label(frame, text="Description :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["description"] = tk.StringVar()
            tk.Entry(frame, textvariable=self.vars["description"], width=32).grid(row=row, column=1, sticky="ew"); row += 1

        if self.fields.get("module_id", False):
            tk.Label(frame, text="Module liÃ© :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["module_id"] = tk.StringVar()
            module_menu = ttk.Combobox(frame, textvariable=self.vars["module_id"], state="readonly")
            module_menu['values'] = [n for _, n in self.module_choices]
            module_menu.current(0)
            module_menu.grid(row=row, column=1, sticky="ew"); row += 1

        if self.fields.get("montant", False):
            tk.Label(frame, text="Montant (â‚¬) :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["montant"] = tk.StringVar(value="0.0")
            tk.Entry(frame, textvariable=self.vars["montant"], width=20).grid(row=row, column=1, sticky="ew"); row += 1

        if self.fields.get("fournisseur", False):
            tk.Label(frame, text="Fournisseur :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["fournisseur"] = tk.StringVar()
            fournisseur_menu = ttk.Combobox(frame, textvariable=self.vars["fournisseur"], values=self.fournisseur_choices)
            fournisseur_menu.grid(row=row, column=1, sticky="ew"); row += 1

        if self.fields.get("date_depense", False):
            tk.Label(frame, text="Date de la dÃ©pense :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["date_depense"] = tk.StringVar()
            tk.Entry(frame, textvariable=self.vars["date_depense"], width=18).grid(row=row, column=1, sticky="ew"); row += 1
        if self.fields.get("date", False):
            tk.Label(frame, text="Date :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["date"] = tk.StringVar()
            tk.Entry(frame, textvariable=self.vars["date"], width=18).grid(row=row, column=1, sticky="ew"); row += 1

        if self.fields.get("echeance", False):
            tk.Label(frame, text="Ã‰chÃ©ance :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["echeance"] = tk.StringVar()
            tk.Entry(frame, textvariable=self.vars["echeance"], width=18).grid(row=row, column=1, sticky="ew"); row += 1

        if self.fields.get("paye_par", False):
            tk.Label(frame, text="PayÃ© par :").grid(row=row, column=0, sticky="w", pady=4)
            self.paye_par_var = tk.StringVar(value="Association")
            paye_frame = tk.Frame(frame)
            paye_frame.grid(row=row, column=1, sticky="w")
            tk.Radiobutton(paye_frame, text="Association", variable=self.paye_par_var, value="Association", command=self.toggle_paye_par).pack(side=tk.LEFT)
            tk.Radiobutton(paye_frame, text="Membre", variable=self.paye_par_var, value="Membre", command=self.toggle_paye_par).pack(side=tk.LEFT)
            row += 1

            self.statut_reglement_var = tk.StringVar(value="RÃ©glÃ©")
            self.statut_remb_var = tk.StringVar(value="Non remboursÃ©")
            self.statut_reglement_frame = tk.Frame(frame)
            tk.Label(self.statut_reglement_frame, text="Statut rÃ¨glement :").pack(side=tk.LEFT)
            ttk.Combobox(self.statut_reglement_frame, textvariable=self.statut_reglement_var, values=["RÃ©glÃ©", "Non rÃ©glÃ©"], state="readonly", width=14).pack(side=tk.LEFT)
            self.statut_reglement_frame.grid(row=row, column=1, sticky="w")
            self.statut_remb_frame = tk.Frame(frame)
            tk.Label(self.statut_remb_frame, text="Statut remboursement :").pack(side=tk.LEFT)
            ttk.Combobox(self.statut_remb_frame, textvariable=self.statut_remb_var, values=["Non remboursÃ©", "RemboursÃ©"], state="readonly", width=16).pack(side=tk.LEFT)
            self.statut_remb_frame.grid(row=row, column=1, sticky="w")
            self.statut_remb_frame.grid_remove()
            row += 1

            self.membre_var = tk.StringVar()
            self.membre_frame = tk.Frame(frame)
            tk.Label(self.membre_frame, text="Membre :").pack(side=tk.LEFT)
            self.membre_menu = ttk.Combobox(self.membre_frame, textvariable=self.membre_var, values=[n for _, n in self.membre_choices], state="readonly", width=16)
            self.membre_menu.pack(side=tk.LEFT)
            self.membre_frame.grid(row=row, column=1, sticky="w")
            self.membre_frame.grid_remove()
            row += 1

        if self.fields.get("moyen_paiement", False):
            tk.Label(frame, text="Moyen de paiement :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["moyen_paiement"] = tk.StringVar()
            moyen_menu = ttk.Combobox(frame, textvariable=self.vars["moyen_paiement"], values=["EspÃ¨ces", "ChÃ¨que", "Virement", "PrÃ©lÃ¨vement", "Carte bancaire", "Carte Asso"], state="readonly")
            moyen_menu.grid(row=row, column=1, sticky="ew"); row += 1

        if self.fields.get("numero_cheque", False):
            tk.Label(frame, text="NumÃ©ro de chÃ¨que :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["numero_cheque"] = tk.StringVar()
            tk.Entry(frame, textvariable=self.vars["numero_cheque"], width=20).grid(row=row, column=1, sticky="ew"); row += 1

        if self.fields.get("numero_facture", False):
            tk.Label(frame, text="NumÃ©ro de facture :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["numero_facture"] = tk.StringVar()
            tk.Entry(frame, textvariable=self.vars["numero_facture"], width=20).grid(row=row, column=1, sticky="ew"); row += 1

        if self.fields.get("justificatif", False):
            tk.Label(frame, text="Justificatif :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["justificatif"] = tk.StringVar()
            tk.Entry(frame, textvariable=self.vars["justificatif"], width=28).grid(row=row, column=1, sticky="ew"); row += 1

        if self.fields.get("commentaire", False):
            tk.Label(frame, text="Commentaire :").grid(row=row, column=0, sticky="w", pady=4)
            self.vars["commentaire"] = tk.StringVar()
            tk.Entry(frame, textvariable=self.vars["commentaire"], width=50).grid(row=row, column=1, sticky="ew"); row += 1

        btns = tk.Frame(self)
        btns.pack(pady=18)
        tk.Button(btns, text="Enregistrer", command=self.save, width=15).pack(side=tk.LEFT, padx=14)
        tk.Button(btns, text="Annuler", command=self.destroy, width=15).pack(side=tk.RIGHT, padx=14)

        self.load_data()
        if self.fields.get("paye_par", False):
            self.toggle_paye_par()

    def toggle_paye_par(self):
        if self.paye_par_var.get() == "Membre":
            self.membre_frame.grid()
            self.statut_remb_frame.grid()
            self.statut_reglement_frame.grid_remove()
        else:
            self.membre_frame.grid_remove()
            self.statut_remb_frame.grid_remove()
            self.statut_reglement_frame.grid()

    def load_data(self):
        if not self.depense_id:
            return
        conn = get_connection()
        try:
            row = conn.execute(f"SELECT * FROM {self.table} WHERE id=?", (self.depense_id,)).fetchone()
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur chargement dÃ©pense: {e}")
            conn.close()
            return
        conn.close()
        if not row:
            return
        for k in self.vars:
            self.vars[k].set(row[k] if k in row.keys() else "")
        if self.fields.get("paye_par", False):
            self.paye_par_var.set(row["paye_par"] if "paye_par" in row.keys() else "Association")
            self.statut_reglement_var.set(row["statut_reglement"] if "statut_reglement" in row.keys() else "RÃ©glÃ©")
            self.statut_remb_var.set(row["statut_remboursement"] if "statut_remboursement" in row.keys() else "Non remboursÃ©")
            if "membre_id" in row.keys() and row["membre_id"] and self.membre_choices:
                for i, (mid, name) in enumerate(self.membre_choices):
                    if mid and int(mid) == row["membre_id"]:
                        self.membre_menu.current(i)
                        break

    @handle_errors
    def save(self):
        # Champs obligatoires
        if self.fields.get("categorie") and not self.vars["categorie"].get().strip():
            messagebox.showerror("Erreur", "CatÃ©gorie obligatoire.")
            return
        if self.fields.get("description") and not self.vars["description"].get().strip():
            messagebox.showerror("Erreur", "Description obligatoire.")
            return
        if self.fields.get("montant"):
            try:
                montant = float(self.vars["montant"].get().replace(",", "."))
                if montant <= 0:
                    raise Exception
            except Exception:
                messagebox.showerror("Erreur", "Montant invalide.")
                return
        # Champs date obligatoires (corrige IntegrityError)
        # Pour depenses_diverses ou depenses_regulieres, la clÃ© est souvent "date_depense"
        if (self.table in ("depenses_diverses", "depenses_regulieres")):
            date_val = self.vars.get("date_depense", self.vars.get("date", None))
            if date_val is None or not date_val.get().strip():
                messagebox.showerror("Erreur", "La date de la dÃ©pense est obligatoire.")
                return
        if self.fields.get("date") and not self.vars["date"].get().strip():
            messagebox.showerror("Erreur", "La date est obligatoire.")
            return

        values = {}
        for k, var in self.vars.items():
            values[k] = var.get().strip()
            if k == "montant":
                values[k] = float(values[k].replace(",", "."))

        if self.fields.get("paye_par", False):
            values["paye_par"] = self.paye_par_var.get()
            values["statut_remboursement"] = self.statut_remb_var.get() if self.paye_par_var.get() == "Membre" else ""
            values["statut_reglement"] = self.statut_reglement_var.get() if self.paye_par_var.get() == "Association" else ""
            if self.paye_par_var.get() == "Membre" and self.membre_choices:
                idx = self.membre_menu.current()
                values["membre_id"] = self.membre_choices[idx][0] if idx >= 0 else None
            else:
                values["membre_id"] = None

        if self.event_id is not None:
            values["event_id"] = self.event_id

        # Correction pour mapping date_depense vers date (pour depenses_regulieres)
        if self.table == "depenses_regulieres":
            if "date_depense" in values and "date" not in values:
                values["date"] = values.pop("date_depense")

        conn = get_connection()
        try:
            if self.depense_id:
                sets = ", ".join([f"{k}=?" for k in values])
                req = f"UPDATE {self.table} SET {sets} WHERE id=?"
                conn.execute(req, list(values.values()) + [self.depense_id])
            else:
                champs = ", ".join(values.keys())
                q = ", ".join(["?"] * len(values))
                req = f"INSERT INTO {self.table} ({champs}) VALUES ({q})"
                conn.execute(req, list(values.values()))
            conn.commit()
        except sqlite3.IntegrityError as e:
            messagebox.showerror("Erreur", f"Erreur d'intÃ©gritÃ© : {e}")
            return
        except sqlite3.OperationalError as e:
            messagebox.showerror("Erreur", f"Erreur opÃ©rationnelle : {e}")
            return
        finally:
            conn.close()
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dialogs/edit_don_dialog.py ===

```python
import tkinter as tk
from tkinter import messagebox
import pandas as pd
from db.db import get_connection, get_df_or_sql
from utils.error_handler import handle_errors

# Note: DataSource.is_visualisation n'Ã©tait pas dÃ©fini dans le code fourni.
# Pour compatibilitÃ©, on vÃ©rifie sa prÃ©sence sinon on considÃ¨re False.
try:
    from db.db import DataSource
    HAS_DATASOURCE = True
except ImportError:
    HAS_DATASOURCE = False

class EditDonDialog(tk.Toplevel):
    def __init__(self, master, don_id, on_save=None):
        super().__init__(master)
        self.title("Ajouter/Modifier don ou subvention")
        self.don_id = don_id
        self.on_save = on_save
        self.geometry("400x320")
        self.resizable(False, False)

        self.donateur_var = tk.StringVar()
        self.montant_var = tk.StringVar()
        self.date_var = tk.StringVar()
        self.commentaire_var = tk.StringVar()

        row = 0
        tk.Label(self, text="Donateur/financeur :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.donateur_var, width=28).grid(row=row, column=1, pady=2); row += 1
        tk.Label(self, text="Montant (â‚¬) :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.montant_var, width=10).grid(row=row, column=1, pady=2, sticky="w"); row += 1
        tk.Label(self, text="Date :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.date_var, width=14).grid(row=row, column=1, pady=2, sticky="w"); row += 1
        tk.Label(self, text="Commentaire :").grid(row=row, column=0, sticky="nw", padx=12, pady=8)
        self.commentaire_widget = tk.Text(self, height=4, width=28, wrap=tk.WORD)
        self.commentaire_widget.grid(row=row, column=1, pady=2, sticky="w"); row += 1

        btn_frame = tk.Frame(self)
        btn_frame.grid(row=row, column=0, columnspan=2, pady=16)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if self.don_id is not None:
            self.prefill_fields()

    def prefill_fields(self):
        try:
            if HAS_DATASOURCE and getattr(DataSource, "is_visualisation", False):
                df = get_df_or_sql("dons_subventions")
                row = df[df['id'] == self.don_id].iloc[0]
            else:
                conn = get_connection()
                row = conn.execute(
                    "SELECT donateur, montant, date, commentaire FROM dons_subventions WHERE id=?", (self.don_id,)
                ).fetchone()
                conn.close()
            if row is not None:
                if not isinstance(row, pd.Series):
                    self.donateur_var.set(row[0])
                    self.montant_var.set(str(row[1]))
                    self.date_var.set(row[2])
                    self.commentaire_widget.delete("1.0", tk.END)
                    self.commentaire_widget.insert("1.0", row[3] if row[3] else "")
                else:
                    self.donateur_var.set(row["donateur"])
                    self.montant_var.set(str(row["montant"]))
                    self.date_var.set(row["date"])
                    self.commentaire_widget.delete("1.0", tk.END)
                    self.commentaire_widget.insert("1.0", row["commentaire"] if row["commentaire"] else "")
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur chargement du don : {e}")

    @handle_errors
    def save(self):
        donateur = self.donateur_var.get().strip()
        montant = self.montant_var.get().strip()
        date = self.date_var.get().strip()
        commentaire = self.commentaire_widget.get("1.0", tk.END).strip()
        if not donateur or not montant or not date:
            messagebox.showerror("Erreur", "Name, montant et date obligatoires.")
            return
        try:
            montant = float(montant.replace(",", "."))
        except Exception:
            messagebox.showerror("Erreur", "Montant invalide.")
            return
        conn = get_connection()
        try:
            if self.don_id is None:
                conn.execute(
                    "INSERT INTO dons_subventions (donateur, montant, date, commentaire) VALUES (?, ?, ?, ?)",
                    (donateur, montant, date, commentaire)
                )
            else:
                conn.execute(
                    "UPDATE dons_subventions SET donateur=?, montant=?, date=?, commentaire=? WHERE id=?",
                    (donateur, montant, date, commentaire, self.don_id)
                )
            conn.commit()
        finally:
            conn.close()
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dialogs/edit_event_dialog.py ===

```python
import tkinter as tk
from tkinter import messagebox
from tkcalendar import DateEntry
import pandas as pd
from dialogs.edit_field_dialog import EditFieldDialog
from db.db import get_connection, get_df_or_sql
from utils.error_handler import handle_errors

# Optionally handle DataSource if present
try:
    from db.db import DataSource
    HAS_DATASOURCE = True
except ImportError:
    HAS_DATASOURCE = False

class EditEventDialog(tk.Toplevel):
    def __init__(self, master, event_id, on_save=None):
        super().__init__(master)
        self.title("Ajouter/Modifier Ã©vÃ©nement")
        self.event_id = event_id
        self.on_save = on_save
        self.geometry("400x340")
        self.resizable(False, False)

        self.name_var = tk.StringVar()
        self.date_var = tk.StringVar()
        self.lieu_var = tk.StringVar()
        self.commentaire_var = tk.StringVar()

        row = 0
        tk.Label(self, text="Name :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.name_var, width=32).grid(row=row, column=1, pady=2); row += 1
        tk.Label(self, text="Date :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        DateEntry(self, textvariable=self.date_var, date_pattern='yyyy-mm-dd').grid(row=row, column=1, pady=2, sticky="w"); row += 1
        tk.Label(self, text="Lieu :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.lieu_var, width=32).grid(row=row, column=1, pady=2); row += 1
        tk.Label(self, text="Commentaire :").grid(row=row, column=0, sticky="nw", padx=12, pady=8)
        self.commentaire_widget = tk.Text(self, height=5, width=32, wrap=tk.WORD)
        self.commentaire_widget.grid(row=row, column=1, pady=2, sticky="w"); row += 1

        btn_frame = tk.Frame(self)
        btn_frame.grid(row=row, column=0, columnspan=2, pady=16)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if self.event_id is not None:
            self.prefill_fields()

    def prefill_fields(self):
        try:
            if HAS_DATASOURCE and getattr(DataSource, "is_visualisation", False):
                df = get_df_or_sql("events")
                row = df[df['id'] == self.event_id].iloc[0]
            else:
                conn = get_connection()
                row = conn.execute(
                    "SELECT name, date, lieu, commentaire FROM events WHERE id=?", (self.event_id,)
                ).fetchone()
                conn.close()
            if row is not None:
                if not isinstance(row, pd.Series):
                    self.name_var.set(row[0])
                    self.date_var.set(row[1])
                    self.lieu_var.set(row[2] if row[2] else "")
                    self.commentaire_widget.delete("1.0", tk.END)
                    self.commentaire_widget.insert("1.0", row[3] if row[3] else "")
                else:
                    self.name_var.set(row["name"])
                    self.date_var.set(row["date"])
                    self.lieu_var.set(row["lieu"] if row["lieu"] else "")
                    self.commentaire_widget.delete("1.0", tk.END)
                    self.commentaire_widget.insert("1.0", row["commentaire"] if row["commentaire"] else "")
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur chargement de l'Ã©vÃ©nement : {e}")

    @handle_errors
    def save(self):
        name = self.name_var.get().strip()
        date = self.date_var.get().strip()
        lieu = self.lieu_var.get().strip()
        commentaire = self.commentaire_widget.get("1.0", tk.END).strip()
        if not name or not date:
            messagebox.showerror("Erreur", "Name et date obligatoires.")
            return
        conn = get_connection()
        try:
            if self.event_id is None:
                conn.execute(
                    "INSERT INTO events (name, date, lieu, commentaire) VALUES (?, ?, ?, ?)",
                    (name, date, lieu, commentaire)
                )
            else:
                conn.execute(
                    "UPDATE events SET name=?, date=?, lieu=?, commentaire=? WHERE id=?",
                    (name, date, lieu, commentaire, self.event_id)
                )
            conn.commit()
        finally:
            conn.close()
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dialogs/edit_field_dialog.py ===

```python
import tkinter as tk
from tkinter import messagebox, ttk
from db.db import get_connection
from utils.error_handler import handle_errors

class EditFieldDialog(tk.Toplevel):
    def __init__(self, master, module_id, field_id, on_save=None, with_modele_colonne=False):
        super().__init__(master)
        self.title("Ajouter/Modifier champ")
        self.module_id = module_id
        self.field_id = field_id
        self.on_save = on_save
        self.with_modele_colonne = with_modele_colonne
        self.geometry("430x260" if with_modele_colonne else "400x210")
        self.resizable(False, False)

        self.nom_var = tk.StringVar()
        self.type_var = tk.StringVar()
        self.modele_colonne_var = tk.StringVar()
        self.modeles_choices = []

        row = 0
        tk.Label(self, text="Name du champ :").grid(row=row, column=0, sticky="w", padx=12, pady=14)
        tk.Entry(self, textvariable=self.nom_var, width=32).grid(row=row, column=1, pady=2); row += 1
        tk.Label(self, text="Type du champ :").grid(row=row, column=0, sticky="w", padx=12, pady=14)
        ttk.Combobox(self, textvariable=self.type_var, values=["TEXT", "INTEGER", "REAL"]).grid(row=row, column=1, pady=2)
        row += 1

        if self.with_modele_colonne:
            tk.Label(self, text="ModÃ¨le de colonne (liste de choix) :").grid(row=row, column=0, sticky="w", padx=12, pady=14)
            self.modeles_combo = ttk.Combobox(self, textvariable=self.modele_colonne_var, state="readonly")
            self.modeles_combo.grid(row=row, column=1, pady=2)
            # PrÃ©remplir la variable avant populate pour gÃ©rer le cas Ã©dition
            if self.field_id is not None:
                conn = get_connection()
                row_val = conn.execute("SELECT modele_colonne FROM event_module_fields WHERE id=?", (self.field_id,)).fetchone()
                conn.close()
                if row_val and row_val["modele_colonne"]:
                    self.modele_colonne_var.set(row_val["modele_colonne"])
            self.populate_modeles_combo()
            row += 1

        btn_frame = tk.Frame(self)
        btn_frame.grid(row=row, column=0, columnspan=2, pady=24)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if self.field_id is not None:
            self.prefill_fields()

    def populate_modeles_combo(self):
        try:
            conn = get_connection()
            rows = conn.execute("SELECT name FROM colonnes_modeles ORDER BY name").fetchall()
            conn.close()
            self.modeles_choices = [""] + [r["name"] for r in rows]
            current = self.modele_colonne_var.get()
            if current and current not in self.modeles_choices:
                self.modeles_choices.append(current)
            self.modeles_combo["values"] = self.modeles_choices
            if current and current in self.modeles_choices:
                self.modeles_combo.set(current)
            else:
                self.modeles_combo.current(0)
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur chargement modÃ¨les de colonnes : {e}")

    def prefill_fields(self):
        try:
            conn = get_connection()
            if self.with_modele_colonne:
                row = conn.execute(
                    "SELECT nom_champ, type_champ, modele_colonne FROM event_module_fields WHERE id=?",
                    (self.field_id,)
                ).fetchone()
            else:
                row = conn.execute(
                    "SELECT nom_champ, type_champ FROM event_module_fields WHERE id=?",
                    (self.field_id,)
                ).fetchone()
            conn.close()
            if row is not None:
                self.nom_var.set(row[0])
                self.type_var.set(row[1])
                # self.modele_colonne_var est dÃ©jÃ  prÃ©rempli avant populate_modeles_combo
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur chargement champ : {e}")

    @handle_errors
    def save(self):
        name = self.nom_var.get().strip()
        typ = self.type_var.get().strip()
        modele_colonne = self.modele_colonne_var.get().strip() if self.with_modele_colonne else None
        if not name or not typ:
            messagebox.showerror("Erreur", "Name et type obligatoires.")
            return
        conn = get_connection()
        try:
            if self.field_id is None:
                if self.with_modele_colonne:
                    conn.execute(
                        "INSERT INTO event_module_fields (module_id, nom_champ, type_champ, modele_colonne) VALUES (?, ?, ?, ?)",
                        (self.module_id, name, typ, modele_colonne if modele_colonne else None)
                    )
                else:
                    conn.execute(
                        "INSERT INTO event_module_fields (module_id, nom_champ, type_champ) VALUES (?, ?, ?)",
                        (self.module_id, name, typ)
                    )
            else:
                if self.with_modele_colonne:
                    conn.execute(
                        "UPDATE event_module_fields SET nom_champ=?, type_champ=?, modele_colonne=? WHERE id=?",
                        (name, typ, modele_colonne if modele_colonne else None, self.field_id)
                    )
                else:
                    conn.execute(
                        "UPDATE event_module_fields SET nom_champ=?, type_champ=? WHERE id=?",
                        (name, typ, self.field_id)
                    )
            conn.commit()
        finally:
            conn.close()
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dialogs/edit_journal_dialog.py ===

```python
import tkinter as tk
from tkinter import messagebox
import pandas as pd
from db.db import get_connection, get_df_or_sql
from utils.error_handler import handle_errors

# GÃ©rer DataSource si prÃ©sent
try:
    from db.db import DataSource
    HAS_DATASOURCE = True
except ImportError:
    HAS_DATASOURCE = False

class EditJournalDialog(tk.Toplevel):
    def __init__(self, master, journal_id, on_save=None):
        super().__init__(master)
        self.title("Ajouter/Modifier ligne journal")
        self.journal_id = journal_id
        self.on_save = on_save
        self.geometry("430x380")
        self.resizable(False, False)

        self.date_var = tk.StringVar()
        self.libelle_var = tk.StringVar()
        self.montant_var = tk.StringVar()
        self.type_var = tk.StringVar()
        self.categorie_var = tk.StringVar()
        self.commentaire_var = tk.StringVar()

        row = 0
        tk.Label(self, text="Date :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.date_var, width=14).grid(row=row, column=1, pady=2, sticky="w"); row += 1
        tk.Label(self, text="LibellÃ© :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.libelle_var, width=30).grid(row=row, column=1, pady=2); row += 1
        tk.Label(self, text="Montant (â‚¬) :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.montant_var, width=12).grid(row=row, column=1, pady=2, sticky="w"); row += 1
        tk.Label(self, text="Type (dÃ©pense/recette) :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.type_var, width=16).grid(row=row, column=1, pady=2, sticky="w"); row += 1
        tk.Label(self, text="CatÃ©gorie :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.categorie_var, width=18).grid(row=row, column=1, pady=2, sticky="w"); row += 1
        tk.Label(self, text="Commentaire :").grid(row=row, column=0, sticky="nw", padx=12, pady=8)
        self.commentaire_widget = tk.Text(self, height=4, width=30, wrap=tk.WORD)
        self.commentaire_widget.grid(row=row, column=1, pady=2, sticky="w"); row += 1

        btn_frame = tk.Frame(self)
        btn_frame.grid(row=row, column=0, columnspan=2, pady=16)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if self.journal_id is not None:
            self.prefill_fields()

    def prefill_fields(self):
        try:
            if HAS_DATASOURCE and getattr(DataSource, "is_visualisation", False):
                df = get_df_or_sql("journal")
                row = df[df['id'] == self.journal_id].iloc[0]
            else:
                conn = get_connection()
                row = conn.execute(
                    "SELECT date, libelle, montant, type, categorie, commentaire FROM journal WHERE id=?", (self.journal_id,)
                ).fetchone()
                conn.close()
            if row is not None:
                if not isinstance(row, pd.Series):
                    self.date_var.set(row[0])
                    self.libelle_var.set(row[1])
                    self.montant_var.set(str(row[2]))
                    self.type_var.set(row[3])
                    self.categorie_var.set(row[4] if row[4] else "")
                    self.commentaire_widget.delete("1.0", tk.END)
                    self.commentaire_widget.insert("1.0", row[5] if row[5] else "")
                else:
                    self.date_var.set(row["date"])
                    self.libelle_var.set(row["libelle"])
                    self.montant_var.set(str(row["montant"]))
                    self.type_var.set(row["type"])
                    self.categorie_var.set(row["categorie"] if row["categorie"] else "")
                    self.commentaire_widget.delete("1.0", tk.END)
                    self.commentaire_widget.insert("1.0", row["commentaire"] if row["commentaire"] else "")
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur chargement journal : {e}")

    @handle_errors
    def save(self):
        date = self.date_var.get().strip()
        libelle = self.libelle_var.get().strip()
        montant = self.montant_var.get().strip()
        typ = self.type_var.get().strip()
        categorie = self.categorie_var.get().strip()
        commentaire = self.commentaire_widget.get("1.0", tk.END).strip()
        if not date or not libelle or not montant or not typ:
            messagebox.showerror("Erreur", "Date, libellÃ©, montant et type obligatoires.")
            return
        try:
            montant = float(montant.replace(",", "."))
        except Exception:
            messagebox.showerror("Erreur", "Montant invalide.")
            return
        conn = get_connection()
        try:
            if self.journal_id is None:
                conn.execute(
                    "INSERT INTO journal (date, libelle, montant, type, categorie, commentaire) VALUES (?, ?, ?, ?, ?, ?)",
                    (date, libelle, montant, typ, categorie, commentaire)
                )
            else:
                conn.execute(
                    "UPDATE journal SET date=?, libelle=?, montant=?, type=?, categorie=?, commentaire=? WHERE id=?",
                    (date, libelle, montant, typ, categorie, commentaire, self.journal_id)
                )
            conn.commit()
        finally:
            conn.close()
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dialogs/edit_member_dialog.py ===

```python
import tkinter as tk
from tkinter import messagebox
import pandas as pd
from db.db import get_connection, get_df_or_sql
from utils.error_handler import handle_errors

# Optionally handle DataSource if present
try:
    from db.db import DataSource
    HAS_DATASOURCE = True
except ImportError:
    HAS_DATASOURCE = False

class EditMemberDialog(tk.Toplevel):
    def __init__(self, master, member_id, on_save=None):
        super().__init__(master)
        self.title("Ajouter/Modifier membre")
        self.member_id = member_id
        self.on_save = on_save
        self.geometry("400x400")
        self.resizable(False, False)

        self.nom_var = tk.StringVar()
        self.prenom_var = tk.StringVar()
        self.email_var = tk.StringVar()
        self.classe_var = tk.StringVar()
        self.cotisation_var = tk.StringVar()
        self.commentaire_var = tk.StringVar()

        row = 0
        tk.Label(self, text="Name :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.nom_var, width=28).grid(row=row, column=1, pady=2); row += 1
        tk.Label(self, text="PrÃ©nom :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.prenom_var, width=28).grid(row=row, column=1, pady=2); row += 1
        tk.Label(self, text="E-mail :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.email_var, width=28).grid(row=row, column=1, pady=2); row += 1
        tk.Label(self, text="Classe :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.classe_var, width=14).grid(row=row, column=1, pady=2, sticky="w"); row += 1
        tk.Label(self, text="Cotisation :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        tk.Entry(self, textvariable=self.cotisation_var, width=10).grid(row=row, column=1, pady=2, sticky="w"); row += 1
        tk.Label(self, text="Commentaire :").grid(row=row, column=0, sticky="nw", padx=12, pady=8)
        self.commentaire_widget = tk.Text(self, height=4, width=28, wrap=tk.WORD)
        self.commentaire_widget.grid(row=row, column=1, pady=2, sticky="w"); row += 1

        btn_frame = tk.Frame(self)
        btn_frame.grid(row=row, column=0, columnspan=2, pady=16)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if self.member_id is not None:
            self.prefill_fields()

    def prefill_fields(self):
        try:
            if HAS_DATASOURCE and getattr(DataSource, "is_visualisation", False):
                df = get_df_or_sql("membres")
                row = df[df['id'] == self.member_id].iloc[0]
            else:
                conn = get_connection()
                row = conn.execute(
                    "SELECT name, prenom, email, classe, cotisation, commentaire FROM membres WHERE id=?", (self.member_id,)
                ).fetchone()
                conn.close()
            if row is not None:
                if not isinstance(row, pd.Series):
                    self.nom_var.set(row[0])
                    self.prenom_var.set(row[1])
                    self.email_var.set(row[2] if row[2] else "")
                    self.classe_var.set(row[3] if row[3] else "")
                    self.cotisation_var.set(str(row[4]) if row[4] else "")
                    self.commentaire_widget.delete("1.0", tk.END)
                    self.commentaire_widget.insert("1.0", row[5] if row[5] else "")
                else:
                    self.nom_var.set(row["name"])
                    self.prenom_var.set(row["prenom"])
                    self.email_var.set(row["email"] if row["email"] else "")
                    self.classe_var.set(row["classe"] if row["classe"] else "")
                    self.cotisation_var.set(str(row["cotisation"]) if row["cotisation"] else "")
                    self.commentaire_widget.delete("1.0", tk.END)
                    self.commentaire_widget.insert("1.0", row["commentaire"] if row["commentaire"] else "")
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur chargement membre : {e}")

    @handle_errors
    def save(self):
        name = self.nom_var.get().strip()
        prenom = self.prenom_var.get().strip()
        email = self.email_var.get().strip()
        classe = self.classe_var.get().strip()
        cotisation = self.cotisation_var.get().strip()
        commentaire = self.commentaire_widget.get("1.0", tk.END).strip()
        if not name or not prenom:
            messagebox.showerror("Erreur", "Name et prÃ©nom obligatoires.")
            return
        conn = get_connection()
        try:
            if self.member_id is None:
                conn.execute(
                    "INSERT INTO membres (name, prenom, email, classe, cotisation, commentaire) VALUES (?, ?, ?, ?, ?, ?)",
                    (name, prenom, email, classe, cotisation, commentaire)
                )
            else:
                conn.execute(
                    "UPDATE membres SET name=?, prenom=?, email=?, classe=?, cotisation=?, commentaire=? WHERE id=?",
                    (name, prenom, email, classe, cotisation, commentaire, self.member_id)
                )
            conn.commit()
        finally:
            conn.close()
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dialogs/edit_module_data_dialog.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection, get_df_or_sql
from utils.error_handler import handle_errors

# Optionally handle DataSource if present
try:
    from db.db import DataSource
    HAS_DATASOURCE = True
except ImportError:
    HAS_DATASOURCE = False

def get_modele_colonne(fid):
    try:
        conn = get_connection()
        row = conn.execute(
            "SELECT modele_colonne FROM event_module_fields WHERE id=?", (fid,)
        ).fetchone()
        conn.close()
        if row:
            return row[0]
    except Exception:
        pass
    return None

def get_choix_for_modele(modele_colonne):
    try:
        conn = get_connection()
        res = conn.execute(
            "SELECT valeur FROM valeurs_modeles_colonnes WHERE modele_id=(SELECT id FROM colonnes_modeles WHERE name=?)",
            (modele_colonne,)
        ).fetchall()
        conn.close()
        return [r["valeur"] for r in res]
    except Exception:
        return []

class EditModuleDataDialog(tk.Toplevel):
    def __init__(self, master, module_id, row_index, fields, on_save=None):
        super().__init__(master)
        self.title("Ajouter/Modifier ligne de donnÃ©es")
        self.module_id = module_id
        self.row_index = row_index
        self.fields = fields
        self.on_save = on_save
        self.widgets = []
        self.vars = []
        self.geometry("520x%s" % (100 + 40*len(fields)))
        self.resizable(False, False)

        # Ajout dynamique des champs avec ComboBox si modÃ¨le, sinon Entry
        for i, (fid, label, *rest) in enumerate(self._fields_with_modele()):
            modele_colonne = rest[0] if rest else None
            tk.Label(self, text=label+" :").grid(row=i, column=0, sticky="w", padx=12, pady=8)
            var = tk.StringVar()
            if modele_colonne:
                choix = get_choix_for_modele(modele_colonne)
                widget = ttk.Combobox(self, textvariable=var, values=choix, state="readonly")
                if choix:
                    var.set(choix[0])
            else:
                widget = tk.Entry(self, textvariable=var, width=38)
            widget.grid(row=i, column=1, pady=2)
            self.widgets.append(widget)
            self.vars.append(var)

        btn_frame = tk.Frame(self)
        btn_frame.grid(row=len(self.fields), column=0, columnspan=2, pady=16)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if self.row_index is not None:
            self.prefill_fields()

    def _fields_with_modele(self):
        # Retourne (field_id, label, modele_colonne) pour chaque champ
        for f in self.fields:
            if len(f) >= 3:
                yield (f[0], f[1], f[2])
            else:
                modele = get_modele_colonne(f[0])
                yield (f[0], f[1], modele)

    def prefill_fields(self):
        try:
            if HAS_DATASOURCE and getattr(DataSource, "is_visualisation", False):
                df = get_df_or_sql("event_module_data")
                df = df[(df["module_id"] == self.module_id) & (df["row_index"] == self.row_index)]
                values = {row["field_id"]: row["valeur"] for _, row in df.iterrows()}
            else:
                conn = get_connection()
                rows = conn.execute(
                    "SELECT field_id, valeur FROM event_module_data WHERE module_id=? AND row_index=?",
                    (self.module_id, self.row_index)
                ).fetchall()
                conn.close()
                values = {fid: v for fid, v in rows}
            for i, (fid, _, *_) in enumerate(self._fields_with_modele()):
                self.vars[i].set(values.get(fid, ""))
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur chargement des donnÃ©es du module : {e}")

    @handle_errors
    def save(self):
        vals = [v.get().strip() for v in self.vars]
        if any(not v for v in vals):
            if not messagebox.askyesno("Champs vides", "Certains champs sont vides. Continuerâ€¯?"):
                return
        conn = get_connection()
        try:
            if self.row_index is None:
                rowidx = conn.execute(
                    "SELECT MAX(row_index) FROM event_module_data WHERE module_id=?", (self.module_id,)
                ).fetchone()[0]
                rowidx = (rowidx or 0) + 1
            else:
                rowidx = self.row_index
                conn.execute("DELETE FROM event_module_data WHERE module_id=? AND row_index=?", (self.module_id, rowidx))
            for i, (fid, _, *_) in enumerate(self._fields_with_modele()):
                conn.execute(
                    "INSERT INTO event_module_data (module_id, row_index, field_id, valeur) VALUES (?, ?, ?, ?)",
                    (self.module_id, rowidx, fid, vals[i])
                )
            conn.commit()
        finally:
            conn.close()
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dialogs/edit_module_dialog.py ===

```python
import tkinter as tk
from tkinter import messagebox
from db.db import get_connection
from utils.error_handler import handle_errors

class EditModuleDialog(tk.Toplevel):
    def __init__(self, master, event_id, module_id, on_save=None):
        super().__init__(master)
        self.title("Ajouter/Modifier module")
        self.event_id = event_id
        self.module_id = module_id
        self.on_save = on_save
        self.geometry("400x180")
        self.resizable(False, False)

        self.nom_var = tk.StringVar()
        row = 0
        tk.Label(self, text="Name du module :").grid(row=row, column=0, sticky="w", padx=12, pady=14)
        tk.Entry(self, textvariable=self.nom_var, width=36).grid(row=row, column=1, pady=2); row += 1

        btn_frame = tk.Frame(self)
        btn_frame.grid(row=row, column=0, columnspan=2, pady=24)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if self.module_id is not None:
            self.prefill_fields()

    def prefill_fields(self):
        try:
            conn = get_connection()
            row = conn.execute(
                "SELECT nom_module FROM event_modules WHERE id=?", (self.module_id,)
            ).fetchone()
            conn.close()
            if row is not None:
                self.nom_var.set(row[0])
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur chargement module : {e}")

    @handle_errors
    def save(self):
        name = self.nom_var.get().strip()
        if not name:
            messagebox.showerror("Erreur", "Name du module obligatoire.")
            return
        conn = get_connection()
        try:
            if self.module_id is None:
                conn.execute(
                    "INSERT INTO event_modules (event_id, nom_module) VALUES (?, ?)",
                    (self.event_id, name)
                )
            else:
                conn.execute(
                    "UPDATE event_modules SET nom_module=? WHERE id=?",
                    (name, self.module_id)
                )
            conn.commit()
        finally:
            conn.close()
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dialogs/edit_stock_dialog.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from tkcalendar import DateEntry
import pandas as pd

from db.db import get_connection, DataSource, get_df_or_sql

class EditStockDialog(tk.Toplevel):
    def __init__(self, master, stock_id, on_save=None):
        super().__init__(master)
        self.title("Ajouter/Modifier article")
        self.stock_id = stock_id
        self.on_save = on_save
        self.geometry("450x540")
        self.resizable(False, False)

        self.nom_var = tk.StringVar()
        self.qte_var = tk.IntVar()
        self.seuil_var = tk.IntVar()
        self.lot_var = tk.StringVar()
        self.date_var = tk.StringVar()
        self.commentaire_var = tk.StringVar()
        self.categorie_var = tk.StringVar()
        self.categories = self.fetch_categories()
        cat_names = [cat['name'] for cat in self.categories]

        row = 0
        tk.Label(self, text="Name :").grid(row=row, column=0, sticky="w", padx=12, pady=8); row += 1
        tk.Entry(self, textvariable=self.nom_var, width=32).grid(row=row-1, column=1, pady=2)
        tk.Label(self, text="CatÃ©gorie :").grid(row=row, column=0, sticky="w", padx=12, pady=8)
        self.cat_cb = ttk.Combobox(self, textvariable=self.categorie_var, values=cat_names, state="readonly", width=25)
        self.cat_cb.grid(row=row, column=1, pady=2, sticky="w"); row += 1
        tk.Label(self, text="QuantitÃ© :").grid(row=row, column=0, sticky="w", padx=12, pady=8); row += 1
        tk.Entry(self, textvariable=self.qte_var, width=12).grid(row=row-1, column=1, pady=2, sticky="w")
        tk.Label(self, text="Seuil alerte :").grid(row=row, column=0, sticky="w", padx=12, pady=8); row += 1
        tk.Entry(self, textvariable=self.seuil_var, width=12).grid(row=row-1, column=1, pady=2, sticky="w")
        tk.Label(self, text="Lot :").grid(row=row, column=0, sticky="w", padx=12, pady=8); row += 1
        tk.Entry(self, textvariable=self.lot_var, width=16).grid(row=row-1, column=1, pady=2, sticky="w")
        tk.Label(self, text="Date de pÃ©remption :").grid(row=row, column=0, sticky="w", padx=12, pady=8); row += 1
        DateEntry(self, textvariable=self.date_var, date_pattern='yyyy-mm-dd').grid(row=row-1, column=1, pady=2, sticky="w")
        tk.Label(self, text="Commentaire :").grid(row=row, column=0, sticky="nw", padx=12, pady=8); row += 1
        self.commentaire_widget = tk.Text(self, height=4, width=32, wrap=tk.WORD)
        self.commentaire_widget.grid(row=row-1, column=1, pady=2, sticky="w")

        btn_frame = tk.Frame(self)
        btn_frame.grid(row=row, column=0, columnspan=2, pady=16)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if self.stock_id is not None:
            self.prefill_fields()

    def fetch_categories(self):
        if DataSource.is_visualisation:
            df = get_df_or_sql("categories")
            return df.to_dict("records")
        conn = get_connection()
        df = pd.read_sql_query("SELECT id, name FROM categories ORDER BY name", conn)
        conn.close()
        return df.to_dict("records")

    def prefill_fields(self):
        if DataSource.is_visualisation:
            df = get_df_or_sql("stock")
            row = df[df['id'] == self.stock_id].iloc[0]
        else:
            conn = get_connection()
            row = conn.execute(
                "SELECT name, quantite, seuil_alerte, lot, date_peremption, commentaire, categorie_id FROM stock WHERE id=?",
                (self.stock_id,)
            ).fetchone()
            conn.close()
        if row is not None:
            if not isinstance(row, pd.Series):
                self.nom_var.set(row[0])
                self.qte_var.set(row[1])
                self.seuil_var.set(row[2])
                self.lot_var.set(row[3] if row[3] else "")
                self.date_var.set(row[4] if row[4] else "")
                self.commentaire_widget.delete("1.0", tk.END)
                self.commentaire_widget.insert("1.0", row[5] if row[5] else "")
                cat_id = row[6]
            else:
                self.nom_var.set(row["name"])
                self.qte_var.set(row["quantite"])
                self.seuil_var.set(row["seuil_alerte"])
                self.lot_var.set(row["lot"] if row["lot"] else "")
                self.date_var.set(row["date_peremption"] if row["date_peremption"] else "")
                self.commentaire_widget.delete("1.0", tk.END)
                self.commentaire_widget.insert("1.0", row["commentaire"] if row["commentaire"] else "")
                cat_id = row["categorie_id"]
            for cat in self.categories:
                if cat['id'] == cat_id:
                    self.categorie_var.set(cat['name'])
                    break

    def save(self):
        name = self.nom_var.get().strip()
        quantite = self.qte_var.get()
        seuil = self.seuil_var.get()
        lot = self.lot_var.get().strip()
        date_peremption = self.date_var.get().strip()
        commentaire = self.commentaire_widget.get("1.0", tk.END).strip()
        cat_nom = self.categorie_var.get()
        cat_id = None
        for cat in self.categories:
            if cat['name'] == cat_nom:
                cat_id = cat['id']
                break
        if not name or cat_id is None:
            messagebox.showerror("Erreur", "Name et catÃ©gorie obligatoires.")
            return
        conn = get_connection()
        if self.stock_id is None:
            conn.execute(
                """INSERT INTO stock (name, categorie_id, quantite, seuil_alerte, lot, date_peremption, commentaire)
                   VALUES (?, ?, ?, ?, ?, ?, ?)""",
                (name, cat_id, quantite, seuil, lot if lot else None,
                 date_peremption if date_peremption else None, commentaire)
            )
        else:
            conn.execute(
                """UPDATE stock SET name=?, categorie_id=?, quantite=?, seuil_alerte=?, lot=?, date_peremption=?, commentaire=?
                WHERE id=?""",
                (name, cat_id, quantite, seuil, lot if lot else None,
                 date_peremption if date_peremption else None, commentaire, self.stock_id)
            )
        conn.commit()
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./dialogs/inventaire_dialog.py ===

```python
import tkinter as tk

class InventaireDialog(tk.Toplevel):
    def __init__(self, master, name, quantite_actuelle):
        super().__init__(master)
        self.title("Inventaire article")
        self.geometry("330x160")
        self.result = None
        self.name = name
        self.quantite_actuelle = quantite_actuelle

        tk.Label(self, text=f"Article : {name}", font=("Arial", 12)).pack(pady=8)
        tk.Label(self, text=f"QuantitÃ© actuelle : {quantite_actuelle}").pack(pady=6)
        tk.Label(self, text="Nouvelle quantitÃ© :").pack()
        self.qte_var = tk.StringVar()
        entry = tk.Entry(self, textvariable=self.qte_var, width=12, font=("Arial", 12))
        entry.pack(pady=6)
        entry.focus_set()
        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=8)
        tk.Button(btn_frame, text="Valider", command=self.on_valider).pack(side=tk.LEFT, padx=12)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=12)

        self.bind("<Return>", lambda e: self.on_valider())

    def on_valider(self):
        self.result = self.qte_var.get().strip()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./exports/exports.py ===

```python
import pandas as pd
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from db.db import get_connection

# ========== EXPORTS BILAN EVENEMENT ==========

def export_bilan_evenement(event_id, format="xlsx", filename=None):
    conn = get_connection()
    # RÃ©cup info Ã©vÃ©nement
    event = conn.execute("SELECT * FROM events WHERE id=?", (event_id,)).fetchone()
    if not event:
        messagebox.showerror("Erreur", "Ã‰vÃ©nement introuvable.")
        return

    # DonnÃ©es recettes
    recettes = pd.read_sql_query(
        "SELECT source, montant, commentaire, module_id FROM event_recettes WHERE event_id=?",
        conn, params=(event_id,)
    )
    # DonnÃ©es dÃ©penses
    depenses = pd.read_sql_query(
        "SELECT categorie, montant, fournisseur, date_depense, paye_par, membre_id, commentaire FROM event_depenses WHERE event_id=?",
        conn, params=(event_id,)
    )
    # DonnÃ©es caisses
    caisses = pd.read_sql_query(
        "SELECT id, nom_caisse, commentaire FROM event_caisses WHERE event_id=?",
        conn, params=(event_id,)
    )
    # DÃ©tail fond de caisse
    caisses_details = []
    for _, caisse in caisses.iterrows():
        cid = caisse["id"]
        debut = conn.execute(
            "SELECT SUM(CASE WHEN type='cheque' THEN valeur ELSE valeur*quantite END) as total FROM event_caisse_details WHERE caisse_id=? AND moment='debut'", (cid,)
        ).fetchone()["total"] or 0.0
        fin = conn.execute(
            "SELECT SUM(CASE WHEN type='cheque' THEN valeur ELSE valeur*quantite END) as total FROM event_caisse_details WHERE caisse_id=? AND moment='fin'", (cid,)
        ).fetchone()["total"] or 0.0
        caisses_details.append({
            "Caisse": caisse["nom_caisse"],
            "Fond dÃ©but (â‚¬)": f"{debut:.2f}",
            "Fond fin (â‚¬)": f"{fin:.2f}",
            "Gain (â‚¬)": f"{fin-debut:.2f}",
            "Commentaire": caisse["commentaire"],
        })
    caisses_details_df = pd.DataFrame(caisses_details)

    conn.close()

    if filename is None:
        ext = "." + format
        filename = filedialog.asksaveasfilename(
            defaultextension=ext,
            filetypes=[("Excel", "*.xlsx"), ("CSV", "*.csv"), ("PDF", "*.pdf")],
            title="Exporter bilan Ã©vÃ©nement",
            initialfile=f"Bilan_{event['name'].replace(' ', '_')}{ext}"
        )
    if not filename:
        return

    if format == "xlsx":
        with pd.ExcelWriter(filename) as writer:
            pd.DataFrame([dict(event)]).to_excel(writer, sheet_name="Ã‰vÃ©nement", index=False)
            recettes.to_excel(writer, sheet_name="Recettes", index=False)
            depenses.to_excel(writer, sheet_name="DÃ©penses", index=False)
            caisses_details_df.to_excel(writer, sheet_name="Caisses", index=False)
        messagebox.showinfo("Export", f"Bilan Ã©vÃ©nement exportÃ© :\n{filename}")
    elif format == "csv":
        recettes.to_csv(filename.replace(".csv", "_recettes.csv"), index=False, encoding="utf-8")
        depenses.to_csv(filename.replace(".csv", "_depenses.csv"), index=False, encoding="utf-8")
        caisses_details_df.to_csv(filename.replace(".csv", "_caisses.csv"), index=False, encoding="utf-8")
        messagebox.showinfo("Export", f"Bilans CSV exportÃ©s.")
    elif format == "pdf":
        try:
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.pagesizes import A4
            from reportlab.lib import colors
            from reportlab.lib.styles import getSampleStyleSheet
            doc = SimpleDocTemplate(filename, pagesize=A4)
            styles = getSampleStyleSheet()
            elements = []
            elements.append(Paragraph(f"Bilan de l'Ã©vÃ©nementÂ : {event['name']}", styles["Title"]))
            elements.append(Spacer(1, 12))
            elements.append(Paragraph(f"DateÂ : {event['date']} | LieuÂ : {event['lieu']}", styles["Normal"]))
            elements.append(Paragraph(f"DescriptionÂ : {event['description']}", styles["Normal"]))
            elements.append(Spacer(1, 16))
            # Recettes
            elements.append(Paragraph("Recettes", styles["Heading2"]))
            if not recettes.empty:
                data = [recettes.columns.tolist()] + recettes.values.tolist()
                t = Table(data)
                t.setStyle(TableStyle([("GRID", (0,0), (-1,-1), 0.5, colors.black)]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune recette.", styles["Normal"]))
            elements.append(Spacer(1, 12))
            # DÃ©penses
            elements.append(Paragraph("DÃ©penses", styles["Heading2"]))
            if not depenses.empty:
                data = [depenses.columns.tolist()] + depenses.values.tolist()
                t = Table(data)
                t.setStyle(TableStyle([("GRID", (0,0), (-1,-1), 0.5, colors.black)]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune dÃ©pense.", styles["Normal"]))
            elements.append(Spacer(1, 12))
            # Caisses
            elements.append(Paragraph("Caisses", styles["Heading2"]))
            if not caisses_details_df.empty:
                data = [caisses_details_df.columns.tolist()] + caisses_details_df.values.tolist()
                t = Table(data)
                t.setStyle(TableStyle([("GRID", (0,0), (-1,-1), 0.5, colors.black)]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune caisse.", styles["Normal"]))
            doc.build(elements)
            messagebox.showinfo("Export", f"Bilan PDF exportÃ©Â :\n{filename}")
        except ImportError:
            messagebox.showerror("Export", "Le module reportlab n'est pas installÃ©.")

# ========== EXPORTS GLOBAUX DÃ‰PENSES / SUBVENTIONS ==========

def export_depenses_global(format="xlsx", filename=None):
    conn = get_connection()
    depenses = pd.read_sql_query(
        "SELECT * FROM depenses_regulieres UNION ALL SELECT * FROM depenses_diverses UNION ALL SELECT * FROM event_depenses", conn
    )
    conn.close()
    if filename is None:
        ext = "." + format
        filename = filedialog.asksaveasfilename(
            defaultextension=ext,
            filetypes=[("Excel", "*.xlsx"), ("CSV", "*.csv"), ("PDF", "*.pdf")],
            title="Exporter toutes les dÃ©penses",
            initialfile="Toutes_depenses" + ext
        )
    if not filename:
        return
    if format == "xlsx":
        depenses.to_excel(filename, index=False)
        messagebox.showinfo("Export", f"Export Excel terminÃ© :\n{filename}")
    elif format == "csv":
        depenses.to_csv(filename, index=False, encoding="utf-8")
        messagebox.showinfo("Export", f"Export CSV terminÃ© :\n{filename}")
    elif format == "pdf":
        try:
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.pagesizes import A4
            from reportlab.lib import colors
            from reportlab.lib.styles import getSampleStyleSheet
            doc = SimpleDocTemplate(filename, pagesize=A4)
            styles = getSampleStyleSheet()
            elements = [Paragraph("Toutes les dÃ©penses", styles["Title"]), Spacer(1, 12)]
            data = [depenses.columns.tolist()] + depenses.values.tolist()
            t = Table(data)
            t.setStyle(TableStyle([("GRID", (0,0), (-1,-1), 0.5, colors.black)]))
            elements.append(t)
            doc.build(elements)
            messagebox.showinfo("Export", f"Export PDF terminÃ©Â :\n{filename}")
        except ImportError:
            messagebox.showerror("Export", "Le module reportlab n'est pas installÃ©.")

def export_subventions_global(format="xlsx", filename=None):
    conn = get_connection()
    subventions = pd.read_sql_query("SELECT * FROM dons_subventions", conn)
    conn.close()
    if filename is None:
        ext = "." + format
        filename = filedialog.asksaveasfilename(
            defaultextension=ext,
            filetypes=[("Excel", "*.xlsx"), ("CSV", "*.csv"), ("PDF", "*.pdf")],
            title="Exporter toutes les subventions",
            initialfile="Toutes_subventions" + ext
        )
    if not filename:
        return
    if format == "xlsx":
        subventions.to_excel(filename, index=False)
        messagebox.showinfo("Export", f"Export Excel terminÃ© :\n{filename}")
    elif format == "csv":
        subventions.to_csv(filename, index=False, encoding="utf-8")
        messagebox.showinfo("Export", f"Export CSV terminÃ© :\n{filename}")
    elif format == "pdf":
        try:
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.pagesizes import A4
            from reportlab.lib import colors
            from reportlab.lib.styles import getSampleStyleSheet
            doc = SimpleDocTemplate(filename, pagesize=A4)
            styles = getSampleStyleSheet()
            elements = [Paragraph("Toutes les subventions", styles["Title"]), Spacer(1, 12)]
            data = [subventions.columns.tolist()] + subventions.values.tolist()
            t = Table(data)
            t.setStyle(TableStyle([("GRID", (0,0), (-1,-1), 0.5, colors.black)]))
            elements.append(t)
            doc.build(elements)
            messagebox.showinfo("Export", f"Export PDF terminÃ©Â :\n{filename}")
        except ImportError:
            messagebox.showerror("Export", "Le module reportlab n'est pas installÃ©.")

# ========== EXPORTS MULTI-EVENEMENTS EN LOT ==========

def export_tous_bilans_evenements(format="xlsx", dossier=None):
    conn = get_connection()
    events = conn.execute("SELECT id, name FROM events ORDER BY date DESC").fetchall()
    conn.close()
    if dossier is None:
        dossier = filedialog.askdirectory(title="Choisir le dossier d'export pour tous les bilans Ã©vÃ©nements")
    if not dossier:
        return
    for ev in events:
        name = ev["name"].replace(" ", "_")
        fname = f"{dossier}/Bilan_{name}.{format}"
        export_bilan_evenement(ev["id"], format=format, filename=fname)
    messagebox.showinfo("Export", f"Tous les bilans Ã©vÃ©nements exportÃ©s dansÂ :\n{dossier}")
    
def export_dataframe_to_excel(df, title="Export Excel"):
    filename = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel", "*.xlsx")], title=title)
    if not filename:
        return
    df.to_excel(filename, index=False)
    messagebox.showinfo("Export", f"Export Excel terminÃ©Â :\n{filename}")

def export_dataframe_to_csv(df, title="Export CSV"):
    filename = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV", "*.csv")], title=title)
    if not filename:
        return
    df.to_csv(filename, index=False, encoding="utf-8")
    messagebox.showinfo("Export", f"Export CSV terminÃ©Â :\n{filename}")

def export_dataframe_to_pdf(df, title="Export PDF"):
    filename = filedialog.asksaveasfilename(defaultextension=".pdf", filetypes=[("PDF", "*.pdf")], title=title)
    if not filename:
        return
    try:
        from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
        from reportlab.lib.pagesizes import A4
        from reportlab.lib import colors
        from reportlab.lib.styles import getSampleStyleSheet
        doc = SimpleDocTemplate(filename, pagesize=A4)
        styles = getSampleStyleSheet()
        elements = [Paragraph(title, styles["Title"]), Spacer(1, 12)]
        data = [list(df.columns)] + df.astype(str).values.tolist()
        t = Table(data)
        t.setStyle(TableStyle([("GRID", (0,0), (-1,-1), 0.5, colors.black)]))
        elements.append(t)
        doc.build(elements)
        messagebox.showinfo("Export", f"Export PDF terminÃ©Â :\n{filename}")
    except ImportError:
        messagebox.showerror("Export", "Le module reportlab n'est pas installÃ©.")
        
def export_bilan_reporte_pdf(recap, parent, exercice, date, date_fin):
    """
    GÃ©nÃ¨re un PDF de bilan de clÃ´ture Ã  partir des DataFrames fournis dans recap
    - recap["synth_evt"] : DataFrame avec recap des Ã©vÃ©nements
    - recap["synth_dep"] : DataFrame avec recap des dÃ©penses
    """
    try:
        from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
        from reportlab.lib.pagesizes import A4
        from reportlab.lib import colors
        from reportlab.lib.styles import getSampleStyleSheet
    except ImportError:
        messagebox.showerror("Export", "Le module reportlab n'est pas installÃ©.")
        return

    file_path = filedialog.asksaveasfilename(
        title="Enregistrer le bilan PDF",
        defaultextension=".pdf",
        filetypes=[("PDF", "*.pdf")],
        parent=parent
    )
    if not file_path:
        return

    styles = getSampleStyleSheet()
    elements = []
    elements.append(Paragraph(f"Bilan de clÃ´ture d'exercice {exercice}", styles["Title"]))
    elements.append(Paragraph(f"PÃ©riode : {date} au {date_fin}", styles["Normal"]))
    elements.append(Spacer(1, 20))

    # SynthÃ¨se Ã©vÃ©nements
    synth_evt = recap.get("synth_evt")
    if synth_evt is not None and not synth_evt.empty:
        elements.append(Paragraph("SynthÃ¨se par Ã©vÃ©nement", styles["Heading2"]))
        data = [list(synth_evt.columns)] + synth_evt.astype(str).values.tolist()
        t = Table(data)
        t.setStyle(TableStyle([
            ("GRID", (0,0), (-1,-1), 0.5, colors.black),
            ("BACKGROUND", (0,0), (-1,0), colors.lightgrey),
            ("ALIGN", (1,1), (-1,-1), "RIGHT"),
        ]))
        elements.append(t)
        elements.append(Spacer(1, 12))

    # SynthÃ¨se dÃ©penses
    synth_dep = recap.get("synth_dep")
    if synth_dep is not None and not synth_dep.empty:
        elements.append(Paragraph("SynthÃ¨se dÃ©penses", styles["Heading2"]))
        data = [list(synth_dep.columns)] + synth_dep.astype(str).values.tolist()
        t = Table(data)
        t.setStyle(TableStyle([
            ("GRID", (0,0), (-1,-1), 0.5, colors.black),
            ("BACKGROUND", (0,0), (-1,0), colors.lightgrey),
            ("ALIGN", (1,1), (-1,-1), "RIGHT"),
        ]))
        elements.append(t)
        elements.append(Spacer(1, 12))

    elements.append(Paragraph("Document gÃ©nÃ©rÃ© automatiquement.", styles["Normal"]))

    doc = SimpleDocTemplate(file_path, pagesize=A4)
    doc.build(elements)
    messagebox.showinfo("Export", f"Bilan PDF exportÃ© :\n{file_path}")
    
def export_bilan_argumente_pdf():
    from exports.export_bilan_argumente import export_bilan_argumente_pdf as real_export_pdf
    real_export_pdf()

def export_bilan_argumente_word():
    from exports.export_bilan_argumente import export_bilan_argumente_word as real_export_word
    real_export_word()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./exports/export_bilan_argumente.py ===

```python
import matplotlib.pyplot as plt
from reportlab.lib.pagesizes import A4
from reportlab.platypus import (
    Paragraph, SimpleDocTemplate, Spacer, Table, PageBreak, Image,
    KeepTogether
)
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from docx import Document
from docx.shared import Inches
import datetime
import tkinter as tk
from tkinter import filedialog, messagebox
from db.db import get_connection

# VISUELS
def save_pie_chart(labels, sizes, filename, title=""):
    import matplotlib.pyplot as plt
    plt.figure(figsize=(5,5))
    plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=140)
    if title:
        plt.title(title)
    plt.axis('equal')
    plt.tight_layout()
    plt.savefig(filename)
    plt.close()
    
    
def save_bar_chart(x, y, filename, xlabel="", ylabel="", title=""):
    import matplotlib.pyplot as plt
    plt.figure(figsize=(7,4))
    plt.bar(x, y, color="#4682B4")
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title)
    plt.tight_layout()
    plt.savefig(filename)
    plt.close()

# RÃ‰SUMÃ‰ EXÃ‰CUTIF AMÃ‰LIORÃ‰
def generate_resume_executif(solde_cloture, evolution, total_recettes, total_depenses, nb_events, nb_membres):
    tendance = "positive" if solde_cloture > 0 else "nÃ©gative"
    if evolution > 0:
        evo = f"en progression de {abs(evolution):.2f}â‚¬ par rapport Ã  l'an passÃ©"
    elif evolution < 0:
        evo = f"en baisse de {abs(evolution):.2f}â‚¬ par rapport Ã  l'an passÃ©"
    else:
        evo = "stable par rapport Ã  l'an passÃ©"
    part_recettes = f"Les recettes de l'exercice atteignent {total_recettes:.2f}â‚¬, traduisant la participation active de la communautÃ©."
    part_depenses = f"Les dÃ©penses, quant Ã  elles, s'Ã©lÃ¨vent Ã  {total_depenses:.2f}â‚¬, tÃ©moignant d'une gestion attentive."
    part_events = f"{nb_events} Ã©vÃ©nement(s) ont Ã©tÃ© organisÃ©s pour impliquer les membres et soutenir les projets."
    part_membres = f"L'association compte {nb_membres} membres engagÃ©s."
    return (
        f"Le solde de clÃ´ture est de {solde_cloture:.2f}â‚¬, "
        f"ce qui traduit une situation financiÃ¨re {tendance}, {evo}.\n\n"
        f"{part_recettes}\n{part_depenses}\n{part_events}\n{part_membres}"
    )
    
    
# RÃ‰CUPÃ‰RATION ET STRUCTURATION DES DONNÃ‰ES
def get_event_details(c):
    events = c.execute("SELECT id, name, date FROM events ORDER BY date ASC").fetchall()
    details = []
    for ev in events:
        rec = c.execute("SELECT SUM(montant) as total FROM event_recettes WHERE event_id=?", (ev["id"],)).fetchone()
        dep = c.execute("SELECT SUM(montant) as total FROM event_depenses WHERE event_id=?", (ev["id"],)).fetchone()
        rec = rec["total"] or 0.0
        dep = dep["total"] or 0.0
        benef = rec - dep
        desc = f"L'Ã©vÃ©nement {ev['name']} du {ev['date']} a rÃ©uni la communautÃ© autour de moments conviviaux. Il a gÃ©nÃ©rÃ© {rec:.2f} â‚¬ de recettes pour {dep:.2f} â‚¬ de dÃ©penses, soit un bÃ©nÃ©fice de {benef:.2f} â‚¬."
        details.append({
            "id": ev["id"],
            "name": ev["name"],
            "date": ev["date"],
            "recettes": rec,
            "depenses": dep,
            "benefice": benef,
            "description": desc,
            "commentaire": ""
        })
    return details
    
    
def get_data_for_bilan():
    from db.db import get_connection
    conn = get_connection()
    c = conn.cursor()
    cfg = c.execute("SELECT exercice, date, date_fin, solde_report, but_asso FROM config ORDER BY id DESC LIMIT 1").fetchone()
    exercice = cfg["exercice"] if cfg else "N/A"
    date = cfg["date"] if cfg else "N/A"
    date_fin = cfg["date_fin"] if cfg else "N/A"
    solde_ouverture = cfg["solde_report"] if cfg else 0.0
    but_asso = cfg["but_asso"] if cfg and "but_asso" in cfg.keys() and cfg["but_asso"] else "L'association a pour objet ... (Ã  personnaliser)"
    comptes = c.execute("SELECT name, solde FROM comptes ORDER BY name").fetchall()
    comptes = [(cb["name"], cb["solde"]) for cb in comptes] if comptes else [("Banque", solde_ouverture)]
    membres = c.execute("SELECT name, prenom FROM membres ORDER BY name, prenom").fetchall()
    nb_membres = len(membres)
    liste_membres = [f"{m['name']} {m['prenom']}" for m in membres]
    event_details = get_event_details(c)
    nb_events = len(event_details)
    liste_events = [f"{e['name']} â€“ {e['date']}" for e in event_details]
    subv = c.execute("SELECT SUM(montant) as total FROM dons_subventions").fetchone()
    subv_total = subv["total"] or 0.0
    rec_events = sum(ev["recettes"] for ev in event_details)
    recettes_par_categorie = []
    if subv_total: recettes_par_categorie.append(("Subventions", subv_total))
    if rec_events: recettes_par_categorie.append(("Recettes Ã©vÃ©nements", rec_events))
    if not recettes_par_categorie:
        recettes_par_categorie = [("Aucune recette", 0.0)]
    total_recettes = sum(x[1] for x in recettes_par_categorie)
    dep_events = sum(ev["depenses"] for ev in event_details)
    dep_annexes = c.execute("SELECT SUM(montant) as total FROM depenses_regulieres").fetchone()
    dep_annexes_total = dep_annexes["total"] or 0.0
    dep_div = c.execute("SELECT SUM(montant) as total FROM depenses_diverses").fetchone()
    dep_div_total = dep_div["total"] or 0.0
    depenses_par_categorie = []
    if dep_events: depenses_par_categorie.append(("DÃ©penses Ã©vÃ©nements", dep_events))
    if dep_annexes_total: depenses_par_categorie.append(("Frais annexes", dep_annexes_total))
    if dep_div_total: depenses_par_categorie.append(("DÃ©penses diverses", dep_div_total))
    if not depenses_par_categorie:
        depenses_par_categorie = [("Aucune dÃ©pense", 0.0)]
    total_depenses = sum(x[1] for x in depenses_par_categorie)
    retro = c.execute("SELECT SUM(montant) as total FROM retrocessions_ecoles").fetchone()
    retro_total = retro["total"] or 0.0
    retro_details = c.execute("SELECT date, ecole, montant, commentaire FROM retrocessions_ecoles ORDER BY date").fetchall()
    retro_details_list = [
        dict(date=r["date"], ecole=r["ecole"], montant=r["montant"], commentaire=r["commentaire"] or "")
        for r in retro_details
    ]
    solde_cloture = solde_ouverture + total_recettes - total_depenses
    solde_apres_retro = solde_cloture - retro_total
    treso = comptes
    prev = c.execute("SELECT solde_report, exercice FROM config WHERE id < (SELECT MAX(id) FROM config) ORDER BY id DESC LIMIT 1").fetchone()
    evolution = 0.0
    compo = []
    if prev:
        evolution = solde_cloture - prev["solde_report"]
        compo = [
            ["Solde ouverture", prev["solde_report"], solde_ouverture],
            ["Recettes totales", 0.0, total_recettes],
            ["DÃ©penses totales", 0.0, total_depenses],
            ["Solde clÃ´ture", prev["solde_report"], solde_cloture]
        ]
    recettes_majoritaires = ", ".join([cat for cat, montant in recettes_par_categorie if montant > 0 and cat != "Aucune recette"])
    depenses_majoritaires = ", ".join([cat for cat, montant in depenses_par_categorie if montant > 0 and cat != "Aucune dÃ©pense"])
    ratio = "N/A" if total_depenses == 0 else f"{total_recettes/total_depenses:.2f}"
    analyse = (
        f"Les recettes principales proviennent de : {recettes_majoritaires if recettes_majoritaires else 'aucune source majeure'}.\n"
        f"Les dÃ©penses majeures sont : {depenses_majoritaires if depenses_majoritaires else 'aucune dÃ©pense majeure'}.\n"
        f"Le ratio recettes/dÃ©penses est de {ratio}.\n"
        f"Nombre d'Ã©vÃ©nements organisÃ©s : {nb_events}.\n"
        f"Nombre de membres engagÃ©s : {nb_membres}."
    )
    resume_executif = generate_resume_executif(solde_cloture, evolution, total_recettes, total_depenses, nb_events, nb_membres)
    conclusion = (
        "L'annÃ©e Ã©coulÃ©e a dÃ©montrÃ© la vitalitÃ© de l'association, soutenue par l'engagement bÃ©nÃ©vole et la diversitÃ© des actions menÃ©es. "
        "La gestion prudente des finances, la mobilisation des partenaires et la gÃ©nÃ©rositÃ© des subventions ont permis de soutenir de nombreux projets scolaires."
    )
    data = {
        "exercice": f"{exercice} ({date} - {date_fin})",
        "date": date,
        "date_fin": date_fin,
        "resume_executif": resume_executif,
        "presentation": but_asso,
        "solde_ouverture": solde_ouverture,
        "total_recettes": total_recettes,
        "total_depenses": total_depenses,
        "solde_cloture": solde_cloture,
        "solde_apres_retro": solde_apres_retro,
        "recettes_par_categorie": recettes_par_categorie,
        "depenses_par_categorie": depenses_par_categorie,
        "analyse": analyse,
        "comparatif": compo,
        "tresorerie": treso,
        "conclusion": conclusion,
        # "etat_stock": etat_stock,   # SUPPRIMÃ‰
        "nb_membres": nb_membres,
        "liste_membres": liste_membres,
        "nb_events": nb_events,
        "liste_events": liste_events,
        "event_details": event_details,
        "subventions_total": subv_total,
        "retrocessions_total": retro_total,
        "retrocessions_details": retro_details_list,
    }
    conn.close()
    return data
    
    
# --- Ã‰DITION SECTION PAR SECTION (fenÃªtre personnalisÃ©e) ---
def edit_argumentaire_section(title, initial_text):
    import tkinter as tk
    result = {}
    win = tk.Toplevel()
    win.title(f"Ã‰dition â€“ {title}")
    win.configure(bg="#f2f7fa")
    win.geometry("850x380")
    win.minsize(600, 220)
    tk.Label(win, text=title, font=("Arial", 15, "bold"), fg="#1b3a4b", bg="#f2f7fa").pack(pady=(18,10))
    txt = tk.Text(win, width=90, height=8, font=("Arial", 12), wrap="word", bg="#f6fafd", fg="#222")
    txt.pack(padx=16, pady=4, expand=True, fill="both")
    txt.insert("1.0", initial_text)
    txt.focus_set()
    txt.tag_add("sel", "1.0", "end")
    def valider():
        result["text"] = txt.get("1.0", "end-1c")
        win.destroy()
    btn = tk.Button(win, text="Valider / Suivant", font=("Arial", 12, "bold"), bg="#4c9ed9", fg="white", activebackground="#337ab7", activeforeground="white", width=18, height=2, command=valider)
    btn.pack(pady=14)
    win.grab_set()
    win.wait_window()
    return result.get("text", initial_text)
    
def edit_argumentaire(data):
    import datetime
    # Titre et sous-titre Ã©ditables
    data["titre"] = edit_argumentaire_section(
        "Titre principal du document", data.get("titre", "<b>Les Interactifs des Ecoles</b>")
    )
    data["sous_titre"] = edit_argumentaire_section(
        "Sous-titre (exercice)", data.get("sous_titre", f"Bilan financier argumentÃ©<br/>Exercice : {data['exercice']}")
    )
    data["date_edition"] = edit_argumentaire_section(
        "Date d'Ã©dition du bilan", data.get("date_edition", f"Date d'Ã©dition du bilan : {datetime.date.today()}")
    )

    data["presentation"] = edit_argumentaire_section("PrÃ©sentation / Historique", data.get("presentation", ""))
    data["resume_executif"] = edit_argumentaire_section("RÃ©sumÃ© exÃ©cutif", data.get("resume_executif", ""))
    # SynthÃ¨se financiÃ¨re Ã©ditable (affichage tableau possible dans le texte)
    data["synthese_financiere"] = edit_argumentaire_section(
        "SynthÃ¨se financiÃ¨re (tableau)", data.get("synthese_financiere",
            f"Solde d'ouverture : {data['solde_ouverture']:.2f} â‚¬\nTotal recettes : {data['total_recettes']:.2f} â‚¬\nTotal dÃ©penses : {data['total_depenses']:.2f} â‚¬\nSolde de clÃ´ture : {data['solde_cloture']:.2f} â‚¬"
        )
    )
    data["subventions"] = edit_argumentaire_section(
        "Subventions et partenaires", data.get("subventions", f"Total subventions versÃ©es : {data['subventions_total']:.2f} â‚¬")
    )
    data["retrocession"] = edit_argumentaire_section(
        "RÃ©trocession aux Ã©coles", data.get("retrocession", f"Total rÃ©trocÃ©dÃ© : {data['retrocessions_total']:.2f} â‚¬")
    )
    data["analyse"] = edit_argumentaire_section("Analyse et commentaires", data.get("analyse", ""))
    data["conclusion"] = edit_argumentaire_section("Conclusion du/de la trÃ©sorier(e)", data.get("conclusion", ""))
    # Paragraphe solde aprÃ¨s rÃ©trocession
    data["solde_apres_retro"] = edit_argumentaire_section(
        "Solde restant aprÃ¨s rÃ©trocessions",
        data.get("solde_apres_retro", f"Solde restant : {data['solde_apres_retro']:.2f} â‚¬\nCe solde est conservÃ© pour les frais Ã  venir de l'association : frais bancaires, achats rÃ©currents, trÃ©sorerie pour les prochains Ã©vÃ©nements, etc.")
    )

    # Boucle sur les Ã©vÃ©nements pour Ã©diter description ET commentaire
    for ev in data.get("event_details", []):
        ev["description"] = edit_argumentaire_section(
            f"Ã‰vÃ©nement : {ev['name']} ({ev['date']})", ev.get("description", "")
        )
        ev["commentaire"] = edit_argumentaire_section(
            f"Commentaire libre pour {ev['name']} ({ev['date']})", ev.get("commentaire", "")
        )

    try:
        conn = get_connection()
        c = conn.cursor()
        c.execute("UPDATE config SET but_asso=? WHERE id=(SELECT MAX(id) FROM config)", (data.get("presentation", ""),))
        conn.commit()
        conn.close()
    except Exception as e:
        print("Erreur lors de la sauvegarde du but_asso :", e)
    return True
    
def ask_date_cloture_if_missing(data):
    import tkinter as tk
    from tkinter import messagebox, simpledialog
    if not data.get("date_fin") or data["date_fin"] in (None, "", "None"):
        root = tk.Tk()
        root.withdraw()
        date_fin = None
        while not date_fin:
            date_fin = simpledialog.askstring(
                "Date de clÃ´ture manquante",
                "Veuillez saisir la date de clÃ´ture de l'exercice (format AAAA-MM-JJ) :"
            )
            if date_fin is None:
                messagebox.showwarning("AnnulÃ©", "Vous devez saisir une date de clÃ´ture pour gÃ©nÃ©rer le bilan.")
                return False
        data["date_fin"] = date_fin
        try:
            conn = get_connection()
            c = conn.cursor()
            c.execute("UPDATE config SET date_fin=? WHERE id=(SELECT MAX(id) FROM config)", (date_fin,))
            conn.commit()
            conn.close()
        except Exception as e:
            print("Erreur lors de la sauvegarde de la date de clÃ´ture :", e)
    return True
    
    
def export_bilan_argumente_pdf():
    root = tk.Tk()
    root.withdraw()
    filename = filedialog.asksaveasfilename(
        title="Enregistrer le bilan argumentÃ© PDF",
        defaultextension=".pdf",
        filetypes=[("Fichier PDF", "*.pdf")],
        initialfile="Bilan_argumente.pdf"
    )
    if not filename:
        return

    data = get_data_for_bilan()
    if not ask_date_cloture_if_missing(data):
        return

    # Mise Ã  jour de l'intitulÃ© de l'exercice avec la bonne date de clÃ´ture
    exercice = data.get("exercice", "").split(" ")[0]
    date = data.get("date") or ""
    date_fin = data.get("date_fin") or ""
    data["exercice"] = f"{exercice} ({date} - {date_fin})"

    ok = edit_argumentaire(data)
    if not ok:
        messagebox.showinfo("AnnulÃ©", "GÃ©nÃ©ration du bilan annulÃ©e.")
        return

    # GÃ©nÃ©ration des camemberts
    if data["depenses_par_categorie"]:
        labels, sizes = zip(*data["depenses_par_categorie"])
        save_pie_chart(labels, sizes, "depenses_pie.png", "DÃ©penses")
    if data["recettes_par_categorie"]:
        labels2, sizes2 = zip(*data["recettes_par_categorie"])
        save_pie_chart(labels2, sizes2, "recettes_pie.png", "Recettes")

    # DÃ©tail des dÃ©penses rÃ©guliÃ¨res et diverses
    conn = get_connection()
    c = conn.cursor()
    dep_reg = c.execute("SELECT date_depense, categorie, montant, commentaire FROM depenses_regulieres ORDER BY date_depense").fetchall()
    dep_div = c.execute("SELECT date_depense, categorie, montant, commentaire FROM depenses_diverses ORDER BY date_depense").fetchall()

    doc = SimpleDocTemplate(
        filename, pagesize=A4,
        rightMargin=38, leftMargin=38, topMargin=50, bottomMargin=38
    )
    styles = getSampleStyleSheet()
    style_title = ParagraphStyle("TitlePerso", parent=styles["Title"], fontSize=26, textColor="#184d72", alignment=1, spaceAfter=15)
    style_h1 = ParagraphStyle("H1Perso", parent=styles["Heading1"], fontSize=17, textColor="#20639b", alignment=1, spaceBefore=16, spaceAfter=8)
    style_h2 = ParagraphStyle("H2Perso", parent=styles["Heading2"], fontSize=14, textColor="#276c93", alignment=1, spaceBefore=10, spaceAfter=6)
    style_text = ParagraphStyle("NormalPerso", parent=styles["Normal"], fontSize=11, textColor="#222", alignment=1, leading=15, spaceAfter=4)
    style_italic = ParagraphStyle("ItalicPerso", parent=styles["Italic"], fontSize=11, textColor="#3a3a3a", alignment=1, leading=13, italic=True)

    elements = []
    # TITRE & INFOS
    elements.append(KeepTogether([
        Paragraph(data['titre'], style_title),
        Spacer(1, 12),
        Paragraph(data['sous_titre'], style_h1),
        Spacer(1, 12),
        Paragraph(data['date_edition'], style_text),
        PageBreak(),
    ]))

    elements.append(KeepTogether([
        Paragraph("PrÃ©sentation / Historique de l'association", style_h1),
        Paragraph(data['presentation'], style_text),
        Spacer(1, 14),
    ]))

    elements.append(KeepTogether([
        Paragraph("Membres & BÃ©nÃ©voles", style_h2),
        Paragraph(f"Nombre total de membres : {data['nb_membres']}", style_text),
        Table([["Name PrÃ©nom"]]+[[m] for m in data["liste_membres"]], style=[
            ('ALIGN', (0,0), (-1,-1), 'CENTER'),
            ('ROWBACKGROUNDS', (0,1), (-1,-1), [colors.whitesmoke, colors.lightcyan]),
        ]) if data["liste_membres"] else Spacer(1, 1),
        Spacer(1, 14),
    ]))

    elements.append(KeepTogether([
        Paragraph("RÃ©sumÃ© exÃ©cutif", style_h1),
        Paragraph(data['resume_executif'], style_text),
        Spacer(1, 14),
    ]))

    elements.append(KeepTogether([
        Paragraph("SynthÃ¨se financiÃ¨re", style_h1),
        Paragraph(data['synthese_financiere'], style_text),
        Spacer(1, 14),
    ]))

    elements.append(KeepTogether([
        Paragraph("Subventions et partenaires", style_h2),
        Paragraph(data['subventions'], style_text),
        Spacer(1, 14),
    ]))

    retro_block = [
        Paragraph("RÃ©trocession aux Ã©coles", style_h2),
        Paragraph(data['retrocession'], style_text),
    ]
    if data["retrocessions_details"]:
        table_retro = [["Date", "Ã‰cole", "Montant (â‚¬)", "Commentaire"]]
        for r in data["retrocessions_details"]:
            table_retro.append([
                r["date"],
                r["ecole"],
                f"{r['montant']:.2f}",
                r["commentaire"] or ""
            ])
        retro_block.append(Table(table_retro, style=[
            ('ALIGN', (0,0), (-1,-1), 'CENTER'),
            ('ROWBACKGROUNDS', (0,1),(-1,-1), [colors.whitesmoke, colors.lightcyan])
        ]))
        retro_block.append(Spacer(1, 8))
    retro_block += [
        Paragraph("Solde restant aprÃ¨s rÃ©trocessions", style_h2),
        Paragraph(data['solde_apres_retro'], style_text),
        Spacer(1, 14)
    ]
    elements.append(KeepTogether(retro_block))

    elements.append(KeepTogether([
        Paragraph("DÃ©tail des recettes", style_h2),
        Table(
            [["CatÃ©gorie", "Montant"]] + [[cat, f"{montant:.2f} â‚¬"] for cat, montant in data['recettes_par_categorie']],
            style=[('ALIGN', (0,0), (-1,-1), 'CENTER'), ('ROWBACKGROUNDS', (0,1), (-1,-1), [colors.lightcyan, colors.whitesmoke])]
        ),
        Spacer(1, 8),
        Image("recettes_pie.png", width=170, height=170) if data["recettes_par_categorie"] else Spacer(1, 1),
        Spacer(1, 14),
    ]))

    elements.append(KeepTogether([
        Paragraph("DÃ©tail des dÃ©penses", style_h2),
        Table(
            [["CatÃ©gorie", "Montant"]] + [[cat, f"{montant:.2f} â‚¬"] for cat, montant in data['depenses_par_categorie']],
            style=[('ALIGN', (0,0), (-1,-1), 'CENTER'), ('ROWBACKGROUNDS', (0,1), (-1,-1), [colors.whitesmoke, colors.lightcyan])]
        ),
        Spacer(1, 8),
        Image("depenses_pie.png", width=170, height=170) if data["depenses_par_categorie"] else Spacer(1, 1),
        Spacer(1, 14),
    ]))

    elements.append(KeepTogether([
        Paragraph("DÃ©penses rÃ©guliÃ¨res", style_h2),
        Table(
            [["Date", "CatÃ©gorie", "Montant (â‚¬)", "Commentaire"]]+
            [[d["date_depense"], d["categorie"], f"{d['montant']:.2f}", d["commentaire"] or ""] for d in dep_reg],
            style=[('ALIGN', (0,0), (-1,-1), 'CENTER'), ('ROWBACKGROUNDS', (0,1), (-1,-1), [colors.whitesmoke, colors.lightcyan])]
        ) if dep_reg else Paragraph("Aucune dÃ©pense rÃ©guliÃ¨re enregistrÃ©e.", style_text),
        Spacer(1, 14),
    ]))
    elements.append(KeepTogether([
        Paragraph("DÃ©penses diverses", style_h2),
        Table(
            [["Date", "CatÃ©gorie", "Montant (â‚¬)", "Commentaire"]]+
            [[d["date_depense"], d["categorie"], f"{d['montant']:.2f}", d["commentaire"] or ""] for d in dep_div],
            style=[('ALIGN', (0,0), (-1,-1), 'CENTER'), ('ROWBACKGROUNDS', (0,1), (-1,-1), [colors.lightcyan, colors.whitesmoke])]
        ) if dep_div else Paragraph("Aucune dÃ©pense diverse enregistrÃ©e.", style_text),
        Spacer(1, 14),
    ]))

    elements.append(Paragraph("DÃ©tail des Ã©vÃ©nements", style_h1))
    for ev in data["event_details"]:
        ev_block = [
            Paragraph(f"{ev['name']} - {ev['date']}", style_h2),
            Paragraph(ev["description"], style_text),
            Paragraph(ev["commentaire"], style_italic) if ev["commentaire"] else Spacer(1, 1),
            Table([
                ["Recettes", f"{ev['recettes']:.2f} â‚¬"],
                ["DÃ©penses", f"{ev['depenses']:.2f} â‚¬"],
                ["BÃ©nÃ©fice", f"{ev['benefice']:.2f} â‚¬"]
            ], style=[('ALIGN', (0,0), (-1,-1), 'CENTER'), ('ROWBACKGROUNDS', (0,1), (-1,-1), [colors.whitesmoke, colors.lightcyan])])
        ]
        if ev["recettes"] or ev["depenses"]:
            save_pie_chart(["Recettes", "DÃ©penses"], [ev["recettes"], ev["depenses"]], f"event_{ev['id']}_pie.png", ev["name"])
            ev_block.append(Image(f"event_{ev['id']}_pie.png", width=110, height=110))
        ev_block.append(Spacer(1, 14))
        elements.append(KeepTogether(ev_block))

    elements.append(KeepTogether([
        Paragraph("Analyse et commentaires", style_h1),
        Paragraph(data['analyse'], style_text),
        Spacer(1, 14),
    ]))

    if data["comparatif"]:
        compo_block = [
            Paragraph("Comparaison avec l'exercice prÃ©cÃ©dent", style_h2),
            Table(
                [["Poste", "AnnÃ©e N-1", "AnnÃ©e N"]]
                + [[poste, f"{n_1:.2f} â‚¬", f"{n:.2f} â‚¬"] for poste, n_1, n in data['comparatif']],
                style=[('ALIGN', (0,0), (-1,-1), 'CENTER'), ('ROWBACKGROUNDS', (0,1), (-1,-1), [colors.whitesmoke, colors.lightcyan])]
            ),
            Spacer(1, 14),
        ]
        elements.append(KeepTogether(compo_block))

    elements.append(KeepTogether([
        Paragraph("Conclusion du/de la trÃ©sorier(e)", style_h1),
        Paragraph(data['conclusion'], style_text),
        Spacer(1, 20),
    ]))

    try:
        doc.build(elements)
        messagebox.showinfo("SuccÃ¨s", f"Bilan argumentÃ© gÃ©nÃ©rÃ© : {filename}")
    except Exception as e:
        messagebox.showerror("Erreur", f"Erreur lors de la gÃ©nÃ©ration : {e}")
        
        
# --- VERSION ENTIÃˆREMENT Ã‰DITABLE DE export_bilan_argumente_word ---
def export_bilan_argumente_word():
    root = tk.Tk()
    root.withdraw()
    filename = filedialog.asksaveasfilename(
        title="Enregistrer le bilan argumentÃ© Word",
        defaultextension=".docx",
        filetypes=[("Fichier Word", "*.docx")],
        initialfile="Bilan_argumente.docx"
    )
    if not filename:
        return
    data = get_data_for_bilan()
    ok = edit_argumentaire(data)
    if not ok:
        messagebox.showinfo("AnnulÃ©", "GÃ©nÃ©ration du bilan annulÃ©e.")
        return

    # GÃ©nÃ©ration des camemberts
    if data["depenses_par_categorie"]:
        labels, sizes = zip(*data["depenses_par_categorie"])
        save_pie_chart(labels, sizes, "depenses_pie.png", "DÃ©penses")
    if data["recettes_par_categorie"]:
        labels2, sizes2 = zip(*data["recettes_par_categorie"])
        save_pie_chart(labels2, sizes2, "recettes_pie.png", "Recettes")

    # RÃ©cupÃ©rer les dÃ©tails des dÃ©penses rÃ©guliÃ¨res et diverses
    conn = get_connection()
    c = conn.cursor()
    dep_reg = c.execute("SELECT date_depense, categorie, montant, commentaire FROM depenses_regulieres ORDER BY date_depense").fetchall()
    dep_div = c.execute("SELECT date_depense, categorie, montant, commentaire FROM depenses_diverses ORDER BY date_depense").fetchall()

    doc = Document()
    doc.add_heading(data['titre'], 0)
    doc.add_heading(data['sous_titre'], 1)
    doc.add_paragraph(data['date_edition'])
    doc.add_page_break()

    doc.add_heading("PrÃ©sentation / Historique de l'association", level=1)
    doc.add_paragraph(data['presentation'])

    doc.add_heading("Membres & BÃ©nÃ©voles", level=2)
    doc.add_paragraph(f"Nombre total de membres : {data['nb_membres']}")
    if data["liste_membres"]:
        tM = doc.add_table(rows=1, cols=1)
        tM.rows[0].cells[0].text = "Name PrÃ©nom"
        for m in data["liste_membres"]:
            tM.add_row().cells[0].text = m

    doc.add_heading("RÃ©sumÃ© exÃ©cutif", level=1)
    doc.add_paragraph(data['resume_executif'])

    doc.add_heading("SynthÃ¨se financiÃ¨re", level=1)
    doc.add_paragraph(data['synthese_financiere'])

    doc.add_heading("Subventions et partenaires", level=2)
    doc.add_paragraph(data['subventions'])

    doc.add_heading("RÃ©trocession aux Ã©coles", level=2)
    doc.add_paragraph(data['retrocession'])
    if data["retrocessions_details"]:
        tR = doc.add_table(rows=1, cols=4)
        tR.rows[0].cells[0].text = "Date"
        tR.rows[0].cells[1].text = "Ã‰cole"
        tR.rows[0].cells[2].text = "Montant (â‚¬)"
        tR.rows[0].cells[3].text = "Commentaire"
        for r in data["retrocessions_details"]:
            row = tR.add_row().cells
            row[0].text = r["date"]
            row[1].text = r["ecole"]
            row[2].text = f"{r['montant']:.2f}"
            row[3].text = r["commentaire"] or ""
    doc.add_paragraph("")
    doc.add_heading("Solde restant aprÃ¨s rÃ©trocessions", level=2)
    doc.add_paragraph(data['solde_apres_retro'])

    doc.add_heading("DÃ©tail des recettes", level=2)
    t = doc.add_table(rows=1, cols=2)
    t.rows[0].cells[0].text = "CatÃ©gorie"
    t.rows[0].cells[1].text = "Montant"
    for cat, montant in data['recettes_par_categorie']:
        row = t.add_row().cells
        row[0].text = cat
        row[1].text = f"{montant:.2f} â‚¬"
    if data["recettes_par_categorie"]:
        doc.add_paragraph("Diagramme des recettes :")
        doc.add_picture("recettes_pie.png", width=Inches(2.5))

    doc.add_heading("DÃ©tail des dÃ©penses", level=2)
    t2 = doc.add_table(rows=1, cols=2)
    t2.rows[0].cells[0].text = "CatÃ©gorie"
    t2.rows[0].cells[1].text = "Montant"
    for cat, montant in data['depenses_par_categorie']:
        row = t2.add_row().cells
        row[0].text = cat
        row[1].text = f"{montant:.2f} â‚¬"
    if data["depenses_par_categorie"]:
        doc.add_paragraph("Diagramme des dÃ©penses :")
        doc.add_picture("depenses_pie.png", width=Inches(2.5))

    # DÃ©tail des dÃ©penses rÃ©guliÃ¨res
    doc.add_heading("DÃ©penses rÃ©guliÃ¨res", level=2)
    if dep_reg:
        tdepreg = doc.add_table(rows=1, cols=4)
        tdepreg.rows[0].cells[0].text = "Date"
        tdepreg.rows[0].cells[1].text = "CatÃ©gorie"
        tdepreg.rows[0].cells[2].text = "Montant (â‚¬)"
        tdepreg.rows[0].cells[3].text = "Commentaire"
        for d in dep_reg:
            row = tdepreg.add_row().cells
            row[0].text = d["date_depense"] or ""
            row[1].text = d["categorie"] or ""
            row[2].text = f"{d['montant']:.2f}"
            row[3].text = d["commentaire"] or ""
    else:
        doc.add_paragraph("Aucune dÃ©pense rÃ©guliÃ¨re enregistrÃ©e.")

    # DÃ©tail des dÃ©penses diverses
    doc.add_heading("DÃ©penses diverses", level=2)
    if dep_div:
        tdepdiv = doc.add_table(rows=1, cols=4)
        tdepdiv.rows[0].cells[0].text = "Date"
        tdepdiv.rows[0].cells[1].text = "CatÃ©gorie"
        tdepdiv.rows[0].cells[2].text = "Montant (â‚¬)"
        tdepdiv.rows[0].cells[3].text = "Commentaire"
        for d in dep_div:
            row = tdepdiv.add_row().cells
            row[0].text = d["date_depense"] or ""
            row[1].text = d["categorie"] or ""
            row[2].text = f"{d['montant']:.2f}"
            row[3].text = d["commentaire"] or ""
    else:
        doc.add_paragraph("Aucune dÃ©pense diverse enregistrÃ©e.")

    doc.add_heading("DÃ©tail des Ã©vÃ©nements", level=1)
    for ev in data["event_details"]:
        doc.add_heading(f"{ev['name']} - {ev['date']}", level=2)
        doc.add_paragraph(ev["description"])
        if ev["commentaire"]:
            doc.add_paragraph(ev["commentaire"], style="Intense Quote")
        table_ev = doc.add_table(rows=3, cols=2)
        table_ev.rows[0].cells[0].text = "Recettes"
        table_ev.rows[0].cells[1].text = f"{ev['recettes']:.2f} â‚¬"
        table_ev.rows[1].cells[0].text = "DÃ©penses"
        table_ev.rows[1].cells[1].text = f"{ev['depenses']:.2f} â‚¬"
        table_ev.rows[2].cells[0].text = "BÃ©nÃ©fice"
        table_ev.rows[2].cells[1].text = f"{ev['benefice']:.2f} â‚¬"
        if ev["recettes"] or ev["depenses"]:
            save_pie_chart(["Recettes", "DÃ©penses"], [ev["recettes"], ev["depenses"]], f"event_{ev['id']}_pie.png", ev["name"])
            doc.add_picture(f"event_{ev['id']}_pie.png", width=Inches(1.5))
        doc.add_paragraph("")

    doc.add_heading("Analyse et commentaires", level=1)
    doc.add_paragraph(data['analyse'])

    if data["comparatif"]:
        doc.add_heading("Comparaison avec l'exercice prÃ©cÃ©dent", level=2)
        t3 = doc.add_table(rows=1, cols=3)
        t3.rows[0].cells[0].text = "Poste"
        t3.rows[0].cells[1].text = "AnnÃ©e N-1"
        t3.rows[0].cells[2].text = "AnnÃ©e N"
        for poste, n_1, n in data['comparatif']:
            row = t3.add_row().cells
            row[0].text = poste
            row[1].text = f"{n_1:.2f} â‚¬"
            row[2].text = f"{n:.2f} â‚¬"

    doc.add_heading("Conclusion du/de la trÃ©sorier(e)", level=1)
    doc.add_paragraph(data['conclusion'])

    try:
        doc.save(filename)
        messagebox.showinfo("SuccÃ¨s", f"Bilan argumentÃ© gÃ©nÃ©rÃ© : {filename}")
    except Exception as e:
        messagebox.showerror("Erreur", f"Erreur lors de la gÃ©nÃ©ration : {e}")
    root = tk.Tk()
    root.withdraw()
    filename = filedialog.asksaveasfilename(
        title="Enregistrer le bilan argumentÃ© Word",
        defaultextension=".docx",
        filetypes=[("Fichier Word", "*.docx")],
        initialfile="Bilan_argumente.docx"
    )
    if not filename:
        return
    data = get_data_for_bilan()
    ok = edit_argumentaire(data)
    if not ok:
        messagebox.showinfo("AnnulÃ©", "GÃ©nÃ©ration du bilan annulÃ©e.")
        return

    # GÃ©nÃ©ration des camemberts
    if data["depenses_par_categorie"]:
        labels, sizes = zip(*data["depenses_par_categorie"])
        save_pie_chart(labels, sizes, "depenses_pie.png", "DÃ©penses")
    if data["recettes_par_categorie"]:
        labels2, sizes2 = zip(*data["recettes_par_categorie"])
        save_pie_chart(labels2, sizes2, "recettes_pie.png", "Recettes")

    # RÃ©cupÃ©rer les dÃ©tails des dÃ©penses rÃ©guliÃ¨res et diverses
    conn = get_connection()
    c = conn.cursor()
    dep_reg = c.execute("SELECT date_depense, categorie, montant, commentaire FROM depenses_regulieres ORDER BY date_depense").fetchall()
    dep_div = c.execute("SELECT date_depense, categorie, montant, commentaire FROM depenses_diverses ORDER BY date_depense").fetchall()

    doc = Document()
    doc.add_heading("Les Interactifs des Ecoles", 0)
    doc.add_heading(f"Bilan financier argumentÃ© - Exercice : {data['exercice']}", 1)
    doc.add_paragraph(f"Date d'Ã©dition du bilan : {datetime.date.today()}")
    doc.add_page_break()

    doc.add_heading("PrÃ©sentation / Historique de l'association", level=1)
    doc.add_paragraph(data['presentation'])

    doc.add_heading("Membres & BÃ©nÃ©voles", level=2)
    doc.add_paragraph(f"Nombre total de membres : {data['nb_membres']}")
    if data["liste_membres"]:
        tM = doc.add_table(rows=1, cols=1)
        tM.rows[0].cells[0].text = "Name PrÃ©nom"
        for m in data["liste_membres"]:
            tM.add_row().cells[0].text = m

    doc.add_heading("RÃ©sumÃ© exÃ©cutif", level=1)
    doc.add_paragraph(data['resume_executif'])

    doc.add_heading("SynthÃ¨se financiÃ¨re", level=1)
    tab = doc.add_table(rows=1, cols=2)
    for i, champ in enumerate(["Solde d'ouverture", "Total recettes", "Total dÃ©penses", "Solde de clÃ´ture"]):
        row_cells = tab.add_row().cells if i else tab.rows[0].cells
        row_cells[0].text = champ
        val = [data['solde_ouverture'], data['total_recettes'], data['total_depenses'], data['solde_cloture']][i]
        row_cells[1].text = f"{val:.2f} â‚¬"

    doc.add_heading("Subventions et partenaires", level=2)
    doc.add_paragraph(f"Total subventions versÃ©es : {data['subventions_total']:.2f} â‚¬")

    doc.add_heading("RÃ©trocession aux Ã©coles", level=2)
    doc.add_paragraph(f"Total rÃ©trocÃ©dÃ© : {data['retrocessions_total']:.2f} â‚¬")
    if data["retrocessions_details"]:
        tR = doc.add_table(rows=1, cols=4)
        tR.rows[0].cells[0].text = "Date"
        tR.rows[0].cells[1].text = "Ã‰cole"
        tR.rows[0].cells[2].text = "Montant (â‚¬)"
        tR.rows[0].cells[3].text = "Commentaire"
        for r in data["retrocessions_details"]:
            row = tR.add_row().cells
            row[0].text = r["date"]
            row[1].text = r["ecole"]
            row[2].text = f"{r['montant']:.2f}"
            row[3].text = r["commentaire"] or ""
    doc.add_paragraph("")
    doc.add_heading("Solde restant aprÃ¨s rÃ©trocessions", level=2)
    doc.add_paragraph(f"Solde restant : {data['solde_apres_retro']:.2f} â‚¬")
    doc.add_paragraph(
        "Ce solde est conservÃ© pour les frais Ã  venir de l'association : frais bancaires, achats rÃ©currents, trÃ©sorerie pour les prochains Ã©vÃ©nements, etc."
    )

    doc.add_heading("DÃ©tail des recettes", level=2)
    t = doc.add_table(rows=1, cols=2)
    t.rows[0].cells[0].text = "CatÃ©gorie"
    t.rows[0].cells[1].text = "Montant"
    for cat, montant in data['recettes_par_categorie']:
        row = t.add_row().cells
        row[0].text = cat
        row[1].text = f"{montant:.2f} â‚¬"
    if data["recettes_par_categorie"]:
        doc.add_paragraph("Diagramme des recettes :")
        doc.add_picture("recettes_pie.png", width=Inches(2.5))

    doc.add_heading("DÃ©tail des dÃ©penses", level=2)
    t2 = doc.add_table(rows=1, cols=2)
    t2.rows[0].cells[0].text = "CatÃ©gorie"
    t2.rows[0].cells[1].text = "Montant"
    for cat, montant in data['depenses_par_categorie']:
        row = t2.add_row().cells
        row[0].text = cat
        row[1].text = f"{montant:.2f} â‚¬"
    if data["depenses_par_categorie"]:
        doc.add_paragraph("Diagramme des dÃ©penses :")
        doc.add_picture("depenses_pie.png", width=Inches(2.5))

    # DÃ©tail des dÃ©penses rÃ©guliÃ¨res
    doc.add_heading("DÃ©penses rÃ©guliÃ¨res", level=2)
    if dep_reg:
        tdepreg = doc.add_table(rows=1, cols=4)
        tdepreg.rows[0].cells[0].text = "Date"
        tdepreg.rows[0].cells[1].text = "CatÃ©gorie"
        tdepreg.rows[0].cells[2].text = "Montant (â‚¬)"
        tdepreg.rows[0].cells[3].text = "Commentaire"
        for d in dep_reg:
            row = tdepreg.add_row().cells
            row[0].text = d["date_depense"] or ""
            row[1].text = d["categorie"] or ""
            row[2].text = f"{d['montant']:.2f}"
            row[3].text = d["commentaire"] or ""
    else:
        doc.add_paragraph("Aucune dÃ©pense rÃ©guliÃ¨re enregistrÃ©e.")

    # DÃ©tail des dÃ©penses diverses
    doc.add_heading("DÃ©penses diverses", level=2)
    if dep_div:
        tdepdiv = doc.add_table(rows=1, cols=4)
        tdepdiv.rows[0].cells[0].text = "Date"
        tdepdiv.rows[0].cells[1].text = "CatÃ©gorie"
        tdepdiv.rows[0].cells[2].text = "Montant (â‚¬)"
        tdepdiv.rows[0].cells[3].text = "Commentaire"
        for d in dep_div:
            row = tdepdiv.add_row().cells
            row[0].text = d["date_depense"] or ""
            row[1].text = d["categorie"] or ""
            row[2].text = f"{d['montant']:.2f}"
            row[3].text = d["commentaire"] or ""
    else:
        doc.add_paragraph("Aucune dÃ©pense diverse enregistrÃ©e.")

    doc.add_heading("DÃ©tail des Ã©vÃ©nements", level=1)
    for ev in data["event_details"]:
        doc.add_heading(f"{ev['name']} - {ev['date']}", level=2)
        doc.add_paragraph(ev["description"])
        if ev["commentaire"]:
            doc.add_paragraph(ev["commentaire"], style="Intense Quote")
        table_ev = doc.add_table(rows=3, cols=2)
        table_ev.rows[0].cells[0].text = "Recettes"
        table_ev.rows[0].cells[1].text = f"{ev['recettes']:.2f} â‚¬"
        table_ev.rows[1].cells[0].text = "DÃ©penses"
        table_ev.rows[1].cells[1].text = f"{ev['depenses']:.2f} â‚¬"
        table_ev.rows[2].cells[0].text = "BÃ©nÃ©fice"
        table_ev.rows[2].cells[1].text = f"{ev['benefice']:.2f} â‚¬"
        if ev["recettes"] or ev["depenses"]:
            save_pie_chart(["Recettes", "DÃ©penses"], [ev["recettes"], ev["depenses"]], f"event_{ev['id']}_pie.png", ev["name"])
            doc.add_picture(f"event_{ev['id']}_pie.png", width=Inches(1.5))
        doc.add_paragraph("")

    doc.add_heading("Analyse et commentaires", level=1)
    doc.add_paragraph(data['analyse'])

    if data["comparatif"]:
        doc.add_heading("Comparaison avec l'exercice prÃ©cÃ©dent", level=2)
        t3 = doc.add_table(rows=1, cols=3)
        t3.rows[0].cells[0].text = "Poste"
        t3.rows[0].cells[1].text = "AnnÃ©e N-1"
        t3.rows[0].cells[2].text = "AnnÃ©e N"
        for poste, n_1, n in data['comparatif']:
            row = t3.add_row().cells
            row[0].text = poste
            row[1].text = f"{n_1:.2f} â‚¬"
            row[2].text = f"{n:.2f} â‚¬"

    doc.add_heading("Conclusion du/de la trÃ©sorier(e)", level=1)
    doc.add_paragraph(data['conclusion'])

    try:
        doc.save(filename)
        messagebox.showinfo("SuccÃ¨s", f"Bilan argumentÃ© gÃ©nÃ©rÃ© : {filename}")
    except Exception as e:
        messagebox.showerror("Erreur", f"Erreur lors de la gÃ©nÃ©ration : {e}")
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./exports/sanitize.py ===

```python
from utils.validation import sanitize_string

def sanitize_row(row: dict) -> dict:
    return {k: sanitize_string(v) if isinstance(v, str) else v for k, v in row.items()}

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./exports/__init__.py ===

```python
# exports package

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./lib/db_articles.py ===

```python
"""
Database helper module for articles management (buvette_articles).

This module provides database operations for managing articles in the buvette system.
Features:
- Short-lived connections with timeout for each operation
- Retry/backoff wrapper for "database is locked" errors
- Backward compatibility with databases lacking purchase_price column
- Exponential backoff for locked database scenarios

Functions include:
- get_all_articles: Retrieve all articles
- get_article_by_id: Get a specific article by ID
- get_article_by_name: Get a specific article by name
- create_article: Create a new article
- update_article_stock: Update the stock quantity of an article
- update_article_purchase_price: Update the purchase price of an article
"""

import sqlite3
import time
from functools import wraps
from db.db import get_db_file

# Configuration for retry logic and database connections
# These constants are also used by migration scripts
DEFAULT_TIMEOUT = 30.0  # seconds - timeout for database connections
MAX_RETRIES = 5  # maximum number of retry attempts on lock
INITIAL_BACKOFF = 0.1  # seconds - initial backoff time

def with_retry(func):
    """
    Decorator to retry database operations on lock errors with exponential backoff.
    
    Args:
        func: Function to wrap with retry logic
        
    Returns:
        Wrapped function with retry capability
    """
    @wraps(func)
    def wrapper(*args, **kwargs):
        retries = 0
        backoff = INITIAL_BACKOFF
        
        while retries < MAX_RETRIES:
            try:
                return func(*args, **kwargs)
            except sqlite3.OperationalError as e:
                error_msg = str(e).lower()
                if "database is locked" in error_msg or "locked" in error_msg:
                    retries += 1
                    if retries >= MAX_RETRIES:
                        print(f"âœ— Database locked after {MAX_RETRIES} retries: {e}")
                        raise
                    
                    wait_time = backoff * (2 ** (retries - 1))
                    print(f"âš  Database locked, retrying in {wait_time:.2f}s (attempt {retries}/{MAX_RETRIES})...")
                    time.sleep(wait_time)
                else:
                    # Other operational errors should be raised immediately
                    raise
            except Exception as e:
                # Non-lock errors should be raised immediately
                raise
        
        # Should not reach here, but just in case
        raise sqlite3.OperationalError(f"Failed after {MAX_RETRIES} retries")
    
    return wrapper

def get_connection_with_timeout():
    """
    Get a short-lived database connection with proper timeout settings.
    
    Returns:
        sqlite3.Connection: Database connection with Row factory
    """
    db_path = get_db_file()
    conn = sqlite3.connect(db_path, timeout=DEFAULT_TIMEOUT)
    conn.row_factory = sqlite3.Row
    return conn

def column_exists(cursor, table, column):
    """
    Check if a column exists in a table.
    
    Args:
        cursor: Database cursor
        table: Table name (must be a valid identifier)
        column: Column name
        
    Returns:
        bool: True if column exists, False otherwise
    """
    # Validate table name to prevent SQL injection (alphanumeric and underscore only)
    if not table.replace('_', '').isalnum():
        raise ValueError(f"Invalid table name: {table}")
    
    cursor.execute(f"PRAGMA table_info({table})")
    columns = [row[1] for row in cursor.fetchall()]
    return column in columns

@with_retry
def get_all_articles():
    """
    Retrieve all articles from buvette_articles table.
    Uses short-lived connection with retry logic.
    
    Returns:
        list: List of article rows as sqlite3.Row objects
    """
    conn = None
    try:
        conn = get_connection_with_timeout()
        cursor = conn.cursor()
        
        # Check if purchase_price column exists for backward compatibility
        has_purchase_price = column_exists(cursor, "buvette_articles", "purchase_price")
        
        if has_purchase_price:
            cursor.execute("""
                SELECT id, name, categorie, unite, contenance, commentaire, stock, purchase_price
                FROM buvette_articles
                ORDER BY name
            """)
        else:
            # Fallback for old database schema
            cursor.execute("""
                SELECT id, name, categorie, unite, contenance, commentaire, stock
                FROM buvette_articles
                ORDER BY name
            """)
        
        articles = cursor.fetchall()
        return articles
    finally:
        if conn:
            conn.close()

@with_retry
def get_article_by_id(article_id):
    """
    Get a specific article by its ID.
    Uses short-lived connection with retry logic.
    
    Args:
        article_id (int): The ID of the article
        
    Returns:
        sqlite3.Row or None: The article row if found, None otherwise
    """
    conn = None
    try:
        conn = get_connection_with_timeout()
        cursor = conn.cursor()
        
        # Check if purchase_price column exists for backward compatibility
        has_purchase_price = column_exists(cursor, "buvette_articles", "purchase_price")
        
        if has_purchase_price:
            cursor.execute("""
                SELECT id, name, categorie, unite, contenance, commentaire, stock, purchase_price
                FROM buvette_articles
                WHERE id = ?
            """, (article_id,))
        else:
            # Fallback for old database schema
            cursor.execute("""
                SELECT id, name, categorie, unite, contenance, commentaire, stock
                FROM buvette_articles
                WHERE id = ?
            """, (article_id,))
        
        article = cursor.fetchone()
        return article
    finally:
        if conn:
            conn.close()

@with_retry
def get_article_by_name(name):
    """
    Get a specific article by its name.
    Uses short-lived connection with retry logic.
    
    Args:
        name (str): The name of the article
        
    Returns:
        sqlite3.Row or None: The article row if found, None otherwise
    """
    conn = None
    try:
        conn = get_connection_with_timeout()
        cursor = conn.cursor()
        
        # Check if purchase_price column exists for backward compatibility
        has_purchase_price = column_exists(cursor, "buvette_articles", "purchase_price")
        
        if has_purchase_price:
            cursor.execute("""
                SELECT id, name, categorie, unite, contenance, commentaire, stock, purchase_price
                FROM buvette_articles
                WHERE name = ?
            """, (name,))
        else:
            # Fallback for old database schema
            cursor.execute("""
                SELECT id, name, categorie, unite, contenance, commentaire, stock
                FROM buvette_articles
                WHERE name = ?
            """, (name,))
        
        article = cursor.fetchone()
        return article
    finally:
        if conn:
            conn.close()

@with_retry
def create_article(name, categorie, unite=None, contenance=None, commentaire=None, stock=0, purchase_price=None):
    """
    Create a new article in the database.
    Uses short-lived connection with retry logic.
    
    Args:
        name (str): Name of the article (required)
        categorie (str): Category of the article
        unite (str, optional): Unit type (e.g., "canette", "bouteille")
        contenance (str, optional): Capacity (e.g., "0.33L", "0.5L")
        commentaire (str, optional): Additional comments
        stock (int, optional): Initial stock quantity (default: 0)
        purchase_price (float, optional): Purchase price per unit
        
    Returns:
        int: The ID of the newly created article
    """
    conn = None
    try:
        conn = get_connection_with_timeout()
        cursor = conn.cursor()
        
        # Check if purchase_price column exists for backward compatibility
        has_purchase_price = column_exists(cursor, "buvette_articles", "purchase_price")
        
        if has_purchase_price:
            cursor.execute("""
                INSERT INTO buvette_articles (name, categorie, unite, contenance, commentaire, stock, purchase_price)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (name, categorie, unite, contenance, commentaire, stock, purchase_price))
        else:
            # Fallback for old database schema (ignore purchase_price)
            cursor.execute("""
                INSERT INTO buvette_articles (name, categorie, unite, contenance, commentaire, stock)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (name, categorie, unite, contenance, commentaire, stock))
        
        article_id = cursor.lastrowid
        conn.commit()
        print(f"âœ“ Created article '{name}' with id {article_id}")
        return article_id
    finally:
        if conn:
            conn.close()

@with_retry
def update_article_stock(article_id, stock):
    """
    Update the stock quantity of an article.
    Uses short-lived connection with retry logic.
    
    Args:
        article_id (int): The ID of the article
        stock (int): The new stock quantity
        
    Returns:
        bool: True if successful
    """
    conn = None
    try:
        conn = get_connection_with_timeout()
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE buvette_articles
            SET stock = ?
            WHERE id = ?
        """, (stock, article_id))
        conn.commit()
        print(f"âœ“ Updated stock for article id {article_id} to {stock}")
        return True
    finally:
        if conn:
            conn.close()

@with_retry
def update_article_purchase_price(article_id, purchase_price):
    """
    Update the purchase price of an article.
    Uses short-lived connection with retry logic.
    Handles backward compatibility gracefully.
    
    Args:
        article_id (int): The ID of the article
        purchase_price (float): The new purchase price per unit
        
    Returns:
        bool: True if successful
    """
    conn = None
    try:
        conn = get_connection_with_timeout()
        cursor = conn.cursor()
        
        # Check if purchase_price column exists for backward compatibility
        has_purchase_price = column_exists(cursor, "buvette_articles", "purchase_price")
        
        if not has_purchase_price:
            print(f"âš  Warning: Column 'purchase_price' does not exist. Please run migration script.")
            print(f"  Migration can be run with: python scripts/migrate_add_purchase_price.py")
            return False
        
        cursor.execute("""
            UPDATE buvette_articles
            SET purchase_price = ?
            WHERE id = ?
        """, (purchase_price, article_id))
        conn.commit()
        print(f"âœ“ Updated purchase_price for article id {article_id} to {purchase_price}")
        return True
    finally:
        if conn:
            conn.close()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./lib/__init__.py ===

```python
"""
Library package for database helpers.
"""

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/buvette.py ===

```python
"""
Module de gestion du module Buvette (UI).

MODIFICATIONS APPLIQUÃ‰ES (PR corrections buvette - copilot/auto-fix-buvette):
- InventaireDialog: ajout de columnconfigure(1, weight=1) et sticky='ew' pour layout amÃ©liorÃ©
- InventaireDialog: remplacement du champ 'Type inventaire' Entry par Combobox (avant/apres/hors_evenement)
- InventaireDialog.save: validation stricte du type d'inventaire
- LignesInventaireDialog.refresh_lignes(): affichage de article_name au lieu de article_id
- LigneInventaireDialog: utilisation de Combobox pour sÃ©lectionner un article
- LigneInventaireDialog.save: appel automatique de set_article_stock() aprÃ¨s enregistrement pour MAJ immÃ©diate
- MouvementDialog: utilisation de Combobox pour sÃ©lectionner un article
- AchatDialog: utilisation de Combobox pour sÃ©lectionner un article
- refresh_bilan(): protection des agrÃ©gations contre les valeurs None
- BuvetteModule.__init__: appel de ensure_stock_column() au dÃ©marrage pour garantir la colonne stock existe
"""

import os
import tkinter as tk
from datetime import datetime
from tkinter import ttk, messagebox
from modules.buvette_db import (
    list_articles, insert_article, update_article, delete_article,
    list_achats, insert_achat, update_achat, delete_achat,
    get_article_by_id, get_achat_by_id,
    list_mouvements, insert_mouvement, update_mouvement, delete_mouvement, get_mouvement_by_id,
    list_articles_names, set_article_stock, ensure_stock_column
)
import modules.buvette_inventaire_db as inv_db
from utils.app_logger import get_logger
from utils.error_handler import handle_exception
# DB functions now return dicts directly, eliminating need for row conversion utilities (row_to_dict, row_get_safe)

logger = get_logger("buvette_module")

class BuvetteModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Gestion Buvette")
        self.notebook = ttk.Notebook(self.top)
        self.notebook.pack(fill=tk.BOTH, expand=True)

        # Assurer que la colonne 'stock' existe dans buvette_articles (migration non destructive)
        try:
            ensure_stock_column()
        except Exception as e:
            logger.warning(f"Erreur lors de la vÃ©rification de la colonne stock: {e}")

        self.create_tab_articles()
        self.create_tab_achats()
        self.create_tab_inventaires()
        self.create_tab_mouvements()
        self.create_tab_bilan()

    # ------------------ TAB ARTICLES ------------------
    def create_tab_articles(self):
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text="Articles")

        self.articles_tree = ttk.Treeview(frame, columns=("name", "categorie", "unite", "contenance", "purchase_price", "commentaire"), show="headings")
        self.articles_tree.heading("name", text="Name")
        self.articles_tree.heading("categorie", text="CatÃ©gorie")
        self.articles_tree.heading("unite", text="UnitÃ©")
        self.articles_tree.heading("contenance", text="Contenance")
        self.articles_tree.heading("purchase_price", text="Prix achat/unitÃ© (â‚¬)")
        self.articles_tree.heading("commentaire", text="Commentaire")
        self.articles_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT, padx=3, pady=3)

        self.refresh_articles()

        btn_frame = tk.Frame(frame)
        btn_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5)
        tk.Button(btn_frame, text="Ajouter", command=self.add_article).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Modifier", command=self.edit_article).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Supprimer", command=self.del_article).pack(fill=tk.X, pady=2)

    def refresh_articles(self):
        try:
            for row in self.articles_tree.get_children():
                self.articles_tree.delete(row)
            for a in list_articles():
                # Use .get() for safe access to optional fields (articles are already dicts)
                purchase_price = a.get("purchase_price")
                purchase_price_display = ""
                if purchase_price is not None:
                    try:
                        purchase_price_display = f"{float(purchase_price):.2f}"
                    except (ValueError, TypeError):
                        pass
                
                self.articles_tree.insert(
                    "", "end", iid=a.get("id", 0),
                    values=(
                        a.get("name", ""),
                        a.get("categorie", ""),
                        a.get("unite", ""),
                        a.get("contenance", ""),
                        purchase_price_display,
                        a.get("commentaire", "")
                    )
                )
        except Exception as e:
            logger.exception("Error refreshing articles list")
            # Write diagnostic report for debugging
            try:
                reports_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "reports")
                os.makedirs(reports_dir, exist_ok=True)
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                report_path = os.path.join(reports_dir, f"inventory_error_refresh_articles_{timestamp}.txt")
                with open(report_path, 'w', encoding='utf-8') as f:
                    f.write(f"Articles Refresh Error Report\n")
                    f.write(f"{'='*60}\n")
                    f.write(f"Timestamp: {datetime.now().isoformat()}\n")
                    f.write(f"Error: {str(e)}\n")
                    f.write(f"Error Type: {type(e).__name__}\n")
                    f.write(f"\nDiagnostic: Error occurred while refreshing articles list.\n")
                    f.write(f"Ensure sqlite3.Row objects are properly converted to dicts.\n")
                logger.info(f"Diagnostic report written to: {report_path}")
            except Exception as report_err:
                logger.error(f"Failed to write diagnostic report: {report_err}")
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des articles. VÃ©rifiez que la structure de la base de donnÃ©es est Ã  jour."))

    def add_article(self):
        ArticleDialog(self.top, self.refresh_articles)

    def edit_article(self):
        sel = self.articles_tree.focus()
        if sel:
            article = get_article_by_id(sel)
            ArticleDialog(self.top, self.refresh_articles, article)
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un article Ã  modifier.")

    def del_article(self):
        sel = self.articles_tree.focus()
        if sel:
            if messagebox.askyesno("Suppression", "Supprimer cet article ?"):
                try:
                    delete_article(sel)
                    self.refresh_articles()
                except Exception as e:
                    messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de l'article."))
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un article Ã  supprimer.")

    # ------------------ TAB ACHATS ------------------
    def create_tab_achats(self):
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text="Achats")

        self.achats_tree = ttk.Treeview(frame, columns=("article_name", "contenance", "date_achat", "quantite", "prix_unitaire", "fournisseur", "facture", "exercice"), show="headings")
        self.achats_tree.heading("article_name", text="Article")
        self.achats_tree.heading("contenance", text="Contenance")
        self.achats_tree.heading("date_achat", text="Date")
        self.achats_tree.heading("quantite", text="QuantitÃ©")
        self.achats_tree.heading("prix_unitaire", text="PU (â‚¬)")
        self.achats_tree.heading("fournisseur", text="Fournisseur")
        self.achats_tree.heading("facture", text="Facture")
        self.achats_tree.heading("exercice", text="Exercice")
        self.achats_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT, padx=3, pady=3)

        self.refresh_achats()

        btn_frame = tk.Frame(frame)
        btn_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5)
        tk.Button(btn_frame, text="Ajouter", command=self.add_achat).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Modifier", command=self.edit_achat).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Supprimer", command=self.del_achat).pack(fill=tk.X, pady=2)

    def refresh_achats(self):
        try:
            for row in self.achats_tree.get_children():
                self.achats_tree.delete(row)
            for ach in list_achats():
                self.achats_tree.insert(
                    "", "end", iid=ach["id"],
                    values=(
                        ach["article_name"],
                        ach["article_contenance"] if "article_contenance" in ach.keys() and ach["article_contenance"] is not None else "",
                        ach["date_achat"],
                        ach["quantite"],
                        ach["prix_unitaire"],
                        ach["fournisseur"],
                        ach["facture"],
                        ach["exercice"]
                    )
                )
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des achats."))

    def add_achat(self):
        AchatDialog(self.top, self.refresh_achats)

    def edit_achat(self):
        sel = self.achats_tree.focus()
        if sel:
            achat = get_achat_by_id(sel)
            AchatDialog(self.top, self.refresh_achats, achat)
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un achat Ã  modifier.")

    def del_achat(self):
        sel = self.achats_tree.focus()
        if sel:
            if messagebox.askyesno("Suppression", "Supprimer cet achat ?"):
                try:
                    delete_achat(sel)
                    self.refresh_achats()
                except Exception as e:
                    messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de l'achat."))
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un achat Ã  supprimer.")

    # ------------------ TAB INVENTAIRES ------------------
    def create_tab_inventaires(self):
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text="Inventaires")

        self.inventaires_tree = ttk.Treeview(frame, columns=("date", "nom", "commentaire"), show="headings")
        self.inventaires_tree.heading("date", text="Date")
        self.inventaires_tree.heading("nom", text="Nom inventaire")
        self.inventaires_tree.heading("commentaire", text="Commentaire")
        self.inventaires_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT, padx=3, pady=3)

        self.refresh_inventaires()

        btn_frame = tk.Frame(frame)
        btn_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5)
        # Removed simple 'Ajouter' button - functionality replaced by detailed inventory dialog below
        tk.Button(btn_frame, text="Modifier", command=self.edit_inventaire).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Supprimer", command=self.del_inventaire).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Voir lignes", command=self.show_lignes_inventaire).pack(fill=tk.X, pady=2)
        # Separator
        ttk.Separator(btn_frame, orient='horizontal').pack(fill=tk.X, pady=10)
        # New detailed inventory button (replaces simple "Ajouter")
        tk.Button(btn_frame, text="Nouvel inventaire\ndÃ©taillÃ©", command=self.add_detailed_inventaire, bg="#4CAF50", fg="white").pack(fill=tk.X, pady=2)

    def refresh_inventaires(self):
        try:
            for row in self.inventaires_tree.get_children():
                self.inventaires_tree.delete(row)
            for inv in inv_db.list_inventaires():
                self.inventaires_tree.insert("", "end", iid=inv["id"], values=(inv["date_inventaire"], inv["type_inventaire"], inv["commentaire"]))
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des inventaires."))

    def add_inventaire(self):
        InventaireDialog(self.top, self.refresh_inventaires)

    def edit_inventaire(self):
        """Open the detailed inventory dialog for editing an existing inventory."""
        sel = self.inventaires_tree.focus()
        if sel:
            inv = None
            for i in inv_db.list_inventaires():
                if str(i["id"]) == str(sel):
                    inv = i
                    break
            if inv:
                # Open detailed dialog with edit mode
                from ui.inventory_lines_dialog import InventoryLinesDialog
                dialog = InventoryLinesDialog(self.top, edit_inventory=inv)
                # Make dialog modal and wait for it to close before refreshing
                dialog.grab_set()
                self.top.wait_window(dialog)
                # Refresh inventory list after dialog closes
                self.refresh_inventaires()
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un inventaire Ã  modifier.")

    def del_inventaire(self):
        sel = self.inventaires_tree.focus()
        if sel:
            if messagebox.askyesno("Suppression", "Supprimer cet inventaire ?"):
                try:
                    inv_db.delete_inventaire(sel)
                    self.refresh_inventaires()
                except Exception as e:
                    messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de l'inventaire."))
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un inventaire Ã  supprimer.")

    def show_lignes_inventaire(self):
        sel = self.inventaires_tree.focus()
        if sel:
            LignesInventaireDialog(self.top, sel)
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un inventaire pour voir les lignes.")

    def add_detailed_inventaire(self):
        """Open the detailed inventory dialog."""
        from ui.inventory_lines_dialog import InventoryLinesDialog
        dialog = InventoryLinesDialog(self.top)
        # Make dialog modal and wait for it to close before refreshing
        dialog.grab_set()
        self.top.wait_window(dialog)
        # Refresh inventory list after dialog closes
        self.refresh_inventaires()

    # ------------------ TAB MOUVEMENTS ------------------
    def create_tab_mouvements(self):
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text="Mouvements")

        self.mouvements_tree = ttk.Treeview(frame, columns=("date", "article_name", "contenance", "type", "quantite", "commentaire"), show="headings")
        self.mouvements_tree.heading("date", text="Date")
        self.mouvements_tree.heading("article_name", text="Article")
        self.mouvements_tree.heading("contenance", text="Contenance")
        self.mouvements_tree.heading("type", text="Type")
        self.mouvements_tree.heading("quantite", text="QuantitÃ©")
        self.mouvements_tree.heading("commentaire", text="Commentaire")
        self.mouvements_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT, padx=3, pady=3)

        self.refresh_mouvements()

        btn_frame = tk.Frame(frame)
        btn_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5)
        tk.Button(btn_frame, text="Ajouter", command=self.add_mouvement).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Modifier", command=self.edit_mouvement).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Supprimer", command=self.del_mouvement).pack(fill=tk.X, pady=2)

    def refresh_mouvements(self):
        try:
            for row in self.mouvements_tree.get_children():
                self.mouvements_tree.delete(row)
            for mvt in list_mouvements():
                self.mouvements_tree.insert(
                    "", "end", iid=mvt["id"],
                    values=(mvt["date"], mvt["article_name"], mvt["article_contenance"] if "article_contenance" in mvt.keys() and mvt["article_contenance"] is not None else "", mvt["type"], mvt["quantite"], mvt["commentaire"])
                )
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des mouvements."))

    def add_mouvement(self):
        MouvementDialog(self.top, self.refresh_mouvements)

    def edit_mouvement(self):
        sel = self.mouvements_tree.focus()
        if sel:
            mvt = get_mouvement_by_id(sel)
            MouvementDialog(self.top, self.refresh_mouvements, mvt)
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un mouvement Ã  modifier.")

    def del_mouvement(self):
        sel = self.mouvements_tree.focus()
        if sel:
            if messagebox.askyesno("Suppression", "Supprimer ce mouvement ?"):
                try:
                    delete_mouvement(sel)
                    self.refresh_mouvements()
                except Exception as e:
                    messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression du mouvement."))
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un mouvement Ã  supprimer.")

    # ------------------ TAB BILAN ------------------
    def create_tab_bilan(self):
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text="Bilan")

        self.bilan_text = tk.Text(frame, height=26, width=120, wrap=tk.WORD)
        self.bilan_text.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        tk.Button(frame, text="RafraÃ®chir bilan", command=self.refresh_bilan).pack(pady=3)
        self.refresh_bilan()

    def refresh_bilan(self):
        try:
            # Protection contre None pour les agrÃ©gations
            achats = sum(int(a["quantite"] or 0) for a in list_achats())
            mvts_entree = sum(int(m["quantite"] or 0) for m in list_mouvements() if m["type"] == "entrÃ©e")
            mvts_sortie = sum(int(m["quantite"] or 0) for m in list_mouvements() if m["type"] == "sortie")
            invs = sum(int(l["quantite"] or 0) for inv in inv_db.list_inventaires() for l in inv_db.list_lignes_inventaire(inv["id"]))
            txt = f"Total achats : {achats}\n"
            txt += f"Total mouvements entrÃ©e : {mvts_entree}\n"
            txt += f"Total mouvements sortie : {mvts_sortie}\n"
            txt += f"Total inventaire (toutes lignes) : {invs}\n"
            self.bilan_text.delete(1.0, tk.END)
            self.bilan_text.insert(tk.END, txt)
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du calcul du bilan."))

# ------------------ DIALOGS ------------------

class ArticleDialog(tk.Toplevel):
    def __init__(self, master, on_done, article=None):
        super().__init__(master)
        self.title("Article")
        self.on_done = on_done
        self.article = article

        tk.Label(self, text="Name").grid(row=0, column=0, sticky="w")
        self.name_var = tk.StringVar(value=article["name"] if article else "")
        tk.Entry(self, textvariable=self.name_var).grid(row=0, column=1)

        tk.Label(self, text="CatÃ©gorie").grid(row=1, column=0, sticky="w")
        self.categorie_var = tk.StringVar(value=article["categorie"] if article else "")
        tk.Entry(self, textvariable=self.categorie_var).grid(row=1, column=1)

        tk.Label(self, text="UnitÃ©").grid(row=2, column=0, sticky="w")
        self.unite_var = tk.StringVar(value=article["unite"] if article else "")
        tk.Entry(self, textvariable=self.unite_var).grid(row=2, column=1)

        tk.Label(self, text="Contenance").grid(row=3, column=0, sticky="w")
        contenance_options = ["0.25L", "0.33L", "0.5L", "0.75L", "1L", "1.5L", "2L"]
        self.contenance_var = tk.StringVar(value=article["contenance"] if article and "contenance" in article else contenance_options[0])
        ttk.Combobox(self, textvariable=self.contenance_var, values=contenance_options, state="readonly").grid(row=3, column=1)

        tk.Label(self, text="Commentaire").grid(row=4, column=0, sticky="w")
        self.commentaire_var = tk.StringVar(value=article["commentaire"] if article else "")
        tk.Entry(self, textvariable=self.commentaire_var).grid(row=4, column=1)

        tk.Button(self, text="Enregistrer", command=self.save).grid(row=5, column=0, columnspan=2, pady=8)

    def save(self):
        name = self.name_var.get()
        categorie = self.categorie_var.get()
        unite = self.unite_var.get()
        contenance = self.contenance_var.get()
        commentaire = self.commentaire_var.get()
        if not name:
            messagebox.showwarning("Saisie", "Le nom est obligatoire.")
            return
        try:
            if self.article:
                update_article(self.article["id"], name, categorie, unite, commentaire, contenance)
            else:
                insert_article(name, categorie, unite, commentaire, contenance)
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de l'article."))

# ... autres classes inchangÃ©es ...
class AchatDialog(tk.Toplevel):
    def __init__(self, master, on_done, achat=None):
        super().__init__(master)
        self.title("Achat")
        self.on_done = on_done
        self.achat = achat

        from modules.buvette_db import list_articles_names
        tk.Label(self, text="Article").grid(row=0, column=0, sticky="w")
        articles = list_articles_names()
        self.article_options = [f"{a['name']} (id={a['id']})" for a in articles]
        self.article_id_map = {f"{a['name']} (id={a['id']})": a['id'] for a in articles}
        self.article_contenance_map = {f"{a['name']} (id={a['id']})": a['contenance'] for a in articles}
        default_article = None
        if achat:
            for opt in self.article_options:
                if self.article_id_map[opt] == achat["article_id"]:
                    default_article = opt
                    break
        self.article_var = tk.StringVar(value=default_article if default_article else (self.article_options[0] if self.article_options else ""))
        self.article_combo = ttk.Combobox(self, textvariable=self.article_var, values=self.article_options, state="readonly")
        self.article_combo.grid(row=0, column=1)

        # Affichage de la contenance de l'article sÃ©lectionnÃ© (lecture seule)
        tk.Label(self, text="Contenance").grid(row=1, column=0, sticky="w")
        self.contenance_var = tk.StringVar(value=self.article_contenance_map.get(self.article_var.get(), ""))
        self.contenance_entry = tk.Entry(self, textvariable=self.contenance_var, state="readonly")
        self.contenance_entry.grid(row=1, column=1)

        def update_contenance(*_):
            self.contenance_var.set(self.article_contenance_map.get(self.article_var.get(), ""))
        self.article_var.trace_add("write", update_contenance)

        tk.Label(self, text="Date").grid(row=2, column=0, sticky="w")
        self.date_var = tk.StringVar(value=achat["date_achat"] if achat else "")
        tk.Entry(self, textvariable=self.date_var).grid(row=2, column=1)

        tk.Label(self, text="QuantitÃ©").grid(row=3, column=0, sticky="w")
        self.quantite_var = tk.IntVar(value=achat["quantite"] if achat else 0)
        tk.Entry(self, textvariable=self.quantite_var).grid(row=3, column=1)

        tk.Label(self, text="PU (â‚¬)").grid(row=4, column=0, sticky="w")
        self.prix_unitaire_var = tk.DoubleVar(value=achat["prix_unitaire"] if achat else 0.0)
        tk.Entry(self, textvariable=self.prix_unitaire_var).grid(row=4, column=1)

        tk.Label(self, text="Fournisseur").grid(row=5, column=0, sticky="w")
        self.fournisseur_var = tk.StringVar(value=achat["fournisseur"] if achat else "")
        tk.Entry(self, textvariable=self.fournisseur_var).grid(row=5, column=1)

        tk.Label(self, text="Facture").grid(row=6, column=0, sticky="w")
        self.facture_var = tk.StringVar(value=achat["facture"] if achat else "")
        tk.Entry(self, textvariable=self.facture_var).grid(row=6, column=1)

        tk.Label(self, text="Exercice").grid(row=7, column=0, sticky="w")
        self.exercice_var = tk.StringVar(value=achat["exercice"] if achat else "")
        tk.Entry(self, textvariable=self.exercice_var).grid(row=7, column=1)

        tk.Button(self, text="Enregistrer", command=self.save).grid(row=8, column=0, columnspan=2, pady=8)

    def save(self):
        article_selection = self.article_var.get()
        article_id = self.article_id_map.get(article_selection)
        # contenance = self.article_contenance_map.get(article_selection) # lecture seule, utile si tu veux l'utiliser
        date_achat = self.date_var.get()
        quantite = self.quantite_var.get()
        prix_unitaire = self.prix_unitaire_var.get()
        fournisseur = self.fournisseur_var.get()
        facture = self.facture_var.get()
        exercice = self.exercice_var.get()
        if not article_id or not date_achat:
            messagebox.showwarning("Saisie", "Article et Date sont obligatoires.")
            return
        try:
            if self.achat:
                update_achat(self.achat["id"], article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice)
            else:
                insert_achat(article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice)
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de l'achat."))
            
class InventaireDialog(tk.Toplevel):
    def __init__(self, master, on_done, inventaire=None):
        super().__init__(master)
        self.title("Inventaire")
        self.on_done = on_done
        self.inventaire = inventaire
        
        # Configure grid pour layout extensible
        self.columnconfigure(1, weight=1)

        tk.Label(self, text="Date").grid(row=0, column=0, sticky="w", padx=5, pady=3)
        self.date_var = tk.StringVar(value=inventaire["date_inventaire"] if inventaire else "")
        tk.Entry(self, textvariable=self.date_var).grid(row=0, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="Type inventaire").grid(row=1, column=0, sticky="w", padx=5, pady=3)
        type_options = ["avant", "apres", "hors_evenement"]
        self.nom_var = tk.StringVar(value=inventaire["type_inventaire"] if inventaire else "hors_evenement")
        ttk.Combobox(self, textvariable=self.nom_var, values=type_options, state="readonly").grid(row=1, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="Commentaire").grid(row=2, column=0, sticky="w", padx=5, pady=3)
        self.commentaire_var = tk.StringVar(value=inventaire["commentaire"] if inventaire else "")
        tk.Entry(self, textvariable=self.commentaire_var).grid(row=2, column=1, sticky="ew", padx=5, pady=3)

        tk.Button(self, text="Enregistrer", command=self.save).grid(row=3, column=0, columnspan=2, pady=8)

    def save(self):
        date = self.date_var.get()
        type_inventaire = self.nom_var.get()
        commentaire = self.commentaire_var.get()
        if not date or not type_inventaire:
            messagebox.showwarning("Saisie", "Date et type sont obligatoires.")
            return
        
        # Valider que le type est bien dans les valeurs acceptÃ©es
        if type_inventaire not in ('avant', 'apres', 'hors_evenement'):
            messagebox.showwarning("Saisie", "Le type doit Ãªtre 'avant', 'apres' ou 'hors_evenement'.")
            return
        
        event_id = None  # No event linked for now
        
        try:
            if self.inventaire:
                inv_db.update_inventaire(self.inventaire["id"], date, event_id, type_inventaire, commentaire)
            else:
                # Capture inv_id for potential future use (e.g., adding lignes immediately after creation)
                inv_id = inv_db.insert_inventaire(date, event_id, type_inventaire, commentaire)
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de l'inventaire."))

class LignesInventaireDialog(tk.Toplevel):
    def __init__(self, master, inventaire_id):
        super().__init__(master)
        self.title("Lignes de l'inventaire")
        self.inventaire_id = inventaire_id
        self.create_widgets()
        self.refresh_lignes()

    def create_widgets(self):
        self.lignes_tree = ttk.Treeview(self, columns=("article_id", "quantite", "commentaire"), show="headings")
        self.lignes_tree.heading("article_id", text="Article")
        self.lignes_tree.heading("quantite", text="QuantitÃ©")
        self.lignes_tree.heading("commentaire", text="Commentaire")
        self.lignes_tree.pack(fill=tk.BOTH, expand=True, padx=3, pady=3)
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X, pady=6)
        tk.Button(btn_frame, text="Ajouter", command=self.add_ligne).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Modifier", command=self.edit_ligne).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Supprimer", command=self.del_ligne).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=6)

    def refresh_lignes(self):
        try:
            for row in self.lignes_tree.get_children():
                self.lignes_tree.delete(row)
            for l in inv_db.list_lignes_inventaire(self.inventaire_id):
                # l is already a dict from list_lignes_inventaire (uses rows_to_dicts)
                # Afficher article_name au lieu de article_id pour meilleure lisibilitÃ©
                article_display = l.get("article_name") or f"ID:{l.get('article_id', 'Unknown')}"
                # ID should always be present from DB, but use str() for safety
                line_id = str(l.get("id", 0))
                self.lignes_tree.insert("", "end", iid=line_id, values=(article_display, l.get("quantite", 0), l.get("commentaire", "")))
        except Exception as e:
            logger.exception("Error refreshing inventory lines")
            # Write diagnostic report for debugging
            try:
                reports_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "reports")
                os.makedirs(reports_dir, exist_ok=True)
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                report_path = os.path.join(reports_dir, f"inventory_error_buvette_{timestamp}.txt")
                with open(report_path, 'w', encoding='utf-8') as f:
                    f.write(f"Inventory Lines Refresh Error Report\n")
                    f.write(f"{'='*60}\n")
                    f.write(f"Timestamp: {datetime.now().isoformat()}\n")
                    f.write(f"Inventaire ID: {self.inventaire_id}\n")
                    f.write(f"Error: {str(e)}\n")
                    f.write(f"Error Type: {type(e).__name__}\n")
                    f.write(f"\nDiagnostic: Error occurred while refreshing inventory lines.\n")
                    f.write(f"Ensure sqlite3.Row objects are properly converted to dicts.\n")
                logger.info(f"Diagnostic report written to: {report_path}")
            except Exception as report_err:
                logger.error(f"Failed to write diagnostic report: {report_err}")
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des lignes d'inventaire."))

    def add_ligne(self):
        LigneInventaireDialog(self, self.refresh_lignes, self.inventaire_id)

    def edit_ligne(self):
        sel = self.lignes_tree.focus()
        if sel:
            ligne = None
            for l in inv_db.list_lignes_inventaire(self.inventaire_id):
                if str(l["id"]) == str(sel):
                    ligne = l
                    break
            if ligne:
                LigneInventaireDialog(self, self.refresh_lignes, self.inventaire_id, ligne)
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner une ligne Ã  modifier.")

    def del_ligne(self):
        sel = self.lignes_tree.focus()
        if sel:
            if messagebox.askyesno("Suppression", "Supprimer cette ligne ?"):
                try:
                    inv_db.delete_ligne_inventaire(sel)
                    self.refresh_lignes()
                except Exception as e:
                    messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de la ligne d'inventaire."))
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner une ligne Ã  supprimer.")

class LigneInventaireDialog(tk.Toplevel):
    def __init__(self, master, on_done, inventaire_id, ligne=None):
        super().__init__(master)
        self.title("Ligne inventaire")
        self.on_done = on_done
        self.inventaire_id = inventaire_id
        self.ligne = ligne

        # Utiliser Combobox pour sÃ©lectionner un article
        tk.Label(self, text="Article").grid(row=0, column=0, sticky="w", padx=5, pady=3)
        articles = list_articles_names()
        self.article_options = [f"{a['name']} ({a['contenance'] or 'N/A'})" for a in articles]
        self.article_id_map = {f"{a['name']} ({a['contenance'] or 'N/A'})": a['id'] for a in articles}
        
        # SÃ©lectionner l'article par dÃ©faut si en mode Ã©dition
        default_article = None
        if ligne:
            for opt in self.article_options:
                if self.article_id_map[opt] == ligne["article_id"]:
                    default_article = opt
                    break
        
        self.article_var = tk.StringVar(value=default_article if default_article else (self.article_options[0] if self.article_options else ""))
        self.article_combo = ttk.Combobox(self, textvariable=self.article_var, values=self.article_options, state="readonly", width=30)
        self.article_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="QuantitÃ©").grid(row=1, column=0, sticky="w", padx=5, pady=3)
        self.quantite_var = tk.IntVar(value=ligne["quantite"] if ligne else 0)
        tk.Entry(self, textvariable=self.quantite_var).grid(row=1, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="Commentaire").grid(row=2, column=0, sticky="w", padx=5, pady=3)
        self.comment_var = tk.StringVar(value=ligne["commentaire"] if ligne else "")
        tk.Entry(self, textvariable=self.comment_var).grid(row=2, column=1, sticky="ew", padx=5, pady=3)

        tk.Button(self, text="Enregistrer", command=self.save).grid(row=3, column=0, columnspan=2, pady=8)

    def save(self):
        article_selection = self.article_var.get()
        article_id = self.article_id_map.get(article_selection)
        quantite = self.quantite_var.get()
        comment = self.comment_var.get()
        if not article_id:
            messagebox.showwarning("Saisie", "Article obligatoire.")
            return
        try:
            if self.ligne:
                inv_db.update_ligne_inventaire(self.ligne["id"], article_id, quantite, comment)
            else:
                inv_db.insert_ligne_inventaire(self.inventaire_id, article_id, quantite, comment)
            
            # Mettre Ã  jour le stock de l'article immÃ©diatement aprÃ¨s l'enregistrement de la ligne d'inventaire
            try:
                set_article_stock(article_id, quantite)
            except Exception as stock_err:
                logger.warning(f"Erreur lors de la mise Ã  jour du stock pour l'article {article_id}: {stock_err}")
            
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de la ligne d'inventaire."))

class MouvementDialog(tk.Toplevel):
    def __init__(self, master, on_done, mvt=None):
        super().__init__(master)
        self.title("Mouvement")
        self.on_done = on_done
        self.mvt = mvt

        tk.Label(self, text="Date").grid(row=0, column=0, sticky="w", padx=5, pady=3)
        self.date_var = tk.StringVar(value=mvt["date"] if mvt else "")
        tk.Entry(self, textvariable=self.date_var).grid(row=0, column=1, sticky="ew", padx=5, pady=3)

        # Utiliser Combobox pour sÃ©lectionner un article
        tk.Label(self, text="Article").grid(row=1, column=0, sticky="w", padx=5, pady=3)
        articles = list_articles_names()
        self.article_options = [f"{a['name']} ({a['contenance'] or 'N/A'})" for a in articles]
        self.article_id_map = {f"{a['name']} ({a['contenance'] or 'N/A'})": a['id'] for a in articles}
        
        # SÃ©lectionner l'article par dÃ©faut si en mode Ã©dition
        default_article = None
        if mvt:
            for opt in self.article_options:
                if self.article_id_map[opt] == mvt["article_id"]:
                    default_article = opt
                    break
        
        self.article_var = tk.StringVar(value=default_article if default_article else (self.article_options[0] if self.article_options else ""))
        self.article_combo = ttk.Combobox(self, textvariable=self.article_var, values=self.article_options, state="readonly", width=30)
        self.article_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="Type").grid(row=2, column=0, sticky="w", padx=5, pady=3)
        self.type_var = tk.StringVar(value=mvt["type"] if mvt else "entrÃ©e")
        type_combo = ttk.Combobox(self, textvariable=self.type_var, values=["entrÃ©e", "sortie"], state="readonly")
        type_combo.grid(row=2, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="QuantitÃ©").grid(row=3, column=0, sticky="w", padx=5, pady=3)
        self.quantite_var = tk.IntVar(value=mvt["quantite"] if mvt else 0)
        tk.Entry(self, textvariable=self.quantite_var).grid(row=3, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="Commentaire").grid(row=4, column=0, sticky="w", padx=5, pady=3)
        self.comment_var = tk.StringVar(value=mvt["commentaire"] if mvt else "")
        tk.Entry(self, textvariable=self.comment_var).grid(row=4, column=1, sticky="ew", padx=5, pady=3)

        tk.Button(self, text="Enregistrer", command=self.save).grid(row=5, column=0, columnspan=2, pady=8)

    def save(self):
        date = self.date_var.get()
        article_selection = self.article_var.get()
        article_id = self.article_id_map.get(article_selection)
        type_mvt = self.type_var.get()
        quantite = self.quantite_var.get()
        comment = self.comment_var.get()
        if not date or not article_id or not type_mvt or not quantite:
            messagebox.showwarning("Saisie", "Tous les champs sont obligatoires.")
            return
        try:
            if self.mvt:
                update_mouvement(self.mvt["id"], date, article_id, type_mvt, quantite, comment)
            else:
                insert_mouvement(date, article_id, type_mvt, quantite, comment)
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement du mouvement."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/buvette_bilan_db.py ===

```python
"""
Module de gestion de la base de donnÃ©es pour les bilans de la buvette.

STANDARDIZATION (PR copilot/audit-db-access-standardization):
- Improved connection management with try/finally blocks to reduce locks
- Converted sqlite3.Row to dicts for consistent .get() access patterns
- Added docstrings and error handling
"""

from db.db import get_connection
from utils.db_helpers import rows_to_dicts, row_to_dict
from utils.app_logger import get_logger
import sqlite3

logger = get_logger("buvette_bilan_db")

def get_conn():
    conn = get_connection()
    return conn

def list_evenements():
    """Liste tous les Ã©vÃ©nements pour lesquels il existe des inventaires buvette, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("SELECT id, name, date FROM events ORDER BY date DESC").fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_inventaire_par_evenement(event_id, typ):
    """
    RÃ©cupÃ¨re l'inventaire 'avant' ou 'aprÃ¨s' pour un Ã©vÃ©nement, returns dict or None.
    typ = 'avant' ou 'apres'
    """
    conn = None
    try:
        conn = get_conn()
        inv = conn.execute("""
            SELECT * FROM buvette_inventaires
            WHERE event_id=? AND type_inventaire=?
            ORDER BY date_inventaire ASC
            LIMIT 1
        """, (event_id, typ)).fetchone()
        return row_to_dict(inv)
    finally:
        if conn:
            conn.close()

def get_lignes_inventaire(inv_id):
    """
    RÃ©cupÃ¨re les lignes d'inventaire (avec info article) pour un inventaire donnÃ©, returns list of dicts.
    """
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT l.*, a.name as article_name, a.categorie, a.unite
            FROM buvette_inventaire_lignes l
            LEFT JOIN buvette_articles a ON l.article_id = a.id
            WHERE l.inventaire_id=?
            ORDER BY a.name
        """, (inv_id,)).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_prix_moyen_achat(article_id, jusqua_date=None):
    """
    Calcule le prix moyen pondÃ©rÃ© d'achat d'un article jusqu'Ã  une date donnÃ©e.
    Returns float.
    """
    conn = None
    try:
        conn = get_conn()
        q = "SELECT SUM(quantite*prix_unitaire) as total, SUM(quantite) as qte FROM buvette_achats WHERE article_id=?"
        params = [article_id]
        if jusqua_date:
            q += " AND date_achat<=?"
            params.append(jusqua_date)
        row = conn.execute(q, params).fetchone()
        row_dict = row_to_dict(row)
        if row_dict and row_dict.get("qte"):
            return row_dict["total"] / row_dict["qte"]
        return 0.0
    finally:
        if conn:
            conn.close()

def get_recette_buvette(event_id):
    """
    RÃ©cupÃ¨re la somme totale des recettes buvette pour un Ã©vÃ©nement.
    Returns float.
    """
    conn = None
    try:
        conn = get_conn()
        row = conn.execute("""
            SELECT SUM(montant) as recette
            FROM buvette_recettes
            WHERE event_id=?
        """, (event_id,)).fetchone()
        row_dict = row_to_dict(row)
        return row_dict.get("recette", 0.0) if row_dict else 0.0
    finally:
        if conn:
            conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/buvette_bilan_dialogs.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
import sqlite3

def get_conn():
    conn = get_connection()
    return conn

def list_evenements():
    conn = get_conn()
    rows = conn.execute("SELECT id, name, date FROM events ORDER BY date DESC").fetchall()
    conn.close()
    return rows

def get_inventaire_par_evenement(event_id, typ):
    conn = get_conn()
    inv = conn.execute("""
        SELECT * FROM buvette_inventaires
        WHERE event_id=? AND type_inventaire=?
        ORDER BY date_inventaire ASC
        LIMIT 1
    """, (event_id, typ)).fetchone()
    conn.close()
    return inv

def get_lignes_inventaire(inv_id):
    conn = get_conn()
    rows = conn.execute("""
        SELECT l.*, a.name as article_name, a.categorie, a.unite
        FROM buvette_inventaire_lignes l
        LEFT JOIN buvette_articles a ON l.article_id = a.id
        WHERE l.inventaire_id=?
        ORDER BY a.name
    """, (inv_id,)).fetchall()
    conn.close()
    return rows

def get_prix_moyen_achat(article_id, jusqua_date=None):
    conn = get_conn()
    q = "SELECT SUM(quantite*prix_unitaire) as total, SUM(quantite) as qte FROM buvette_achats WHERE article_id=?"
    params = [article_id]
    if jusqua_date:
        q += " AND date_achat<=?"
        params.append(jusqua_date)
    row = conn.execute(q, params).fetchone()
    conn.close()
    if row and row["qte"]:
        return row["total"]/row["qte"]
    return 0.0

def get_recette_buvette(event_id):
    conn = get_conn()
    row = conn.execute("""
        SELECT SUM(montant) as recette
        FROM buvette_recettes
        WHERE event_id=?
    """, (event_id,)).fetchone()
    conn.close()
    return row["recette"] or 0.0

class BuvetteBilanDialog(tk.Toplevel):
    def __init__(self, master):
        super().__init__(master)
        self.title("Bilan Buvette par Ã©vÃ©nement")
        self.geometry("900x600")
        self.create_widgets()

    def create_widgets(self):
        frm_select = tk.Frame(self)
        frm_select.pack(fill=tk.X, padx=10, pady=8)

        tk.Label(frm_select, text="Ã‰vÃ©nement :").pack(side=tk.LEFT)
        self.event_combo = ttk.Combobox(frm_select, state="readonly", width=50)
        events = list_evenements()
        self.events = {f"{ev['date']} - {ev['name']}": ev['id'] for ev in events}
        self.event_combo["values"] = list(self.events.keys())
        self.event_combo.pack(side=tk.LEFT, padx=4)
        tk.Button(frm_select, text="Voir bilan", command=self.display_bilan).pack(side=tk.LEFT, padx=12)

        self.text = tk.Text(self, height=30, width=120)
        self.text.pack(fill=tk.BOTH, expand=True, padx=10, pady=8)

    def display_bilan(self):
        evt_label = self.event_combo.get()
        if not evt_label or evt_label not in self.events:
            messagebox.showwarning("Ã‰vÃ©nement", "SÃ©lectionnez un Ã©vÃ©nement.")
            return
        event_id = self.events[evt_label]

        inv_avant = get_inventaire_par_evenement(event_id, "avant")
        inv_apres = get_inventaire_par_evenement(event_id, "apres")

        bilan_txt = f"BILAN BUVETTE - {evt_label}\n"
        bilan_txt += "\n--- Inventaire AVANT ---\n"
        if inv_avant:
            lignes_avant = get_lignes_inventaire(inv_avant["id"])
            for l in lignes_avant:
                bilan_txt += f"{l['article_name']}: {l['quantite']} {l['unite']} ({l['categorie']})\n"
        else:
            bilan_txt += "Aucun inventaire avant.\n"

        bilan_txt += "\n--- Inventaire APRES ---\n"
        if inv_apres:
            lignes_apres = get_lignes_inventaire(inv_apres["id"])
            for l in lignes_apres:
                bilan_txt += f"{l['article_name']}: {l['quantite']} {l['unite']} ({l['categorie']})\n"
        else:
            bilan_txt += "Aucun inventaire aprÃ¨s.\n"

        bilan_txt += "\n--- Recette Buvette ---\n"
        recette = get_recette_buvette(event_id)
        bilan_txt += f"Total recettes buvette : {recette:.2f} â‚¬\n"

        self.text.delete(1.0, tk.END)
        self.text.insert(tk.END, bilan_txt)
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/buvette_db.py ===

```python
"""
Module de gestion de la base de donnÃ©es pour le module Buvette.

MODIFICATIONS APPLIQUÃ‰ES (PR corrections buvette - copilot/auto-fix-buvette):
- Harmonisation des noms de colonnes pour buvette_mouvements:
  * INSERT et UPDATE utilisent maintenant date_mouvement, type_mouvement, motif
    (au lieu de date, type, commentaire) pour correspondre au schÃ©ma DB
  * Les SELECT ajoutent des alias (AS date, AS type, AS commentaire) pour
    maintenir la compatibilitÃ© avec le code UI existant

- Ajout de la gestion du stock (PR copilot/auto-fix-buvette):
  * Fonction ensure_stock_column(): migration non destructive pour ajouter la colonne 'stock'
  * Fonction set_article_stock(article_id, stock): mise Ã  jour du stock d'un article
  * Fonction get_article_stock(article_id): rÃ©cupÃ©ration du stock actuel d'un article
  * Ces fonctions permettent de suivre les quantitÃ©s en stock aprÃ¨s chaque inventaire

STANDARDIZATION (PR copilot/audit-db-access-standardization):
- Improved connection management with try/finally blocks to reduce locks
- Converted sqlite3.Row to dicts for consistent .get() access patterns
- Centralized error handling
"""

from db.db import get_connection
from utils.db_helpers import rows_to_dicts, row_to_dict
from utils.app_logger import get_logger
import sqlite3

logger = get_logger("buvette_db")

def get_conn():
    conn = get_connection()
    return conn

# ----- ARTICLES -----
def list_articles():
    """List all articles, returns list of dicts for .get() access."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("SELECT * FROM buvette_articles ORDER BY name").fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_article_by_id(article_id):
    """Get article by ID, returns dict or None."""
    conn = None
    try:
        conn = get_conn()
        row = conn.execute("SELECT * FROM buvette_articles WHERE id=?", (article_id,)).fetchone()
        return row_to_dict(row)
    finally:
        if conn:
            conn.close()

def insert_article(name, categorie, unite, commentaire, contenance, purchase_price=None):
    """Insert new article."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            INSERT INTO buvette_articles (name, categorie, unite, commentaire, contenance, purchase_price)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (name, categorie, unite, commentaire, contenance, purchase_price))
        conn.commit()
    finally:
        if conn:
            conn.close()

def update_article(article_id, name, categorie, unite, commentaire, contenance, purchase_price=None):
    """Update existing article."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_articles SET name=?, categorie=?, unite=?, commentaire=?, contenance=?, purchase_price=?
            WHERE id=?
        """, (name, categorie, unite, commentaire, contenance, purchase_price, article_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_article(article_id):
    """Delete article by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_articles WHERE id=?", (article_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- ACHATS -----
def list_achats():
    """List all achats with article info, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT a.*, ar.name AS article_name, ar.contenance AS article_contenance
            FROM buvette_achats a
            LEFT JOIN buvette_articles ar ON a.article_id = ar.id
            ORDER BY a.date_achat DESC
        """).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_achat_by_id(achat_id):
    """Get achat by ID with article info, returns dict or None."""
    conn = None
    try:
        conn = get_conn()
        row = conn.execute("""
            SELECT a.*, ar.name AS article_name, ar.contenance AS article_contenance
            FROM buvette_achats a
            LEFT JOIN buvette_articles ar ON a.article_id = ar.id
            WHERE a.id=?
        """, (achat_id,)).fetchone()
        return row_to_dict(row)
    finally:
        if conn:
            conn.close()

def insert_achat(article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice):
    """Insert new achat."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            INSERT INTO buvette_achats (article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice))
        conn.commit()
    finally:
        if conn:
            conn.close()

def update_achat(achat_id, article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice):
    """Update existing achat."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_achats SET article_id=?, date_achat=?, quantite=?, prix_unitaire=?,
                fournisseur=?, facture=?, exercice=?
            WHERE id=?
        """, (article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice, achat_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_achat(achat_id):
    """Delete achat by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_achats WHERE id=?", (achat_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- MOUVEMENTS -----
def list_mouvements():
    """List all mouvements with article info, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT m.*, 
                   m.date_mouvement AS date, 
                   m.type_mouvement AS type,
                   m.motif AS commentaire,
                   ar.name AS article_name, 
                   ar.contenance AS article_contenance
            FROM buvette_mouvements m
            LEFT JOIN buvette_articles ar ON m.article_id = ar.id
            ORDER BY m.date_mouvement DESC
        """).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_mouvement_by_id(mvt_id):
    """Get mouvement by ID with article info, returns dict or None."""
    conn = None
    try:
        conn = get_conn()
        row = conn.execute("""
            SELECT m.*, 
                   m.date_mouvement AS date, 
                   m.type_mouvement AS type,
                   m.motif AS commentaire,
                   ar.name AS article_name, 
                   ar.contenance AS article_contenance
            FROM buvette_mouvements m
            LEFT JOIN buvette_articles ar ON m.article_id = ar.id
            WHERE m.id=?
        """, (mvt_id,)).fetchone()
        return row_to_dict(row)
    finally:
        if conn:
            conn.close()

def insert_mouvement(date_mouvement, article_id, type_mouvement, quantite, motif):
    """Insert new mouvement."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            INSERT INTO buvette_mouvements (date_mouvement, article_id, type_mouvement, quantite, motif)
            VALUES (?, ?, ?, ?, ?)
        """, (date_mouvement, article_id, type_mouvement, quantite, motif))
        conn.commit()
    finally:
        if conn:
            conn.close()

def update_mouvement(mvt_id, date_mouvement, article_id, type_mouvement, quantite, motif):
    """Update existing mouvement."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_mouvements SET date_mouvement=?, article_id=?, type_mouvement=?, quantite=?, motif=?
            WHERE id=?
        """, (date_mouvement, article_id, type_mouvement, quantite, motif, mvt_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_mouvement(mvt_id):
    """Delete mouvement by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_mouvements WHERE id=?", (mvt_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- INVENTAIRE LIGNES -----
def list_lignes_inventaire(inventaire_id):
    """List inventory lines for a specific inventory, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT l.*, ar.name AS article_name, ar.contenance AS article_contenance
            FROM buvette_inventaire_lignes l
            LEFT JOIN buvette_articles ar ON l.article_id = ar.id
            WHERE l.inventaire_id=?
            ORDER BY l.id
        """, (inventaire_id,)).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def insert_ligne_inventaire(inventaire_id, article_id, quantite, commentaire):
    """Insert new inventory line."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            INSERT INTO buvette_inventaire_lignes (inventaire_id, article_id, quantite, commentaire)
            VALUES (?, ?, ?, ?)
        """, (inventaire_id, article_id, quantite, commentaire))
        conn.commit()
    finally:
        if conn:
            conn.close()

def update_ligne_inventaire(ligne_id, article_id, quantite, commentaire):
    """Update existing inventory line."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_inventaire_lignes SET article_id=?, quantite=?, commentaire=?
            WHERE id=?
        """, (article_id, quantite, commentaire, ligne_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_ligne_inventaire(ligne_id):
    """Delete inventory line by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_inventaire_lignes WHERE id=?", (ligne_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- UTILITY -----
def list_articles_names():
    """List article IDs, names and contenance, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("SELECT id, name, contenance FROM buvette_articles ORDER BY name").fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def ensure_stock_column():
    """
    Migration non destructive: Ajoute la colonne 'stock' Ã  buvette_articles si elle n'existe pas.
    Cette fonction doit Ãªtre appelÃ©e au dÃ©marrage de l'application ou lors de la mise Ã  jour de la DB.
    """
    conn = None
    try:
        conn = get_conn()
        # VÃ©rifier si la colonne stock existe dÃ©jÃ 
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns = [row["name"] for row in cursor.fetchall()]
        
        if "stock" not in columns:
            conn.execute("ALTER TABLE buvette_articles ADD COLUMN stock INTEGER DEFAULT 0")
            conn.commit()
            logger.info("Column 'stock' added to buvette_articles")
            return True  # Colonne ajoutÃ©e
        return False  # Colonne existait dÃ©jÃ 
    except Exception as e:
        if conn:
            conn.rollback()
        logger.error(f"Error ensuring stock column: {e}")
        raise e
    finally:
        if conn:
            conn.close()

def set_article_stock(article_id, stock):
    """
    Met Ã  jour le stock d'un article.
    Cette fonction est appelÃ©e aprÃ¨s l'enregistrement d'un inventaire pour mettre Ã  jour
    le stock de l'article immÃ©diatement.
    
    Args:
        article_id: ID de l'article
        stock: Nouvelle valeur du stock (quantitÃ© en unitÃ©s)
    """
    conn = None
    try:
        conn = get_conn()
        conn.execute("UPDATE buvette_articles SET stock=? WHERE id=?", (stock, article_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def get_article_stock(article_id):
    """
    RÃ©cupÃ¨re le stock actuel d'un article.
    
    Args:
        article_id: ID de l'article
        
    Returns:
        int: Stock actuel de l'article (0 si la colonne n'existe pas ou si l'article n'existe pas)
    """
    conn = None
    try:
        conn = get_conn()
        # VÃ©rifier si la colonne stock existe
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns = [row["name"] for row in cursor.fetchall()]
        
        if "stock" in columns:
            row = conn.execute("SELECT stock FROM buvette_articles WHERE id=?", (article_id,)).fetchone()
            return row_to_dict(row).get("stock", 0) if row else 0
        else:
            return 0
    finally:
        if conn:
            conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/buvette_dialogs.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from datetime import date
import modules.buvette_db as db

# -------- DIALOGUES ARTICLES ----------
class ArticleDialog(tk.Toplevel):
    def __init__(self, master, article_id=None, on_save=None):
        super().__init__(master)
        self.title("Article buvette")
        self.geometry("350x400")
        self.on_save = on_save
        self.article_id = article_id

        self.nom_var = tk.StringVar()
        self.categorie_var = tk.StringVar()
        self.unite_var = tk.StringVar()
        self.contenance_var = tk.StringVar()
        self.comment_var = tk.StringVar()
        self.purchase_price_var = tk.DoubleVar()

        tk.Label(self, text="Name :").pack(pady=4)
        tk.Entry(self, textvariable=self.nom_var, width=30).pack()
        tk.Label(self, text="CatÃ©gorie :").pack(pady=4)
        tk.Entry(self, textvariable=self.categorie_var, width=25).pack()
        tk.Label(self, text="UnitÃ© (ex: canette, bouteille...) :").pack(pady=4)
        tk.Entry(self, textvariable=self.unite_var, width=18).pack()
        tk.Label(self, text="Contenance :").pack(pady=4)
        contenance_options = ["0.25L", "0.33L", "0.5L", "0.75L", "1L", "1.5L", "2L"]
        self.contenance_cb = ttk.Combobox(self, textvariable=self.contenance_var, state="readonly", width=10)
        self.contenance_cb["values"] = contenance_options
        self.contenance_cb.pack()
        tk.Label(self, text="Prix achat / unitÃ© (â‚¬) :").pack(pady=4)
        tk.Entry(self, textvariable=self.purchase_price_var, width=15).pack()
        tk.Label(self, text="Commentaire :").pack(pady=4)
        tk.Entry(self, textvariable=self.comment_var, width=35).pack()

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=14)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=12)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=12)

        if article_id:
            self.load_article()

    def load_article(self):
        r = db.get_article_by_id(self.article_id)
        if r:
            self.nom_var.set(r["name"])
            self.categorie_var.set(r["categorie"])
            self.unite_var.set(r["unite"])
            self.contenance_var.set(r["contenance"] if r["contenance"] else "")
            if "purchase_price" in r.keys() and r["purchase_price"] is not None:
                self.purchase_price_var.set(r["purchase_price"])
            self.comment_var.set(r["commentaire"])

    def save(self):
        name = self.nom_var.get().strip()
        if not name:
            messagebox.showerror("Erreur", "Le nom de l'article est obligatoire.")
            return
        categorie = self.categorie_var.get().strip()
        unite = self.unite_var.get().strip()
        contenance = self.contenance_var.get().strip()
        comment = self.comment_var.get().strip()
        try:
            # Get purchase price, handling empty or invalid input
            purchase_price = self.purchase_price_var.get()
        except tk.TclError:
            # TclError occurs when the DoubleVar field is empty or contains invalid data
            purchase_price = None
        if self.article_id:
            db.update_article(self.article_id, name, categorie, unite, comment, contenance, purchase_price)
        else:
            db.insert_article(name, categorie, unite, comment, contenance, purchase_price)
        if self.on_save:
            self.on_save()
        self.destroy()

# -------- DIALOGUES ACHATS ----------
class AchatDialog(tk.Toplevel):
    def __init__(self, master, achat_id=None, on_save=None):
        super().__init__(master)
        self.title("Achat buvette")
        self.geometry("420x440")
        self.on_save = on_save
        self.achat_id = achat_id

        self.article_var = tk.StringVar()
        self.date_var = tk.StringVar(value=str(date.today()))
        self.qte_var = tk.IntVar()
        self.pu_var = tk.DoubleVar()
        self.fournisseur_var = tk.StringVar()
        self.facture_var = tk.StringVar()
        self.exercice_var = tk.StringVar()
        self.contenance_display_var = tk.StringVar()

        tk.Label(self, text="Article :").pack(pady=4)
        article_list = db.list_articles_names()
        self.articles_dict = {f"{r['name']} (id={r['id']})": r["id"] for r in article_list}
        self.articles_contenance = {f"{r['name']} (id={r['id']})": r["contenance"] for r in article_list}
        self.article_cb = ttk.Combobox(self, textvariable=self.article_var, state="readonly", width=28)
        self.article_cb["values"] = list(self.articles_dict.keys())
        self.article_cb.pack()

        tk.Label(self, text="Contenance :").pack(pady=4)
        self.contenance_display = tk.Entry(self, textvariable=self.contenance_display_var, width=14, state="readonly")
        self.contenance_display.pack()

        def update_contenance_display(*args):
            selected_article = self.article_var.get()
            contenance_val = self.articles_contenance.get(selected_article, "")
            self.contenance_display_var.set(contenance_val if contenance_val else "")
        self.article_var.trace_add("write", update_contenance_display)
        update_contenance_display()

        tk.Label(self, text="Date achat :").pack(pady=4)
        tk.Entry(self, textvariable=self.date_var).pack()
        tk.Label(self, text="QuantitÃ© :").pack(pady=4)
        tk.Entry(self, textvariable=self.qte_var).pack()
        tk.Label(self, text="Prix unitaire (â‚¬) :").pack(pady=4)
        tk.Entry(self, textvariable=self.pu_var).pack()
        tk.Label(self, text="Fournisseur :").pack(pady=4)
        tk.Entry(self, textvariable=self.fournisseur_var).pack()
        tk.Label(self, text="Facture nÂ° :").pack(pady=4)
        tk.Entry(self, textvariable=self.facture_var).pack()
        tk.Label(self, text="Exercice :").pack(pady=4)
        tk.Entry(self, textvariable=self.exercice_var).pack()

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=12)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if achat_id:
            self.load_achat()

    def load_achat(self):
        r = db.get_achat_by_id(self.achat_id)
        if r:
            article_key = None
            for k, v in self.articles_dict.items():
                if v == r["article_id"]:
                    article_key = k
                    break
            if article_key:
                self.article_var.set(article_key)
                self.contenance_display_var.set(self.articles_contenance.get(article_key, ""))
            self.date_var.set(r["date_achat"])
            self.qte_var.set(r["quantite"])
            self.pu_var.set(r["prix_unitaire"])
            self.fournisseur_var.set(r["fournisseur"])
            self.facture_var.set(r["facture"])
            self.exercice_var.set(r["exercice"])

    def save(self):
        article_key = self.article_var.get()
        if not article_key or article_key not in self.articles_dict:
            messagebox.showerror("Erreur", "Article obligatoire.")
            return
        article_id = self.articles_dict[article_key]
        champs = (
            article_id,
            self.date_var.get(),
            self.qte_var.get(),
            self.pu_var.get(),
            self.fournisseur_var.get(),
            self.facture_var.get(),
            self.exercice_var.get()
        )
        if self.achat_id:
            db.update_achat(self.achat_id, *champs)
        else:
            db.insert_achat(*champs)
        if self.on_save:
            self.on_save()
        self.destroy()

# -------- DIALOGUES MOUVEMENTS ----------
class MouvementDialog(tk.Toplevel):
    def __init__(self, master, on_done, mvt=None):
        super().__init__(master)
        self.title("Mouvement")
        self.on_done = on_done
        self.mvt = mvt

        self.article_var = tk.StringVar()
        self.date_var = tk.StringVar(value=mvt["date"] if mvt else "")
        self.type_var = tk.StringVar(value=mvt["type"] if mvt else "")
        self.quantite_var = tk.IntVar(value=mvt["quantite"] if mvt else 0)
        self.comment_var = tk.StringVar(value=mvt["commentaire"] if mvt else "")
        self.contenance_display_var = tk.StringVar()

        tk.Label(self, text="Article :").pack(pady=4)
        article_list = db.list_articles_names()
        self.articles_dict = {f"{r['name']} (id={r['id']})": r["id"] for r in article_list}
        self.articles_contenance = {f"{r['name']} (id={r['id']})": r["contenance"] for r in article_list}
        self.article_cb = ttk.Combobox(self, textvariable=self.article_var, state="readonly", width=28)
        self.article_cb["values"] = list(self.articles_dict.keys())
        self.article_cb.pack()

        tk.Label(self, text="Contenance :").pack(pady=4)
        self.contenance_display = tk.Entry(self, textvariable=self.contenance_display_var, width=14, state="readonly")
        self.contenance_display.pack()

        def update_contenance_display(*args):
            selected_article = self.article_var.get()
            contenance_val = self.articles_contenance.get(selected_article, "")
            self.contenance_display_var.set(contenance_val if contenance_val else "")
        self.article_var.trace_add("write", update_contenance_display)
        update_contenance_display()

        tk.Label(self, text="Date :").pack(pady=4)
        tk.Entry(self, textvariable=self.date_var).pack()
        tk.Label(self, text="Type (entrÃ©e/sortie) :").pack(pady=4)
        tk.Entry(self, textvariable=self.type_var).pack()
        tk.Label(self, text="QuantitÃ© :").pack(pady=4)
        tk.Entry(self, textvariable=self.quantite_var).pack()
        tk.Label(self, text="Commentaire :").pack(pady=4)
        tk.Entry(self, textvariable=self.comment_var).pack()

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=12)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if mvt:
            self.load_mvt()

    def load_mvt(self):
        if self.mvt:
            article_key = None
            for k, v in self.articles_dict.items():
                if v == self.mvt["article_id"]:
                    article_key = k
                    break
            if article_key:
                self.article_var.set(article_key)
                self.contenance_display_var.set(self.articles_contenance.get(article_key, ""))
            self.date_var.set(self.mvt["date"])
            self.type_var.set(self.mvt["type"])
            self.quantite_var.set(self.mvt["quantite"])
            self.comment_var.set(self.mvt["commentaire"])

    def save(self):
        article_key = self.article_var.get()
        if not article_key or article_key not in self.articles_dict:
            messagebox.showerror("Erreur", "Article obligatoire.")
            return
        article_id = self.articles_dict[article_key]
        date = self.date_var.get()
        type_mvt = self.type_var.get()
        quantite = self.quantite_var.get()
        comment = self.comment_var.get()
        if not date or not article_id or not type_mvt or not quantite:
            messagebox.showwarning("Saisie", "Tous les champs sont obligatoires.")
            return
        try:
            if self.mvt:
                db.update_mouvement(self.mvt["id"], date, article_id, type_mvt, quantite, comment)
            else:
                db.insert_mouvement(date, article_id, type_mvt, quantite, comment)
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de l'enregistrement du mouvement : {e}")

# -------- DIALOGUES INVENTAIRE LIGNES ----------
class LigneInventaireDialog(tk.Toplevel):
    def __init__(self, master, on_done, inventaire_id, ligne=None):
        super().__init__(master)
        self.title("Ligne inventaire")
        self.on_done = on_done
        self.inventaire_id = inventaire_id
        self.ligne = ligne

        self.article_var = tk.StringVar()
        self.quantite_var = tk.IntVar(value=ligne["quantite"] if ligne else 0)
        self.comment_var = tk.StringVar(value=ligne["commentaire"] if ligne else "")
        self.contenance_display_var = tk.StringVar()

        tk.Label(self, text="Article :").pack(pady=4)
        article_list = db.list_articles_names()
        self.articles_dict = {f"{r['name']} (id={r['id']})": r["id"] for r in article_list}
        self.articles_contenance = {f"{r['name']} (id={r['id']})": r["contenance"] for r in article_list}
        self.article_cb = ttk.Combobox(self, textvariable=self.article_var, state="readonly", width=28)
        self.article_cb["values"] = list(self.articles_dict.keys())
        self.article_cb.pack()

        tk.Label(self, text="Contenance :").pack(pady=4)
        self.contenance_display = tk.Entry(self, textvariable=self.contenance_display_var, width=14, state="readonly")
        self.contenance_display.pack()

        def update_contenance_display(*args):
            selected_article = self.article_var.get()
            contenance_val = self.articles_contenance.get(selected_article, "")
            self.contenance_display_var.set(contenance_val if contenance_val else "")
        self.article_var.trace_add("write", update_contenance_display)
        update_contenance_display()

        tk.Label(self, text="QuantitÃ© :").pack(pady=4)
        tk.Entry(self, textvariable=self.quantite_var).pack()
        tk.Label(self, text="Commentaire :").pack(pady=4)
        tk.Entry(self, textvariable=self.comment_var).pack()

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=12)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if ligne:
            self.load_ligne()

    def load_ligne(self):
        if self.ligne:
            article_key = None
            for k, v in self.articles_dict.items():
                if v == self.ligne["article_id"]:
                    article_key = k
                    break
            if article_key:
                self.article_var.set(article_key)
                self.contenance_display_var.set(self.articles_contenance.get(article_key, ""))
            self.quantite_var.set(self.ligne["quantite"])
            self.comment_var.set(self.ligne["commentaire"])

    def save(self):
        article_key = self.article_var.get()
        if not article_key or article_key not in self.articles_dict:
            messagebox.showerror("Erreur", "Article obligatoire.")
            return
        article_id = self.articles_dict[article_key]
        quantite = self.quantite_var.get()
        comment = self.comment_var.get()
        if not article_id:
            messagebox.showwarning("Saisie", "Article obligatoire.")
            return
        try:
            if self.ligne:
                db.update_ligne_inventaire(self.ligne["id"], article_id, quantite, comment)
            else:
                db.insert_ligne_inventaire(self.inventaire_id, article_id, quantite, comment)
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de l'enregistrement de la ligne d'inventaire : {e}")
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/buvette_inventaire_db.py ===

```python
"""
Module de gestion de la base de donnÃ©es pour les inventaires de la buvette.

STANDARDIZATION (PR copilot/audit-db-access-standardization):
- Improved connection management with try/finally blocks to reduce locks
- Converted sqlite3.Row to dicts for consistent .get() access patterns
- Added docstrings and error handling
"""

from db.db import get_connection
from utils.db_helpers import rows_to_dicts, row_to_dict
from utils.app_logger import get_logger
import sqlite3

logger = get_logger("buvette_inventaire_db")

def get_conn():
    conn = get_connection()
    return conn

# ----- INVENTAIRES -----
def list_inventaires():
    """List all inventaires with event info, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT i.*, e.name as event_name, e.date as event_date
            FROM buvette_inventaires i
            LEFT JOIN events e ON i.event_id = e.id
            ORDER BY date_inventaire DESC
        """).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_inventaire_by_id(inv_id):
    """Get inventaire by ID with event info, returns dict or None."""
    conn = None
    try:
        conn = get_conn()
        row = conn.execute("""
            SELECT i.*, e.name as event_name, e.date as event_date
            FROM buvette_inventaires i
            LEFT JOIN events e ON i.event_id = e.id
            WHERE i.id=?
        """, (inv_id,)).fetchone()
        return row_to_dict(row)
    finally:
        if conn:
            conn.close()

def insert_inventaire(date_inventaire, event_id, type_inventaire, commentaire):
    """Insert new inventaire, returns ID of created record."""
    conn = None
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("""
            INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
            VALUES (?, ?, ?, ?)
        """, (date_inventaire, event_id, type_inventaire, commentaire))
        inv_id = cur.lastrowid
        conn.commit()
        return inv_id
    finally:
        if conn:
            conn.close()

def update_inventaire(inv_id, date_inventaire, event_id, type_inventaire, commentaire):
    """Update existing inventaire."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_inventaires SET date_inventaire=?, event_id=?, type_inventaire=?, commentaire=?
            WHERE id=?
        """, (date_inventaire, event_id, type_inventaire, commentaire, inv_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_inventaire(inv_id):
    """Delete inventaire by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_inventaires WHERE id=?", (inv_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- LIGNES D'INVENTAIRE -----
def list_lignes_inventaire(inventaire_id):
    """List inventory lines for specific inventory with article names, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT l.*, a.name as article_name
            FROM buvette_inventaire_lignes l
            LEFT JOIN buvette_articles a ON l.article_id = a.id
            WHERE l.inventaire_id=?
            ORDER BY a.name
        """, (inventaire_id,)).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def insert_ligne_inventaire(inventaire_id, article_id, quantite, commentaire=None):
    """Insert new inventory line."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            INSERT INTO buvette_inventaire_lignes (inventaire_id, article_id, quantite, commentaire)
            VALUES (?, ?, ?, ?)
        """, (inventaire_id, article_id, quantite, commentaire))
        conn.commit()
    finally:
        if conn:
            conn.close()

def update_ligne_inventaire(ligne_id, article_id, quantite, commentaire=None):
    """Update existing inventory line."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_inventaire_lignes SET article_id=?, quantite=?, commentaire=?
            WHERE id=?
        """, (article_id, quantite, commentaire, ligne_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_ligne_inventaire(ligne_id):
    """Delete inventory line by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_inventaire_lignes WHERE id=?", (ligne_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

def upsert_ligne_inventaire(inventaire_id, article_id, quantite, commentaire=None):
    """Insert or update inventory line for article in inventory."""
    conn = None
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("""
            SELECT id FROM buvette_inventaire_lignes WHERE inventaire_id=? AND article_id=?
        """, (inventaire_id, article_id))
        row = cur.fetchone()
        if row:
            cur.execute("""
                UPDATE buvette_inventaire_lignes SET quantite=?, commentaire=?
                WHERE inventaire_id=? AND article_id=?
            """, (quantite, commentaire, inventaire_id, article_id))
        else:
            cur.execute("""
                INSERT INTO buvette_inventaire_lignes (inventaire_id, article_id, quantite, commentaire)
                VALUES (?, ?, ?, ?)
            """, (inventaire_id, article_id, quantite, commentaire))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- EVENEMENTS UTILITY -----
def list_events():
    """List events for dropdown, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("SELECT id, name FROM events ORDER BY date DESC").fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/buvette_inventaire_dialogs.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from datetime import date
import modules.buvette_inventaire_db as db
import modules.buvette_db as buvette_db
from utils.app_logger import get_logger
from modules.db_row_utils import _row_to_dict, _rows_to_dicts
from utils.db_helpers import rows_to_dicts
from modules.inventory_lines_dialog import load_inventory_lines

logger = get_logger("buvette_inventaire_dialogs")

class InventaireDialog(tk.Toplevel):
    """Dialog for creating/editing buvette inventory with dynamic article lines."""
    
    def __init__(self, master, on_save=None, inventaire_id=None):
        super().__init__(master)
        self.title("Inventaire Buvette")
        self.geometry("900x700")
        self.on_save = on_save
        
        # Handle both inventaire_id (int) and inventaire (dict) for backward compatibility
        if inventaire_id is not None:
            if isinstance(inventaire_id, dict):
                # If a dict is passed, extract the id
                self.inventaire_id = inventaire_id.get("id")
            else:
                # It's an int
                self.inventaire_id = inventaire_id
        else:
            self.inventaire_id = None
        
        # Variables for header fields
        self.date_var = tk.StringVar(value=str(date.today()))
        self.type_var = tk.StringVar()
        self.evt_var = tk.StringVar()
        self.comment_var = tk.StringVar()
        
        # Create UI
        self._create_header_section()
        self._create_lines_section()
        self._create_button_section()
        
        # Load data if editing
        if self.inventaire_id:
            self._load_inventaire()
    
    def _create_header_section(self):
        """Create the header section with date, type, event, and comment fields."""
        frm = tk.Frame(self)
        frm.pack(padx=16, pady=8, fill=tk.X)
        
        # Row 0: Date and Type
        tk.Label(frm, text="Date :").grid(row=0, column=0, sticky="e", padx=(0, 5))
        tk.Entry(frm, textvariable=self.date_var, width=15).grid(row=0, column=1, sticky="w")
        
        tk.Label(frm, text="Type :").grid(row=0, column=2, sticky="e", padx=(20, 5))
        type_combo = ttk.Combobox(
            frm, 
            textvariable=self.type_var, 
            values=["avant", "apres", "hors_evenement"],
            width=16,
            state="readonly"
        )
        type_combo.grid(row=0, column=3, sticky="w")
        
        # Row 1: Event
        tk.Label(frm, text="Ã‰vÃ©nement :").grid(row=1, column=0, sticky="e", padx=(0, 5), pady=(5, 0))
        self.evt_cb = ttk.Combobox(frm, textvariable=self.evt_var, width=40, state="readonly")
        try:
            events = db.list_events()
            # Convert Row objects to dicts for safe access
            events = _rows_to_dicts(events)
            self.evt_cb["values"] = [""] + [f"{r['id']} - {r['name']}" for r in events]
        except Exception as e:
            logger.warning(f"Could not load events: {e}")
            self.evt_cb["values"] = [""]
        self.evt_cb.grid(row=1, column=1, columnspan=3, sticky="w", pady=(5, 0))
        
        # Row 2: Comment
        tk.Label(frm, text="Commentaire :").grid(row=2, column=0, sticky="e", padx=(0, 5), pady=(5, 0))
        tk.Entry(frm, textvariable=self.comment_var, width=60).grid(
            row=2, column=1, columnspan=3, sticky="ew", pady=(5, 0)
        )
    
    def _create_lines_section(self):
        """Create the lines section with Treeview and add/remove buttons."""
        frame = tk.Frame(self)
        frame.pack(padx=16, pady=10, fill=tk.BOTH, expand=True)
        
        tk.Label(frame, text="Articles inventoriÃ©s", font=("Arial", 10, "bold")).pack(anchor="w")
        
        # Treeview for article lines
        tree_frame = tk.Frame(frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, pady=(5, 0))
        
        scrollbar = ttk.Scrollbar(tree_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Columns: article_id (hidden), name, categorie, contenance, quantite
        self.lines_tree = ttk.Treeview(
            tree_frame,
            columns=("article_id", "name", "categorie", "contenance", "quantite"),
            show="headings",
            displaycolumns=("name", "categorie", "contenance", "quantite"),  # Hide article_id
            yscrollcommand=scrollbar.set
        )
        scrollbar.config(command=self.lines_tree.yview)
        
        # Configure columns
        self.lines_tree.column("article_id", width=50)  # Hidden via displaycolumns
        self.lines_tree.column("name", width=200, anchor="w")
        self.lines_tree.column("categorie", width=150, anchor="w")
        self.lines_tree.column("contenance", width=100, anchor="w")
        self.lines_tree.column("quantite", width=100, anchor="center")
        
        # Set headings (article_id won't be shown due to displaycolumns)
        self.lines_tree.heading("article_id", text="ID")
        self.lines_tree.heading("name", text="Article")
        self.lines_tree.heading("categorie", text="CatÃ©gorie")
        self.lines_tree.heading("contenance", text="Contenance")
        self.lines_tree.heading("quantite", text="QuantitÃ©")
        
        self.lines_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Buttons for add/remove
        btn_frame = tk.Frame(frame)
        btn_frame.pack(fill=tk.X, pady=(5, 0))
        tk.Button(btn_frame, text="Ajouter ligne", command=self._add_line).pack(side=tk.LEFT, padx=5)
        tk.Button(btn_frame, text="Supprimer ligne", command=self._remove_line).pack(side=tk.LEFT, padx=5)
    
    def _create_button_section(self):
        """Create the bottom button section."""
        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=16)
        tk.Button(btn_frame, text="Enregistrer", command=self._save, width=12).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Annuler", command=self.destroy, width=12).pack(side=tk.LEFT, padx=10)
    
    def _add_line(self):
        """Open dialog to add a new line."""
        AddLineDialog(self, self._refresh_after_line_add)
    
    def _refresh_after_line_add(self, article_id, article_name, categorie, contenance, quantite):
        """Callback after adding a line."""
        # Check if article already exists in tree
        for item in self.lines_tree.get_children():
            values = self.lines_tree.item(item)["values"]
            if values[0] == article_id:
                # Update existing line
                self.lines_tree.item(item, values=(article_id, article_name, categorie, contenance, quantite))
                return
        
        # Add new line
        self.lines_tree.insert("", "end", values=(article_id, article_name, categorie, contenance, quantite))
    
    def _remove_line(self):
        """Remove selected line from tree."""
        selected = self.lines_tree.selection()
        if not selected:
            messagebox.showwarning("SÃ©lection", "Veuillez sÃ©lectionner une ligne Ã  supprimer.")
            return
        
        if messagebox.askyesno("Confirmation", "Supprimer cette ligne ?"):
            for item in selected:
                self.lines_tree.delete(item)
    
    def _load_inventaire(self):
        """Load existing inventory data."""
        try:
            inv = db.get_inventaire_by_id(self.inventaire_id)
            if not inv:
                messagebox.showerror("Erreur", "Inventaire introuvable.")
                self.destroy()
                return
            
            # Convert Row to dict for safe .get() access
            inv = _row_to_dict(inv)
            
            # Load header data
            self.date_var.set(inv["date_inventaire"] or "")
            self.type_var.set(inv["type_inventaire"] or "")
            self.comment_var.set(inv["commentaire"] or "")
            if inv.get("event_id"):
                self.evt_var.set(f"{inv['event_id']} - {inv.get('event_name', '')}")
            
            # Load lines using robust helper function with error reporting
            try:
                # Use load_inventory_lines which converts Rows to dicts and handles errors
                lignes = load_inventory_lines(self.inventaire_id)
                
                for ligne in lignes:
                    # Now ligne is a dict, safe to use .get()
                    article_id = ligne.get("article_id")
                    quantite = ligne.get("quantite", 0)
                    
                    if not article_id:
                        logger.warning(f"Skipping line with missing article_id: {ligne}")
                        continue
                    
                    # Get article details
                    try:
                        article = buvette_db.get_article_by_id(article_id)
                        if article:
                            # Convert Row to dict for safe .get() access
                            article = _row_to_dict(article)
                            self.lines_tree.insert("", "end", values=(
                                article_id,
                                article.get("name", ""),
                                article.get("categorie", ""),
                                article.get("contenance", ""),
                                quantite
                            ))
                    except Exception as e:
                        logger.warning(f"Could not load article {article_id}: {e}")
                        # Add line with minimal info
                        self.lines_tree.insert("", "end", values=(
                            article_id, f"Article #{article_id}", "", "", quantite
                        ))
            except Exception as e:
                # Error already logged and reported by load_inventory_lines
                logger.error(f"Failed to load inventory lines: {e}")
                messagebox.showerror(
                    "Erreur", 
                    f"Impossible de charger les lignes d'inventaire.\n"
                    f"Un rapport d'erreur dÃ©taillÃ© a Ã©tÃ© gÃ©nÃ©rÃ© dans reports/\n\n"
                    f"Erreur: {e}"
                )
        
        except Exception as e:
            logger.error(f"Error loading inventory: {e}")
            messagebox.showerror("Erreur", f"Erreur lors du chargement : {e}")
            self.destroy()
    
    def _save(self):
        """Save inventory and lines."""
        # Validate required fields
        type_inv = self.type_var.get()
        if not type_inv:
            messagebox.showerror("Erreur", "Le type d'inventaire est obligatoire.")
            return
        
        if type_inv not in ["avant", "apres", "hors_evenement"]:
            messagebox.showerror("Erreur", "Type d'inventaire invalide.")
            return
        
        date_inv = self.date_var.get()
        if not date_inv:
            messagebox.showerror("Erreur", "La date est obligatoire.")
            return
        
        commentaire = self.comment_var.get()
        evt = self.evt_var.get()
        event_id = None
        if evt and " - " in evt:
            try:
                event_id = int(evt.split(" - ")[0])
            except ValueError:
                pass
        
        try:
            # Insert or update inventory
            if self.inventaire_id:
                db.update_inventaire(self.inventaire_id, date_inv, event_id, type_inv, commentaire)
                inv_id = self.inventaire_id
            else:
                inv_id = db.insert_inventaire(date_inv, event_id, type_inv, commentaire)
            
            # Save lines
            for item in self.lines_tree.get_children():
                values = self.lines_tree.item(item)["values"]
                article_id = values[0]
                quantite = values[4]
                
                # Upsert line
                db.upsert_ligne_inventaire(inv_id, article_id, quantite)
            
            # Update article stock if quantite field exists
            self._update_article_stock()
            
            messagebox.showinfo("SuccÃ¨s", "Inventaire enregistrÃ© avec succÃ¨s.")
            
            if self.on_save:
                self.on_save()
            
            self.destroy()
        
        except Exception as e:
            logger.error(f"Error saving inventory: {e}")
            messagebox.showerror("Erreur", f"Erreur lors de l'enregistrement : {e}")
    
    def _update_article_stock(self):
        """Update article stock based on inventory quantities (if quantite field exists)."""
        try:
            # Check if buvette_articles has a quantite field
            conn = db.get_conn()
            cursor = conn.cursor()
            cursor.execute("PRAGMA table_info(buvette_articles)")
            columns = [col[1] for col in cursor.fetchall()]
            
            if "quantite" not in columns:
                logger.info("buvette_articles table does not have quantite field, skipping stock update")
                conn.close()
                return
            
            # Update stock for each line
            for item in self.lines_tree.get_children():
                values = self.lines_tree.item(item)["values"]
                article_id = values[0]
                quantite = values[4]
                
                cursor.execute(
                    "UPDATE buvette_articles SET quantite=? WHERE id=?",
                    (quantite, article_id)
                )
            
            conn.commit()
            conn.close()
            logger.info("Article stock updated successfully")
        
        except Exception as e:
            logger.warning(f"Could not update article stock: {e}")


class AddLineDialog(tk.Toplevel):
    """Dialog for adding a line to inventory."""
    
    def __init__(self, master, callback):
        super().__init__(master)
        self.title("Ajouter une ligne")
        self.geometry("500x250")
        self.callback = callback
        
        # Variables
        self.article_var = tk.StringVar()
        self.quantite_var = tk.IntVar(value=0)
        self.create_new_var = tk.BooleanVar(value=False)
        
        # New article fields
        self.new_name_var = tk.StringVar()
        self.new_categorie_var = tk.StringVar()
        self.new_contenance_var = tk.StringVar()
        
        self._create_widgets()
        self._toggle_fields()
    
    def _create_widgets(self):
        """Create dialog widgets."""
        frame = tk.Frame(self, padx=16, pady=16)
        frame.pack(fill=tk.BOTH, expand=True)
        
        # Checkbox to create new article
        tk.Checkbutton(
            frame,
            text="CrÃ©er un nouvel article",
            variable=self.create_new_var,
            command=self._toggle_fields
        ).grid(row=0, column=0, columnspan=2, sticky="w", pady=(0, 10))
        
        # Select existing article
        self.select_label = tk.Label(frame, text="Article :")
        self.select_label.grid(row=1, column=0, sticky="e", padx=(0, 5))
        
        self.article_combo = ttk.Combobox(frame, textvariable=self.article_var, width=40, state="readonly")
        try:
            articles = buvette_db.list_articles()
            # Convert Rows to dicts for safe .get() access
            articles = rows_to_dicts(articles)
            self.article_combo["values"] = [
                f"{a['id']} - {a['name']} ({a.get('contenance', '')})" for a in articles
            ]
        except Exception as e:
            logger.warning(f"Could not load articles: {e}")
            self.article_combo["values"] = []
        self.article_combo.grid(row=1, column=1, sticky="w")
        
        # New article fields
        self.name_label = tk.Label(frame, text="Nom :")
        self.name_label.grid(row=2, column=0, sticky="e", padx=(0, 5), pady=(5, 0))
        self.name_entry = tk.Entry(frame, textvariable=self.new_name_var, width=40)
        self.name_entry.grid(row=2, column=1, sticky="w", pady=(5, 0))
        
        self.categorie_label = tk.Label(frame, text="CatÃ©gorie :")
        self.categorie_label.grid(row=3, column=0, sticky="e", padx=(0, 5), pady=(5, 0))
        self.categorie_entry = tk.Entry(frame, textvariable=self.new_categorie_var, width=40)
        self.categorie_entry.grid(row=3, column=1, sticky="w", pady=(5, 0))
        
        self.contenance_label = tk.Label(frame, text="Contenance :")
        self.contenance_label.grid(row=4, column=0, sticky="e", padx=(0, 5), pady=(5, 0))
        self.contenance_entry = tk.Entry(frame, textvariable=self.new_contenance_var, width=40)
        self.contenance_entry.grid(row=4, column=1, sticky="w", pady=(5, 0))
        
        # Quantity
        tk.Label(frame, text="QuantitÃ© :").grid(row=5, column=0, sticky="e", padx=(0, 5), pady=(10, 0))
        tk.Entry(frame, textvariable=self.quantite_var, width=15).grid(row=5, column=1, sticky="w", pady=(10, 0))
        
        # Buttons
        btn_frame = tk.Frame(frame)
        btn_frame.grid(row=6, column=0, columnspan=2, pady=(20, 0))
        tk.Button(btn_frame, text="Ajouter", command=self._add, width=12).pack(side=tk.LEFT, padx=5)
        tk.Button(btn_frame, text="Annuler", command=self.destroy, width=12).pack(side=tk.LEFT, padx=5)
    
    def _toggle_fields(self):
        """Toggle between existing article selection and new article creation."""
        if self.create_new_var.get():
            # Show new article fields
            self.select_label.config(state="disabled")
            self.article_combo.config(state="disabled")
            self.name_label.config(state="normal")
            self.name_entry.config(state="normal")
            self.categorie_label.config(state="normal")
            self.categorie_entry.config(state="normal")
            self.contenance_label.config(state="normal")
            self.contenance_entry.config(state="normal")
        else:
            # Show existing article selection
            self.select_label.config(state="normal")
            self.article_combo.config(state="readonly")
            self.name_label.config(state="disabled")
            self.name_entry.config(state="disabled")
            self.categorie_label.config(state="disabled")
            self.categorie_entry.config(state="disabled")
            self.contenance_label.config(state="disabled")
            self.contenance_entry.config(state="disabled")
    
    def _add(self):
        """Add the line."""
        quantite = self.quantite_var.get()
        
        try:
            if self.create_new_var.get():
                # Create new article
                name = self.new_name_var.get().strip()
                if not name:
                    messagebox.showerror("Erreur", "Le nom de l'article est obligatoire.")
                    return
                
                categorie = self.new_categorie_var.get().strip()
                contenance = self.new_contenance_var.get().strip()
                
                # Insert new article using existing function
                try:
                    buvette_db.insert_article(
                        name=name, 
                        categorie=categorie, 
                        unite="", 
                        commentaire="", 
                        contenance=contenance
                    )
                    # Get the newly created article's ID
                    articles = buvette_db.list_articles()
                    article = next((a for a in articles if a["name"] == name), None)
                    if not article:
                        messagebox.showerror("Erreur", "Article crÃ©Ã© mais introuvable.")
                        return
                    article_id = article["id"]
                except Exception as e:
                    logger.error(f"Error creating article: {e}")
                    messagebox.showerror("Erreur", f"Erreur lors de la crÃ©ation de l'article : {e}")
                    return
            else:
                # Use existing article
                article_str = self.article_var.get()
                if not article_str:
                    messagebox.showerror("Erreur", "Veuillez sÃ©lectionner un article.")
                    return
                
                article_id = int(article_str.split(" - ")[0])
                article = buvette_db.get_article_by_id(article_id)
                if not article:
                    messagebox.showerror("Erreur", "Article introuvable.")
                    return
                
                # Convert Row to dict for safe .get() access
                article = _row_to_dict(article)
                name = article["name"]
                categorie = article.get("categorie", "")
                contenance = article.get("contenance", "")
            
            # Call callback with article data
            self.callback(article_id, name, categorie, contenance, quantite)
            self.destroy()
        
        except Exception as e:
            logger.error(f"Error adding line: {e}")
            messagebox.showerror("Erreur", f"Erreur : {e}")
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/buvette_mouvements_db.py ===

```python
"""
Module de gestion de la base de donnÃ©es pour les mouvements de stock de la buvette.

STANDARDIZATION (PR copilot/audit-db-access-standardization):
- Improved connection management with try/finally blocks to reduce locks
- Converted sqlite3.Row to dicts for consistent .get() access patterns
- Added docstrings and error handling
"""

from db.db import get_connection
from utils.db_helpers import rows_to_dicts, row_to_dict
from utils.app_logger import get_logger
import sqlite3

logger = get_logger("buvette_mouvements_db")

def get_conn():
    conn = get_connection()
    return conn

# ----- MOUVEMENTS -----
def list_mouvements():
    """List all mouvements with article and event info, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT m.*, a.name AS article_name, e.name AS event_name, e.date AS event_date
            FROM buvette_mouvements m
            LEFT JOIN buvette_articles a ON m.article_id = a.id
            LEFT JOIN events e ON m.event_id = e.id
            ORDER BY m.date_mouvement DESC
        """).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_mouvement_by_id(mvt_id):
    """Get mouvement by ID with article and event info, returns dict or None."""
    conn = None
    try:
        conn = get_conn()
        row = conn.execute("""
            SELECT m.*, a.name AS article_name, e.name AS event_name, e.date AS event_date
            FROM buvette_mouvements m
            LEFT JOIN buvette_articles a ON m.article_id = a.id
            LEFT JOIN events e ON m.event_id = e.id
            WHERE m.id=?
        """, (mvt_id,)).fetchone()
        return row_to_dict(row)
    finally:
        if conn:
            conn.close()

def insert_mouvement(article_id, date_mouvement, type_mouvement, quantite, motif, event_id):
    """Insert new mouvement."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            INSERT INTO buvette_mouvements (article_id, date_mouvement, type_mouvement, quantite, motif, event_id)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (article_id, date_mouvement, type_mouvement, quantite, motif, event_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def update_mouvement(mvt_id, article_id, date_mouvement, type_mouvement, quantite, motif, event_id):
    """Update existing mouvement."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_mouvements SET article_id=?, date_mouvement=?, type_mouvement=?, quantite=?, motif=?, event_id=?
            WHERE id=?
        """, (article_id, date_mouvement, type_mouvement, quantite, motif, event_id, mvt_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_mouvement(mvt_id):
    """Delete mouvement by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_mouvements WHERE id=?", (mvt_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- UTILITY -----
def list_articles():
    """List articles for dropdown, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("SELECT id, name FROM buvette_articles ORDER BY name").fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def list_events():
    """List events for dropdown, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("SELECT id, name FROM events ORDER BY date DESC").fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/buvette_mouvements_dialogs.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from datetime import date
import modules.buvette_mouvements_db as db
from modules.db_row_utils import _rows_to_dicts

class MouvementDialog(tk.Toplevel):
    def __init__(self, master, mouvement_id=None, on_save=None):
        super().__init__(master)
        self.title("Mouvement de stock buvette")
        self.geometry("400x420")
        self.on_save = on_save
        self.mouvement_id = mouvement_id

        self.article_var = tk.StringVar()
        self.date_var = tk.StringVar(value=str(date.today()))
        self.type_var = tk.StringVar()
        self.qte_var = tk.IntVar()
        self.motif_var = tk.StringVar()
        self.evt_var = tk.StringVar()

        tk.Label(self, text="Article :").pack(pady=4)
        self.article_cb = ttk.Combobox(self, textvariable=self.article_var, state="readonly", width=28)
        self.articles_dict = {str(r["name"]): r["id"] for r in db.list_articles()}
        self.article_cb["values"] = list(self.articles_dict.keys())
        self.article_cb.pack()

        tk.Label(self, text="Date :").pack(pady=4)
        tk.Entry(self, textvariable=self.date_var).pack()
        tk.Label(self, text="Type mouvement :").pack(pady=4)
        self.type_cb = ttk.Combobox(self, textvariable=self.type_var, state="readonly", width=18)
        self.type_cb["values"] = [
            "casse", "consommation_reunion", "don", "peremption", "autre"
        ]
        self.type_cb.pack()
        tk.Label(self, text="QuantitÃ© :").pack(pady=4)
        tk.Entry(self, textvariable=self.qte_var).pack()
        tk.Label(self, text="Motif / commentaire :").pack(pady=4)
        tk.Entry(self, textvariable=self.motif_var).pack()
        tk.Label(self, text="Ã‰vÃ©nement (optionnel) :").pack(pady=4)
        self.evt_cb = ttk.Combobox(self, textvariable=self.evt_var, width=28, state="readonly")
        self.evt_dict = {"": None}
        # Convert Row objects to dicts for safe access
        events = _rows_to_dicts(db.list_events())
        for r in events:
            label = f"{r['id']} - {r['name']}"
            self.evt_dict[label] = r["id"]
        self.evt_cb["values"] = list(self.evt_dict.keys())
        self.evt_cb.pack()

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=14)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=12)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=12)

        if mouvement_id:
            self.load_mouvement()

    def load_mouvement(self):
        mvt = db.get_mouvement_by_id(self.mouvement_id)
        if mvt:
            self.article_var.set(self._find_name_by_id(self.articles_dict, mvt["article_id"]))
            self.date_var.set(mvt["date_mouvement"])
            self.type_var.set(mvt["type_mouvement"])
            self.qte_var.set(mvt["quantite"])
            self.motif_var.set(mvt["motif"])
            self.evt_var.set(self._find_name_by_id(self.evt_dict, mvt["event_id"]))

    def _find_name_by_id(self, d, val):
        for k, v in d.items():
            if v == val:
                return k
        return ""

    def save(self):
        nom_article = self.article_var.get()
        if not nom_article or nom_article not in self.articles_dict:
            messagebox.showerror("Erreur", "Article obligatoire.")
            return
        article_id = self.articles_dict[nom_article]
        date_mvt = self.date_var.get()
        type_mvt = self.type_var.get()
        quantite = self.qte_var.get()
        motif = self.motif_var.get()
        evt_label = self.evt_var.get()
        event_id = self.evt_dict.get(evt_label, None)
        if self.mouvement_id:
            db.update_mouvement(self.mouvement_id, article_id, date_mvt, type_mvt, quantite, motif, event_id)
        else:
            db.insert_mouvement(article_id, date_mvt, type_mvt, quantite, motif, event_id)
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/categories.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
import pandas as pd
from db.db import get_connection
from utils.validation import is_required

class CategoriesModule:
    def __init__(self, master):
        self.master = master
        self.top = tk.Toplevel(master)
        self.top.title("Gestion des CatÃ©gories")
        self.top.geometry("700x400")
        self.create_table()
        self.create_buttons()
        self.refresh_categories()

    def create_table(self):
        style = ttk.Style()
        style.theme_use("default")
        style.configure("Treeview.Heading", font=('Arial', 11, 'bold'))
        style.configure("Treeview", font=('Consolas', 11), rowheight=24)
        style.configure("oddrow", background="#F2F2F2")
        style.configure("evenrow", background="#FFFFFF")

        self.tree = ttk.Treeview(
            self.top, columns=("id", "name", "parent"), show="headings", selectmode="browse"
        )
        self.tree.heading("id", text="ID")
        self.tree.heading("name", text="Name")
        self.tree.heading("parent", text="CatÃ©gorie parente")
        self.tree.column("id", width=40, anchor="center")
        self.tree.column("name", width=180)
        self.tree.column("parent", width=180)
        self.tree.pack(fill=tk.BOTH, expand=True)
        vsb = ttk.Scrollbar(self.top, orient="vertical", command=self.tree.yview)
        vsb.pack(side='right', fill='y')
        self.tree.configure(yscroll=vsb.set)

    def refresh_categories(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        df = pd.read_sql_query("""
            SELECT c.id, c.name, p.name as parent
            FROM categories c
            LEFT JOIN categories p ON c.parent_id = p.id
            ORDER BY COALESCE(p.name, c.name), c.name
        """, conn)
        self.df = df
        for idx, (_, row) in enumerate(df.iterrows()):
            tag = "evenrow" if idx % 2 == 0 else "oddrow"
            self.tree.insert("", "end", values=(
                row['id'], row['name'], row['parent'] if pd.notnull(row['parent']) else ""
            ), tags=(tag,))

    def create_buttons(self):
        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=8)
        tk.Button(btn_frame, text="Ajouter", command=self.add_category).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Modifier", command=self.edit_category).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_category).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=10)

    def add_category(self):
        data = self.category_form()
        if not data:
            return
        if not is_required(data['name']):
            messagebox.showerror("Erreur", "Le name est obligatoire.")
            return
        conn = get_connection()
        cur = conn.cursor()
        cur.execute("INSERT INTO categories (name, parent_id) VALUES (?, ?)", (data['name'], data['parent_id']))
        conn.commit()
        self.refresh_categories()

    def edit_category(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une catÃ©gorie Ã  modifier.")
            return
        item = self.tree.item(selected[0])
        cat_id = item['values'][0]
        row = self.df[self.df['id'] == cat_id].iloc[0]
        data = self.category_form(row)
        if not data:
            return
        if not is_required(data['name']):
            messagebox.showerror("Erreur", "Le name est obligatoire.")
            return
        conn = get_connection()
        cur = conn.cursor()
        cur.execute(
            "UPDATE categories SET name=?, parent_id=? WHERE id=?",
            (data['name'], data['parent_id'], cat_id)
        )
        conn.commit()
        self.refresh_categories()

    def delete_category(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une catÃ©gorie Ã  supprimer.")
            return
        item = self.tree.item(selected[0])
        cat_id = item['values'][0]
        name = item['values'][1]
        # VÃ©rifier si cette catÃ©gorie a des enfants ou des buvette_articles liÃ©s
        conn = get_connection()
        cur = conn.cursor()
        cur.execute("SELECT COUNT(*) FROM categories WHERE parent_id=?", (cat_id,))
        nb_children = cur.fetchone()[0]
        cur.execute("SELECT COUNT(*) FROM stock WHERE categorie_id=?", (cat_id,))
        nb_stock = cur.fetchone()[0]
        if nb_children > 0:
            messagebox.showerror("Erreur", "Impossible de supprimer une catÃ©gorie qui a des sous-catÃ©gories.")
            return
        if nb_stock > 0:
            messagebox.showerror("Erreur", "Impossible de supprimer une catÃ©gorie liÃ©e Ã  des buvette_articles en stock.")
            return
        if messagebox.askyesno("Confirmation", f"Supprimer la catÃ©gorie '{name}' ?"):
            cur.execute("DELETE FROM categories WHERE id=?", (cat_id,))
            conn.commit()
            self.refresh_categories()

    def category_form(self, row=None):
        form = tk.Toplevel(self.top)
        form.title("Saisie CatÃ©gorie")
        conn = get_connection()
        df_cat = pd.read_sql_query("SELECT id, name FROM categories WHERE parent_id IS NULL", conn)
        # PrÃ©remplissage
        values = [
            row['name'] if row is not None else "",
            row['parent'] if row is not None else "",  # CatÃ©gorie parente
        ]
        tk.Label(form, text="Name").grid(row=0, column=0, sticky="w", pady=3, padx=5)
        nom_entry = tk.Entry(form, width=30)
        nom_entry.grid(row=0, column=1, pady=3, padx=5)
        nom_entry.insert(0, values[0])

        tk.Label(form, text="CatÃ©gorie parente (optionnel)").grid(row=1, column=0, sticky="w", pady=3, padx=5)
        parent_var = tk.StringVar()
        parent_cb = ttk.Combobox(form, textvariable=parent_var, values=list(df_cat['name']), state="readonly", width=27)
        parent_cb.grid(row=1, column=1, pady=3, padx=5)
        if values[1] and values[1] in df_cat['name'].values:
            parent_cb.set(values[1])
        else:
            parent_cb.set("")

        result = {}
        def validate():
            result['name'] = nom_entry.get().strip()
            parent_nom = parent_var.get().strip()
            if not result['name']:
                messagebox.showerror("Erreur", "Le name est obligatoire.")
                return
            if parent_nom:
                parent_row = df_cat[df_cat['name'] == parent_nom]
                if not parent_row.empty:
                    result['parent_id'] = int(parent_row.iloc[0]['id'])
                else:
                    result['parent_id'] = None
            else:
                result['parent_id'] = None
            form.destroy()
        tk.Button(form, text="Valider", command=validate).grid(row=2, column=0, pady=10)
        tk.Button(form, text="Annuler", command=lambda: form.destroy()).grid(row=2, column=1, pady=10)
        form.grab_set()
        form.wait_window()
        if result:
            return result
        else:
            return None
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/cloture_exercice.py ===

```python
import tkinter as tk
from tkinter import messagebox, filedialog
import zipfile
import os
import pandas as pd

from db.db import get_connection
from exports.exports import (
    export_bilan_reporte_pdf,
    export_bilan_argumente_pdf,
    export_bilan_argumente_word
)
from dialogs.cloture_confirm_dialog import ClotureConfirmDialog

class ClotureExerciceModule:
    def __init__(self, master, visualisation_mode=False):
        self.master = master
        self.visualisation_mode = visualisation_mode
        self.top = tk.Toplevel(master)
        self.top.title("ClÃ´ture de l'exercice")
        self.top.geometry("520x420")
        self.create_widgets()

    def create_widgets(self):
        row = 0
        tk.Label(self.top, text="ClÃ´ture d'exercice annuel", font=("Arial", 15, "bold")).grid(row=row, column=0, columnspan=2, pady=14)
        row += 1
        tk.Label(self.top, text="â€¢ Cette opÃ©ration va :\n"
                               "- Exporter toutes les tables de la base sous forme CSV\n"
                               "- GÃ©nÃ©rer une archive ZIP pour archivage ou visualisation\n"
                               "- Permettre l'Ã©dition d'un bilan PDF rÃ©digÃ©\n"
                               "- Permettre l'Ã©dition d'un bilan FIN D'EXERCICE argumentÃ© PDF ou Word\n"
                               "- (Optionnel) RÃ©initialiser les donnÃ©es pour le nouvel exercice\n\n"
                               "âš ï¸ Cette opÃ©ration est IRRÃ‰VERSIBLE", fg="red").grid(row=row, column=0, columnspan=2, pady=8)
        row += 1
        tk.Button(self.top, text="Exporter l'exercice en ZIP", command=self.export_zip, width=36).grid(row=row, column=0, columnspan=2, pady=18)
        row += 1
        tk.Button(self.top, text="Exporter le bilan PDF rÃ©digÃ©", command=self.export_bilan_pdf, width=36).grid(row=row, column=0, columnspan=2, pady=10)
        row += 1
        tk.Button(self.top, text="Exporter le bilan FIN D'EXERCICE (argumentÃ© PDF)", command=export_bilan_argumente_pdf, width=36).grid(row=row, column=0, columnspan=2, pady=10)
        row += 1
        tk.Button(self.top, text="Exporter le bilan FIN D'EXERCICE (argumentÃ© Word)", command=export_bilan_argumente_word, width=36).grid(row=row, column=0, columnspan=2, pady=10)
        row += 1
        tk.Button(self.top, text="RÃ©initialiser la base de donnÃ©es", command=self.cloture_confirm, width=36, fg="red").grid(row=row, column=0, columnspan=2, pady=14)
        row += 1
        tk.Button(self.top, text="Fermer", command=self.top.destroy, width=16).grid(row=row, column=1, pady=6, sticky="e")


    def export_zip(self):
        tables = [
            "events", "event_modules", "event_module_fields", "event_module_data",
            "members", "dons_subventions", "depenses_regulieres", "depenses_diverses",
            "journal", "categories", "stock"
        ]
        file_path = filedialog.asksaveasfilename(
            title="Enregistrer l'exercice (ZIP)",
            defaultextension=".zip",
            filetypes=[("Archive ZIP", "*.zip")]
        )
        if not file_path:
            return
        tmp_dir = "tmp_cloture_export"
        os.makedirs(tmp_dir, exist_ok=True)
        conn = get_connection()
        for tab in tables:
            df = pd.read_sql_query(f"SELECT * FROM {tab}", conn)
            df.to_csv(os.path.join(tmp_dir, f"{tab}.csv"), index=False, encoding="utf-8")
        conn.close()
        with zipfile.ZipFile(file_path, "w", zipfile.ZIP_DEFLATED) as zf:
            for tab in tables:
                zf.write(os.path.join(tmp_dir, f"{tab}.csv"), arcname=f"{tab}.csv")
        # Clean temp
        for tab in tables:
            try:
                os.remove(os.path.join(tmp_dir, f"{tab}.csv"))
            except Exception:
                pass
        try:
            os.rmdir(tmp_dir)
        except Exception:
            pass
        messagebox.showinfo("ClÃ´ture", f"Archive exportÃ©e :\n{file_path}")

    def export_bilan_pdf(self):
        # Tu peux adapter ici pour rassembler les synthÃ¨ses nÃ©cessaires
        # Par exemple, synthÃ¨se Ã©vÃ©nements, dÃ©penses, dons...
        # Ici, on mocke des DataFrames pour la dÃ©monstration
        synth_evt = pd.DataFrame([
            {"evenement": "MarchÃ© de NoÃ«l", "recettes": 1200, "depenses": 400, "solde": 800},
            {"evenement": "Vente de gÃ¢teaux", "recettes": 450, "depenses": 100, "solde": 350}
        ])
        synth_dep = pd.DataFrame([
            {"origine": "MarchÃ© de NoÃ«l", "categorie": "Fournitures", "total": 300},
            {"origine": "Vente de gÃ¢teaux", "categorie": "IngrÃ©dients", "total": 100}
        ])
        recap = {"synth_evt": synth_evt, "synth_dep": synth_dep}
        exercice = "2023-2024"
        date = "2023-09-01"
        date_fin = "2024-08-31"
        export_bilan_reporte_pdf(recap, self.top, exercice, date, date_fin)

    def cloture_confirm(self):
        ClotureConfirmDialog(self.top)
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/db_api.py ===

```python
"""
Central Database API Module

Provides centralized database connection management with:
- WAL mode for better concurrency
- Busy timeout to reduce lock errors
- Query helper functions (query_one, query_all)
- Transaction context manager

This module is the recommended way to interact with the database
across the application, ensuring consistent connection configuration
and error handling.
"""

import sqlite3
import time
from typing import Optional, List, Dict, Any, Callable, Tuple
from contextlib import contextmanager
from db.db import get_db_file
from utils.app_logger import get_logger
from modules.db_row_utils import _row_to_dict, _rows_to_dicts

logger = get_logger("db_api")


def get_connection(row_factory: Optional[Any] = sqlite3.Row) -> sqlite3.Connection:
    """
    Get a database connection with optimal settings.
    
    Sets:
    - PRAGMA journal_mode=WAL (Write-Ahead Logging for better concurrency)
    - PRAGMA busy_timeout=5000 (Wait up to 5 seconds if DB is locked)
    - row_factory=sqlite3.Row by default (for named column access)
    
    Args:
        row_factory: Factory for row objects (default: sqlite3.Row)
                     Set to None for tuples, or provide custom factory
    
    Returns:
        sqlite3.Connection: Configured database connection
        
    Example:
        >>> conn = get_connection()
        >>> cursor = conn.cursor()
        >>> cursor.execute("SELECT * FROM articles")
        >>> row = cursor.fetchone()
        >>> print(row['name'])  # Named access works
    """
    try:
        db_file = get_db_file()
        conn = sqlite3.connect(
            db_file, 
            timeout=10, 
            detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES
        )
        
        # Set row factory for named column access
        if row_factory is not None:
            conn.row_factory = row_factory
        
        # Set pragmas for better concurrency and reliability
        try:
            conn.execute("PRAGMA journal_mode=WAL;")
            conn.execute("PRAGMA busy_timeout=5000;")
        except Exception as pragma_exc:
            logger.warning(f"Failed to set PRAGMAs: {pragma_exc}")
        
        return conn
    except Exception as e:
        logger.error(f"Error connecting to database: {e}")
        raise


def query_one(
    query: str, 
    params: Optional[Tuple] = None,
    converter: Optional[Callable] = None
) -> Optional[Dict[str, Any]]:
    """
    Execute a query and return a single row as a dict.
    
    Args:
        query: SQL query string
        params: Query parameters (optional)
        converter: Optional converter function (default: _row_to_dict)
                   Set to None to disable conversion
    
    Returns:
        dict or None: Single row as dict, or None if no results
        
    Example:
        >>> article = query_one("SELECT * FROM articles WHERE id = ?", (1,))
        >>> print(article.get('name', 'Unknown'))
    """
    if converter is None:
        converter = _row_to_dict
    
    conn = None
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        
        row = cursor.fetchone()
        
        if row is None:
            return None
        
        # Convert if converter provided
        if converter:
            return converter(row, cursor)
        else:
            return row
        
    except Exception as e:
        logger.error(f"Error executing query_one: {e}")
        logger.error(f"Query: {query}")
        logger.error(f"Params: {params}")
        raise
    finally:
        if conn:
            conn.close()


def query_all(
    query: str, 
    params: Optional[Tuple] = None,
    converter: Optional[Callable] = None
) -> List[Dict[str, Any]]:
    """
    Execute a query and return all rows as a list of dicts.
    
    Args:
        query: SQL query string
        params: Query parameters (optional)
        converter: Optional converter function (default: _rows_to_dicts)
                   Set to None to disable conversion
    
    Returns:
        list of dicts: All rows as dicts
        
    Example:
        >>> articles = query_all("SELECT * FROM articles WHERE categorie = ?", ('Boisson',))
        >>> for article in articles:
        >>>     print(article.get('name', 'Unknown'))
    """
    if converter is None:
        converter = _rows_to_dicts
    
    conn = None
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        
        rows = cursor.fetchall()
        
        # Convert if converter provided
        if converter:
            return converter(rows, cursor)
        else:
            return rows if rows else []
        
    except Exception as e:
        logger.error(f"Error executing query_all: {e}")
        logger.error(f"Query: {query}")
        logger.error(f"Params: {params}")
        raise
    finally:
        if conn:
            conn.close()


@contextmanager
def transaction(conn: Optional[sqlite3.Connection] = None):
    """
    Context manager for database transactions.
    
    Automatically commits on success, rolls back on exception.
    If no connection provided, creates one.
    
    Args:
        conn: Optional existing connection to use
    
    Yields:
        sqlite3.Connection: Database connection for transaction
        
    Example:
        >>> with transaction() as conn:
        >>>     cursor = conn.cursor()
        >>>     cursor.execute("INSERT INTO articles (...) VALUES (...)")
        >>>     cursor.execute("UPDATE stock SET ...")
        >>> # Automatically committed
        
        >>> # Or with existing connection:
        >>> conn = get_connection()
        >>> with transaction(conn):
        >>>     # Do multiple operations
        >>>     pass
    """
    if conn is None:
        conn = get_connection()
        close_after = True
    else:
        close_after = False
    
    try:
        yield conn
        conn.commit()
    except Exception as e:
        logger.error(f"Transaction failed, rolling back: {e}")
        conn.rollback()
        raise
    finally:
        if close_after:
            conn.close()


def execute_query(
    query: str,
    params: Optional[Tuple] = None,
    commit: bool = True
) -> int:
    """
    Execute a query (INSERT, UPDATE, DELETE) and return rows affected.
    
    Args:
        query: SQL query string
        params: Query parameters (optional)
        commit: Whether to commit the transaction (default: True)
    
    Returns:
        int: Number of rows affected
        
    Example:
        >>> rows_updated = execute_query(
        ...     "UPDATE articles SET stock = ? WHERE id = ?",
        ...     (50, 1)
        ... )
        >>> print(f"Updated {rows_updated} rows")
    """
    conn = None
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        
        rows_affected = cursor.rowcount
        
        if commit:
            conn.commit()
        
        return rows_affected
        
    except Exception as e:
        logger.error(f"Error executing query: {e}")
        logger.error(f"Query: {query}")
        logger.error(f"Params: {params}")
        if conn:
            conn.rollback()
        raise
    finally:
        if conn:
            conn.close()


def execute(
    query: str,
    params: Optional[Tuple] = None,
    commit: bool = True,
    retries: int = 3,
    retry_delay: float = 0.5
) -> int:
    """
    Execute a query with retry logic for database lock errors.
    
    This function attempts to execute a query multiple times if it encounters
    a "database is locked" error, with exponential backoff between retries.
    
    Args:
        query: SQL query string (INSERT, UPDATE, DELETE)
        params: Query parameters (optional)
        commit: Whether to commit the transaction (default: True)
        retries: Number of retry attempts on lock errors (default: 3)
        retry_delay: Initial delay between retries in seconds (default: 0.5)
                     Delay doubles with each retry (exponential backoff)
    
    Returns:
        int: Number of rows affected
        
    Raises:
        sqlite3.OperationalError: If database remains locked after all retries
        Exception: Any other database error
        
    Example:
        >>> # Simple usage with default retries
        >>> rows = execute(
        ...     "UPDATE articles SET stock = ? WHERE id = ?",
        ...     (50, 1)
        ... )
        
        >>> # Custom retry configuration for critical operations
        >>> rows = execute(
        ...     "INSERT INTO orders (...) VALUES (...)",
        ...     params,
        ...     retries=5,
        ...     retry_delay=1.0
        ... )
    """
    last_exception = None
    delay = retry_delay
    
    for attempt in range(retries):
        conn = None
        try:
            conn = get_connection()
            cursor = conn.cursor()
            
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            
            rows_affected = cursor.rowcount
            
            if commit:
                conn.commit()
            
            # Success - return result
            return rows_affected
            
        except sqlite3.OperationalError as e:
            last_exception = e
            error_msg = str(e).lower()
            
            # Check if this is a "database is locked" error
            if "locked" in error_msg and attempt < retries - 1:
                logger.warning(
                    f"Database locked on attempt {attempt + 1}/{retries}. "
                    f"Retrying in {delay}s... Query: {query[:100]}"
                )
                if conn:
                    try:
                        conn.close()
                    except sqlite3.Error:
                        # Ignore errors when closing connection
                        pass
                time.sleep(delay)
                delay *= 2  # Exponential backoff
                continue
            else:
                # Not a lock error or final attempt - log and raise
                logger.error(f"Database error after {attempt + 1} attempts: {e}")
                logger.error(f"Query: {query}")
                logger.error(f"Params: {params}")
                if conn:
                    try:
                        conn.rollback()
                    except sqlite3.Error:
                        # Ignore errors during rollback
                        pass
                raise
                
        except Exception as e:
            # Non-lock error - log and raise immediately
            logger.error(f"Error executing query: {e}")
            logger.error(f"Query: {query}")
            logger.error(f"Params: {params}")
            if conn:
                try:
                    conn.rollback()
                except sqlite3.Error:
                    # Ignore errors during rollback
                    pass
            raise
        finally:
            if conn:
                try:
                    conn.close()
                except sqlite3.Error:
                    # Ignore errors when closing connection
                    pass


# Convenience aliases
fetch_one = query_one
fetch_all = query_all

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/db_row_utils.py ===

```python
"""
Database row utility functions for safe sqlite3.Row conversions.

This module provides utility functions to safely convert sqlite3.Row objects
to dictionaries, enabling the use of .get() method for optional field access.

Note: This module duplicates functionality from utils.db_helpers for module-specific
use. The underscore prefix (_row_to_dict, _rows_to_dicts) indicates these are
internal utilities specific to the modules/ directory. The utils.db_helpers versions
(row_to_dict, rows_to_dicts) remain available for general use throughout the codebase.

Functions:
    _row_to_dict: Convert a single sqlite3.Row to dict
    _rows_to_dicts: Convert a list of sqlite3.Row objects to list of dicts
"""

from typing import Any, Dict, List, Optional
import sqlite3


def _row_to_dict(row: Optional[sqlite3.Row], cursor: Optional[Any] = None) -> Optional[Dict[str, Any]]:
    """
    Convert sqlite3.Row to dict for safe .get() access.
    
    sqlite3.Row objects support dictionary-style access (row['column']) but
    lack the .get() method that dicts have for optional fields with defaults.
    This function converts a Row to a dict to enable .get() usage.
    
    Args:
        row: sqlite3.Row object, tuple, or None
        cursor: Optional cursor with description for tuple fallback
        
    Returns:
        dict or None: Dictionary representation of the row, or None if input is None
        
    Example:
        >>> row = cursor.execute("SELECT * FROM table").fetchone()
        >>> row_dict = _row_to_dict(row)
        >>> value = row_dict.get('optional_column', 'default')
        
        >>> # With cursor fallback for plain tuples:
        >>> cursor = conn.cursor()
        >>> cursor.execute("SELECT * FROM table")
        >>> row = cursor.fetchone()
        >>> row_dict = _row_to_dict(row, cursor)
    """
    if row is None:
        return None
    
    # Handle both sqlite3.Row and tuple types
    if isinstance(row, dict):
        # Already a dict, return as-is
        return row
    
    try:
        # Convert Row to dict
        return dict(row)
    except (TypeError, ValueError) as e:
        # Fallback for other sequence types (tuples, etc.) using cursor.description
        if cursor and hasattr(cursor, 'description') and cursor.description:
            try:
                return {cursor.description[i][0]: row[i] for i in range(len(row))}
            except (IndexError, TypeError):
                pass
        # If it's a tuple and we don't have column names, return None
        # In practice, sqlite3.Row should always work with dict()
        if hasattr(row, '__iter__') and not isinstance(row, (str, bytes)):
            return None
        raise TypeError(f"Cannot convert {type(row)} to dict: {e}")


def _rows_to_dicts(rows: List[sqlite3.Row], cursor: Optional[Any] = None) -> List[Dict[str, Any]]:
    """
    Convert list of sqlite3.Row objects to list of dicts.
    
    This is a batch version of _row_to_dict() for converting multiple rows.
    Filters out None values automatically.
    
    Args:
        rows: list of sqlite3.Row objects or tuples
        cursor: Optional cursor with description for tuple fallback
        
    Returns:
        list of dicts: List of dictionary representations
        
    Example:
        >>> rows = cursor.execute("SELECT * FROM table").fetchall()
        >>> dicts = _rows_to_dicts(rows)
        >>> for d in dicts:
        >>>     print(d.get('optional_column', 'N/A'))
        
        >>> # With cursor fallback:
        >>> cursor = conn.cursor()
        >>> cursor.execute("SELECT * FROM table")
        >>> rows = cursor.fetchall()
        >>> dicts = _rows_to_dicts(rows, cursor)
    """
    if not rows:
        return []
    
    result = []
    for row in rows:
        converted = _row_to_dict(row, cursor)
        if converted is not None:
            result.append(converted)
    
    return result

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/depenses_diverses.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
from dialogs.depense_dialog import DepenseDialog

class DepensesDiversesModule:
    def __init__(self, master):
        self.columns = (
            "id", "categorie", "module_id", "montant", "fournisseur", "date_depense",
            "paye_par", "membre_id", "statut_remboursement", "statut_reglement",
            "moyen_paiement", "numero_cheque", "numero_facture", "commentaire"
        )
        self.top = tk.Toplevel(master)
        self.top.title("DÃ©penses Diverses")
        self.top.geometry("900x500")
        self.create_widgets()
        self.refresh_list()

    def create_widgets(self):
        self.tree = ttk.Treeview(self.top, columns=self.columns, show="headings")
        headers = [
            ("id", "ID"), ("categorie", "CatÃ©gorie"), ("module_id", "Module liÃ©"),
            ("montant", "Montant (â‚¬)"), ("fournisseur", "Fournisseur"),
            ("date_depense", "Date de la dÃ©pense"),
            ("paye_par", "PayÃ© par"), ("membre_id", "Membre"),
            ("statut_remboursement", "Statut remboursement"),
            ("statut_reglement", "Statut rÃ¨glement"),
            ("moyen_paiement", "Moyen paiement"), ("numero_cheque", "NÂ° chÃ¨que"),
            ("numero_facture", "NÂ° facture"), ("commentaire", "Commentaire")
        ]
        for col, text in headers:
            self.tree.heading(col, text=text)
            self.tree.column(col, width=120, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=6)
        tk.Button(btn_frame, text="Ajouter DÃ©pense Diverses", command=self.add_depense).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Ã‰diter sÃ©lection", command=self.edit_depense).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Supprimer sÃ©lection", command=self.delete_selected).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=8)

    def get_module_choices(self):
        conn = get_connection()
        modules = conn.execute("SELECT id, nom_module FROM event_modules ORDER BY nom_module").fetchall()
        conn.close()
        return [("", "Aucun")] + [(str(m["id"]), m["nom_module"]) for m in modules]

    def get_fournisseur_choices(self):
        conn = get_connection()
        fournisseurs = conn.execute("SELECT name FROM fournisseurs ORDER BY name").fetchall()
        conn.close()
        return [f["name"] for f in fournisseurs]

    def get_membre_choices(self):
        conn = get_connection()
        membres = conn.execute("SELECT id, name, prenom FROM membres ORDER BY name, prenom").fetchall()
        conn.close()
        return [(str(m["id"]), f"{m['prenom']} {m['name']}") for m in membres]

    def add_depense(self):
        DepenseDialog(
            self.top,
            table="depenses_diverses",
            module_choices=self.get_module_choices(),
            fournisseur_choices=self.get_fournisseur_choices(),
            membre_choices=self.get_membre_choices(),
            on_save=self.refresh_list,
            fields={
                "categorie": True,
                "module_id": True,
                "montant": True,
                "fournisseur": True,
                "date_depense": True,
                "paye_par": True,
                "moyen_paiement": True,
                "numero_cheque": True,
                "numero_facture": True,
                "commentaire": True,
            }
        )

    def edit_depense(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne Ã  Ã©diter.")
            return
        item = self.tree.item(sel[0])
        depense_id = item["values"][0]
        if not messagebox.askyesno("Confirmation", "Voulez-vous vraiment modifier cette dÃ©penseâ€¯?"):
            return
        DepenseDialog(
            self.top,
            table="depenses_diverses",
            depense_id=depense_id,
            module_choices=self.get_module_choices(),
            fournisseur_choices=self.get_fournisseur_choices(),
            membre_choices=self.get_membre_choices(),
            on_save=self.refresh_list,
            fields={
                "categorie": True,
                "module_id": True,
                "montant": True,
                "fournisseur": True,
                "date_depense": True,
                "paye_par": True,
                "moyen_paiement": True,
                "numero_cheque": True,
                "numero_facture": True,
                "commentaire": True,
            }
        )

    def delete_selected(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne Ã  supprimer.")
            return
        item = self.tree.item(sel[0])
        id_ = item["values"][0]
        if not messagebox.askyesno("Confirmer", "Supprimer cette dÃ©pense ?"):
            return
        conn = get_connection()
        conn.execute("DELETE FROM depenses_diverses WHERE id = ?", (id_,))
        conn.commit()
        conn.close()
        self.refresh_list()

    def refresh_list(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        items = conn.execute(
            "SELECT id, categorie, module_id, montant, fournisseur, date_depense, paye_par, membre_id, statut_remboursement, statut_reglement, moyen_paiement, numero_cheque, numero_facture, commentaire FROM depenses_diverses ORDER BY date_depense DESC, id DESC"
        ).fetchall()
        for item in items:
            module_name = ""
            membre_nom = ""
            if item["module_id"]:
                mod = conn.execute("SELECT nom_module FROM event_modules WHERE id=?", (item["module_id"],)).fetchone()
                if mod:
                    module_name = mod["nom_module"]
            if item["membre_id"]:
                mem = conn.execute("SELECT name, prenom FROM membres WHERE id=?", (item["membre_id"],)).fetchone()
                if mem:
                    membre_nom = f"{mem['prenom']} {mem['name']}"
            self.tree.insert(
                "", "end",
                values=[
                    item["id"], item["categorie"], module_name, f"{item['montant']:.2f}",
                    item["fournisseur"] or "", item["date_depense"] or "", item["paye_par"] or "",
                    membre_nom, item["statut_remboursement"] or "", item["statut_reglement"] or "",
                    item["moyen_paiement"] or "", item["numero_cheque"] or "",
                    item["numero_facture"] or "", item["commentaire"] or ""
                ]
            )
        conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/depenses_regulieres.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
from dialogs.depense_dialog import DepenseDialog

class DepensesRegulieresModule:
    def __init__(self, master):
        self.columns = (
            "id", "categorie", "module_id", "montant", "fournisseur", "date_depense",
            "paye_par", "membre_id", "statut_remboursement", "statut_reglement",
            "moyen_paiement", "numero_cheque", "numero_facture", "commentaire"
        )
        self.top = tk.Toplevel(master)
        self.top.title("DÃ©penses RÃ©guliÃ¨res")
        self.top.geometry("900x500")
        self.create_widgets()
        self.refresh_list()

    def create_widgets(self):
        self.tree = ttk.Treeview(self.top, columns=self.columns, show="headings")
        headers = [
            ("id", "ID"), ("categorie", "CatÃ©gorie"), ("module_id", "Module liÃ©"),
            ("montant", "Montant (â‚¬)"), ("fournisseur", "Fournisseur"),
            ("date_depense", "Date de la dÃ©pense"),
            ("paye_par", "PayÃ© par"), ("membre_id", "Membre"),
            ("statut_remboursement", "Statut remboursement"),
            ("statut_reglement", "Statut rÃ¨glement"),
            ("moyen_paiement", "Moyen paiement"), ("numero_cheque", "NÂ° chÃ¨que"),
            ("numero_facture", "NÂ° facture"), ("commentaire", "Commentaire")
        ]
        for col, text in headers:
            self.tree.heading(col, text=text)
            self.tree.column(col, width=120, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=6)
        tk.Button(btn_frame, text="Ajouter DÃ©pense RÃ©guliÃ¨re", command=self.add_depense).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Ã‰diter sÃ©lection", command=self.edit_depense).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Supprimer sÃ©lection", command=self.delete_selected).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=8)

    def get_module_choices(self):
        conn = get_connection()
        modules = conn.execute("SELECT id, nom_module FROM event_modules ORDER BY nom_module").fetchall()
        conn.close()
        return [("", "Aucun")] + [(str(m["id"]), m["nom_module"]) for m in modules]

    def get_fournisseur_choices(self):
        conn = get_connection()
        fournisseurs = conn.execute("SELECT name FROM fournisseurs ORDER BY name").fetchall()
        conn.close()
        return [f["name"] for f in fournisseurs]

    def get_membre_choices(self):
        conn = get_connection()
        membres = conn.execute("SELECT id, name, prenom FROM membres ORDER BY name, prenom").fetchall()
        conn.close()
        return [(str(m["id"]), f"{m['prenom']} {m['name']}") for m in membres]

    def add_depense(self):
        DepenseDialog(
            self.top,
            table="depenses_regulieres",
            module_choices=self.get_module_choices(),
            fournisseur_choices=self.get_fournisseur_choices(),
            membre_choices=self.get_membre_choices(),
            on_save=self.refresh_list,
            fields={
                "categorie": True,
                "module_id": True,
                "montant": True,
                "fournisseur": True,
                "date_depense": True,
                "paye_par": True,
                "moyen_paiement": True,
                "numero_cheque": True,
                "numero_facture": True,
                "commentaire": True,
            }
        )

    def edit_depense(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne Ã  Ã©diter.")
            return
        item = self.tree.item(sel[0])
        depense_id = item["values"][0]
        if not messagebox.askyesno("Confirmation", "Voulez-vous vraiment modifier cette dÃ©penseâ€¯?"):
            return
        DepenseDialog(
            self.top,
            table="depenses_regulieres",
            depense_id=depense_id,
            module_choices=self.get_module_choices(),
            fournisseur_choices=self.get_fournisseur_choices(),
            membre_choices=self.get_membre_choices(),
            on_save=self.refresh_list,
            fields={
                "categorie": True,
                "module_id": True,
                "montant": True,
                "fournisseur": True,
                "date_depense": True,
                "paye_par": True,
                "moyen_paiement": True,
                "numero_cheque": True,
                "numero_facture": True,
                "commentaire": True,
            }
        )

    def delete_selected(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne Ã  supprimer.")
            return
        item = self.tree.item(sel[0])
        id_ = item["values"][0]
        if not messagebox.askyesno("Confirmer", "Supprimer cette dÃ©pense rÃ©guliÃ¨re ?"):
            return
        conn = get_connection()
        conn.execute("DELETE FROM depenses_regulieres WHERE id = ?", (id_,))
        conn.commit()
        conn.close()
        self.refresh_list()

    def refresh_list(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        items = conn.execute(
            "SELECT id, categorie, module_id, montant, fournisseur, date_depense, paye_par, membre_id, statut_remboursement, statut_reglement, moyen_paiement, numero_cheque, numero_facture, commentaire FROM depenses_regulieres ORDER BY date_depense DESC, id DESC"
        ).fetchall()
        for item in items:
            module_name = ""
            membre_nom = ""
            if item["module_id"]:
                mod = conn.execute("SELECT nom_module FROM event_modules WHERE id=?", (item["module_id"],)).fetchone()
                if mod:
                    module_name = mod["nom_module"]
            if item["membre_id"]:
                mem = conn.execute("SELECT name, prenom FROM membres WHERE id=?", (item["membre_id"],)).fetchone()
                if mem:
                    membre_nom = f"{mem['prenom']} {mem['name']}"
            self.tree.insert(
                "", "end",
                values=[
                    item["id"], item["categorie"], module_name, f"{item['montant']:.2f}",
                    item["fournisseur"] or "", item["date_depense"] or "", item["paye_par"] or "",
                    membre_nom, item["statut_remboursement"] or "", item["statut_reglement"] or "",
                    item["moyen_paiement"] or "", item["numero_cheque"] or "",
                    item["numero_facture"] or "", item["commentaire"] or ""
                ]
            )
        conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/depots_retraits_banque.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_df_or_sql, get_connection
import pandas as pd
from datetime import date

class DepotsRetraitsBanqueModule:
    def __init__(self, master):
        self.master = master
        self.top = tk.Toplevel(master)
        self.top.title("Suivi des DÃ©pÃ´ts/Retraits Ã  la Banque")
        self.top.geometry("900x500")
        self.create_widgets()
        self.refresh_table()

    def create_widgets(self):
        frm_btn = tk.Frame(self.top)
        frm_btn.pack(fill=tk.X, pady=4)

        tk.Button(frm_btn, text="Ajouter Mouvement", command=self.ajouter_mouvement).pack(side=tk.LEFT, padx=5)
        tk.Button(frm_btn, text="Supprimer sÃ©lection", command=self.supprimer_selection).pack(side=tk.LEFT, padx=5)
        tk.Button(frm_btn, text="Exporter Excel", command=self.exporter_excel).pack(side=tk.LEFT, padx=5)
        tk.Label(frm_btn, text="Filtrer par banque:").pack(side=tk.LEFT, padx=10)
        self.var_banque = tk.StringVar()
        self.cmb_banque = ttk.Combobox(frm_btn, textvariable=self.var_banque, width=15, state="readonly")
        self.cmb_banque.pack(side=tk.LEFT)
        self.cmb_banque.bind("<<ComboboxSelected>>", lambda e: self.refresh_table())
        tk.Button(frm_btn, text="Tout afficher", command=lambda: self.var_banque.set('')).pack(side=tk.LEFT, padx=3)

        self.tree = ttk.Treeview(
            self.top,
            columns=("id", "date", "type", "montant", "reference", "banque", "pointe", "commentaire"),
            show="headings", selectmode="browse"
        )
        for col, w in zip(
            ("id", "date", "type", "montant", "reference", "banque", "pointe", "commentaire"),
            [0, 90, 120, 90, 110, 90, 60, 250]
        ):
            self.tree.heading(col, text=col.capitalize())
            self.tree.column(col, width=w)
        self.tree["displaycolumns"] = ("date", "type", "montant", "reference", "banque", "pointe", "commentaire")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        self.tree.bind("<Double-1>", self.toggle_pointage)

    def refresh_table(self):
        banque = self.var_banque.get()
        query = "SELECT * FROM depots_retraits_banque"
        if banque:
            query += " WHERE banque = ?"
            df = pd.read_sql_query(query, get_connection(), params=(banque,))
        else:
            df = get_df_or_sql("depots_retraits_banque")

        banques = sorted(get_df_or_sql("SELECT DISTINCT banque FROM depots_retraits_banque WHERE banque IS NOT NULL AND banque!=''")["banque"].unique().tolist())
        self.cmb_banque["values"] = [""] + banques

        self.tree.delete(*self.tree.get_children())
        for _, row in df.iterrows():
            self.tree.insert(
                "", "end", iid=row["id"],
                values=(
                    row["id"],
                    row["date"],
                    row["type"],
                    f"{row['montant']:.2f}",
                    row.get("reference", ""),
                    row.get("banque", ""),
                    "Oui" if row.get("pointe", 0) else "Non",
                    row.get("commentaire", "")
                )
            )

    def ajouter_mouvement(self):
        win = tk.Toplevel(self.top)
        win.title("Ajouter un dÃ©pÃ´t/retrait")
        win.transient(self.top)

        tk.Label(win, text="Date (AAAA-MM-JJ):").grid(row=0, column=0, sticky="e")
        ent_date = tk.Entry(win)
        ent_date.insert(0, date.today().isoformat())
        ent_date.grid(row=0, column=1)

        tk.Label(win, text="Type:").grid(row=1, column=0, sticky="e")
        cmb_type = ttk.Combobox(win, values=["DÃ©pÃ´t chÃ¨que", "DÃ©pÃ´t espÃ¨ces", "Retrait espÃ¨ces"], state="readonly")
        cmb_type.grid(row=1, column=1)
        cmb_type.set("DÃ©pÃ´t chÃ¨que")

        tk.Label(win, text="Montant (â‚¬):").grid(row=2, column=0, sticky="e")
        ent_montant = tk.Entry(win)
        ent_montant.grid(row=2, column=1)

        tk.Label(win, text="RÃ©fÃ©rence (bordereau, etc.):").grid(row=3, column=0, sticky="e")
        ent_reference = tk.Entry(win)
        ent_reference.grid(row=3, column=1)

        tk.Label(win, text="Banque:").grid(row=4, column=0, sticky="e")
        ent_banque = tk.Entry(win)
        ent_banque.grid(row=4, column=1)

        tk.Label(win, text="Commentaire:").grid(row=5, column=0, sticky="e")
        ent_comment = tk.Entry(win)
        ent_comment.grid(row=5, column=1)

        def valider():
            try:
                montant = float(ent_montant.get().replace(",", "."))
                if not ent_date.get():
                    raise ValueError("Date obligatoire")
                if montant == 0:
                    raise ValueError("Montant nul")
                conn = get_connection()
                c = conn.cursor()
                c.execute(
                    """INSERT INTO depots_retraits_banque (date, type, montant, reference, banque, commentaire)
                    VALUES (?, ?, ?, ?, ?, ?)""",
                    (
                        ent_date.get(),
                        cmb_type.get(),
                        montant,
                        ent_reference.get(),
                        ent_banque.get(),
                        ent_comment.get(),
                    ),
                )
                conn.commit()
                conn.close()
                win.destroy()
                self.refresh_table()
            except Exception as e:
                messagebox.showerror("Erreur", str(e))

        tk.Button(win, text="Enregistrer", command=valider).grid(row=6, column=0, columnspan=2, pady=8)

    def supprimer_selection(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showinfo("Suppression", "SÃ©lectionnez une ligne Ã  supprimer.")
            return
        if messagebox.askyesno("Suppression", "Supprimer cet enregistrement ?"):
            id_ = sel[0]
            conn = get_connection()
            c = conn.cursor()
            c.execute("DELETE FROM depots_retraits_banque WHERE id=?", (id_,))
            conn.commit()
            conn.close()
            self.refresh_table()

    def toggle_pointage(self, event):
        item = self.tree.identify_row(event.y)
        if not item:
            return
        id_ = int(item)
        conn = get_connection()
        c = conn.cursor()
        c.execute("SELECT pointe FROM depots_retraits_banque WHERE id=?", (id_,))
        row = c.fetchone()
        if row:
            new_val = 0 if row[0] else 1
            c.execute("UPDATE depots_retraits_banque SET pointe=? WHERE id=?", (new_val, id_))
            conn.commit()
        conn.close()
        self.refresh_table()

    def exporter_excel(self):
        df = get_df_or_sql("depots_retraits_banque")
        try:
            df.to_excel("depots_retraits_banque.xlsx", index=False)
            messagebox.showinfo("Export", "Export Excel effectuÃ© dans le fichier depots_retraits_banque.xlsx")
        except Exception as e:
            messagebox.showerror("Export", "Erreur export : " + str(e))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/dons_subventions.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
from utils.validation import is_required, is_number

class DonsSubventionsModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Dons et Subventions")
        self.top.geometry("700x400")
        self.create_widgets()
        self.refresh_list()

    def create_widgets(self):
        columns = ("id", "type", "source", "montant", "date", "justificatif")
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings")
        for col, text, w in zip(
            columns,
            ["ID", "Type", "Source", "Montant (â‚¬)", "Date", "Justificatif"],
            [50, 80, 180, 100, 100, 150]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=6)
        tk.Button(btn_frame, text="Ajouter Don/Subvention", command=self.add_don_subvention).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Supprimer sÃ©lection", command=self.delete_selected).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=8)

    def add_don_subvention(self):
        AddDonSubventionDialog(self.top, self.refresh_list)

    def delete_selected(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne Ã  supprimer.")
            return
        item = self.tree.item(sel[0])
        id_ = item["values"][0]
        if not messagebox.askyesno("Confirmer", "Supprimer ce don/subvention ?"):
            return
        conn = get_connection()
        conn.row_factory = None
        conn.execute("DELETE FROM dons_subventions WHERE id = ?", (id_,))
        conn.commit()
        conn.close()
        self.refresh_list()

    def refresh_list(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        conn.row_factory = None
        items = conn.execute(
            "SELECT id, type, source, montant, date, justificatif FROM dons_subventions ORDER BY date DESC, id DESC"
        ).fetchall()
        conn.close()
        for item in items:
            self.tree.insert("", "end", values=item)

class AddDonSubventionDialog(tk.Toplevel):
    def __init__(self, master, on_save):
        super().__init__(master)
        self.title("Ajouter un Don/Subvention")
        self.resizable(False, False)
        self.on_save = on_save

        tk.Label(self, text="Type (Don/Subvention) *").grid(row=0, column=0, sticky="e", pady=4, padx=6)
        self.type_var = tk.StringVar()
        self.type_combo = ttk.Combobox(self, textvariable=self.type_var, values=["Don", "Subvention"], width=20, state="readonly")
        self.type_combo.grid(row=0, column=1, pady=4)
        self.type_combo.current(0)

        tk.Label(self, text="Source (name, organisme) *").grid(row=1, column=0, sticky="e", pady=4, padx=6)
        self.source_var = tk.StringVar()
        tk.Entry(self, textvariable=self.source_var, width=28).grid(row=1, column=1, pady=4)

        tk.Label(self, text="Montant (â‚¬) *").grid(row=2, column=0, sticky="e", pady=4, padx=6)
        self.montant_var = tk.StringVar()
        tk.Entry(self, textvariable=self.montant_var, width=15).grid(row=2, column=1, pady=4)

        tk.Label(self, text="Date (YYYY-MM-DD) *").grid(row=3, column=0, sticky="e", pady=4, padx=6)
        self.date_var = tk.StringVar()
        tk.Entry(self, textvariable=self.date_var, width=15).grid(row=3, column=1, pady=4)

        tk.Label(self, text="Justificatif (facultatif)").grid(row=4, column=0, sticky="e", pady=4, padx=6)
        self.justif_var = tk.StringVar()
        tk.Entry(self, textvariable=self.justif_var, width=28).grid(row=4, column=1, pady=4)

        btn_frame = tk.Frame(self)
        btn_frame.grid(row=5, column=0, columnspan=2, pady=12)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=12)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.LEFT, padx=12)

    def save(self):
        type_ = self.type_var.get().strip()
        source = self.source_var.get().strip()
        montant_str = self.montant_var.get().replace(",", ".").strip()
        try:
            montant = float(montant_str)
        except Exception:
            montant = None
        date = self.date_var.get().strip()
        justificatif = self.justif_var.get().strip()
        if not is_required(type_) or not is_required(source) or montant is None or not is_required(date):
            messagebox.showerror("Erreur", "Champs obligatoires manquants ou montant invalide.")
            return
        conn = get_connection()
        conn.row_factory = None
        conn.execute(
            "INSERT INTO dons_subventions (type, source, montant, date, justificatif) VALUES (?, ?, ?, ?, ?)",
            (type_, source, montant, date, justificatif)
        )
        conn.commit()
        conn.close()
        messagebox.showinfo("AjoutÃ©", "Don/Subvention enregistrÃ©.")
        self.destroy()
        if self.on_save:
            self.on_save()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/events.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
from modules.event_modules import EventModulesWindow
from modules.event_payments import PaymentsWindow
from modules.event_caisses import EventCaissesWindow
from modules.event_recettes import EventRecettesWindow
from modules.event_depenses import EventDepensesWindow
from utils.app_logger import get_logger
from utils.error_handler import handle_exception
from utils.date_helpers import parse_date, today

logger = get_logger("events_module")

class EventsWindow(tk.Toplevel):
    def __init__(self, master):
        super().__init__(master)
        self.title("Gestion des Ã©vÃ©nements")
        self.geometry("1100x500")
        self.minsize(900, 300)
        self.create_widgets()
        self.refresh_events()

    def create_widgets(self):
        # --- Barre du haut ---
        top_frame = tk.Frame(self)
        top_frame.pack(side=tk.TOP, fill=tk.X)

        tk.Button(top_frame, text="Nouvel Ã©vÃ©nement", command=self.add_event).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(top_frame, text="Ã‰diter", command=self.edit_event).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(top_frame, text="Supprimer", command=self.delete_event).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(top_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)

        # --- Tableau au centre ---
        tree_frame = tk.Frame(self)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=0)

        columns = ("id", "name", "date", "lieu", "description", "recettes", "depenses", "gain")
        self.tree = ttk.Treeview(tree_frame, columns=columns, show="headings")
        headings = [
            ("id", "ID"),
            ("name", "Name"),
            ("date", "Date"),
            ("lieu", "Lieu"),
            ("description", "Description"),
            ("recettes", "Recettes (â‚¬)"),
            ("depenses", "DÃ©penses (â‚¬)"),
            ("gain", "Gain (â‚¬)")
        ]
        for col, lbl in headings:
            self.tree.heading(col, text=lbl)
            if col == "id":
                self.tree.column(col, width=50, anchor="center", stretch=False)
            elif col in ("recettes", "depenses", "gain"):
                self.tree.column(col, width=100, anchor="e", stretch=False)
            else:
                self.tree.column(col, width=140, stretch=True)
        self.tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)

        vsb = ttk.Scrollbar(tree_frame, orient="vertical", command=self.tree.yview)
        hsb = ttk.Scrollbar(tree_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        vsb.pack(side=tk.RIGHT, fill=tk.Y)
        hsb.pack(side=tk.BOTTOM, fill=tk.X)

        # --- Barre du bas faÃ§on dashboard ---
        bottom_frame = tk.Frame(self)
        bottom_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(12, 10))
        btn_style = {"font": ("Arial", 10, "bold"), "height": 2, "width": 20}

        tk.Button(bottom_frame, text="Modules personnalisÃ©s", command=self.open_modules, **btn_style).pack(side=tk.LEFT, padx=6)
        tk.Button(bottom_frame, text="Paiements", command=self.open_payments, **btn_style).pack(side=tk.LEFT, padx=6)
        tk.Button(bottom_frame, text="Caisses Ã©vÃ©nement", command=self.open_caisses, **btn_style).pack(side=tk.LEFT, padx=6)
        tk.Button(bottom_frame, text="Recettes Ã©vÃ©nement", command=self.open_recettes, **btn_style).pack(side=tk.LEFT, padx=6)
        tk.Button(bottom_frame, text="DÃ©penses Ã©vÃ©nement", command=self.open_depenses, **btn_style).pack(side=tk.LEFT, padx=6)

    def refresh_events(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            events = conn.execute("SELECT * FROM events ORDER BY date DESC").fetchall()
            for ev in events:
                event_id = ev["id"]
                recettes = conn.execute(
                    "SELECT COALESCE(SUM(montant), 0) FROM event_recettes WHERE event_id = ?", (event_id,)
                ).fetchone()[0]
                depenses = conn.execute(
                    "SELECT COALESCE(SUM(montant), 0) FROM event_depenses WHERE event_id = ?", (event_id,)
                ).fetchone()[0]
                gain = recettes - depenses
                self.tree.insert(
                    "", "end",
                    values=(
                        ev["id"],
                        ev["name"],
                        ev["date"],
                        ev["lieu"],
                        ev["description"],
                        f"{recettes:.2f}",
                        f"{depenses:.2f}",
                        f"{gain:.2f}"
                    )
                )
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des Ã©vÃ©nements."))

    def get_selected_event_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_event(self):
        EventDialog(self, on_save=self.refresh_events)

    def edit_event(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        EventDialog(self, event_id=eid, on_save=self.refresh_events)

    def delete_event(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer cet Ã©vÃ©nement ?"):
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM events WHERE id = ?", (eid,))
            conn.commit()
            conn.close()
            logger.info(f"Ã‰vÃ©nement supprimÃ© id {eid}")
            self.refresh_events()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de l'Ã©vÃ©nement."))

    def open_modules(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        EventModulesWindow(self, event_id=eid)

    def open_payments(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        PaymentsWindow(self, event_id=eid)
        
    def open_caisses(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        EventCaissesWindow(self, event_id=eid)    

    def open_recettes(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        EventRecettesWindow(self, event_id=eid)

    def open_depenses(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        EventDepensesWindow(self, event_id=eid)        

class EventDialog(tk.Toplevel):
    def __init__(self, master, event_id=None, on_save=None):
        super().__init__(master)
        self.title("Ã‰vÃ©nement" if not event_id else "Ã‰diter l'Ã©vÃ©nement")
        self.event_id = event_id
        self.on_save = on_save
        self.geometry("420x320")
        self.resizable(False, False)

        self.name_var = tk.StringVar()
        self.date_var = tk.StringVar()
        self.lieu_var = tk.StringVar()
        self.desc_var = tk.StringVar()

        tk.Label(self, text="Name :").pack(pady=6)
        tk.Entry(self, textvariable=self.name_var, width=40).pack()
        tk.Label(self, text="Date (yyyy-mm-dd) :").pack(pady=6)
        tk.Entry(self, textvariable=self.date_var, width=20).pack()
        tk.Label(self, text="Lieu :").pack(pady=6)
        tk.Entry(self, textvariable=self.lieu_var, width=30).pack()
        tk.Label(self, text="Description :").pack(pady=6)
        tk.Entry(self, textvariable=self.desc_var, width=45).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=36, pady=16)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=36, pady=16)

        if self.event_id:
            self.load_event()

    def load_event(self):
        try:
            conn = get_connection()
            ev = conn.execute("SELECT * FROM events WHERE id = ?", (self.event_id,)).fetchone()
            conn.close()
            if ev:
                self.name_var.set(ev["name"])
                self.date_var.set(ev["date"])
                self.lieu_var.set(ev["lieu"])
                self.desc_var.set(ev["description"])
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement de l'Ã©vÃ©nement."))

    def save(self):
        name = self.name_var.get().strip()
        date = self.date_var.get().strip() or today()
        lieu = self.lieu_var.get().strip()
        desc = self.desc_var.get().strip()
        if not name:
            messagebox.showerror("Erreur", "Le nom de l'Ã©vÃ©nement est obligatoire.")
            return
        if not parse_date(date):
            messagebox.showerror("Erreur", "Date invalide (format attendu : YYYY-MM-DD).")
            return
        try:
            conn = get_connection()
            if self.event_id:
                conn.execute(
                    "UPDATE events SET name=?, date=?, lieu=?, description=? WHERE id=?",
                    (name, date, lieu, desc, self.event_id)
                )
            else:
                conn.execute(
                    "INSERT INTO events (name, date, lieu, description) VALUES (?, ?, ?, ?)",
                    (name, date, lieu, desc)
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de l'Ã©vÃ©nement."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/event_caisses.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("event_caisses")

class EventCaissesWindow(tk.Toplevel):
    def __init__(self, master, event_id):
        super().__init__(master)
        self.title(f"Caisses de l'Ã©vÃ©nement {event_id}")
        self.geometry("700x400")
        self.event_id = event_id
        self.create_widgets()
        self.refresh_caisses()

    def create_widgets(self):
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X)
        tk.Button(btn_frame, text="Nouvelle caisse", command=self.add_caisse).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Ã‰diter", command=self.edit_caisse).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_caisse).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)

        columns = ("id", "nom", "solde_initial", "responsable")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        self.tree.heading("id", text="ID")
        self.tree.heading("nom", text="Nom de la caisse")
        self.tree.heading("solde_initial", text="Solde initial (â‚¬)")
        self.tree.heading("responsable", text="Responsable")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

    def refresh_caisses(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            caisses = conn.execute(
                "SELECT * FROM event_caisses WHERE event_id = ? ORDER BY id", (self.event_id,)
            ).fetchall()
            for caisse in caisses:
                self.tree.insert(
                    "", "end",
                    values=(
                        caisse["id"],
                        caisse["nom"],
                        f"{caisse['solde_initial']:.2f}" if caisse["solde_initial"] is not None else "",
                        caisse["responsable"] or ""
                    )
                )
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des caisses."))

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_caisse(self):
        CaisseDialog(self, event_id=self.event_id, on_save=self.refresh_caisses)

    def edit_caisse(self):
        cid = self.get_selected_id()
        if not cid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une caisse Ã  Ã©diter.")
            return
        CaisseDialog(self, event_id=self.event_id, caisse_id=cid, on_save=self.refresh_caisses)

    def delete_caisse(self):
        cid = self.get_selected_id()
        if not cid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une caisse Ã  supprimer.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer cette caisse ?"):
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM event_caisses WHERE id=? AND event_id=?", (cid, self.event_id))
            conn.commit()
            conn.close()
            logger.info(f"Caisse supprimÃ©e id {cid}, event_id {self.event_id}")
            self.refresh_caisses()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de la caisse."))

class CaisseDialog(tk.Toplevel):
    def __init__(self, master, event_id, caisse_id=None, on_save=None):
        super().__init__(master)
        self.title("Caisse" if caisse_id is None else "Ã‰diter caisse")
        self.event_id = event_id
        self.caisse_id = caisse_id
        self.on_save = on_save
        self.geometry("340x260")
        self.resizable(False, False)

        self.nom_var = tk.StringVar()
        self.solde_var = tk.StringVar()
        self.resp_var = tk.StringVar()

        tk.Label(self, text="Nom de la caisse :").pack(pady=8)
        tk.Entry(self, textvariable=self.nom_var, width=30).pack()
        tk.Label(self, text="Solde initial (â‚¬) :").pack(pady=8)
        tk.Entry(self, textvariable=self.solde_var, width=15).pack()
        tk.Label(self, text="Responsable :").pack(pady=8)
        tk.Entry(self, textvariable=self.resp_var, width=25).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=30, pady=18)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=30, pady=18)

        if self.caisse_id:
            self.load_caisse()

    def load_caisse(self):
        try:
            conn = get_connection()
            caisse = conn.execute(
                "SELECT nom, solde_initial, responsable FROM event_caisses WHERE id=? AND event_id=?",
                (self.caisse_id, self.event_id)
            ).fetchone()
            conn.close()
            if caisse:
                self.nom_var.set(caisse["nom"])
                self.solde_var.set(f"{caisse['solde_initial']:.2f}" if caisse["solde_initial"] is not None else "")
                self.resp_var.set(caisse["responsable"] or "")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement de la caisse."))

    def save(self):
        nom = self.nom_var.get().strip()
        solde = self.solde_var.get().replace(",", ".").strip()
        resp = self.resp_var.get().strip()
        if not nom:
            messagebox.showerror("Erreur", "Le nom de la caisse est obligatoire.")
            return
        try:
            solde_float = float(solde) if solde else 0.0
        except Exception:
            messagebox.showerror("Erreur", "Solde initial invalide.")
            return
        try:
            conn = get_connection()
            if self.caisse_id:
                conn.execute(
                    "UPDATE event_caisses SET nom=?, solde_initial=?, responsable=? WHERE id=? AND event_id=?",
                    (nom, solde_float, resp, self.caisse_id, self.event_id)
                )
            else:
                conn.execute(
                    "INSERT INTO event_caisses (event_id, nom, solde_initial, responsable) VALUES (?, ?, ?, ?)",
                    (self.event_id, nom, solde_float, resp)
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de la caisse."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/event_caisse_details.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("event_caisse_details")

class EventCaisseDetailsWindow(tk.Toplevel):
    def __init__(self, master, caisse_id):
        super().__init__(master)
        self.caisse_id = caisse_id
        self.title(f"DÃ©tails de la caisse {caisse_id}")
        self.geometry("800x450")
        self.create_widgets()
        self.refresh_details()

    def create_widgets(self):
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X)
        tk.Button(btn_frame, text="Nouvelle opÃ©ration", command=self.add_operation).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_operation).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)

        columns = ("id", "date", "type_op", "montant", "description", "justificatif")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        self.tree.heading("id", text="ID")
        self.tree.heading("date", text="Date")
        self.tree.heading("type_op", text="Type opÃ©ration")
        self.tree.heading("montant", text="Montant (â‚¬)")
        self.tree.heading("description", text="Description")
        self.tree.heading("justificatif", text="Justificatif")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

    def refresh_details(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            ops = conn.execute(
                "SELECT * FROM event_caisse_details WHERE caisse_id = ? ORDER BY date, id", (self.caisse_id,)
            ).fetchall()
            for op in ops:
                self.tree.insert(
                    "", "end",
                    values=(
                        op["id"],
                        op["date"],
                        op["type_op"],
                        f"{op['montant']:.2f}" if op["montant"] is not None else "",
                        op["description"] or "",
                        op["justificatif"] or ""
                    )
                )
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des opÃ©rations de caisse."))

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_operation(self):
        OperationDialog(self, caisse_id=self.caisse_id, on_save=self.refresh_details)

    def delete_operation(self):
        oid = self.get_selected_id()
        if not oid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une opÃ©ration Ã  supprimer.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer cette opÃ©ration ?"):
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM event_caisse_details WHERE id=? AND caisse_id=?", (oid, self.caisse_id))
            conn.commit()
            conn.close()
            logger.info(f"OpÃ©ration supprimÃ©e id {oid}, caisse_id {self.caisse_id}")
            self.refresh_details()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de l'opÃ©ration."))

class OperationDialog(tk.Toplevel):
    def __init__(self, master, caisse_id, operation_id=None, on_save=None):
        super().__init__(master)
        self.title("OpÃ©ration" if operation_id is None else "Ã‰diter opÃ©ration")
        self.caisse_id = caisse_id
        self.operation_id = operation_id
        self.on_save = on_save
        self.geometry("380x320")
        self.resizable(False, False)

        self.date_var = tk.StringVar()
        self.type_var = tk.StringVar()
        self.montant_var = tk.StringVar()
        self.desc_var = tk.StringVar()
        self.justif_var = tk.StringVar()

        tk.Label(self, text="Date (YYYY-MM-DD) :").pack(pady=6)
        tk.Entry(self, textvariable=self.date_var, width=20).pack()
        tk.Label(self, text="Type opÃ©ration :").pack(pady=6)
        type_ops = ["EntrÃ©e", "Sortie"]
        ttk.Combobox(self, textvariable=self.type_var, values=type_ops, state="readonly", width=15).pack()
        tk.Label(self, text="Montant (â‚¬) :").pack(pady=6)
        tk.Entry(self, textvariable=self.montant_var, width=14).pack()
        tk.Label(self, text="Description :").pack(pady=6)
        tk.Entry(self, textvariable=self.desc_var, width=30).pack()
        tk.Label(self, text="Justificatif :").pack(pady=6)
        tk.Entry(self, textvariable=self.justif_var, width=30).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=36, pady=16)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=36, pady=16)

        if self.operation_id:
            self.load_operation()

    def load_operation(self):
        try:
            conn = get_connection()
            op = conn.execute(
                "SELECT * FROM event_caisse_details WHERE id=? AND caisse_id=?",
                (self.operation_id, self.caisse_id)
            ).fetchone()
            conn.close()
            if op:
                self.date_var.set(op["date"])
                self.type_var.set(op["type_op"])
                self.montant_var.set(f"{op['montant']:.2f}" if op["montant"] is not None else "")
                self.desc_var.set(op["description"] or "")
                self.justif_var.set(op["justificatif"] or "")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement de l'opÃ©ration."))

    def save(self):
        date = self.date_var.get().strip()
        typ = self.type_var.get().strip()
        montant = self.montant_var.get().replace(",", ".").strip()
        desc = self.desc_var.get().strip()
        justif = self.justif_var.get().strip()
        if not date or not typ or not montant:
            messagebox.showerror("Erreur", "Date, type et montant sont obligatoires.")
            return
        try:
            montant_float = float(montant)
        except Exception:
            messagebox.showerror("Erreur", "Montant invalide.")
            return
        try:
            conn = get_connection()
            if self.operation_id:
                conn.execute(
                    "UPDATE event_caisse_details SET date=?, type_op=?, montant=?, description=?, justificatif=? WHERE id=? AND caisse_id=?",
                    (date, typ, montant_float, desc, justif, self.operation_id, self.caisse_id)
                )
            else:
                conn.execute(
                    "INSERT INTO event_caisse_details (caisse_id, date, type_op, montant, description, justificatif) VALUES (?, ?, ?, ?, ?, ?)",
                    (self.caisse_id, date, typ, montant_float, desc, justif)
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de l'opÃ©ration."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/event_depenses.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("event_depenses")

class EventDepensesWindow(tk.Toplevel):
    def __init__(self, master, event_id):
        super().__init__(master)
        self.title(f"DÃ©penses de l'Ã©vÃ©nement {event_id}")
        self.geometry("860x480")
        self.event_id = event_id
        self.create_widgets()
        self.refresh_depenses()

    def create_widgets(self):
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X)
        tk.Button(btn_frame, text="Nouvelle dÃ©pense", command=self.add_depense).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Ã‰diter", command=self.edit_depense).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_depense).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)

        columns = ("id", "date", "fournisseur", "categorie", "montant", "description", "justificatif")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        self.tree.heading("id", text="ID")
        self.tree.heading("date", text="Date")
        self.tree.heading("fournisseur", text="Fournisseur")
        self.tree.heading("categorie", text="CatÃ©gorie")
        self.tree.heading("montant", text="Montant (â‚¬)")
        self.tree.heading("description", text="Description")
        self.tree.heading("justificatif", text="Justificatif")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

    def refresh_depenses(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            depenses = conn.execute(
                "SELECT * FROM event_depenses WHERE event_id = ? ORDER BY date, id", (self.event_id,)
            ).fetchall()
            for dep in depenses:
                self.tree.insert(
                    "", "end",
                    values=(
                        dep["id"],
                        dep["date"],
                        dep["fournisseur"] or "",
                        dep["categorie"] or "",
                        f"{dep['montant']:.2f}" if dep["montant"] is not None else "",
                        dep["description"] or "",
                        dep["justificatif"] or ""
                    )
                )
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des dÃ©penses."))

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_depense(self):
        DepenseDialog(self, event_id=self.event_id, on_save=self.refresh_depenses)

    def edit_depense(self):
        did = self.get_selected_id()
        if not did:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une dÃ©pense Ã  Ã©diter.")
            return
        DepenseDialog(self, event_id=self.event_id, depense_id=did, on_save=self.refresh_depenses)

    def delete_depense(self):
        did = self.get_selected_id()
        if not did:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une dÃ©pense Ã  supprimer.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer cette dÃ©pense ?"):
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM event_depenses WHERE id=? AND event_id=?", (did, self.event_id))
            conn.commit()
            conn.close()
            logger.info(f"DÃ©pense supprimÃ©e id {did}, event_id {self.event_id}")
            self.refresh_depenses()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de la dÃ©pense."))

class DepenseDialog(tk.Toplevel):
    def __init__(self, master, event_id, depense_id=None, on_save=None):
        super().__init__(master)
        self.title("DÃ©pense" if depense_id is None else "Ã‰diter dÃ©pense")
        self.event_id = event_id
        self.depense_id = depense_id
        self.on_save = on_save
        self.geometry("410x370")
        self.resizable(False, False)

        self.date_var = tk.StringVar()
        self.fournisseur_var = tk.StringVar()
        self.categorie_var = tk.StringVar()
        self.montant_var = tk.StringVar()
        self.desc_var = tk.StringVar()
        self.justif_var = tk.StringVar()

        tk.Label(self, text="Date (YYYY-MM-DD) :").pack(pady=6)
        tk.Entry(self, textvariable=self.date_var, width=20).pack()
        tk.Label(self, text="Fournisseur :").pack(pady=6)
        tk.Entry(self, textvariable=self.fournisseur_var, width=32).pack()
        tk.Label(self, text="CatÃ©gorie :").pack(pady=6)
        tk.Entry(self, textvariable=self.categorie_var, width=28).pack()
        tk.Label(self, text="Montant (â‚¬) :").pack(pady=6)
        tk.Entry(self, textvariable=self.montant_var, width=14).pack()
        tk.Label(self, text="Description :").pack(pady=6)
        tk.Entry(self, textvariable=self.desc_var, width=36).pack()
        tk.Label(self, text="Justificatif :").pack(pady=6)
        tk.Entry(self, textvariable=self.justif_var, width=36).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=36, pady=16)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=36, pady=16)

        if self.depense_id:
            self.load_depense()

    def load_depense(self):
        try:
            conn = get_connection()
            dep = conn.execute(
                "SELECT * FROM event_depenses WHERE id=? AND event_id=?",
                (self.depense_id, self.event_id)
            ).fetchone()
            conn.close()
            if dep:
                self.date_var.set(dep["date"])
                self.fournisseur_var.set(dep["fournisseur"] or "")
                self.categorie_var.set(dep["categorie"] or "")
                self.montant_var.set(f"{dep['montant']:.2f}" if dep["montant"] is not None else "")
                self.desc_var.set(dep["description"] or "")
                self.justif_var.set(dep["justificatif"] or "")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement de la dÃ©pense."))

    def save(self):
        date = self.date_var.get().strip()
        fournisseur = self.fournisseur_var.get().strip()
        categorie = self.categorie_var.get().strip()
        montant = self.montant_var.get().replace(",", ".").strip()
        desc = self.desc_var.get().strip()
        justif = self.justif_var.get().strip()
        if not date or not montant:
            messagebox.showerror("Erreur", "Date et montant sont obligatoires.")
            return
        try:
            montant_float = float(montant)
        except Exception:
            messagebox.showerror("Erreur", "Montant invalide.")
            return
        try:
            conn = get_connection()
            if self.depense_id:
                conn.execute(
                    "UPDATE event_depenses SET date=?, fournisseur=?, categorie=?, montant=?, description=?, justificatif=? WHERE id=? AND event_id=?",
                    (date, fournisseur, categorie, montant_float, desc, justif, self.depense_id, self.event_id)
                )
            else:
                conn.execute(
                    "INSERT INTO event_depenses (event_id, date, fournisseur, categorie, montant, description, justificatif) VALUES (?, ?, ?, ?, ?, ?, ?)",
                    (self.event_id, date, fournisseur, categorie, montant_float, desc, justif)
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de la dÃ©pense."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/event_modules.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection
from modules.model_colonnes import GestionModelColonnes, ask_add_custom_column, get_choix_pour_colonne
from dialogs.add_row_dialog import AddRowDialog
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("event_modules")

class ChoiceDialog(tk.Toplevel):
    def __init__(self, master, label, choices):
        super().__init__(master)
        self.title("Choix")
        self.result = None
        self.var = tk.StringVar()
        tk.Label(self, text=label).pack(padx=10, pady=10)
        cb = ttk.Combobox(self, textvariable=self.var, values=choices, state="readonly")
        cb.pack(padx=10, pady=6)
        if choices:
            cb.current(0)
        btnf = tk.Frame(self)
        btnf.pack(pady=8)
        tk.Button(btnf, text="OK", command=self.on_ok).pack(side="left", padx=5)
        tk.Button(btnf, text="Annuler", command=self.on_cancel).pack(side="right", padx=5)
        self.bind("<Return>", lambda e: self.on_ok())
        self.bind("<Escape>", lambda e: self.on_cancel())
        self.grab_set()
        self.wait_window(self)

    def on_ok(self):
        self.result = self.var.get()
        self.destroy()

    def on_cancel(self):
        self.result = None
        self.destroy()

class EventModulesWindow(tk.Toplevel):
    def __init__(self, master, event_id):
        super().__init__(master)
        self.title("Modules/Tableaux personnalisÃ©s de l'Ã©vÃ©nement")
        self.geometry("800x500")
        self.event_id = event_id
        self.create_widgets()
        self.refresh_modules()

    def create_widgets(self):
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X)
        tk.Button(btn_frame, text="Nouveau module", command=self.add_module).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Ã‰diter", command=self.edit_module).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_module).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Ouvrir", command=self.open_module).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)

        self.tree = ttk.Treeview(self, columns=("id", "nom_module"), show="headings")
        self.tree.heading("id", text="ID")
        self.tree.heading("nom_module", text="Nom du module/tableau")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

    def refresh_modules(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            mods = conn.execute("SELECT * FROM event_modules WHERE event_id = ?", (self.event_id,)).fetchall()
            for mod in mods:
                self.tree.insert("", "end", values=(mod["id"], mod["nom_module"]))
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la rÃ©cupÃ©ration des modules personnalisÃ©s."))

    def get_selected_module_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_module(self):
        try:
            name = simpledialog.askstring("Module/Tableau", "Nom du module/tableau :")
            if not name:
                return
            conn = get_connection()
            conn.execute(
                "INSERT INTO event_modules (event_id, nom_module) VALUES (?, ?)",
                (self.event_id, name)
            )
            conn.commit()
            conn.close()
            self.refresh_modules()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'ajout du module."))

    def edit_module(self):
        mid = self.get_selected_module_id()
        if not mid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un module.")
            return
        name = simpledialog.askstring("Modifier nom", "Nouveau nom du module/tableau :")
        if not name:
            return
        try:
            conn = get_connection()
            conn.execute("UPDATE event_modules SET nom_module=? WHERE id=?", (name, mid))
            conn.commit()
            conn.close()
            self.refresh_modules()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la modification du module."))

    def delete_module(self):
        mid = self.get_selected_module_id()
        if not mid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un module.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer ce module/tableau ?"):
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM event_modules WHERE id=?", (mid,))
            conn.execute("DELETE FROM event_module_fields WHERE module_id=?", (mid,))
            conn.execute("DELETE FROM event_module_data WHERE module_id=?", (mid,))
            conn.commit()
            conn.close()
            self.refresh_modules()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression du module."))

    def open_module(self):
        mid = self.get_selected_module_id()
        if not mid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un module.")
            return
        ModuleTableWindow(self, module_id=mid)

class TypeChampDialog(simpledialog.Dialog):
    def body(self, master):
        tk.Label(master, text="Type du champ :", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="w", columnspan=2)
        self.type_var = tk.StringVar(value="TEXT")
        types = [("TEXT", "pour du texte (chaÃ®nes de caractÃ¨res)"),
                 ("INTEGER", "pour les nombres entiers"),
                 ("REAL", "pour les nombres dÃ©cimaux (ex: 3.14)")]
        for i, (val, desc) in enumerate(types):
            tk.Radiobutton(master, text=val, variable=self.type_var, value=val).grid(row=i+1, column=0, sticky="w")
            tk.Label(master, text=desc).grid(row=i+1, column=1, sticky="w")
        return None

    def apply(self):
        self.result = self.type_var.get()

class PrixUnitaireDialog(simpledialog.Dialog):
    def body(self, master):
        tk.Label(master, text="Associer un prix unitaire Ã  cette colonne ?", font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=2)
        tk.Label(master, text="Prix unitaire (â‚¬) (laisser vide pour aucun) :").grid(row=1, column=0, sticky="w")
        self.prix_var = tk.StringVar()
        tk.Entry(master, textvariable=self.prix_var, width=10).grid(row=1, column=1)
        return None

    def apply(self):
        try:
            self.result = float(self.prix_var.get().replace(",", "."))
        except Exception:
            self.result = None

class ModuleTableWindow(tk.Toplevel):
    def __init__(self, master, module_id):
        super().__init__(master)
        self.title("Gestion du tableau personnalisÃ©")
        self.geometry("1000x650")
        self.module_id = module_id
        self.editing_entry = None  # Pour l'Ã©dition de cellule
        self.id_col_total = self.get_id_col_total()  # id field de la colonne "Montant total" (ou None)
        self.create_widgets()
        self.refresh_fields()
        self.refresh_data()

    def create_widgets(self):
        btnf = tk.Frame(self)
        btnf.pack(fill=tk.X)
        tk.Button(btnf, text="Ajouter colonne", command=self.add_field).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Supprimer colonne", command=self.delete_field).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Ã‰diter colonne", command=self.edit_field).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="DÃ©finir colonne Montant total", command=self.set_total_column).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Ã‰diter prix", command=self.edit_column_price).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Ajouter ligne", command=self.add_row).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Supprimer ligne", command=self.delete_row).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Exporter PDF", command=self.export_pdf).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Exporter Excel", command=self.export_excel).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="ModÃ¨les de colonnes", command=self.open_model_colonnes).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=4)

        self.fields = []
        self.tree = ttk.Treeview(self, columns=[], show="headings", selectmode="browse")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)
        self.tree.bind("<Double-1>", self.on_cell_double_click)

    def open_model_colonnes(self):
        GestionModelColonnes(self)

    def refresh_fields(self):
        try:
            conn = get_connection()
            self.fields = conn.execute(
                "SELECT * FROM event_module_fields WHERE module_id = ? ORDER BY id", (self.module_id,)
            ).fetchall()
            conn.close()
            # Update tree columns
            self.tree["columns"] = [f["id"] for f in self.fields]
            for f in self.fields:
                titre = f["nom_champ"]
                if self.id_col_total and int(f["id"]) == self.id_col_total:
                    titre += " (Montant total)"
                else:
                    val_prix = f["prix_unitaire"] if "prix_unitaire" in f.keys() else None
                    if val_prix not in (None, "", 0):
                        try:
                            titre += f" ({float(val_prix):.2f}â‚¬)"
                        except Exception:
                            titre += f" ({val_prix}â‚¬)"
                self.tree.heading(f["id"], text=titre)
                self.tree.column(f["id"], width=120)
            self.tree["show"] = "headings"
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la rÃ©cupÃ©ration des colonnes du module."))

    def refresh_data(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            rows = conn.execute(
                "SELECT row_index FROM event_module_data WHERE module_id = ? GROUP BY row_index ORDER BY row_index", (self.module_id,)
            ).fetchall()
            for row in rows:
                values = []
                for f in self.fields:
                    val = conn.execute(
                        "SELECT valeur FROM event_module_data WHERE module_id = ? AND row_index = ? AND field_id = ?",
                        (self.module_id, row["row_index"], f["id"])
                    ).fetchone()
                    values.append("" if not val else val["valeur"])
                self.tree.insert("", "end", iid=row["row_index"], values=values)
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du rafraÃ®chissement des donnÃ©es du module."))

    def get_id_col_total(self):
        conn = get_connection()
        id_col = conn.execute("SELECT id_col_total FROM event_modules WHERE id=?", (self.module_id,)).fetchone()
        conn.close()
        return id_col["id_col_total"] if id_col and id_col["id_col_total"] else None

    def add_field(self):
        try:
            res = ask_add_custom_column(self)
            if not res:
                return
            name = res["name"]
            typ = res["type"]
            modele_colonne = res.get("modele_colonne")
            dlg_prix = PrixUnitaireDialog(self)
            prix = dlg_prix.result
            conn = get_connection()
            conn.execute(
                "INSERT INTO event_module_fields (module_id, nom_champ, type_champ, prix_unitaire, modele_colonne) VALUES (?, ?, ?, ?, ?)",
                (self.module_id, name, typ, prix, modele_colonne)
            )
            conn.commit()
            conn.close()
            self.refresh_fields()
            self.refresh_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'ajout de colonne."))

    def delete_field(self):
        try:
            if not self.fields:
                messagebox.showwarning("Suppression", "Aucune colonne Ã  supprimer.")
                return
            ch = [f"{f['nom_champ']} (id {f['id']})" for f in self.fields]
            idx = simpledialog.askinteger("Index colonne Ã  supprimer", f"Index (1-{len(self.fields)}) :\n"+"\n".join(f"{i+1}. {ch[i]}" for i in range(len(ch))))
            if not idx or idx < 1 or idx > len(self.fields):
                return
            field_id = self.fields[idx-1]["id"]
            conn = get_connection()
            conn.execute("DELETE FROM event_module_data WHERE module_id=? AND field_id=?", (self.module_id, field_id))
            conn.execute("DELETE FROM event_module_fields WHERE id=?", (field_id,))
            if self.id_col_total and int(field_id) == self.id_col_total:
                conn.execute("UPDATE event_modules SET id_col_total=NULL WHERE id=?", (self.module_id,))
                self.id_col_total = None
            conn.commit()
            conn.close()
            self.refresh_fields()
            self.refresh_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de colonne."))

    def edit_field(self):
        try:
            if not self.fields:
                messagebox.showwarning("Ã‰diter colonne", "Aucune colonne Ã  Ã©diter.")
                return
            ch = [f"{f['nom_champ']} (id {f['id']})" for f in self.fields]
            idx = simpledialog.askinteger(
                "Ã‰diter colonne",
                f"Index de la colonne Ã  Ã©diter (1-{len(self.fields)}) :\n" +
                "\n".join(f"{i+1}. {ch[i]}" for i in range(len(ch)))
            )
            if not idx or idx < 1 or idx > len(self.fields):
                return
            field = self.fields[idx-1]
            from dialogs.edit_field_dialog import EditFieldDialog
            def refresh_all():
                self.refresh_fields()
                self.recompute_all_totals()
                self.refresh_data()
            EditFieldDialog(
                self,
                self.module_id,
                field_id=field["id"],
                on_save=refresh_all,
                with_modele_colonne=True
            )
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'Ã©dition de colonne."))

    def set_total_column(self):
        try:
            if not self.fields:
                messagebox.showwarning("Montant total", "Ajoute d'abord des colonnes.")
                return
            ch = [f"{f['nom_champ']} (id {f['id']})" for f in self.fields]
            idx = simpledialog.askinteger("Colonne total", f"Quelle colonne doit contenir le montant total ?\nIndex (1-{len(self.fields)}) :\n"+"\n".join(f"{i+1}. {ch[i]}" for i in range(len(ch))))
            if not idx or idx < 1 or idx > len(self.fields):
                return
            field_id = int(self.fields[idx-1]["id"])
            conn = get_connection()
            conn.execute("UPDATE event_modules SET id_col_total=? WHERE id=?", (field_id, self.module_id))
            conn.commit()
            conn.close()
            self.id_col_total = field_id
            self.recompute_all_totals()
            self.refresh_fields()
            self.refresh_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la dÃ©finition de la colonne total."))

    def add_row(self):
        try:
            if not self.fields:
                messagebox.showwarning("Champs", "Ajoute d'abord des colonnes.")
                return
            def get_choices(modele_colonne_nom):
                conn = get_connection()
                row = conn.execute("SELECT id FROM colonnes_modeles WHERE name=?", (modele_colonne_nom,)).fetchone()
                if not row:
                    return []
                modele_id = row["id"]
                choix = [v["valeur"] for v in conn.execute("SELECT valeur FROM valeurs_modeles_colonnes WHERE modele_id=?", (modele_id,)).fetchall()]
                conn.close()
                return choix
            dlg = AddRowDialog(self, self.fields, get_choices)
            if not dlg.result:
                return
            conn = get_connection()
            row_idx = conn.execute(
                "SELECT MAX(row_index) as mx FROM event_module_data WHERE module_id = ?", (self.module_id,)
            ).fetchone()
            next_row = 1 if not row_idx or not row_idx["mx"] else row_idx["mx"] + 1
            for f in self.fields:
                val = dlg.result.get(f["id"], "")
                conn.execute(
                    "INSERT INTO event_module_data (module_id, row_index, field_id, valeur) VALUES (?, ?, ?, ?)",
                    (self.module_id, next_row, f["id"], val)
                )
            conn.commit()
            if self.id_col_total:
                self.recompute_total_for_row(next_row)
            conn.close()
            self.refresh_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'ajout de ligne."))

    def delete_row(self):
        try:
            sel = self.tree.selection()
            if not sel:
                messagebox.showwarning("SÃ©lection", "SÃ©lectionne une ligne Ã  supprimer.")
                return
            row_idx = int(sel[0])
            conn = get_connection()
            conn.execute("DELETE FROM event_module_data WHERE module_id=? AND row_index=?", (self.module_id, row_idx))
            conn.commit()
            conn.close()
            self.refresh_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de ligne."))

    def on_cell_double_click(self, event):
        if self.editing_entry is not None:
            return
        region = self.tree.identify_region(event.x, event.y)
        if region != "cell":
            return
        col = self.tree.identify_column(event.x)
        rowid = self.tree.identify_row(event.y)
        if not rowid or not col:
            return
        col_idx = int(col.replace('#', '')) - 1
        if col_idx < 0 or col_idx >= len(self.fields):
            return
        selected_field = self.fields[col_idx]
        x, y, width, height = self.tree.bbox(rowid, col)
        value = self.tree.set(rowid, selected_field["id"])
        entry = tk.Entry(self.tree, width=16)
        entry.place(x=x, y=y, width=width, height=height)
        entry.insert(0, value)
        entry.focus()
        entry.select_range(0, tk.END)
        self.editing_entry = entry

        def on_validate(e=None):
            try:
                new_value = entry.get()
                conn = get_connection()
                res = conn.execute(
                    "SELECT id FROM event_module_data WHERE module_id=? AND row_index=? AND field_id=?",
                    (self.module_id, int(rowid), selected_field["id"])
                ).fetchone()
                if res:
                    conn.execute(
                        "UPDATE event_module_data SET valeur=? WHERE id=?",
                        (new_value, res["id"])
                    )
                else:
                    conn.execute(
                        "INSERT INTO event_module_data (module_id, row_index, field_id, valeur) VALUES (?, ?, ?, ?)",
                        (self.module_id, int(rowid), selected_field["id"], new_value)
                    )
                conn.commit()
                conn.close()
                entry.destroy()
                self.editing_entry = None
                if self.id_col_total:
                    self.recompute_total_for_row(int(rowid))
                self.refresh_data()
            except Exception as e:
                entry.destroy()
                self.editing_entry = None
                messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la modification de cellule."))

        def on_cancel(e=None):
            entry.destroy()
            self.editing_entry = None

        entry.bind("<Return>", on_validate)
        entry.bind("<FocusOut>", on_cancel)

    def edit_column_price(self):
        try:
            if not self.fields:
                messagebox.showwarning("Prix unitaire", "Aucune colonne Ã  Ã©diter.")
                return
            ch = [f"{f['nom_champ']} (id {f['id']})" for f in self.fields]
            idx = simpledialog.askinteger(
                "Ã‰diter prix",
                f"Index de la colonne (1-{len(self.fields)}) :\n" +
                "\n".join(f"{i+1}. {ch[i]}" for i in range(len(ch)))
            )
            if not idx or idx < 1 or idx > len(self.fields):
                return
            field_id = self.fields[idx-1]["id"]
            old_price = self.fields[idx-1]["prix_unitaire"]
            new_price = simpledialog.askstring(
                "Prix unitaire",
                f"Nouveau prix unitaire (â‚¬) pour {self.fields[idx-1]['nom_champ']} (laisse vide pour aucun) :",
                initialvalue=old_price if old_price not in (None, "") else ""
            )
            if new_price is None:
                return  # AnnulÃ©
            conn = get_connection()
            conn.execute("UPDATE event_module_fields SET prix_unitaire=? WHERE id=?", (new_price if new_price else None, field_id))
            conn.commit()
            conn.close()
            self.refresh_fields()
            self.recompute_all_totals()
            self.refresh_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la modification du prix de colonne."))

    def recompute_total_for_row(self, rowid):
        try:
            if not self.id_col_total:
                return
            conn = get_connection()
            total = 0.0
            for f in self.fields:
                val_prix = f["prix_unitaire"] if "prix_unitaire" in f.keys() else None
                if val_prix not in (None, "", 0):
                    try:
                        prix = float(val_prix)
                    except Exception:
                        prix = 0
                    val_row = conn.execute(
                        "SELECT valeur FROM event_module_data WHERE module_id=? AND row_index=? AND field_id=?",
                        (self.module_id, rowid, f["id"])
                    ).fetchone()
                    try:
                        qte = float(val_row["valeur"]) if val_row and val_row["valeur"] not in (None, "") else 0
                    except Exception:
                        qte = 0
                    total += qte * prix
            res_total = conn.execute(
                "SELECT id FROM event_module_data WHERE module_id=? AND row_index=? AND field_id=?",
                (self.module_id, rowid, self.id_col_total)
            ).fetchone()
            if res_total:
                conn.execute(
                    "UPDATE event_module_data SET valeur=? WHERE id=?",
                    (f"{total:.2f}", res_total["id"])
                )
            else:
                conn.execute(
                    "INSERT INTO event_module_data (module_id, row_index, field_id, valeur) VALUES (?, ?, ?, ?)",
                    (self.module_id, rowid, self.id_col_total, f"{total:.2f}")
                )
            conn.commit()
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du calcul du total ligne."))

    def recompute_all_totals(self):
        try:
            if not self.id_col_total:
                return
            conn = get_connection()
            rows = conn.execute(
                "SELECT row_index FROM event_module_data WHERE module_id = ? GROUP BY row_index ORDER BY row_index", (self.module_id,)
            ).fetchall()
            conn.close()
            for row in rows:
                self.recompute_total_for_row(row["row_index"])
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du recalcul des totaux."))

    def export_pdf(self):
        try:
            import sys, os
            parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
            if parent_dir not in sys.path:
                sys.path.append(parent_dir)
            from exports.exports import export_dataframe_to_pdf
        except ImportError as e:
            messagebox.showerror("Export PDF", "Le module d'export PDF n'est pas disponible.")
            return

        try:
            conn = get_connection()
            fields = conn.execute(
                "SELECT * FROM event_module_fields WHERE module_id = ? ORDER BY id", (self.module_id,)
            ).fetchall()
            rows = conn.execute(
                "SELECT row_index FROM event_module_data WHERE module_id = ? GROUP BY row_index ORDER BY row_index", (self.module_id,)
            ).fetchall()
            headers = [f["nom_champ"] for f in fields]
            data = []
            for row in rows:
                values = []
                for f in fields:
                    val = conn.execute(
                        "SELECT valeur FROM event_module_data WHERE module_id=? AND row_index=? AND field_id=?",
                        (self.module_id, row["row_index"], f["id"])
                    ).fetchone()
                    values.append("" if not val else val["valeur"])
                data.append(values)
            import pandas as pd
            df = pd.DataFrame(data, columns=headers)
            conn.close()
            export_dataframe_to_pdf(df, title="Export PDF - Module personnalisÃ©")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'export PDF du module personnalisÃ©."))

    def export_excel(self):
        try:
            import sys, os
            parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
            if parent_dir not in sys.path:
                sys.path.append(parent_dir)
            from exports.exports import export_dataframe_to_excel
        except ImportError as e:
            from tkinter import messagebox
            messagebox.showerror("Export Excel", "Le module d'export Excel n'est pas disponible.")
            return

        try:
            conn = get_connection()
            fields = conn.execute(
                "SELECT * FROM event_module_fields WHERE module_id = ? ORDER BY id", (self.module_id,)
            ).fetchall()
            rows = conn.execute(
                "SELECT row_index FROM event_module_data WHERE module_id = ? GROUP BY row_index ORDER BY row_index", (self.module_id,)
            ).fetchall()
            headers = [f["nom_champ"] for f in fields]
            data = []
            for row in rows:
                values = []
                for f in fields:
                    val = conn.execute(
                        "SELECT valeur FROM event_module_data WHERE module_id=? AND row_index=? AND field_id=?",
                        (self.module_id, row["row_index"], f["id"])
                    ).fetchone()
                    values.append("" if not val else val["valeur"])
                data.append(values)
            import pandas as pd
            df = pd.DataFrame(data, columns=headers)
            conn.close()
            export_dataframe_to_excel(df, title="Export Excel - Module personnalisÃ©")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'export Excel du module personnalisÃ©."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/event_module_data.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
import pandas as pd
from db.db import get_connection, DataSource, get_df_or_sql
from utils.error_handler import handle_exception
from utils.app_logger import get_logger

logger = get_logger("event_module_data")

def ask_choice_value(parent, champ, choix):
    class ChoiceDialog(simpledialog.Dialog):
        def body(self, master):
            tk.Label(master, text=f"Valeur pour {champ} :").pack()
            self.var = tk.StringVar()
            self.combo = ttk.Combobox(master, textvariable=self.var, values=choix, state="readonly")
            self.combo.pack()
            if choix:
                self.combo.current(0)
            return self.combo
        def apply(self):
            self.result = self.var.get()
    d = ChoiceDialog(parent)
    return d.result

class EventModuleDataWindow(tk.Toplevel):
    def __init__(self, master, module_id):
        super().__init__(master)
        self.title("DonnÃ©es du module personnalisÃ©")
        self.module_id = module_id
        try:
            self.fields = self.load_fields()
            self.create_widgets()
            self.load_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'initialisation de la fenÃªtre de donnÃ©es du module."))

    def load_fields(self):
        try:
            conn = get_connection()
            df = pd.read_sql_query(
                "SELECT id, nom_champ, modele_colonne FROM event_module_fields WHERE module_id=?",
                conn, params=(self.module_id,)
            )
            conn.close()
            return df.to_records(index=False)
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement des colonnes du module."))
            return []

    def create_widgets(self):
        cols = ["row_index"] + [f[1] for f in self.fields]
        self.tree = ttk.Treeview(self, columns=cols, show="headings", selectmode="browse")
        for col in cols:
            self.tree.heading(col, text=col.capitalize())
            self.tree.column(col, width=110)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X, pady=6)
        tk.Button(btn_frame, text="Ajouter", command=self.add_row).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Modifier", command=self.edit_row).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_row).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=6)

    def load_data(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            df = pd.read_sql_query("SELECT * FROM event_module_data WHERE module_id=? ORDER BY row_index", conn, params=(self.module_id,))
            conn.close()
            grouped = {}
            for _, row in df.iterrows():
                idx = row["row_index"]
                if idx not in grouped:
                    grouped[idx] = {}
                grouped[idx][row["field_id"]] = row["valeur"]
            for idx in sorted(grouped):
                vals = [idx] + [grouped[idx].get(f[0], "") for f in self.fields]
                self.tree.insert("", "end", values=vals)
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des donnÃ©es du module."))

    def get_selected_row_index(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne.")
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_row(self):
        try:
            # DÃ©termine le prochain row_index
            conn = get_connection()
            res = conn.execute("SELECT MAX(row_index) FROM event_module_data WHERE module_id=?", (self.module_id,)).fetchone()
            next_idx = (res[0] or 0) + 1
            conn.close()

            row_values = []
            for field in self.fields:
                field_id, nom_champ, modele_colonne = field
                if modele_colonne:
                    # RÃ©cupÃ¨re les valeurs du modÃ¨le
                    conn = get_connection()
                    res = conn.execute(
                        "SELECT valeur FROM valeurs_modeles_colonnes WHERE modele_id=(SELECT id FROM colonnes_modeles WHERE name=?)",
                        (modele_colonne,)
                    ).fetchall()
                    conn.close()
                    choix = [r["valeur"] for r in res]
                    valeur = ask_choice_value(self, nom_champ, choix)
                else:
                    valeur = simpledialog.askstring("Saisie", f"Valeur pour {nom_champ} :", parent=self)
                if valeur is None:
                    return  # AnnulÃ©
                row_values.append((field_id, valeur))

            # Enregistre chaque valeur dans event_module_data
            conn = get_connection()
            for field_id, valeur in row_values:
                conn.execute(
                    "INSERT INTO event_module_data (module_id, row_index, field_id, valeur) VALUES (?, ?, ?, ?)",
                    (self.module_id, next_idx, field_id, valeur)
                )
            conn.commit()
            conn.close()
            self.load_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'ajout d'une ligne."))

    def edit_row(self):
        messagebox.showinfo("Non implÃ©mentÃ©", "L'Ã©dition des lignes n'est pas encore implÃ©mentÃ©e !")

    def delete_row(self):
        rowidx = self.get_selected_row_index()
        if rowidx is not None and messagebox.askyesno("Suppression", f"Supprimer la ligne {rowidx}â€¯?"):
            try:
                conn = get_connection()
                conn.execute("DELETE FROM event_module_data WHERE module_id=? AND row_index=?", (self.module_id, rowidx))
                conn.commit()
                conn.close()
                self.load_data()
            except Exception as e:
                messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de la ligne."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/event_module_fields.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection, DataSource, get_df_or_sql
from dialogs.edit_field_dialog import EditFieldDialog
from utils.error_handler import handle_exception
from utils.app_logger import get_logger

logger = get_logger("event_module_fields")

class EventModuleFieldsWindow(tk.Toplevel):
    def __init__(self, master, module_id):
        super().__init__(master)
        self.title("Champs du module personnalisÃ©")
        self.module_id = module_id
        self.create_widgets()
        self.refresh_fields()

    def create_widgets(self):
        columns = ("id", "nom_champ", "type_champ", "prix_unitaire", "modele_colonne")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        self.tree.heading("id", text="ID")
        self.tree.column("id", width=60)
        self.tree.heading("nom_champ", text="Nom")
        self.tree.column("nom_champ", width=180)
        self.tree.heading("type_champ", text="Type")
        self.tree.column("type_champ", width=80)
        self.tree.heading("prix_unitaire", text="Prix unitaire (â‚¬)")
        self.tree.column("prix_unitaire", width=120)
        self.tree.heading("modele_colonne", text="ModÃ¨le colonne")
        self.tree.column("modele_colonne", width=140)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X, pady=6)
        tk.Button(btn_frame, text="Ajouter", command=self.add_field).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Modifier", command=self.edit_field).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_field).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Ã‰diter prix", command=self.edit_field_price).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=6)

    def refresh_fields(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            if getattr(DataSource, "is_visualisation", False):
                df = get_df_or_sql("event_module_fields")
                dict_items = df[df["module_id"] == self.module_id].to_dict("records")
            else:
                conn = get_connection()
                dict_items = conn.execute(
                    "SELECT id, nom_champ, type_champ, prix_unitaire, modele_colonne FROM event_module_fields WHERE module_id=? ORDER BY id", (self.module_id,)
                ).fetchall()
                conn.close()
            for item in dict_items:
                prix = item["prix_unitaire"] if isinstance(item, dict) else item[3]
                prix_aff = f"{float(prix):.2f}" if prix not in (None, "", 0) else ""
                modele = item["modele_colonne"] if isinstance(item, dict) else item[4]
                vals = [
                    item["id"] if isinstance(item, dict) else item[0],
                    item["nom_champ"] if isinstance(item, dict) else item[1],
                    item["type_champ"] if isinstance(item, dict) else item[2],
                    prix_aff,
                    modele or ""
                ]
                self.tree.insert("", "end", values=vals)
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des champs du module."))

    def get_selected_field_id(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un champ.")
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_field(self):
        try:
            EditFieldDialog(self, self.module_id, None, on_save=self.refresh_fields, with_modele_colonne=True)
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'ajout d'un champ."))

    def edit_field(self):
        fid = self.get_selected_field_id()
        if fid is not None:
            try:
                EditFieldDialog(self, self.module_id, fid, on_save=self.refresh_fields, with_modele_colonne=True)
            except Exception as e:
                messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la modification du champ."))

    def delete_field(self):
        fid = self.get_selected_field_id()
        if fid is not None and messagebox.askyesno("Suppression", "Supprimer ce champâ€¯?"):
            try:
                conn = get_connection()
                conn.execute("DELETE FROM event_module_fields WHERE id=?", (fid,))
                conn.commit()
                conn.close()
                self.refresh_fields()
            except Exception as e:
                messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression du champ."))

    def edit_field_price(self):
        fid = self.get_selected_field_id()
        if fid is None:
            return
        try:
            conn = get_connection()
            champ = conn.execute("SELECT nom_champ, prix_unitaire FROM event_module_fields WHERE id=?", (fid,)).fetchone()
            conn.close()
            if champ is None:
                return
            old_price = champ["prix_unitaire"]
            new_price = simpledialog.askstring(
                "Prix unitaire",
                f"Nouveau prix unitaire (â‚¬) pour Â«Â {champ['nom_champ']}Â Â» (laisser vide pour aucun) :",
                initialvalue=str(old_price) if old_price not in (None, "") else ""
            )
            if new_price is None:
                return  # AnnulÃ©
            conn = get_connection()
            conn.execute("UPDATE event_module_fields SET prix_unitaire=? WHERE id=?", (new_price if new_price else None, fid))
            conn.commit()
            conn.close()
            self.refresh_fields()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la modification du prix du champ."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/event_payments.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("event_payments")

class PaymentsWindow(tk.Toplevel):
    def __init__(self, master, event_id):
        super().__init__(master)
        self.title("Paiements de l'Ã©vÃ©nement")
        self.geometry("900x500")
        self.event_id = event_id
        self.create_widgets()
        self.refresh_payments()

    def create_widgets(self):
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X)
        tk.Button(btn_frame, text="Ajouter paiement", command=self.add_payment).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Ã‰diter", command=self.edit_payment).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_payment).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)

        cols = ("id", "nom_payeuse", "classe", "mode_paiement", "banque", "numero_cheque", "montant", "commentaire")
        labels = ("ID", "Name", "Classe", "Mode", "Banque", "NÂ° ChÃ¨que", "Montant", "Commentaire")
        self.tree = ttk.Treeview(self, columns=cols, show="headings")
        for c, l in zip(cols, labels):
            self.tree.heading(c, text=l)
            self.tree.column(c, width=120 if c=="montant" else 110)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=7, pady=7)

    def refresh_payments(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            pays = conn.execute(
                "SELECT * FROM event_payments WHERE event_id = ? ORDER BY id DESC", (self.event_id,)
            ).fetchall()
            for p in pays:
                self.tree.insert("", "end", values=(
                    p["id"], p["nom_payeuse"], p["classe"], p["mode_paiement"], p["banque"], p["numero_cheque"], p["montant"], p["commentaire"]
                ))
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des paiements."))

    def get_selected_payment_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_payment(self):
        PaymentDialog(self, event_id=self.event_id, on_save=self.refresh_payments)

    def edit_payment(self):
        pid = self.get_selected_payment_id()
        if not pid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un paiement.")
            return
        PaymentDialog(self, event_id=self.event_id, payment_id=pid, on_save=self.refresh_payments)

    def delete_payment(self):
        pid = self.get_selected_payment_id()
        if not pid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un paiement.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer ce paiement ?"):
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM event_payments WHERE id=?", (pid,))
            conn.commit()
            conn.close()
            self.refresh_payments()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression du paiement."))

class PaymentDialog(tk.Toplevel):
    def __init__(self, master, event_id, payment_id=None, on_save=None):
        super().__init__(master)
        self.title("Paiement")
        self.event_id = event_id
        self.payment_id = payment_id
        self.on_save = on_save
        self.geometry("500x420")
        self.resizable(False, False)

        self.nom_var = tk.StringVar()
        self.classe_var = tk.StringVar()
        self.mode_var = tk.StringVar()
        self.banque_var = tk.StringVar()
        self.numero_var = tk.StringVar()
        self.montant_var = tk.DoubleVar()
        self.comment_var = tk.StringVar()

        tk.Label(self, text="Name payeur.se :").pack(pady=5)
        tk.Entry(self, textvariable=self.nom_var, width=40).pack()
        tk.Label(self, text="Classe :").pack(pady=5)
        tk.Entry(self, textvariable=self.classe_var, width=20).pack()
        tk.Label(self, text="Mode paiement (C/E/autre) :").pack(pady=5)
        tk.Entry(self, textvariable=self.mode_var, width=8).pack()
        tk.Label(self, text="Banque :").pack(pady=5)
        tk.Entry(self, textvariable=self.banque_var, width=20).pack()
        tk.Label(self, text="NÂ° chÃ¨que :").pack(pady=5)
        tk.Entry(self, textvariable=self.numero_var, width=20).pack()
        tk.Label(self, text="Montant :").pack(pady=5)
        tk.Entry(self, textvariable=self.montant_var, width=10).pack()
        tk.Label(self, text="Commentaire :").pack(pady=5)
        tk.Entry(self, textvariable=self.comment_var, width=35).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=36, pady=16)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=36, pady=16)

        if self.payment_id:
            self.load_payment()

    def load_payment(self):
        try:
            conn = get_connection()
            p = conn.execute("SELECT * FROM event_payments WHERE id=?", (self.payment_id,)).fetchone()
            conn.close()
            if p:
                self.nom_var.set(p["nom_payeuse"])
                self.classe_var.set(p["classe"])
                self.mode_var.set(p["mode_paiement"])
                self.banque_var.set(p["banque"])
                self.numero_var.set(p["numero_cheque"])
                self.montant_var.set(p["montant"])
                self.comment_var.set(p["commentaire"])
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement du paiement."))

    def save(self):
        d = dict(
            name=self.nom_var.get().strip(),
            classe=self.classe_var.get().strip(),
            mode=self.mode_var.get().strip(),
            banque=self.banque_var.get().strip(),
            numero=self.numero_var.get().strip(),
            montant=self.montant_var.get(),
            comment=self.comment_var.get().strip()
        )
        if not d["name"]:
            messagebox.showerror("Erreur", "Name obligatoire.")
            return
        if not d["mode"]:
            messagebox.showerror("Erreur", "Mode de paiement obligatoire.")
            return
        try:
            conn = get_connection()
            if self.payment_id:
                conn.execute(
                    "UPDATE event_payments SET nom_payeuse=?, classe=?, mode_paiement=?, banque=?, numero_cheque=?, montant=?, commentaire=? WHERE id=?",
                    (d["name"], d["classe"], d["mode"], d["banque"], d["numero"], d["montant"], d["comment"], self.payment_id)
                )
            else:
                conn.execute(
                    "INSERT INTO event_payments (event_id, nom_payeuse, classe, mode_paiement, banque, numero_cheque, montant, commentaire) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                    (self.event_id, d["name"], d["classe"], d["mode"], d["banque"], d["numero"], d["montant"], d["comment"])
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement du paiement."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/event_recettes.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("event_recettes")

def update_vente_sur_place_recette(event_id):
    """Calcule le gain de toutes les caisses et l'ajoute/actualise la recette 'Vente sur place'."""
    try:
        conn = get_connection()
        gain_total = 0
        caisses = conn.execute("SELECT id FROM event_caisses WHERE event_id=?", (event_id,)).fetchall()
        for caisse in caisses:
            cid = caisse["id"]
            r = conn.execute(
                "SELECT SUM(CASE WHEN type='cheque' THEN valeur ELSE valeur*quantite END) AS tot FROM event_caisse_details WHERE caisse_id=? AND moment='debut'", (cid,)
            ).fetchone()
            fond_debut = r["tot"] if r["tot"] else 0
            r = conn.execute(
                "SELECT SUM(CASE WHEN type='cheque' THEN valeur ELSE valeur*quantite END) AS tot FROM event_caisse_details WHERE caisse_id=? AND moment='fin'", (cid,)
            ).fetchone()
            fond_fin = r["tot"] if r["tot"] else 0
            gain_total += (fond_fin - fond_debut)
        exist = conn.execute("SELECT id FROM event_recettes WHERE event_id=? AND source='Vente sur place'", (event_id,)).fetchone()
        if exist:
            conn.execute("UPDATE event_recettes SET montant=? WHERE id=?", (gain_total, exist["id"]))
        else:
            conn.execute("INSERT INTO event_recettes (event_id, source, montant) VALUES (?, 'Vente sur place', ?)", (event_id, gain_total))
        conn.commit()
        conn.close()
    except Exception as e:
        logger.error(f"Erreur update_vente_sur_place_recette: {e}")

class EventRecettesWindow(tk.Toplevel):
    def __init__(self, master, event_id):
        super().__init__(master)
        self.title("Recettes de l'Ã©vÃ©nement")
        self.geometry("850x400")
        self.event_id = event_id

        try:
            update_vente_sur_place_recette(self.event_id)
        except Exception as e:
            logger.error(f"Erreur lors de l'update automatique 'Vente sur place': {e}")

        self.create_widgets()
        self.refresh_recettes()

    def create_widgets(self):
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X)
        tk.Button(btn_frame, text="Ajouter recette", command=self.add_recette).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Ã‰diter", command=self.edit_recette).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_recette).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)
        self.tree = ttk.Treeview(self, columns=("id", "source", "module", "montant", "commentaire"), show="headings")
        for col, lbl in zip(("id", "source", "module", "montant", "commentaire"),
                            ("ID", "Source", "Module liÃ©", "Montant (â‚¬)", "Commentaire")):
            self.tree.heading(col, text=lbl)
            self.tree.column(col, width=120 if col in ("montant", "module") else 170)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

    def refresh_recettes(self):
        try:
            self.tree.delete(*self.tree.get_children())
            conn = get_connection()
            recettes = conn.execute("SELECT * FROM event_recettes WHERE event_id=? ORDER BY source", (self.event_id,)).fetchall()
            for r in recettes:
                module_name = ""
                if r["module_id"]:
                    mod = conn.execute("SELECT nom_module FROM event_modules WHERE id=?", (r["module_id"],)).fetchone()
                    if mod:
                        module_name = mod["nom_module"]
                self.tree.insert("", "end", values=(r["id"], r["source"], module_name, f"{r['montant']:.2f}", r["commentaire"] if r["commentaire"] else ""))
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des recettes."))

    def get_selected_recette_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_recette(self):
        RecetteDialog(self, event_id=self.event_id, on_save=self.refresh_recettes)

    def edit_recette(self):
        rid = self.get_selected_recette_id()
        if not rid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une recette.")
            return
        RecetteDialog(self, event_id=self.event_id, recette_id=rid, on_save=self.refresh_recettes)

    def delete_recette(self):
        rid = self.get_selected_recette_id()
        if not rid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une recette.")
            return
        try:
            conn = get_connection()
            r = conn.execute("SELECT source FROM event_recettes WHERE id=?", (rid,)).fetchone()
            if r and r["source"] == "Vente sur place":
                messagebox.showerror("Erreur", "Impossible de supprimer la recette automatique 'Vente sur place'.")
                conn.close()
                return
            conn.execute("DELETE FROM event_recettes WHERE id=?", (rid,))
            conn.commit()
            conn.close()
            self.refresh_recettes()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de la recette."))

class RecetteDialog(tk.Toplevel):
    def __init__(self, master, event_id, recette_id=None, on_save=None):
        super().__init__(master)
        self.title("Recette" if not recette_id else "Ã‰diter la recette")
        self.event_id = event_id
        self.recette_id = recette_id
        self.on_save = on_save
        self.geometry("460x350")
        self.resizable(False, False)
        self.source_var = tk.StringVar()
        self.montant_var = tk.DoubleVar()
        self.comment_var = tk.StringVar()
        self.module_var = tk.StringVar()
        self.colonne_var = tk.StringVar()
        self.module_choices = []
        self.colonnes_choices = []

        tk.Label(self, text="Source :").pack(pady=4)
        tk.Entry(self, textvariable=self.source_var, width=35).pack()

        tk.Label(self, text="Module liÃ© :").pack(pady=4)
        self.module_menu = ttk.Combobox(self, textvariable=self.module_var, state="readonly")
        self.module_menu.pack()
        self.module_menu.bind("<<ComboboxSelected>>", self.on_module_selected)

        self.colonne_frame = tk.Frame(self)
        self.colonne_label = tk.Label(self.colonne_frame, text="Colonne Ã  sommer :")
        self.colonne_menu = ttk.Combobox(self.colonne_frame, textvariable=self.colonne_var, state="readonly")
        self.colonne_label.pack(side=tk.LEFT)
        self.colonne_menu.pack(side=tk.LEFT)
        self.colonne_frame.pack(pady=4)
        self.colonne_frame.pack_forget()  # cachÃ©e par dÃ©faut
        self.colonne_menu.bind("<<ComboboxSelected>>", self.update_montant_from_colonne)

        tk.Label(self, text="Montant (â‚¬) :").pack(pady=4)
        self.montant_entry = tk.Entry(self, textvariable=self.montant_var, width=20)
        self.montant_entry.pack()

        tk.Label(self, text="Commentaire :").pack(pady=4)
        tk.Entry(self, textvariable=self.comment_var, width=45).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=30, pady=14)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=30, pady=14)

        self.populate_module_menu()
        if self.recette_id:
            self.load_recette()

    def populate_module_menu(self):
        try:
            conn = get_connection()
            mods = conn.execute("SELECT id, nom_module FROM event_modules WHERE event_id=?", (self.event_id,)).fetchall()
            self.module_choices = [("", "Aucun")] + [(str(m["id"]), m["nom_module"]) for m in mods]
            self.module_menu['values'] = [name for _, name in self.module_choices]
            self.module_menu.current(0)
            conn.close()
            self.hide_colonne_menu()
        except Exception as e:
            logger.error(f"Erreur populate_module_menu: {e}")

    def populate_colonne_menu(self, module_id):
        try:
            conn = get_connection()
            fields = conn.execute("SELECT id, nom_champ FROM event_module_fields WHERE module_id=?", (module_id,)).fetchall()
            conn.close()
            self.colonnes_choices = [(str(f["id"]), f["nom_champ"]) for f in fields]
            if not self.colonnes_choices:
                self.hide_colonne_menu()
                return
            self.colonne_menu['values'] = [name for _, name in self.colonnes_choices]
            self.colonne_menu.current(0)
            self.show_colonne_menu()
            self.update_montant_from_colonne()
        except Exception as e:
            logger.error(f"Erreur populate_colonne_menu: {e}")

    def hide_colonne_menu(self):
        self.colonne_frame.pack_forget()

    def show_colonne_menu(self):
        self.colonne_frame.pack(pady=4)

    def on_module_selected(self, event=None):
        idx = self.module_menu.current()
        if idx > 0:
            module_id = int(self.module_choices[idx][0])
            self.populate_colonne_menu(module_id)
            self.montant_entry.config(state="readonly")
        else:
            self.hide_colonne_menu()
            self.montant_entry.config(state="normal")

    def update_montant_from_colonne(self, event=None):
        module_idx = self.module_menu.current()
        colonne_idx = self.colonne_menu.current()
        if module_idx > 0 and colonne_idx >= 0 and self.colonnes_choices:
            module_id = int(self.module_choices[module_idx][0])
            field_id = int(self.colonnes_choices[colonne_idx][0])
            try:
                conn = get_connection()
                rows = conn.execute(
                    "SELECT valeur FROM event_module_data WHERE module_id=? AND field_id=?", (module_id, field_id)
                ).fetchall()
                somme = 0.0
                for r in rows:
                    try:
                        somme += float(r["valeur"])
                    except (TypeError, ValueError):
                        pass
                conn.close()
                self.montant_var.set(round(somme, 2))
            except Exception as e:
                logger.error(f"Erreur update_montant_from_colonne: {e}")

    def load_recette(self):
        try:
            conn = get_connection()
            r = conn.execute("SELECT * FROM event_recettes WHERE id=?", (self.recette_id,)).fetchone()
            conn.close()
            if r:
                self.source_var.set(r["source"])
                self.montant_var.set(r["montant"])
                self.comment_var.set(r["commentaire"] or "")
                if r["module_id"]:
                    for i, (mid, name) in enumerate(self.module_choices):
                        if mid and int(mid) == r["module_id"]:
                            self.module_menu.current(i)
                            self.populate_colonne_menu(int(mid))
                            break
        except Exception as e:
            logger.error(f"Erreur load_recette: {e}")

    def save(self):
        source = self.source_var.get().strip()
        montant = self.montant_var.get()
        comment = self.comment_var.get().strip()
        module_idx = self.module_menu.current()
        module_id = None
        if module_idx > 0:
            module_id = int(self.module_choices[module_idx][0])
        else:
            self.hide_colonne_menu()
        if not source:
            messagebox.showerror("Erreur", "Source obligatoire.")
            return
        if source.lower() == "vente sur place":
            messagebox.showerror("Erreur", "La recette 'Vente sur place' est gÃ©rÃ©e automatiquement.")
            return
        try:
            conn = get_connection()
            if self.recette_id:
                conn.execute(
                    "UPDATE event_recettes SET source=?, montant=?, commentaire=?, module_id=? WHERE id=?",
                    (source, montant, comment, module_id, self.recette_id)
                )
            else:
                conn.execute(
                    "INSERT INTO event_recettes (event_id, source, montant, commentaire, module_id) VALUES (?, ?, ?, ?, ?)",
                    (self.event_id, source, montant, comment, module_id)
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de la recette."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/exports.py ===

```python
import pandas as pd
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from db.db import get_connection

# ========== EXPORTS BILAN EVENEMENT ==========

def export_bilan_evenement(event_id, format="xlsx", filename=None):
    conn = get_connection()
    # RÃ©cup info Ã©vÃ©nement
    event = conn.execute("SELECT * FROM events WHERE id=?", (event_id,)).fetchone()
    if not event:
        messagebox.showerror("Erreur", "Ã‰vÃ©nement introuvable.")
        return

    # DonnÃ©es recettes
    recettes = pd.read_sql_query(
        "SELECT source, montant, commentaire, module_id FROM event_recettes WHERE event_id=?",
        conn, params=(event_id,)
    )
    # DonnÃ©es dÃ©penses
    depenses = pd.read_sql_query(
        "SELECT categorie, montant, fournisseur, date_depense, paye_par, membre_id, commentaire FROM event_depenses WHERE event_id=?",
        conn, params=(event_id,)
    )
    # DonnÃ©es caisses
    caisses = pd.read_sql_query(
        "SELECT id, nom_caisse, commentaire FROM event_caisses WHERE event_id=?",
        conn, params=(event_id,)
    )
    # DÃ©tail fond de caisse
    caisses_details = []
    for _, caisse in caisses.iterrows():
        cid = caisse["id"]
        debut = conn.execute(
            "SELECT SUM(CASE WHEN type='cheque' THEN valeur ELSE valeur*quantite END) as total FROM event_caisse_details WHERE caisse_id=? AND moment='debut'", (cid,)
        ).fetchone()["total"] or 0.0
        fin = conn.execute(
            "SELECT SUM(CASE WHEN type='cheque' THEN valeur ELSE valeur*quantite END) as total FROM event_caisse_details WHERE caisse_id=? AND moment='fin'", (cid,)
        ).fetchone()["total"] or 0.0
        caisses_details.append({
            "Caisse": caisse["nom_caisse"],
            "Fond dÃ©but (â‚¬)": f"{debut:.2f}",
            "Fond fin (â‚¬)": f"{fin:.2f}",
            "Gain (â‚¬)": f"{fin-debut:.2f}",
            "Commentaire": caisse["commentaire"],
        })
    caisses_details_df = pd.DataFrame(caisses_details)

    conn.close()

    if filename is None:
        ext = "." + format
        filename = filedialog.asksaveasfilename(
            defaultextension=ext,
            filetypes=[("Excel", "*.xlsx"), ("CSV", "*.csv"), ("PDF", "*.pdf")],
            title="Exporter bilan Ã©vÃ©nement",
            initialfile=f"Bilan_{event['name'].replace(' ', '_')}{ext}"
        )
    if not filename:
        return

    if format == "xlsx":
        with pd.ExcelWriter(filename) as writer:
            pd.DataFrame([dict(event)]).to_excel(writer, sheet_name="Ã‰vÃ©nement", index=False)
            recettes.to_excel(writer, sheet_name="Recettes", index=False)
            depenses.to_excel(writer, sheet_name="DÃ©penses", index=False)
            caisses_details_df.to_excel(writer, sheet_name="Caisses", index=False)
        messagebox.showinfo("Export", f"Bilan Ã©vÃ©nement exportÃ© :\n{filename}")
    elif format == "csv":
        recettes.to_csv(filename.replace(".csv", "_recettes.csv"), index=False, encoding="utf-8")
        depenses.to_csv(filename.replace(".csv", "_depenses.csv"), index=False, encoding="utf-8")
        caisses_details_df.to_csv(filename.replace(".csv", "_caisses.csv"), index=False, encoding="utf-8")
        messagebox.showinfo("Export", f"Bilans CSV exportÃ©s.")
    elif format == "pdf":
        try:
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.pagesizes import A4
            from reportlab.lib import colors
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle

            doc = SimpleDocTemplate(filename, pagesize=A4, rightMargin=24, leftMargin=24, topMargin=24, bottomMargin=24)
            styles = getSampleStyleSheet()
            styles.add(ParagraphStyle(name='Justify', alignment=4))

            elements = []

            # Titre principal
            elements.append(Paragraph(f"<b>Bilan de l'Ã©vÃ©nement : {event['name']}</b>", styles["Title"]))
            elements.append(Paragraph(f"<i>Date : {event['date']} | Lieu : {event['lieu']}</i>", styles["Normal"]))
            elements.append(Spacer(1, 10))
            elements.append(Paragraph(f"{event['description']}", styles["BodyText"]))
            elements.append(Spacer(1, 16))

            # === TABLEAU SYNTHÃ‰TIQUE (Recette/DÃ©pense/Gain) ===
            total_recettes = recettes["montant"].sum() if not recettes.empty else 0.0
            total_depenses = depenses["montant"].sum() if not depenses.empty else 0.0
            gain = total_recettes - total_depenses

            synth_data = [
                ["Recettes (â‚¬)", "DÃ©penses (â‚¬)", "Gain (â‚¬)"],
                [f"{total_recettes:.2f}", f"{total_depenses:.2f}", f"{gain:.2f}"]
            ]
            synth_table = Table(synth_data, hAlign="LEFT", colWidths=[90, 90, 90])
            synth_table.setStyle(TableStyle([
                ("GRID", (0,0), (-1,-1), 1, colors.black),
                ("BACKGROUND", (0,0), (-1,0), colors.HexColor("#cce6ff")),
                ("FONTNAME", (0,0), (-1,0), "Helvetica-Bold"),
                ("ALIGN", (0,0), (-1,-1), "CENTER"),
                ("FONTSIZE", (0,0), (-1,-1), 11),
                ("BOTTOMPADDING", (0,0), (-1,0), 6)
            ]))
            elements.append(synth_table)
            elements.append(Spacer(1, 18))

            # Recettes
            elements.append(Paragraph("<b>Recettes</b>", styles["Heading2"]))
            if not recettes.empty:
                recettes_data = [recettes.columns.tolist()] + [
                    [
                        Paragraph(str(row[0]), styles["Normal"]),
                        Paragraph(str(row[1]), styles["Normal"]),
                        Paragraph(str(row[2]), styles["Normal"]),
                        Paragraph(str(row[3]), styles["Normal"])
                    ] for row in recettes.values
                ]
                t = Table(recettes_data, hAlign="LEFT", colWidths=[110, 70, 220, 60])
                t.setStyle(TableStyle([
                    ("GRID", (0,0), (-1,-1), 0.7, colors.grey),
                    ("BACKGROUND", (0,0), (-1,0), colors.HexColor("#e0e0e0")),
                    ("FONTNAME", (0,0), (-1,0), "Helvetica-Bold"),
                    ("ALIGN", (0,0), (-1,0), "CENTER"),
                    ("ALIGN", (1,1), (1,-1), "RIGHT"),  # montant Ã  droite
                    ("VALIGN", (0,0), (-1,-1), "TOP"),
                    ("FONTSIZE", (0,0), (-1,-1), 9),
                    ("LEFTPADDING", (0,0), (-1,-1), 6),
                    ("RIGHTPADDING", (0,0), (-1,-1), 6),
                    ("ROWBACKGROUNDS", (0,1), (-1,-1), [colors.whitesmoke, colors.lightgrey])
                ]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune recette.", styles["Normal"]))
            elements.append(Spacer(1, 16))

            # DÃ©penses
            elements.append(Paragraph("<b>DÃ©penses</b>", styles["Heading2"]))
            if not depenses.empty:
                depenses_data = [depenses.columns.tolist()] + [
                    [
                        Paragraph(str(row[0]), styles["Normal"]),  # categorie
                        Paragraph(str(row[1]), styles["Normal"]),  # montant
                        Paragraph(str(row[2]), styles["Normal"]),  # fournisseur
                        Paragraph(str(row[3]), styles["Normal"]),  # date_depense
                        Paragraph(str(row[4]), styles["Normal"]),  # paye_par
                        Paragraph(str(row[5]), styles["Normal"]),  # membre_id
                        Paragraph(str(row[6]), styles["Normal"])   # commentaire
                    ] for row in depenses.values
                ]
                t = Table(depenses_data, hAlign="LEFT", colWidths=[75, 60, 90, 60, 60, 50, 160])
                t.setStyle(TableStyle([
                    ("GRID", (0,0), (-1,-1), 0.7, colors.grey),
                    ("BACKGROUND", (0,0), (-1,0), colors.HexColor("#e0e0e0")),
                    ("FONTNAME", (0,0), (-1,0), "Helvetica-Bold"),
                    ("ALIGN", (1,1), (1,-1), "RIGHT"),  # montant Ã  droite
                    ("VALIGN", (0,0), (-1,-1), "TOP"),
                    ("FONTSIZE", (0,0), (-1,-1), 8),
                    ("LEFTPADDING", (0,0), (-1,-1), 4),
                    ("RIGHTPADDING", (0,0), (-1,-1), 4),
                    ("ROWBACKGROUNDS", (0,1), (-1,-1), [colors.whitesmoke, colors.lightgrey])
                ]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune dÃ©pense.", styles["Normal"]))
            elements.append(Spacer(1, 18))

            # Caisses
            elements.append(Paragraph("<b>Caisses</b>", styles["Heading2"]))
            if not caisses_details_df.empty:
                caisses_data = [caisses_details_df.columns.tolist()] + [
                    [
                        Paragraph(str(row[0]), styles["Normal"]),
                        Paragraph(str(row[1]), styles["Normal"]),
                        Paragraph(str(row[2]), styles["Normal"]),
                        Paragraph(str(row[3]), styles["Normal"]),
                        Paragraph(str(row[4]), styles["Normal"])
                    ] for row in caisses_details_df.values
                ]
                t = Table(caisses_data, hAlign="LEFT", colWidths=[110, 60, 60, 60, 180])
                t.setStyle(TableStyle([
                    ("GRID", (0,0), (-1,-1), 0.7, colors.grey),
                    ("BACKGROUND", (0,0), (-1,0), colors.HexColor("#e0e0e0")),
                    ("FONTNAME", (0,0), (-1,0), "Helvetica-Bold"),
                    ("ALIGN", (1,1), (3,-1), "RIGHT"),
                    ("VALIGN", (0,0), (-1,-1), "TOP"),
                    ("FONTSIZE", (0,0), (-1,-1), 9),
                    ("LEFTPADDING", (0,0), (-1,-1), 4),
                    ("RIGHTPADDING", (0,0), (-1,-1), 4),
                    ("ROWBACKGROUNDS", (0,1), (-1,-1), [colors.whitesmoke, colors.lightgrey])
                ]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune caisse.", styles["Normal"]))

            doc.build(elements)
            messagebox.showinfo("Export", f"Bilan PDF exportÃ©Â :\n{filename}")
        except ImportError:
            messagebox.showerror("Export", "Le module reportlab n'est pas installÃ©.")

# ========== EXPORTS GLOBAUX DÃ‰PENSES / SUBVENTIONS ==========

def export_depenses_global(format="xlsx", filename=None):
    conn = get_connection()
    depenses = pd.read_sql_query("""
        SELECT 
            date_depense as date,
            categorie,
            montant,
            fournisseur,
            paye_par,
            membre_id,
            commentaire,
            'RÃ©guliÃ¨re' as type_depense
        FROM depenses_regulieres
        UNION ALL
        SELECT 
            date_depense as date,
            categorie,
            montant,
            fournisseur,
            paye_par,
            membre_id,
            commentaire,
            'Diverse' as type_depense
        FROM depenses_diverses
    """, conn)
    conn.close()
    if filename is None:
        ext = "." + format
        filename = filedialog.asksaveasfilename(
            defaultextension=ext,
            filetypes=[("Excel", "*.xlsx"), ("CSV", "*.csv"), ("PDF", "*.pdf")],
            title="Exporter toutes les dÃ©penses",
            initialfile="Toutes_depenses" + ext
        )
    if not filename:
        return
    if format == "xlsx":
        depenses.to_excel(filename, index=False)
        messagebox.showinfo("Export", f"Export Excel terminÃ© :\n{filename}")
    elif format == "csv":
        depenses.to_csv(filename, index=False, encoding="utf-8")
        messagebox.showinfo("Export", f"Export CSV terminÃ© :\n{filename}")
    elif format == "pdf":
        try:
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.pagesizes import A4
            from reportlab.lib import colors
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle

            doc = SimpleDocTemplate(filename, pagesize=A4, rightMargin=24, leftMargin=24, topMargin=24, bottomMargin=24)
            styles = getSampleStyleSheet()
            styles.add(ParagraphStyle(name='Justify', alignment=4))

            elements = []
            elements.append(Paragraph("<b>Toutes les dÃ©penses</b>", styles["Title"]))
            elements.append(Spacer(1, 14))

            if not depenses.empty:
                data = [depenses.columns.tolist()] + [
                    [
                        Paragraph(str(row[0]), styles["Normal"]), # date
                        Paragraph(str(row[1]), styles["Normal"]), # categorie
                        Paragraph(str(row[2]), styles["Normal"]), # montant
                        Paragraph(str(row[3]), styles["Normal"]), # fournisseur
                        Paragraph(str(row[4]), styles["Normal"]), # paye_par
                        Paragraph(str(row[5]), styles["Normal"]), # membre_id
                        Paragraph(str(row[6]), styles["Normal"]), # commentaire
                        Paragraph(str(row[7]), styles["Normal"])  # type_depense
                    ]
                    for row in depenses.values
                ]
                # Largeurs proportionnelles : les 6 premiÃ¨res colonnes restent fixes, la colonne "commentaire" et "type_depense" adaptatives
                t = Table(
                    data,
                    hAlign="LEFT",
                    colWidths=[55, 75, 55, 90, 60, 45, "*", 60]  # "*" donne tout l'espace restant Ã  "commentaire"
                )
                t.setStyle(TableStyle([
                    ("GRID", (0,0), (-1,-1), 0.7, colors.grey),
                    ("BACKGROUND", (0,0), (-1,0), colors.HexColor("#cce6ff")),
                    ("FONTNAME", (0,0), (-1,0), "Helvetica-Bold"),
                    ("ALIGN", (2,1), (2,-1), "RIGHT"),    # montant Ã  droite
                    ("ALIGN", (0,0), (-1,0), "CENTER"),   # en-tÃªtes centrÃ©es
                    ("VALIGN", (0,0), (-1,-1), "TOP"),
                    ("FONTSIZE", (0,0), (-1,-1), 9),
                    ("LEFTPADDING", (0,0), (-1,-1), 5),
                    ("RIGHTPADDING", (0,0), (-1,-1), 5),
                    ("ROWBACKGROUNDS", (0,1), (-1,-1), [colors.whitesmoke, colors.lightgrey]),
                    ("BOTTOMPADDING", (0,0), (-1,0), 6),
                    ("TOPPADDING", (0,0), (-1,0), 6)
                ]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune dÃ©pense.", styles["Normal"]))

            doc.build(elements)
            messagebox.showinfo("Export", f"Export PDF terminÃ© :\n{filename}")
        except ImportError:
            messagebox.showerror("Export", "Le module reportlab n'est pas installÃ©.")

def export_subventions_global(format="xlsx", filename=None):
    conn = get_connection()
    subventions = pd.read_sql_query("SELECT * FROM dons_subventions", conn)
    conn.close()
    if filename is None:
        ext = "." + format
        filename = filedialog.asksaveasfilename(
            defaultextension=ext,
            filetypes=[("Excel", "*.xlsx"), ("CSV", "*.csv"), ("PDF", "*.pdf")],
            title="Exporter toutes les subventions",
            initialfile="Toutes_subventions" + ext
        )
    if not filename:
        return
    if format == "xlsx":
        subventions.to_excel(filename, index=False)
        messagebox.showinfo("Export", f"Export Excel terminÃ© :\n{filename}")
    elif format == "csv":
        subventions.to_csv(filename, index=False, encoding="utf-8")
        messagebox.showinfo("Export", f"Export CSV terminÃ© :\n{filename}")
    elif format == "pdf":
        try:
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.pagesizes import A4
            from reportlab.lib import colors
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle

            doc = SimpleDocTemplate(filename, pagesize=A4, rightMargin=24, leftMargin=24, topMargin=24, bottomMargin=24)
            styles = getSampleStyleSheet()
            styles.add(ParagraphStyle(name='Justify', alignment=4))

            elements = []
            elements.append(Paragraph("<b>Toutes les subventions et dons</b>", styles["Title"]))
            elements.append(Spacer(1, 12))

            if not subventions.empty:
                data = [subventions.columns.tolist()] + [
                    [Paragraph(str(col), styles["Normal"]) for col in row]
                    for row in subventions.values
                ]
                t = Table(data, hAlign="LEFT", colWidths=[65, 120, 70, 70, 110, 80])
                t.setStyle(TableStyle([
                    ("GRID", (0,0), (-1,-1), 0.7, colors.grey),
                    ("BACKGROUND", (0,0), (-1,0), colors.HexColor("#e0e0e0")),
                    ("FONTNAME", (0,0), (-1,0), "Helvetica-Bold"),
                    ("ALIGN", (2,1), (2,-1), "RIGHT"),  # montant Ã  droite
                    ("VALIGN", (0,0), (-1,-1), "TOP"),
                    ("FONTSIZE", (0,0), (-1,-1), 9),
                    ("LEFTPADDING", (0,0), (-1,-1), 4),
                    ("RIGHTPADDING", (0,0), (-1,-1), 4),
                    ("ROWBACKGROUNDS", (0,1), (-1,-1), [colors.whitesmoke, colors.lightgrey])
                ]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune subvention ni don.", styles["Normal"]))

            doc.build(elements)
            messagebox.showinfo("Export", f"Export PDF terminÃ© :\n{filename}")
        except ImportError:
            messagebox.showerror("Export", "Le module reportlab n'est pas installÃ©.")

# ========== EXPORTS MULTI-EVENEMENTS EN LOT ==========

def export_tous_bilans_evenements(format="xlsx", dossier=None):
    conn = get_connection()
    events = conn.execute("SELECT id, name FROM events ORDER BY date DESC").fetchall()
    conn.close()
    if dossier is None:
        dossier = filedialog.askdirectory(title="Choisir le dossier d'export pour tous les bilans Ã©vÃ©nements")
    if not dossier:
        return
    for ev in events:
        name = ev["name"].replace(" ", "_")
        fname = f"{dossier}/Bilan_{name}.{format}"
        export_bilan_evenement(ev["id"], format=format, filename=fname)
    messagebox.showinfo("Export", f"Tous les bilans Ã©vÃ©nements exportÃ©s dansÂ :\n{dossier}")
    
class ExportsWindow(tk.Toplevel):
    def __init__(self, master=None):
        super().__init__(master)
        self.title("Exports et Bilans")
        self.geometry("640x520")
        self.resizable(False, False)
        self.create_widgets()
        self.populate_events()

    def create_widgets(self):
        frm = tk.Frame(self)
        frm.pack(fill="both", expand=True, padx=20, pady=16)

        # SÃ©lection d'un Ã©vÃ©nement
        tk.Label(frm, text="Bilan par Ã©vÃ©nement :", font=("Arial", 12, "bold")).pack(anchor="w", pady=(0, 4))
        sel_frame = tk.Frame(frm)
        sel_frame.pack(anchor="w", pady=(0, 10))
        self.event_var = tk.StringVar()
        self.event_cb = ttk.Combobox(sel_frame, textvariable=self.event_var, state="readonly", width=38)
        self.event_cb.pack(side="left")
        tk.Button(sel_frame, text="Exporter Excel", command=lambda: export_bilan_evenement(self.get_selected_event_id(), "xlsx")).pack(side="left", padx=3)
        tk.Button(sel_frame, text="Exporter CSV", command=lambda: export_bilan_evenement(self.get_selected_event_id(), "csv")).pack(side="left", padx=3)
        tk.Button(sel_frame, text="Exporter PDF", command=lambda: export_bilan_evenement(self.get_selected_event_id(), "pdf")).pack(side="left", padx=3)

        # Export tous bilans Ã©vÃ©nements
        tk.Label(frm, text="Exporter tous les bilans Ã©vÃ©nements :", font=("Arial", 12, "bold")).pack(anchor="w", pady=(16, 4))
        all_ev_frame = tk.Frame(frm)
        all_ev_frame.pack(anchor="w", pady=(0, 10))
        tk.Button(all_ev_frame, text="Tous en Excel", command=lambda: export_tous_bilans_evenements("xlsx")).pack(side="left", padx=3)
        tk.Button(all_ev_frame, text="Tous en CSV", command=lambda: export_tous_bilans_evenements("csv")).pack(side="left", padx=3)
        tk.Button(all_ev_frame, text="Tous en PDF", command=lambda: export_tous_bilans_evenements("pdf")).pack(side="left", padx=3)

        # Export global dÃ©penses
        tk.Label(frm, text="Exporter toutes les dÃ©penses :", font=("Arial", 12, "bold")).pack(anchor="w", pady=(16, 4))
        dep_frame = tk.Frame(frm)
        dep_frame.pack(anchor="w", pady=(0, 10))
        tk.Button(dep_frame, text="Excel", command=lambda: export_depenses_global("xlsx")).pack(side="left", padx=3)
        tk.Button(dep_frame, text="CSV", command=lambda: export_depenses_global("csv")).pack(side="left", padx=3)
        tk.Button(dep_frame, text="PDF", command=lambda: export_depenses_global("pdf")).pack(side="left", padx=3)

        # Export global subventions/dons
        tk.Label(frm, text="Exporter tous les dons/subventions :", font=("Arial", 12, "bold")).pack(anchor="w", pady=(16, 4))
        sub_frame = tk.Frame(frm)
        sub_frame.pack(anchor="w", pady=(0, 10))
        tk.Button(sub_frame, text="Excel", command=lambda: export_subventions_global("xlsx")).pack(side="left", padx=3)
        tk.Button(sub_frame, text="CSV", command=lambda: export_subventions_global("csv")).pack(side="left", padx=3)
        tk.Button(sub_frame, text="PDF", command=lambda: export_subventions_global("pdf")).pack(side="left", padx=3)

        # Bouton fermer
        tk.Button(frm, text="Fermer", command=self.destroy).pack(side="bottom", pady=8)

    def populate_events(self):
        conn = get_connection()
        events = conn.execute("SELECT id, name, date FROM events ORDER BY date DESC").fetchall()
        conn.close()
        self.event_list = [(str(ev["id"]), f"{ev['date']} - {ev['name']}") for ev in events]
        self.event_cb["values"] = [ev[1] for ev in self.event_list]
        if self.event_list:
            self.event_cb.current(0)

    def get_selected_event_id(self):
        idx = self.event_cb.current()
        if idx < 0 or not self.event_list:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un Ã©vÃ©nement.")
            return None
        return int(self.event_list[idx][0])
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/fournisseurs.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog, filedialog
import pandas as pd
from db.db import get_connection

class FournisseursWindow(tk.Toplevel):
    def __init__(self, master=None):
        super().__init__(master)
        self.title("Gestion des fournisseurs")
        self.geometry("430x400")
        self.resizable(False, False)
        self.create_widgets()
        self.refresh_fournisseurs()

    def create_widgets(self):
        frame = tk.Frame(self)
        frame.pack(fill=tk.BOTH, expand=True, padx=12, pady=10)

        self.tree = ttk.Treeview(frame, columns=("id", "name"), show="headings", selectmode="browse")
        self.tree.heading("id", text="ID")
        self.tree.heading("name", text="Nom du fournisseur")
        self.tree.column("id", width=50)
        self.tree.column("name", width=260)
        self.tree.pack(fill=tk.BOTH, expand=True, pady=8)

        btns = tk.Frame(frame)
        btns.pack(fill=tk.X, pady=8)
        tk.Button(btns, text="Ajouter", command=self.add_fournisseur).pack(side=tk.LEFT, padx=4)
        tk.Button(btns, text="Renommer", command=self.edit_fournisseur).pack(side=tk.LEFT, padx=4)
        tk.Button(btns, text="Supprimer", command=self.delete_fournisseur).pack(side=tk.LEFT, padx=4)
        tk.Button(btns, text="Ajout Liste", command=self.add_fournisseurs_mass).pack(side=tk.LEFT, padx=4)
        tk.Button(btns, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=4)

    def refresh_fournisseurs(self):
        self.tree.delete(*self.tree.get_children())
        conn = get_connection()
        fournisseurs = conn.execute("SELECT * FROM fournisseurs ORDER BY name").fetchall()
        for f in fournisseurs:
            self.tree.insert("", "end", values=(f["id"], f["name"]))
        conn.close()

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un fournisseur.")
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_fournisseur(self):
        name = tk.simpledialog.askstring("Ajouter fournisseur", "Nom du fournisseur :")
        if not name:
            return
        conn = get_connection()
        try:
            conn.execute("INSERT INTO fournisseurs (name) VALUES (?)", (name.strip(),))
            conn.commit()
        except Exception as e:
            messagebox.showerror("Erreur", f"Impossible d'ajouter : {e}")
        conn.close()
        self.refresh_fournisseurs()

    def add_fournisseurs_mass(self):
        win = tk.Toplevel(self)
        win.title("Ajout de fournisseurs en masse")
        win.geometry("320x330")
        tk.Label(win, text="Collez ici la liste des fournisseurs (un par ligne) :", font=("Arial", 11)).pack(pady=8)
        txt = tk.Text(win, width=36, height=12, font=("Arial", 11))
        txt.pack(padx=10, pady=5, fill=tk.BOTH, expand=True)
        txt.focus_set()
        def valider():
            lines = txt.get("1.0", "end-1c").splitlines()
            fournisseurs = [l.strip() for l in lines if l.strip()]
            if not fournisseurs:
                messagebox.showinfo("Aucun fournisseur", "Aucun nom Ã  ajouter.")
                return
            conn = get_connection()
            c = conn.cursor()
            n_inserted = 0
            for name in fournisseurs:
                try:
                    c.execute("INSERT OR IGNORE INTO fournisseurs (name) VALUES (?)", (name,))
                    n_inserted += c.rowcount
                except Exception:
                    pass
            conn.commit()
            conn.close()
            messagebox.showinfo("Import", f"{n_inserted} fournisseurs importÃ©s.")
            self.refresh_fournisseurs()
            win.destroy()
        tk.Button(win, text="Ajouter Ã  la base", command=valider, font=("Arial", 11, "bold"), bg="#4c9ed9", fg="white").pack(pady=12)
        win.grab_set()
        win.wait_window()

    def edit_fournisseur(self):
        fid = self.get_selected_id()
        if not fid:
            return
        conn = get_connection()
        old = conn.execute("SELECT name FROM fournisseurs WHERE id=?", (fid,)).fetchone()
        conn.close()
        if not old:
            return
        new_nom = tk.simpledialog.askstring("Renommer fournisseur", "Nouveau name :", initialvalue=old["name"])
        if not new_nom or new_nom.strip() == old["name"]:
            return
        conn = get_connection()
        try:
            conn.execute("UPDATE fournisseurs SET name=? WHERE id=?", (new_nom.strip(), fid))
            conn.commit()
        except Exception as e:
            messagebox.showerror("Erreur", f"Impossible de renommer : {e}")
        conn.close()
        self.refresh_fournisseurs()

    def delete_fournisseur(self):
        fid = self.get_selected_id()
        if not fid:
            return
        if not messagebox.askyesno("Supprimer", "ÃŠtes-vous sÃ»r de vouloir supprimer ce fournisseur ?"):
            return
        confirm = simpledialog.askstring("Confirmation", "Retapez SUPPRIMER pour confirmer la suppression du fournisseur :", parent=self)
        if (confirm or "").strip().upper() != "SUPPRIMER":
            messagebox.showinfo("AnnulÃ©", "Suppression annulÃ©e.")
            return
        conn = get_connection()
        try:
            conn.execute("DELETE FROM fournisseurs WHERE id=?", (fid,))
            conn.commit()
        except Exception as e:
            messagebox.showerror("Erreur", f"Impossible de supprimer : {e}")
        conn.close()
        self.refresh_fournisseurs()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/historique_clotures.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection

class HistoriqueCloturesModule(tk.Toplevel):
    def __init__(self, master=None):
        super().__init__(master)
        self.title("Gestion des dates de clÃ´ture")
        self.geometry("480x350")
        self.resizable(False, False)
        self.create_widgets()
        self.refresh_list()

    def create_widgets(self):
        frame = tk.Frame(self)
        frame.pack(fill=tk.BOTH, expand=True, padx=14, pady=12)
        self.tree = ttk.Treeview(frame, columns=("id", "date_cloture"), show="headings", selectmode="browse")
        self.tree.heading("id", text="ID")
        self.tree.heading("date_cloture", text="Date de clÃ´ture")
        self.tree.column("id", width=60)
        self.tree.column("date_cloture", width=180)
        self.tree.pack(fill=tk.BOTH, expand=True, pady=8)

        btns = tk.Frame(frame)
        btns.pack(fill=tk.X, pady=10)
        tk.Button(btns, text="Ajouter", command=self.add_cloture).pack(side=tk.LEFT, padx=6)
        tk.Button(btns, text="Modifier", command=self.edit_cloture).pack(side=tk.LEFT, padx=6)
        tk.Button(btns, text="Supprimer", command=self.delete_cloture).pack(side=tk.LEFT, padx=6)
        tk.Button(btns, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=6)

    def refresh_list(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        clotures = conn.execute("SELECT id, date_cloture FROM historique_clotures ORDER BY date_cloture DESC").fetchall()
        for c in clotures:
            self.tree.insert("", "end", values=(c["id"], c["date_cloture"]))
        conn.close()

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une clÃ´ture.")
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_cloture(self):
        date = simpledialog.askstring("Ajouter une clÃ´ture", "Date de clÃ´ture (YYYY-MM-DD) :")
        if not date:
            return
        conn = get_connection()
        conn.execute("INSERT INTO historique_clotures (date_cloture) VALUES (?)", (date,))
        conn.commit()
        conn.close()
        self.refresh_list()

    def edit_cloture(self):
        cid = self.get_selected_id()
        if not cid:
            return
        conn = get_connection()
        old = conn.execute("SELECT date_cloture FROM historique_clotures WHERE id=?", (cid,)).fetchone()
        conn.close()
        if not old:
            return
        new_date = simpledialog.askstring("Modifier clÃ´ture", "Nouvelle date (YYYY-MM-DD) :", initialvalue=old["date_cloture"])
        if not new_date or new_date == old["date_cloture"]:
            return
        conn = get_connection()
        conn.execute("UPDATE historique_clotures SET date_cloture=? WHERE id=?", (new_date, cid))
        conn.commit()
        conn.close()
        self.refresh_list()

    def delete_cloture(self):
        cid = self.get_selected_id()
        if not cid:
            return
        if not messagebox.askyesno("Supprimer", "Supprimer cette clÃ´ture ?"):
            return
        conn = get_connection()
        conn.execute("DELETE FROM historique_clotures WHERE id=?", (cid,))
        conn.commit()
        conn.close()
        self.refresh_list()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/historique_inventaire.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
import pandas as pd
from db.db import get_connection

class HistoriqueInventairesModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Historique des inventaires")
        self.top.geometry("900x500")
        self.create_table()
        self.refresh_inventaires()

    def create_table(self):
        style = ttk.Style()
        style.theme_use("default")
        style.configure("Treeview.Heading", font=('Arial', 11, 'bold'))
        style.configure("Treeview", font=('Consolas', 11), rowheight=22)
        style.configure("oddrow", background="#F2F2F2")
        style.configure("evenrow", background="#FFFFFF")

        columns = ("id", "date", "evenement", "nb_lignes", "commentaire")
        self.tree = ttk.Treeview(
            self.top, columns=columns, show="headings", selectmode="browse"
        )
        for col, text, w in zip(
            columns,
            ["ID", "Date", "Ã‰vÃ©nement", "Nb buvette_articles", "Commentaire"],
            [40, 120, 160, 100, 340]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True)
        vsb = ttk.Scrollbar(self.top, orient="vertical", command=self.tree.yview)
        vsb.pack(side='right', fill='y')
        self.tree.configure(yscroll=vsb.set)
        self.tree.bind("<Double-1>", self.show_lignes_inventaire)

        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=8)
        tk.Button(btn_frame, text="Afficher les lignes", command=self.show_lignes_inventaire).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=10)

    def refresh_inventaires(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        df = pd.read_sql_query(
            """
            SELECT i.id, i.date_inventaire as date, e.name as evenement, i.commentaire,
                (SELECT COUNT(*) FROM inventaire_lignes WHERE inventaire_id = i.id) as nb_lignes
            FROM inventaires i
            LEFT JOIN events e ON i.event_id = e.id
            ORDER BY i.date_inventaire DESC, i.id DESC
            """, conn
        )
        self.df = df
        for idx, (_, row) in enumerate(df.iterrows()):
            tag = "evenrow" if idx % 2 == 0 else "oddrow"
            self.tree.insert(
                "", "end",
                values=(
                    row['id'],
                    row['date'][:10] if pd.notnull(row['date']) else "",
                    row['evenement'] if pd.notnull(row['evenement']) else "",
                    row['nb_lignes'],
                    row['commentaire'] if pd.notnull(row['commentaire']) else ""
                ),
                tags=(tag,)
            )

    def show_lignes_inventaire(self, event=None):
        sel = self.tree.selection()
        if not sel:
            messagebox.showinfo("SÃ©lection", "SÃ©lectionnez un inventaire Ã  afficher.")
            return
        item = self.tree.item(sel[0])
        inv_id = item["values"][0]
        LignesInventaireDialog(self.top, inv_id)

class LignesInventaireDialog(tk.Toplevel):
    def __init__(self, master, inventaire_id):
        super().__init__(master)
        self.title(f"Lignes de l'inventaire nÂ°{inventaire_id}")
        self.geometry("750x400")
        self.create_table()
        self.refresh_lignes(inventaire_id)

    def create_table(self):
        columns = ("stock_id", "name", "categorie", "quantite_constatee")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        for col, text, w in zip(
            columns,
            ["ID stock", "Name article", "CatÃ©gorie", "QtÃ© constatÃ©e"],
            [60, 220, 160, 100]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True)

    def refresh_lignes(self, inventaire_id):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        lignes = conn.execute(
            """
            SELECT l.stock_id, s.name, c.name as categorie, l.quantite_constatee
            FROM inventaire_lignes l
            LEFT JOIN stock s ON l.stock_id = s.id
            LEFT JOIN categories c ON s.categorie_id = c.id
            WHERE l.inventaire_id = ?
            ORDER BY s.name
            """, (inventaire_id,)
        ).fetchall()
        for l in lignes:
            self.tree.insert("", "end", values=(l["stock_id"], l["name"], l["categorie"], l["quantite_constatee"]))
        conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/inventaire.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
try:
    import pandas as pd
except ModuleNotFoundError:
    print("Le module 'pandas' est requis pour la gestion des inventaires. Installe-le : python -m pip install pandas")
    raise
from db.db import get_connection

class InventaireModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Nouvel inventaire")
        self.top.geometry("900x600")
        self.create_widgets()
        self.load_stock()

    def create_widgets(self):
        form = tk.Frame(self.top)
        form.pack(fill=tk.X, pady=6)
        tk.Label(form, text="Date de l'inventaire (YYYY-MM-DD) :").grid(row=0, column=0, sticky="e", padx=8, pady=2)
        self.date_var = tk.StringVar()
        tk.Entry(form, textvariable=self.date_var, width=16).grid(row=0, column=1, sticky="w")

        tk.Label(form, text="Ã‰vÃ©nement liÃ© (optionnel) :").grid(row=0, column=2, sticky="e", padx=8, pady=2)
        self.evt_var = tk.StringVar()
        self.evt_cb = ttk.Combobox(form, textvariable=self.evt_var, width=26, state="readonly")
        self.evt_cb.grid(row=0, column=3, sticky="w")
        self.evt_cb["values"] = self.get_events()
        self.evt_cb.set("")

        tk.Label(form, text="Commentaire :").grid(row=1, column=0, sticky="e", padx=8, pady=2)
        self.comment_var = tk.StringVar()
        tk.Entry(form, textvariable=self.comment_var, width=60).grid(row=1, column=1, columnspan=3, sticky="w")

        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=10)
        tk.Button(btn_frame, text="Enregistrer inventaire", command=self.save_inventaire).pack(side=tk.LEFT, padx=12)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=12)

        # Tableau des buvette_articles
        columns = ("stock_id", "name", "categorie", "quantite_stock", "quantite_constatee")
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings", selectmode="browse")
        for col, text, w in zip(
            columns,
            ["ID stock", "Name article", "CatÃ©gorie", "QuantitÃ© stock", "QtÃ© constatÃ©e"],
            [60, 220, 160, 100, 120]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True)

        self.tree.bind("<Double-1>", self.edit_qte_constatee)

    def get_events(self):
        conn = get_connection()
        evts = conn.execute("SELECT name FROM events ORDER BY date DESC").fetchall()
        conn.close()
        return [e["name"] for e in evts]

    def load_stock(self):
        conn = get_connection()
        self.stock_df = pd.read_sql_query("""
            SELECT s.id as stock_id, s.name, c.name as categorie, s.quantite
            FROM stock s LEFT JOIN categories c ON s.categorie_id = c.id
            ORDER BY s.name
        """, conn)
        conn.close()
        for row in self.tree.get_children():
            self.tree.delete(row)
        for _, row in self.stock_df.iterrows():
            self.tree.insert(
                "", "end",
                values=(row["stock_id"], row["name"], row["categorie"], row["quantite"], row["quantite"])
            )

    def edit_qte_constatee(self, event=None):
        sel = self.tree.selection()
        if not sel:
            return
        item = self.tree.item(sel[0])
        qte = item["values"][4]
        qte_new = simpledialog.askinteger("Saisie", "Nouvelle quantitÃ© constatÃ©e :", initialvalue=qte)
        if qte_new is not None:
            vals = list(item["values"])
            vals[4] = qte_new
            self.tree.item(sel[0], values=vals)

    def save_inventaire(self):
        date = self.date_var.get().strip()
        evt_name = self.evt_var.get().strip()
        comment = self.comment_var.get().strip()
        if not date:
            messagebox.showerror("Erreur", "Date obligatoire.")
            return
        conn = get_connection()
        evt_id = None
        if evt_name:
            row = conn.execute("SELECT id FROM events WHERE name=?", (evt_name,)).fetchone()
            if row:
                evt_id = row["id"]
        # Insert inventaire
        conn.execute(
            "INSERT INTO inventaires (date_inventaire, event_id, commentaire) VALUES (?, ?, ?)",
            (date, evt_id, comment)
        )
        inv_id = conn.execute("SELECT last_insert_rowid()").fetchone()[0]
        # Insert lignes
        for row_id in self.tree.get_children():
            vals = self.tree.item(row_id)["values"]
            stock_id = vals[0]
            qte_constatee = vals[4]
            conn.execute(
                "INSERT INTO inventaire_lignes (inventaire_id, stock_id, quantite_constatee) VALUES (?, ?, ?)",
                (inv_id, stock_id, qte_constatee)
            )
        conn.commit()
        conn.close()
        messagebox.showinfo("OK", "Inventaire enregistrÃ© !")
        self.top.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/inventory_lines_dialog.py ===

```python
"""
Helper module for loading inventory lines safely.

This module provides robust functions for loading inventory data with proper
error handling and reporting. It ensures that sqlite3.Row objects are properly
converted to dictionaries before any .get() operations are performed.

Functions:
    load_inventory_lines: Load inventory lines with error handling and reporting
"""

import os
from datetime import datetime
from typing import List, Dict, Any, Optional
from utils.app_logger import get_logger
from modules.db_row_utils import _row_to_dict, _rows_to_dicts
from modules.buvette_inventaire_db import list_lignes_inventaire as _list_lignes_inventaire

logger = get_logger("inventory_lines_dialog")


def load_inventory_lines(inventaire_id: int) -> List[Dict[str, Any]]:
    """
    Load inventory lines with robust error handling and conversion.
    
    This function:
    1. Fetches inventory lines from the database
    2. Converts sqlite3.Row objects to dicts using _rows_to_dicts
    3. Handles errors gracefully with detailed reporting
    4. Writes error reports to reports/inventory_error_<timestamp>.txt on failure
    
    Args:
        inventaire_id: The ID of the inventory to load lines for
        
    Returns:
        List of dicts representing inventory lines, with keys:
        - id: line ID
        - inventaire_id: inventory ID
        - article_id: article ID
        - quantite: quantity counted
        - commentaire: optional comment
        - article_name: article name (from JOIN)
        
    Raises:
        Exception: Re-raises any exception after writing an error report
        
    Example:
        >>> try:
        >>>     lines = load_inventory_lines(inventory_id=42)
        >>>     for line in lines:
        >>>         article_id = line.get('article_id', 0)
        >>>         quantity = line.get('quantite', 0)
        >>> except Exception as e:
        >>>     logger.error(f"Failed to load inventory: {e}")
    """
    raw_rows = None  # Initialize for error reporting scope
    try:
        # Fetch raw rows from database
        logger.info(f"Loading inventory lines for inventaire_id={inventaire_id}")
        raw_rows = _list_lignes_inventaire(inventaire_id)
        
        if not raw_rows:
            logger.info(f"No lines found for inventaire_id={inventaire_id}")
            return []
        
        # Convert Row objects to dicts for safe .get() access
        lines_dicts = _rows_to_dicts(raw_rows)
        
        logger.info(f"Successfully loaded {len(lines_dicts)} inventory lines")
        return lines_dicts
        
    except Exception as e:
        # Log the error
        logger.error(f"Error loading inventory lines for inventaire_id={inventaire_id}: {e}", exc_info=True)
        
        # Write detailed error report
        _write_error_report(inventaire_id, e, raw_rows)
        
        # Re-raise the exception so callers can handle it
        raise


def _write_error_report(
    inventaire_id: int, 
    error: Exception, 
    raw_rows: Optional[List] = None
) -> None:
    """
    Write a detailed error report to reports/inventory_error_<timestamp>.txt.
    
    Args:
        inventaire_id: The inventory ID that failed to load
        error: The exception that occurred
        raw_rows: Optional raw rows data for debugging (if available)
    """
    try:
        # Ensure reports directory exists
        reports_dir = os.path.join(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
            "reports"
        )
        os.makedirs(reports_dir, exist_ok=True)
        
        # Generate error report filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_filename = f"inventory_error_{timestamp}.txt"
        report_path = os.path.join(reports_dir, report_filename)
        
        # Compile error report
        report_lines = [
            "=" * 80,
            "INVENTORY LOADING ERROR REPORT",
            "=" * 80,
            f"Timestamp: {datetime.now().isoformat()}",
            f"Inventaire ID: {inventaire_id}",
            "",
            "ERROR DETAILS:",
            f"Exception Type: {type(error).__name__}",
            f"Exception Message: {str(error)}",
            "",
        ]
        
        # Add raw rows information if available
        if raw_rows is not None:
            report_lines.extend([
                "RAW ROWS DATA:",
                f"Number of rows: {len(raw_rows)}",
                f"Row type: {type(raw_rows[0]).__name__ if raw_rows else 'N/A'}",
                "",
            ])
            
            # Try to show sample data (safely)
            if raw_rows:
                report_lines.append("First row sample (if accessible):")
                try:
                    first_row = raw_rows[0]
                    # Try to convert to dict
                    row_dict = _row_to_dict(first_row)
                    if row_dict:
                        for key, value in row_dict.items():
                            report_lines.append(f"  {key}: {value}")
                    else:
                        report_lines.append(f"  Could not convert row to dict: {first_row}")
                except Exception as row_error:
                    report_lines.append(f"  Error accessing row data: {row_error}")
                report_lines.append("")
        
        report_lines.extend([
            "RECOMMENDED ACTIONS:",
            "1. Check that the database connection is properly configured",
            "2. Verify that buvette_inventaire_lignes table exists and has expected columns",
            "3. Ensure sqlite3.Row factory is properly set on database connections",
            "4. Check for any database migration issues",
            "",
            "=" * 80,
        ])
        
        # Write report to file
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(report_lines))
        
        logger.info(f"Error report written to: {report_path}")
        
    except Exception as report_error:
        # If we can't write the report, at least log it
        logger.error(f"Failed to write error report: {report_error}")

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/journal.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import pandas as pd
from db.db import get_connection
from exports.exports import (
    export_dataframe_to_excel,
    export_dataframe_to_pdf,
    export_dataframe_to_csv
)

class JournalModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Journal GÃ©nÃ©ral")
        self.top.geometry("1200x700")
        self.create_widgets()
        self.refresh_journal()

    def create_widgets(self):
        # Zone filtres/recherche/export
        filter_frame = tk.Frame(self.top)
        filter_frame.pack(fill=tk.X, padx=8, pady=4)
        tk.Label(filter_frame, text="Recherche :").pack(side=tk.LEFT)
        self.search_var = tk.StringVar()
        search_entry = tk.Entry(filter_frame, textvariable=self.search_var, width=32)
        search_entry.pack(side=tk.LEFT, padx=5)
        search_entry.bind('<Return>', lambda e: self.apply_filter())
        tk.Button(filter_frame, text="Filtrer", command=self.apply_filter).pack(side=tk.LEFT, padx=4)
        tk.Button(filter_frame, text="Effacer", command=self.clear_filter).pack(side=tk.LEFT, padx=4)
        tk.Button(filter_frame, text="Exporter Excel", command=self.export_excel).pack(side=tk.RIGHT, padx=4)
        tk.Button(filter_frame, text="Exporter PDF", command=self.export_pdf).pack(side=tk.RIGHT, padx=4)
        tk.Button(filter_frame, text="Exporter CSV", command=self.export_csv).pack(side=tk.RIGHT, padx=4)

        # Tableau principal
        columns = ("date", "type", "libelle", "montant", "justificatif")
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings")
        for col, text, w, anchor in zip(
            columns,
            ["Date", "Type", "LibellÃ©", "Montant (â‚¬)", "Justificatif/Commentaire"],
            [100, 150, 290, 120, 470],
            ["center", "w", "w", "e", "w"]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor=anchor)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=6, pady=3)

        # Scrollbars
        vsb = ttk.Scrollbar(self.top, orient="vertical", command=self.tree.yview)
        hsb = ttk.Scrollbar(self.top, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        vsb.pack(side='right', fill='y')
        hsb.pack(side='bottom', fill='x')

        # Ligne de total et solde progressif
        self.total_var = tk.StringVar()
        self.recette_var = tk.StringVar()
        self.depense_var = tk.StringVar()
        self.solde_ouv_var = tk.StringVar()
        total_frame = tk.Frame(self.top)
        total_frame.pack(fill=tk.X, padx=6, pady=3)
        tk.Label(total_frame, textvariable=self.solde_ouv_var, anchor="e", fg="orange").pack(side=tk.LEFT, padx=(0, 15))
        tk.Label(total_frame, textvariable=self.recette_var, anchor="e", fg="green").pack(side=tk.LEFT)
        tk.Label(total_frame, textvariable=self.depense_var, anchor="e", fg="red").pack(side=tk.LEFT, padx=(15,0))
        tk.Label(total_frame, textvariable=self.total_var, anchor="e", fg="blue").pack(side=tk.RIGHT)

        # Double-clic pour dÃ©tail
        self.tree.bind("<Double-1>", self.show_detail)

        # Bouton fermer
        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=4)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=10)

    def refresh_journal(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        # RÃ©cupÃ©rer le solde d'ouverture
        solde_ouverture = 0.0
        try:
            row = conn.execute("SELECT solde_report FROM config ORDER BY id DESC LIMIT 1").fetchone()
            if row and row[0] is not None:
                solde_ouverture = float(row[0])
        except Exception:
            pass
        df = pd.read_sql_query("""
            SELECT date, 'Recette' as type, source as libelle, montant, justificatif FROM dons_subventions
            UNION ALL
            SELECT e.date as date, 'Recette Ã©vÃ¨nement', er.source, er.montant, er.commentaire
                FROM event_recettes er
                JOIN events e ON er.event_id = e.id
            UNION ALL
            SELECT date_depense as date, 'DÃ©pense rÃ©guliÃ¨re', categorie, -montant, commentaire AS justificatif FROM depenses_regulieres
            UNION ALL
            SELECT date_depense as date, 'DÃ©pense diverse', commentaire, -montant, commentaire AS justificatif FROM depenses_diverses
            UNION ALL
            SELECT e.date as date, 'DÃ©pense Ã©vÃ¨nement', ed.categorie, -ed.montant, ed.commentaire
                FROM event_depenses ed
                JOIN events e ON ed.event_id = e.id
            ORDER BY date
        """, conn)
        # Ajout du solde progressif avec solde d'ouverture
        df = df.copy()
        try:
            df["montant"] = df["montant"].astype(float)
        except Exception:
            pass
        df["Solde"] = df["montant"].cumsum() + solde_ouverture
        self.df = df
        self.solde_ouverture = solde_ouverture
        self.populate_table(self.df)
        conn.close()

    def populate_table(self, df):
        self.tree.delete(*self.tree.get_children())
        total = self.solde_ouverture
        total_recettes = 0
        total_depenses = 0
        for _, row in df.iterrows():
            montant = row["montant"]
            try:
                montant_float = float(montant)
            except Exception:
                montant_float = 0
            total += montant_float
            if montant_float > 0:
                total_recettes += montant_float
            else:
                total_depenses += montant_float  # nÃ©gatif
            # Couleur selon type
            tags = []
            if montant_float > 0:
                tags.append("recette")
            elif montant_float < 0:
                tags.append("depense")
            self.tree.insert(
                "", "end",
                values=(row["date"], row["type"], row["libelle"], f"{montant_float:.2f}", row["justificatif"]),
                tags=tags
            )
        self.tree.tag_configure('depense', background="#ffeaea")
        self.tree.tag_configure('recette', background="#eaffea")
        self.solde_ouv_var.set(f"Solde d'ouverture : {self.solde_ouverture:.2f} â‚¬")
        self.total_var.set(f"Solde global : {total:.2f} â‚¬")
        self.recette_var.set(f"Total recettes : {total_recettes:.2f} â‚¬")
        self.depense_var.set(f"Total dÃ©penses : {abs(total_depenses):.2f} â‚¬")

    def apply_filter(self):
        term = self.search_var.get().lower()
        if not term:
            self.populate_table(self.df)
            return
        mask = self.df.apply(lambda row: row.astype(str).str.lower().str.contains(term).any(), axis=1)
        filtered = self.df[mask]
        self.populate_table(filtered)

    def clear_filter(self):
        self.search_var.set("")
        self.populate_table(self.df)

    def export_excel(self):
        if hasattr(self, 'df') and not self.df.empty:
            export_dataframe_to_excel(self.df, title="Export Excel - Journal GÃ©nÃ©ral")

    def export_pdf(self):
        if hasattr(self, 'df') and not self.df.empty:
            export_dataframe_to_pdf(self.df, title="Export PDF - Journal GÃ©nÃ©ral")

    def export_csv(self):
        if hasattr(self, 'df') and not self.df.empty:
            export_dataframe_to_csv(self.df, title="Export CSV - Journal GÃ©nÃ©ral")

    def show_detail(self, event):
        item = self.tree.identify_row(event.y)
        if item:
            vals = self.tree.item(item)['values']
            cols = ["Date", "Type", "LibellÃ©", "Montant (â‚¬)", "Justificatif/Commentaire"]
            tk.messagebox.showinfo("DÃ©tail Ã©criture", "\n".join(f"{c} : {v}" for c, v in zip(cols, vals)))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/members.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection
import pandas as pd
from utils.validation import is_email, is_required
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

STATUTS = [
    "PrÃ©sidente", "PrÃ©sident", "Vice-PrÃ©sidente", "Vice-PrÃ©sident",
    "SecrÃ©taire", "SecrÃ©taire-Adjointe", "SecrÃ©taire-Adjoint",
    "TrÃ©soriÃ¨re", "TrÃ©sorier", "TrÃ©soriÃ¨re-Adjointe", "TrÃ©sorier-Adjoint",
    "Membre"
]
COTISATION_ETATS = ["RÃ©glÃ©", "Non rÃ©glÃ©", "ExemptÃ©"]

logger = get_logger("members_module")

class MembersModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Gestion des Membres")
        self.top.geometry("980x520")
        self.create_table()
        self.create_buttons()
        self.refresh_members()

    def create_table(self):
        columns = (
            "id", "name", "prenom", "email", "cotisation", "commentaire",
            "telephone", "statut", "date_adhesion"
        )
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings")
        headings = [
            ("ID", 40), ("Name", 140), ("PrÃ©nom", 130), ("Email", 180),
            ("Cotisation", 90), ("Commentaire", 140),
            ("TÃ©lÃ©phone", 110), ("Statut", 110), ("Date adhÃ©sion", 110)
        ]
        for idx, (col, w) in enumerate(zip(columns, [h[1] for h in headings])):
            self.tree.heading(col, text=headings[idx][0])
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True)
        vsb = ttk.Scrollbar(self.top, orient="vertical", command=self.tree.yview)
        vsb.pack(side='right', fill='y')
        self.tree.configure(yscroll=vsb.set)

    def create_buttons(self):
        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=8)
        tk.Button(btn_frame, text="Ajouter membre", command=self.add_member).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Modifier", command=self.edit_member).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_member).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Exporter CSV", command=self.export_csv).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=10)

    def refresh_members(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            df = pd.read_sql_query("SELECT * FROM membres ORDER BY name, prenom", conn)
            self.df = df
            for _, row in df.iterrows():
                self.tree.insert(
                    "", "end",
                    values=(
                        row["id"], row["name"], row["prenom"], row["email"], row.get("cotisation", ""),
                        row.get("commentaire", ""), row.get("telephone", ""), row.get("statut", ""),
                        row.get("date_adhesion", "")
                    )
                )
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des membres."))

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_member(self):
        EditMemberDialog(self.top, member_id=None, on_save=self.refresh_members)

    def edit_member(self):
        mid = self.get_selected_id()
        if not mid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un membre Ã  modifier.")
            return
        EditMemberDialog(self.top, member_id=mid, on_save=self.refresh_members)

    def delete_member(self):
        mid = self.get_selected_id()
        if not mid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un membre Ã  supprimer.")
            return
        if not messagebox.askyesno("Confirmer", "ÃŠtes-vous sÃ»r de vouloir supprimer ce membre ?"):
            return
        confirm = simpledialog.askstring(
            "Confirmation",
            "Retapez SUPPRIMER pour confirmer la suppression du membre :",
            parent=self.top
        )
        if (confirm or "").strip().upper() != "SUPPRIMER":
            messagebox.showinfo("AnnulÃ©", "Suppression annulÃ©e.")
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM membres WHERE id=?", (mid,))
            conn.commit()
            conn.close()
            logger.info(f"Membre supprimÃ© id {mid}")
            self.refresh_members()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression du membre."))

    def export_csv(self):
        from tkinter import filedialog
        from utils.csv_helpers import write_csv
        try:
            filepath = filedialog.asksaveasfilename(
                title="Exporter membres en CSV",
                defaultextension=".csv",
                filetypes=[("CSV", "*.csv")]
            )
            if not filepath:
                return
            df = getattr(self, "df", None)
            if df is not None and not df.empty:
                write_csv(filepath, df.values.tolist(), header=list(df.columns))
                messagebox.showinfo("Export CSV", f"Export rÃ©ussi dans {filepath}")
            else:
                messagebox.showwarning("Alerte", "Aucun membre Ã  exporter.")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'export CSV."))

class EditMemberDialog(tk.Toplevel):
    def __init__(self, master, member_id=None, on_save=None):
        super().__init__(master)
        self.title("Membre" if member_id is None else "Modifier membre")
        self.member_id = member_id
        self.on_save = on_save
        self.geometry("420x440")
        self.resizable(False, False)

        self.nom_var = tk.StringVar()
        self.prenom_var = tk.StringVar()
        self.email_var = tk.StringVar()
        self.cotisation_var = tk.StringVar()
        self.commentaire_var = tk.StringVar()
        self.tel_var = tk.StringVar()
        self.statut_var = tk.StringVar()
        self.date_var = tk.StringVar()

        tk.Label(self, text="Name :").pack(pady=4)
        tk.Entry(self, textvariable=self.nom_var, width=30).pack()
        tk.Label(self, text="PrÃ©nom :").pack(pady=4)
        tk.Entry(self, textvariable=self.prenom_var, width=30).pack()
        tk.Label(self, text="Email :").pack(pady=4)
        tk.Entry(self, textvariable=self.email_var, width=35).pack()
        tk.Label(self, text="Cotisation :").pack(pady=4)
        cotisation_menu = ttk.Combobox(
            self, textvariable=self.cotisation_var, values=COTISATION_ETATS, state="readonly", width=16
        )
        cotisation_menu.pack()
        tk.Label(self, text="Commentaire :").pack(pady=4)
        tk.Entry(self, textvariable=self.commentaire_var, width=35).pack()
        tk.Label(self, text="TÃ©lÃ©phone :").pack(pady=4)
        tk.Entry(self, textvariable=self.tel_var, width=18).pack()
        tk.Label(self, text="Statut :").pack(pady=4)
        statut_menu = ttk.Combobox(
            self, textvariable=self.statut_var, values=STATUTS, state="readonly", width=24
        )
        statut_menu.pack()
        tk.Label(self, text="Date adhÃ©sion (YYYY-MM-DD) :").pack(pady=4)
        tk.Entry(self, textvariable=self.date_var, width=20).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=36, pady=16)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=36, pady=16)

        if self.member_id is not None:
            self.load_member()

    def load_member(self):
        try:
            conn = get_connection()
            row = conn.execute(
                "SELECT name, prenom, email, cotisation, commentaire, telephone, statut, date_adhesion FROM membres WHERE id=?",
                (self.member_id,)
            ).fetchone()
            conn.close()
            if row is not None:
                self.nom_var.set(row[0])
                self.prenom_var.set(row[1])
                self.email_var.set(row[2] if row[2] else "")
                self.cotisation_var.set(row[3] if row[3] else COTISATION_ETATS[1])  # dÃ©faut: "Non rÃ©glÃ©"
                self.commentaire_var.set(row[4] if row[4] else "")
                self.tel_var.set(row[5] if row[5] else "")
                self.statut_var.set(row[6] if row[6] else STATUTS[0])
                self.date_var.set(row[7] if row[7] else "")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement du membre."))

    def save(self):
        name = self.nom_var.get().strip()
        prenom = self.prenom_var.get().strip()
        email = self.email_var.get().strip()
        cotisation = self.cotisation_var.get().strip()
        commentaire = self.commentaire_var.get().strip()
        tel = self.tel_var.get().strip()
        statut = self.statut_var.get().strip()
        date_adh = self.date_var.get().strip()
        if not is_required(name) or not is_required(prenom) or not is_required(date_adh):
            messagebox.showerror("Erreur", "Name, prÃ©nom et date d'adhÃ©sion sont obligatoires.")
            return
        if not cotisation:
            cotisation = COTISATION_ETATS[1]  # dÃ©faut: "Non rÃ©glÃ©"
        if not statut:
            statut = STATUTS[0]
        if email and not is_email(email):
            messagebox.showerror("Erreur", "Email invalide.")
            return
        try:
            conn = get_connection()
            if self.member_id is not None:
                conn.execute(
                    "UPDATE membres SET name=?, prenom=?, email=?, cotisation=?, commentaire=?, telephone=?, statut=?, date_adhesion=? WHERE id=?",
                    (name, prenom, email, cotisation, commentaire, tel, statut, date_adh, self.member_id)
                )
            else:
                conn.execute(
                    "INSERT INTO membres (name, prenom, email, cotisation, commentaire, telephone, statut, date_adhesion) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                    (name, prenom, email, cotisation, commentaire, tel, statut, date_adh)
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement du membre."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/model_colonnes.py ===

```python
"""
Module pour la gestion centralisÃ©e des modÃ¨les de colonnes et de leurs listes de choix.
Utilise les tables colonnes_modeles et valeurs_modeles_colonnes pour cohÃ©rence avec le reste de l'application.
"""
import tkinter as tk
from tkinter import ttk, simpledialog, messagebox
from db.db import get_connection

def create_tables_if_needed():
    conn = get_connection()
    conn.execute("""
        CREATE TABLE IF NOT EXISTS colonnes_modeles (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE NOT NULL,
            type_modele TEXT DEFAULT 'TEXT'
        )
    """)
    conn.execute("""
        CREATE TABLE IF NOT EXISTS valeurs_modeles_colonnes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            modele_id INTEGER,
            valeur TEXT,
            FOREIGN KEY(modele_id) REFERENCES colonnes_modeles(id)
        )
    """)
    conn.commit()
    conn.close()

def get_colonnes_connues():
    conn = get_connection()
    res = conn.execute("SELECT * FROM colonnes_modeles ORDER BY name").fetchall()
    conn.close()
    return res

def get_choix_pour_colonne(modele_id):
    conn = get_connection()
    res = conn.execute("SELECT valeur FROM valeurs_modeles_colonnes WHERE modele_id=? ORDER BY valeur", (modele_id,)).fetchall()
    conn.close()
    return [r['valeur'] for r in res]

def ajouter_modele_colonne(name, typ, valeurs):
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("INSERT OR IGNORE INTO colonnes_modeles (name, type_modele) VALUES (?, ?)", (name, typ))
    modele_id = cur.execute("SELECT id FROM colonnes_modeles WHERE name=?", (name,)).fetchone()["id"]
    # Efface anciennes valeurs
    cur.execute("DELETE FROM valeurs_modeles_colonnes WHERE modele_id=?", (modele_id,))
    for v in valeurs:
        cur.execute("INSERT INTO valeurs_modeles_colonnes (modele_id, valeur) VALUES (?, ?)", (modele_id, v))
    conn.commit()
    conn.close()

class GestionModelColonnes(tk.Toplevel):
    def __init__(self, master):
        super().__init__(master)
        self.title("Gestion des modÃ¨les de colonnes")
        self.geometry("650x420")
        self.minsize(400, 200)
        self.maxsize(900, 600)
        create_tables_if_needed()
        self.frame = tk.Frame(self)
        self.frame.pack(fill="both", expand=True, padx=10, pady=10)
        self.refresh_list()
        btns = tk.Frame(self)
        btns.pack(fill="x")
        tk.Button(btns, text="Ajouter un modÃ¨le", command=self.ajouter).pack(side="left", padx=5, pady=8)
        tk.Button(btns, text="Fermer", command=self.destroy).pack(side="right", padx=5, pady=8)

    def refresh_list(self):
        for w in self.frame.winfo_children():
            w.destroy()
        tk.Label(self.frame, text="ModÃ¨les existants :", font=("Arial", 10, "bold")).pack(anchor="w", pady=(0, 6))
        colonnes = get_colonnes_connues()
        for c in colonnes:
            frm = tk.Frame(self.frame)
            frm.pack(fill="x", pady=2, anchor="w")
            tk.Label(frm, text=f"{c['name']} ({c['type_modele']})", anchor="w").pack(side="left")
            choix = get_choix_pour_colonne(c["id"])
            if choix:
                tk.Button(frm, text="Voir la liste", command=lambda cid=c["id"]: self.voir_liste_choix(cid)).pack(side="left", padx=4)
            tk.Button(frm, text="Modifier", command=lambda cid=c['id']: self.modifier(cid)).pack(side="left", padx=2)
            tk.Button(frm, text="Supprimer", command=lambda cid=c['id']: self.supprimer(cid)).pack(side="left", padx=2)

    def ajouter(self):
        ModeleColonneDialog(self, callback=self.refresh_list)

    def modifier(self, modele_id):
        ModeleColonneDialog(self, modele_id=modele_id, callback=self.refresh_list)

    def supprimer(self, modele_id):
        if messagebox.askyesno("Suppression", "Supprimer ce modÃ¨le ?"):
            conn = get_connection()
            conn.execute("DELETE FROM colonnes_modeles WHERE id=?", (modele_id,))
            conn.execute("DELETE FROM valeurs_modeles_colonnes WHERE modele_id=?", (modele_id,))
            conn.commit()
            conn.close()
            self.refresh_list()

    def voir_liste_choix(self, modele_id):
        choix = get_choix_pour_colonne(modele_id)
        txt = "\n".join(choix) if choix else "(Aucun choix enregistrÃ©)"
        top = tk.Toplevel(self)
        top.title("Liste des choix")
        top.geometry("350x300")
        tk.Label(top, text="Valeurs possibles :", font=("Arial", 10, "bold")).pack(pady=8)
        text = tk.Text(top, height=15, width=40)
        text.pack(padx=8, pady=8)
        text.insert("1.0", txt)
        text.config(state="disabled")
        tk.Button(top, text="Fermer", command=top.destroy).pack(pady=8)

class ModeleColonneDialog(tk.Toplevel):
    def __init__(self, master, modele_id=None, callback=None):
        super().__init__(master)
        self.callback = callback
        self.modele_id = modele_id
        self.title("Ajout/modification modÃ¨le colonne")
        self.geometry("400x240")
        self.nom_var = tk.StringVar()
        self.type_var = tk.StringVar(value="TEXT")
        self.valeurs_var = tk.StringVar()
        if modele_id:
            self.load_colonne(modele_id)
        tk.Label(self, text="Name colonne :").pack()
        tk.Entry(self, textvariable=self.nom_var).pack(fill="x", padx=8)
        tk.Label(self, text="Type :").pack()
        ttk.Combobox(self, textvariable=self.type_var, values=["TEXT", "INTEGER", "REAL"]).pack(fill="x", padx=8)
        tk.Label(self, text="Valeurs possibles (sÃ©parÃ©es par ;) :").pack()
        tk.Entry(self, textvariable=self.valeurs_var).pack(fill="x", padx=8)
        btns = tk.Frame(self)
        btns.pack(fill="x", pady=8)
        tk.Button(btns, text="Valider", command=self.valider).pack(side="left", padx=6)
        tk.Button(btns, text="Annuler", command=self.destroy).pack(side="right", padx=6)

    def load_colonne(self, modele_id):
        conn = get_connection()
        c = conn.execute("SELECT * FROM colonnes_modeles WHERE id=?", (modele_id,)).fetchone()
        self.nom_var.set(c["name"])
        self.type_var.set(c["type_modele"])
        choix = get_choix_pour_colonne(modele_id)
        self.valeurs_var.set(";".join(choix))
        conn.close()

    def valider(self):
        name = self.nom_var.get().strip()
        typ = self.type_var.get()
        valeurs = [v.strip() for v in self.valeurs_var.get().split(";") if v.strip()]
        if not name:
            messagebox.showerror("Erreur", "Name requis")
            return
        ajouter_modele_colonne(name, typ, valeurs)
        if self.callback:
            self.callback()
        self.destroy()

# FenÃªtre dâ€™ajout de colonne avec menu dÃ©roulant pour les modÃ¨les connus
def ask_add_custom_column(parent):
    create_tables_if_needed()
    colonnes = get_colonnes_connues()
    noms_colonnes = [c["name"] for c in colonnes]
    dlg = AddCustomColumnDialog(parent, noms_colonnes, colonnes)
    parent.wait_window(dlg)
    return dlg.result if hasattr(dlg, "result") else None

class AddCustomColumnDialog(tk.Toplevel):
    def __init__(self, master, noms_colonnes, colonnes):
        super().__init__(master)
        self.title("Ajouter une colonne")
        self.geometry("400x250")
        self.result = None
        self.colonnes = colonnes
        self.nom_var = tk.StringVar()
        self.type_var = tk.StringVar(value="TEXT")
        self.choix_var = tk.StringVar()
        self.choix_values = []
        self.choice_combobox = None
        self.selected_modele_colonne = None

        tk.Label(self, text="Name de colonne :").pack(anchor="w")
        self.combo_nom = ttk.Combobox(self, textvariable=self.nom_var, values=noms_colonnes)
        self.combo_nom.pack(fill="x", padx=8, pady=2)
        self.combo_nom.bind("<<ComboboxSelected>>", self.on_nom_selected)
        self.combo_nom.bind("<KeyRelease>", self.on_nom_typed)

        tk.Label(self, text="Type :").pack(anchor="w")
        self.combo_type = ttk.Combobox(self, textvariable=self.type_var, values=["TEXT", "INTEGER", "REAL"])
        self.combo_type.pack(fill="x", padx=8, pady=2)

        self.choix_frame = tk.Frame(self)
        self.choix_frame.pack(fill="x", padx=4, pady=4)

        btns = tk.Frame(self)
        btns.pack(fill="x", pady=8)
        tk.Button(btns, text="Valider", command=self.on_validate).pack(side="left", padx=6)
        tk.Button(btns, text="Annuler", command=self.destroy).pack(side="right", padx=6)
        tk.Button(btns, text="GÃ©rer les modÃ¨les", command=lambda: GestionModelColonnes(self)).pack(side="right", padx=6)

    def clear_choix(self):
        for w in self.choix_frame.winfo_children():
            w.destroy()
        self.choix_values = []
        self.choice_combobox = None
        self.selected_modele_colonne = None

    def on_nom_selected(self, event=None):
        name = self.nom_var.get()
        self.clear_choix()
        col = next((c for c in self.colonnes if c["name"] == name), None)
        if col:
            self.type_var.set(col["type_modele"])
            self.selected_modele_colonne = col["name"]  # Correction : mÃ©morise le modÃ¨le de colonne sÃ©lectionnÃ©
            choix = get_choix_pour_colonne(col["id"])
            if choix:
                tk.Label(self.choix_frame, text="Valeur Ã  choisir :", font=("Arial", 10, "bold")).pack(anchor="w")
                self.choice_combobox = ttk.Combobox(self.choix_frame, values=choix, textvariable=self.choix_var)
                self.choice_combobox.pack(fill="x", padx=6, pady=2)
                self.choix_values = choix
        else:
            self.type_var.set("TEXT")
            self.selected_modele_colonne = None

    def on_nom_typed(self, event=None):
        # Si saisie libre (name non connu), effacer champ choix
        if self.nom_var.get() not in [c["name"] for c in self.colonnes]:
            self.clear_choix()
            self.type_var.set("TEXT")
            self.selected_modele_colonne = None

    def on_validate(self):
        name = self.nom_var.get().strip()
        typ = self.type_var.get().strip()
        valeur_choisie = self.choix_var.get().strip() if self.choice_combobox else None
        if not name:
            messagebox.showerror("Erreur", "Name de colonne requis")
            return
        result = {"name": name, "type": typ}
        # Correction : toujours transmettre le modele_colonne si c'est un modÃ¨le connu
        if self.selected_modele_colonne:
            result["modele_colonne"] = self.selected_modele_colonne
        else:
            result["modele_colonne"] = None
        if self.choice_combobox and valeur_choisie:
            result["valeur_choisie"] = valeur_choisie
        self.result = result
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/mouvements_stock.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
import pandas as pd

class MouvementsStockModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Historique des mouvements de stock")
        self.top.geometry("1000x550")
        self.create_table()
        self.refresh_mouvements()

    def create_table(self):
        columns = ("id", "date", "name", "type", "quantite", "prix_achat_total", "prix_unitaire", "date_peremption", "commentaire")
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings")
        for col, text, w in zip(
            columns,
            ["ID", "Date", "Article", "Type", "QuantitÃ©", "Prix total", "Prix unitaire", "Date pÃ©remption", "Commentaire"],
            [40, 100, 160, 70, 80, 90, 90, 110, 220]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True)
        vsb = ttk.Scrollbar(self.top, orient="vertical", command=self.tree.yview)
        vsb.pack(side='right', fill='y')
        self.tree.configure(yscroll=vsb.set)
        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=8)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=10)

    def refresh_mouvements(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        df = pd.read_sql_query("""
            SELECT m.id, m.date, s.name, m.type, m.quantite, m.prix_achat_total, m.prix_unitaire, m.date_peremption, m.commentaire
            FROM mouvements_stock m
            LEFT JOIN stock s ON m.stock_id = s.id
            ORDER BY m.date DESC, m.id DESC
        """, conn)
        for _, row in df.iterrows():
            self.tree.insert(
                "", "end",
                values=(
                    row["id"], row["date"], row["name"], row["type"], row["quantite"],
                    f"{row['prix_achat_total']:.2f}" if pd.notnull(row['prix_achat_total']) else "",
                    f"{row['prix_unitaire']:.2f}" if pd.notnull(row['prix_unitaire']) else "",
                    row["date_peremption"] if pd.notnull(row["date_peremption"]) else "",
                    row["commentaire"] if pd.notnull(row["commentaire"]) else ""
                )
            )
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/retrocessions_ecoles.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection

class RetrocessionsEcolesModule(tk.Toplevel):
    def __init__(self, master=None):
        super().__init__(master)
        self.title("RÃ©trocessions aux Ã©coles")
        self.geometry("560x420")
        self.resizable(False, False)
        self.create_widgets()
        self.refresh_list()

    def create_widgets(self):
        frame = tk.Frame(self)
        frame.pack(fill=tk.BOTH, expand=True, padx=12, pady=10)

        self.tree = ttk.Treeview(frame, columns=("id", "date", "ecole", "montant", "commentaire"), show="headings", selectmode="browse")
        for col, txt, w in zip(
            ("id", "date", "ecole", "montant", "commentaire"),
            ["ID", "Date", "Ã‰cole", "Montant (â‚¬)", "Commentaire"],
            [40, 90, 140, 100, 160]
        ):
            self.tree.heading(col, text=txt)
            self.tree.column(col, width=w)
        self.tree.pack(fill=tk.BOTH, expand=True, pady=6)

        btns = tk.Frame(frame)
        btns.pack(fill=tk.X, pady=10)
        tk.Button(btns, text="Ajouter", command=self.add_retro).pack(side=tk.LEFT, padx=6)
        tk.Button(btns, text="Modifier", command=self.edit_retro).pack(side=tk.LEFT, padx=6)
        tk.Button(btns, text="Supprimer", command=self.delete_retro).pack(side=tk.LEFT, padx=6)
        tk.Button(btns, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=6)

    def refresh_list(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        rows = conn.execute(
            "SELECT id, date, ecole, montant, commentaire FROM retrocessions_ecoles ORDER BY date DESC"
        ).fetchall()
        for r in rows:
            self.tree.insert("", "end", values=(r["id"], r["date"], r["ecole"], f"{r['montant']:.2f}", r["commentaire"]))
        conn.close()

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne.")
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_retro(self):
        self.edit_retro_form()

    def edit_retro(self):
        cid = self.get_selected_id()
        if not cid:
            return
        conn = get_connection()
        old = conn.execute("SELECT * FROM retrocessions_ecoles WHERE id=?", (cid,)).fetchone()
        conn.close()
        if not old:
            return
        self.edit_retro_form(old)

    def edit_retro_form(self, data=None):
        win = tk.Toplevel(self)
        win.title("RÃ©trocession" + (" - Modifier" if data else " - Ajouter"))
        win.geometry("350x290")
        win.grab_set()

        tk.Label(win, text="Date (YYYY-MM-DD)").pack(pady=(16,2))
        date_var = tk.StringVar(value=data["date"] if data else "")
        tk.Entry(win, textvariable=date_var).pack()

        tk.Label(win, text="Ã‰cole").pack(pady=(12,2))
        ecole_var = tk.StringVar(value=data["ecole"] if data else "")
        tk.Entry(win, textvariable=ecole_var).pack()

        tk.Label(win, text="Montant (â‚¬)").pack(pady=(12,2))
        montant_var = tk.StringVar(value=f"{data['montant']:.2f}" if data else "")
        tk.Entry(win, textvariable=montant_var).pack()

        tk.Label(win, text="Commentaire").pack(pady=(12,2))
        comm_var = tk.StringVar(value=data["commentaire"] if data else "")
        tk.Entry(win, textvariable=comm_var).pack()

        def valider():
            date = date_var.get().strip()
            ecole = ecole_var.get().strip()
            montant = montant_var.get().replace(",", ".").strip()
            commentaire = comm_var.get().strip()
            try:
                montant_float = float(montant)
            except Exception:
                messagebox.showerror("Erreur", "Montant invalide.")
                return
            if not (date and ecole):
                messagebox.showerror("Erreur", "Date et Ã©cole obligatoires.")
                return
            conn = get_connection()
            if data:
                conn.execute("UPDATE retrocessions_ecoles SET date=?, ecole=?, montant=?, commentaire=? WHERE id=?",
                             (date, ecole, montant_float, commentaire, data["id"]))
            else:
                conn.execute("INSERT INTO retrocessions_ecoles (date, ecole, montant, commentaire) VALUES (?, ?, ?, ?)",
                             (date, ecole, montant_float, commentaire))
            conn.commit()
            conn.close()
            win.destroy()
            self.refresh_list()

        tk.Button(win, text="Valider", command=valider).pack(pady=16)
        tk.Button(win, text="Annuler", command=win.destroy).pack()
        win.wait_window()

    def delete_retro(self):
        cid = self.get_selected_id()
        if not cid:
            return
        if not messagebox.askyesno("Supprimer", "Supprimer cette rÃ©trocession ?"):
            return
        conn = get_connection()
        conn.execute("DELETE FROM retrocessions_ecoles WHERE id=?", (cid,))
        conn.commit()
        conn.close()
        self.refresh_list()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/solde_ouverture.py ===

```python
import tkinter as tk
from tkinter import messagebox
from db.db import get_connection

class SoldeOuvertureDialog(tk.Toplevel):
    def __init__(self, master, on_save=None):
        super().__init__(master)
        self.title("Solde d'ouverture bancaire")
        self.geometry("380x180")
        self.resizable(False, False)
        self.on_save = on_save

        tk.Label(self, text="Solde d'ouverture bancaire en dÃ©but d'exercice :", font=("Arial", 12)).pack(pady=16)
        self.solde_var = tk.StringVar()
        tk.Entry(self, textvariable=self.solde_var, font=("Arial", 14), width=16, justify="center").pack(pady=6)

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=16)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=20)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=20)

        self.load_solde()

    def load_solde(self):
        conn = get_connection()
        row = conn.execute("SELECT solde_report FROM config ORDER BY id DESC LIMIT 1").fetchone()
        conn.close()
        if row and row[0] is not None:
            self.solde_var.set(f"{row[0]:.2f}")
        else:
            self.solde_var.set("0.00")

    def save(self):
        val = self.solde_var.get().replace(",", ".").strip()
        try:
            float_val = float(val)
        except Exception:
            messagebox.showerror("Erreur", "Veuillez saisir un montant valide.")
            return
        conn = get_connection()
        conn.execute("UPDATE config SET solde_report=? WHERE id=(SELECT MAX(id) FROM config)", (float_val,))
        conn.commit()
        conn.close()
        messagebox.showinfo("OK", "Solde d'ouverture mis Ã  jour.")
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/stock.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
import pandas as pd
from db.db import get_connection

class StockModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Gestion du Stock")
        self.top.geometry("1050x600")
        self.create_table()
        self.create_buttons()
        self.refresh_stock()

    def create_table(self):
        columns = ("id", "name", "categorie", "quantite", "seuil_alerte", "date_peremption", "lot", "commentaire")
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings")
        for col, text, w in zip(
            columns,
            ["ID", "Name", "CatÃ©gorie", "QuantitÃ©", "Seuil alerte", "Date pÃ©remption", "Lot", "Commentaire"],
            [40, 160, 120, 80, 95, 100, 95, 220]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True)
        vsb = ttk.Scrollbar(self.top, orient="vertical", command=self.tree.yview)
        vsb.pack(side='right', fill='y')
        self.tree.configure(yscroll=vsb.set)

    def create_buttons(self):
        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=8)
        tk.Button(btn_frame, text="Ajouter article", command=self.add_stock).pack(side=tk.LEFT, padx=7)
        tk.Button(btn_frame, text="Modifier", command=self.edit_stock).pack(side=tk.LEFT, padx=7)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_stock).pack(side=tk.LEFT, padx=7)
        tk.Button(btn_frame, text="Mouvement stock", command=self.open_mouvements).pack(side=tk.LEFT, padx=7)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=7)

    def refresh_stock(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        df = pd.read_sql_query("""
            SELECT s.id, s.name, c.name as categorie, s.quantite, s.seuil_alerte, s.date_peremption, s.lot, s.commentaire
            FROM stock s
            LEFT JOIN categories c ON s.categorie_id = c.id
            ORDER BY s.name
        """, conn)
        self.df = df
        for idx, (_, row) in enumerate(df.iterrows()):
            self.tree.insert(
                "", "end",
                values=(
                    row["id"], row["name"], row["categorie"], row["quantite"],
                    row["seuil_alerte"], row["date_peremption"], row["lot"], row["commentaire"]
                )
            )

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_stock(self):
        StockDialog(self.top, on_save=self.refresh_stock)

    def edit_stock(self):
        sid = self.get_selected_id()
        if not sid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un article Ã  modifier.")
            return
        row = self.df[self.df['id'] == sid].iloc[0]
        StockDialog(self.top, stock=row, on_save=self.refresh_stock)

    def delete_stock(self):
        sid = self.get_selected_id()
        if not sid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un article Ã  supprimer.")
            return
        if not messagebox.askyesno("Confirmer", "ÃŠtes-vous sÃ»r de vouloir supprimer cet article ?"):
            return
        confirm = simpledialog.askstring("Confirmation", "Retapez SUPPRIMER pour confirmer la suppression de l'article :", parent=self.top)
        if (confirm or "").strip().upper() != "SUPPRIMER":
            messagebox.showinfo("AnnulÃ©", "Suppression annulÃ©e.")
            return
        conn = get_connection()
        conn.execute("DELETE FROM stock WHERE id=?", (sid,))
        conn.commit()
        conn.close()
        self.refresh_stock()

    def open_mouvements(self):
        from modules.mouvements_stock import MouvementsStockModule
        MouvementsStockModule(self.top)

class StockDialog(tk.Toplevel):
    def __init__(self, master, stock=None, on_save=None):
        super().__init__(master)
        self.title("Article" if stock is None else "Modifier article")
        self.stock = stock
        self.on_save = on_save
        self.geometry("420x440")
        self.resizable(False, False)

        self.nom_var = tk.StringVar()
        self.cat_var = tk.StringVar()
        self.qte_var = tk.IntVar()
        self.seuil_var = tk.IntVar()
        self.date_peremp_var = tk.StringVar()
        self.lot_var = tk.StringVar()
        self.comment_var = tk.StringVar()

        tk.Label(self, text="Name :").pack(pady=5)
        tk.Entry(self, textvariable=self.nom_var, width=30).pack()
        tk.Label(self, text="CatÃ©gorie :").pack(pady=5)
        self.cat_cb = ttk.Combobox(self, textvariable=self.cat_var, state="readonly", width=25)
        self.cat_cb.pack()
        self.cat_cb["values"] = self.get_categories()
        tk.Label(self, text="QuantitÃ© :").pack(pady=5)
        tk.Entry(self, textvariable=self.qte_var, width=12).pack()
        tk.Label(self, text="Seuil alerte :").pack(pady=5)
        tk.Entry(self, textvariable=self.seuil_var, width=12).pack()
        tk.Label(self, text="Date pÃ©remption :").pack(pady=5)
        tk.Entry(self, textvariable=self.date_peremp_var, width=15).pack()
        tk.Label(self, text="Lot :").pack(pady=5)
        tk.Entry(self, textvariable=self.lot_var, width=18).pack()
        tk.Label(self, text="Commentaire :").pack(pady=5)
        tk.Entry(self, textvariable=self.comment_var, width=38).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=36, pady=17)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=36, pady=17)

        if self.stock is not None:
            self.load_stock()

    def get_categories(self):
        conn = get_connection()
        cats = conn.execute("SELECT name FROM categories ORDER BY name").fetchall()
        conn.close()
        return [c["name"] for c in cats]

    def load_stock(self):
        s = self.stock
        self.nom_var.set(s["name"])
        self.cat_var.set(s["categorie"])
        self.qte_var.set(s["quantite"])
        self.seuil_var.set(s["seuil_alerte"])
        self.date_peremp_var.set(s["date_peremption"])
        self.lot_var.set(s["lot"])
        self.comment_var.set(s["commentaire"])

    def save(self):
        name = self.nom_var.get().strip()
        cat = self.cat_var.get().strip()
        qte = self.qte_var.get()
        seuil = self.seuil_var.get()
        datep = self.date_peremp_var.get().strip()
        lot = self.lot_var.get().strip()
        comment = self.comment_var.get().strip()
        if not name:
            messagebox.showerror("Erreur", "Name obligatoire.")
            return
        conn = get_connection()
        cat_id = None
        if cat:
            row = conn.execute("SELECT id FROM categories WHERE name=?", (cat,)).fetchone()
            if row:
                cat_id = row["id"]
        if self.stock is not None:
            conn.execute(
                "UPDATE stock SET name=?, categorie_id=?, quantite=?, seuil_alerte=?, date_peremption=?, lot=?, commentaire=? WHERE id=?",
                (name, cat_id, qte, seuil, datep, lot, comment, self.stock["id"])
            )
        else:
            conn.execute(
                "INSERT INTO stock (name, categorie_id, quantite, seuil_alerte, date_peremption, lot, commentaire) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (name, cat_id, qte, seuil, datep, lot, comment)
            )
        conn.commit()
        conn.close()
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/stock_inventaire.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
import pandas as pd
from db.db import get_connection, DataSource, get_df_or_sql
from dialogs.inventaire_dialog import InventaireDialog

class StockInventaireModule:
    def __init__(self, master, visualisation_mode=False):
        self.master = master
        self.visualisation_mode = visualisation_mode
        self.top = tk.Toplevel(master)
        self.top.title("Inventaire rapide du stock")
        self.top.geometry("950x500")
        self.create_table()
        self.create_buttons()
        self.load_stock()

    def create_table(self):
        columns = ("id", "name", "categorie", "quantite", "nouvelle_quantite")
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings")
        for col, w in zip(columns, [45, 180, 130, 90, 110]):
            self.tree.heading(col, text=col.capitalize())
            self.tree.column(col, width=w)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

    def create_buttons(self):
        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=8)
        tk.Button(btn_frame, text="Inventorier", command=self.inventorier, state=tk.DISABLED if self.visualisation_mode else tk.NORMAL).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=10)

    def load_stock(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        if DataSource.is_visualisation:
            df = get_df_or_sql("stock")
            cat_df = get_df_or_sql("categories")
            df = df.merge(cat_df, left_on="categorie_id", right_on="id", how="left", suffixes=('', '_cat'))
            df['categorie'] = df['nom_cat'].fillna('')
        else:
            conn = get_connection()
            query = """
                SELECT s.id, s.name, c.name as categorie, s.quantite
                FROM stock s
                LEFT JOIN categories c ON s.categorie_id = c.id
                ORDER BY s.name
            """
            df = pd.read_sql_query(query, conn)
            conn.close()
        for _, row in df.iterrows():
            self.tree.insert("", "end", values=(row["id"], row["name"], row.get("categorie", ""), row["quantite"], ""))

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un article.")
            return None
        return self.tree.item(sel[0])["values"][0]

    def inventorier(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un article Ã  inventorier.")
            return
        item = self.tree.item(sel[0])
        stock_id = item["values"][0]
        name = item["values"][1]
        quantite = item["values"][3]
        dialog = InventaireDialog(self.top, name, quantite)
        self.top.wait_window(dialog)
        if dialog.result is not None:
            nouvelle_qte = dialog.result
            try:
                nouvelle_qte = int(nouvelle_qte)
            except Exception:
                messagebox.showerror("Erreur", "QuantitÃ© invalide.")
                return
            conn = get_connection()
            conn.execute("UPDATE stock SET quantite=? WHERE id=?", (nouvelle_qte, stock_id))
            conn.commit()
            conn.close()
            self.load_stock()
            messagebox.showinfo("Inventaire", f"QuantitÃ© de Â«Â {name}Â Â» mise Ã  jour.")
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./modules/stock_stats.py ===

```python
import tkinter as tk
from tkinter import ttk
import pandas as pd
from db.db import get_connection

class StockStatsModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Statistiques du Stock")
        self.top.geometry("850x480")
        self.show_stats()

    def show_stats(self):
        conn = get_connection()
        df = pd.read_sql_query("""
            SELECT c.name as categorie, COUNT(s.id) as nb_articles, SUM(s.quantite) as total_qte
            FROM stock s
            LEFT JOIN categories c ON s.categorie_id = c.id
            GROUP BY c.name
            ORDER BY c.name
        """, conn)
        conn.close()

        tree = ttk.Treeview(self.top, columns=("categorie", "nb_articles", "total_qte"), show="headings")
        tree.heading("categorie", text="CatÃ©gorie")
        tree.heading("nb_articles", text="Nb buvette_articles")
        tree.heading("total_qte", text="QuantitÃ© totale")
        tree.column("categorie", width=200)
        tree.column("nb_articles", width=100, anchor="center")
        tree.column("total_qte", width=120, anchor="center")
        tree.pack(fill=tk.BOTH, expand=True, padx=12, pady=18)

        for _, row in df.iterrows():
            tree.insert("", "end", values=(row["categorie"], row["nb_articles"], row["total_qte"]))

        tk.Button(self.top, text="Fermer", command=self.top.destroy).pack(pady=10)
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/analyze_modules_columns.py ===

```python
#!/usr/bin/env python3
"""
Script d'analyse stricte des modules pour dÃ©tecter les tables et colonnes utilisÃ©es.

Ce script parcourt le code Python du projet (modules/, ui/, scripts/, lib/)
et extrait UNIQUEMENT les identifiants SQL valides des requÃªtes SQL pour
produire un rapport dÃ©taillÃ© des schÃ©mas attendus par le code.

Contraintes:
- Utilise un regex strict ^[A-Za-z_][A-Za-z0-9_]*$ pour valider les identifiants SQL
- N'extrait QUE depuis les patterns SQL: INSERT INTO, UPDATE SET, SELECT FROM
- Ignore les tokens de code, appels de fonction, texte UI
- GÃ©nÃ¨re des rapports UTF-8
- Collecte les identifiants invalides pour rapport

Usage:
    python scripts/analyze_modules_columns.py
    
Sortie:
    reports/SQL_SCHEMA_HINTS.md - Rapport lisible avec tables et colonnes dÃ©tectÃ©es
    db/schema_hints.yaml - Manifest machine-readable avec colonnes attendues et types infÃ©rÃ©s
"""

import os
import re
import sys
from collections import defaultdict
from pathlib import Path
from typing import Dict, Set, List, Tuple

# Force UTF-8 encoding for stdout/stderr
try:
    sys.stdout.reconfigure(encoding='utf-8')
    sys.stderr.reconfigure(encoding='utf-8')
except Exception:
    pass

# Valid SQL identifier pattern: starts with letter or underscore, followed by letters, digits, or underscores
SQL_IDENTIFIER_PATTERN = re.compile(r'^[A-Za-z_][A-Za-z0-9_]*$')


class StrictSQLAnalyzer:
    """Analyseur strict de code Python pour extraire UNIQUEMENT les identifiants SQL valides."""
    
    def __init__(self, repo_root):
        self.repo_root = Path(repo_root)
        self.table_columns = defaultdict(lambda: {
            "columns": set(),
            "files": set(),
            "column_types": {}
        })
        self.skipped_identifiers = defaultdict(set)  # Track invalid identifiers
        
        # Patterns pour infÃ©rer les types de colonnes
        self.type_patterns = {
            'REAL': [
                r'(prix|montant|solde|total|cout|tarif|taux|valeur)(_\w+)?$',
                r'(disponible|contenance|quantite)(_\w+)?$',
            ],
            'INTEGER': [
                r'^id(_\w+)?$',
                r'(_id|_count|seuil)$',
                r'^(stock|nombre|count)(_\w+)?$',
            ],
            'TEXT': [
                r'(nom|name|prenom|email|adresse|ville|pays)(_\w+)?$',
                r'(commentaire|description|libelle|categorie)(_\w+)?$',
                r'(type|statut|mode|reference|numero|lot)(_\w+)?$',
                r'(fournisseur|donateur|ecole|banque)(_\w+)?$',
                r'(lieu|unite|facture|motif)(_\w+)?$',
            ],
            'DATE': [
                r'date(_\w+)?$',
            ],
        }
    
    def is_valid_sql_identifier(self, identifier: str) -> bool:
        """VÃ©rifie si un identifiant est un identifiant SQL valide."""
        if not identifier:
            return False
        return SQL_IDENTIFIER_PATTERN.match(identifier) is not None
    
    def infer_column_type(self, column_name: str) -> str:
        """InfÃ¨re le type SQL d'une colonne basÃ© sur son nom."""
        column_lower = column_name.lower()
        
        # Test patterns for each type
        for sql_type, patterns in self.type_patterns.items():
            for pattern in patterns:
                if re.search(pattern, column_lower, re.IGNORECASE):
                    return sql_type
        
        # Default to TEXT if no pattern matches
        return 'TEXT'
    
    def add_table_column(self, table: str, column: str, filepath: str):
        """
        Ajoute une colonne Ã  une table aprÃ¨s validation stricte.
        
        Args:
            table: Nom de la table
            column: Nom de la colonne
            filepath: Fichier source
        """
        # Validate table name
        if not self.is_valid_sql_identifier(table):
            self.skipped_identifiers[filepath].add(f"table:{table}")
            return
        
        # Validate column name
        if not self.is_valid_sql_identifier(column):
            self.skipped_identifiers[filepath].add(f"column:{column} (table:{table})")
            return
        
        # Add to tracking
        self.table_columns[table]["columns"].add(column)
        self.table_columns[table]["files"].add(filepath)
        
        # Infer type if not already set
        if column not in self.table_columns[table]["column_types"]:
            self.table_columns[table]["column_types"][column] = self.infer_column_type(column)
    
    def analyze_file(self, filepath: Path):
        """Analyse un fichier Python pour extraire les rÃ©fÃ©rences SQL strictes."""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            print(f"Warning: Could not read {filepath}: {e}")
            return
        
        relative_path = str(filepath.relative_to(self.repo_root))
        
        # Extract SQL references using strict patterns
        self._extract_insert_statements(content, relative_path)
        self._extract_update_statements(content, relative_path)
        self._extract_select_statements(content, relative_path)
        self._extract_create_table_statements(content, relative_path)
    
    def _extract_insert_statements(self, content: str, filepath: str):
        """Extrait les colonnes depuis INSERT INTO statements."""
        # Pattern: INSERT INTO table_name (col1, col2, col3)
        pattern = r'INSERT\s+INTO\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(([^)]+)\)'
        
        for match in re.finditer(pattern, content, re.IGNORECASE):
            table = match.group(1)
            columns_str = match.group(2)
            
            # Extract individual column names
            columns = [col.strip() for col in columns_str.split(',')]
            
            for col in columns:
                # Remove any whitespace and validate
                col = col.strip()
                if col:
                    self.add_table_column(table, col, filepath)
    
    def _extract_update_statements(self, content: str, filepath: str):
        """Extrait les colonnes depuis UPDATE statements."""
        # Pattern: UPDATE table_name SET col1=?, col2=?
        pattern = r'UPDATE\s+([A-Za-z_][A-Za-z0-9_]*)\s+SET\s+([^;]+?)(?:WHERE|;|$)'
        
        for match in re.finditer(pattern, content, re.IGNORECASE | re.DOTALL):
            table = match.group(1)
            set_clause = match.group(2)
            
            # Extract column names from SET clause (before = sign)
            col_pattern = r'([A-Za-z_][A-Za-z0-9_]*)\s*='
            for col_match in re.finditer(col_pattern, set_clause):
                col = col_match.group(1)
                self.add_table_column(table, col, filepath)
    
    def _extract_select_statements(self, content: str, filepath: str):
        """Extrait les tables depuis SELECT statements (colonnes depuis liste explicite)."""
        # Pattern: SELECT col1, col2 FROM table_name
        # or SELECT * FROM table_name
        pattern = r'SELECT\s+([\w\s,.*()]+?)\s+FROM\s+([A-Za-z_][A-Za-z0-9_]*)'
        
        for match in re.finditer(pattern, content, re.IGNORECASE):
            columns_str = match.group(1).strip()
            table = match.group(2)
            
            # Register the table (even with SELECT *)
            self.table_columns[table]["files"].add(filepath)
            
            # If not SELECT *, try to extract column names
            if '*' not in columns_str:
                # Extract column names (simple identifier extraction)
                col_pattern = r'\b([A-Za-z_][A-Za-z0-9_]*)\b'
                for col_match in re.finditer(col_pattern, columns_str):
                    col = col_match.group(1)
                    # Skip SQL keywords that might appear
                    if col.upper() not in ('AS', 'FROM', 'SELECT', 'DISTINCT', 'COUNT', 'MAX', 'MIN', 'SUM', 'AVG'):
                        self.add_table_column(table, col, filepath)
    
    def _extract_create_table_statements(self, content: str, filepath: str):
        """Extrait les colonnes depuis CREATE TABLE statements."""
        # Pattern: CREATE TABLE [IF NOT EXISTS] table_name (columns...)
        pattern = r'CREATE\s+TABLE(?:\s+IF\s+NOT\s+EXISTS)?\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(([^;]+)\)'
        
        for match in re.finditer(pattern, content, re.IGNORECASE | re.DOTALL):
            table = match.group(1)
            columns_def = match.group(2)
            
            # Register table
            self.table_columns[table]["files"].add(filepath)
            
            # Parse column definitions
            # Split by comma, but be careful of constraints
            for line in columns_def.split(','):
                line = line.strip()
                if not line:
                    continue
                
                # Skip constraint definitions
                if line.upper().startswith(('PRIMARY', 'FOREIGN', 'UNIQUE', 'CHECK', 'CONSTRAINT')):
                    continue
                
                # Extract column name (first word) and type (second word)
                parts = line.split()
                if parts:
                    col_name = parts[0].strip()
                    
                    # Extract type if present
                    col_type = None
                    if len(parts) > 1:
                        type_str = parts[1].upper()
                        if 'INTEGER' in type_str or 'INT' in type_str:
                            col_type = 'INTEGER'
                        elif 'REAL' in type_str or 'FLOAT' in type_str or 'DOUBLE' in type_str:
                            col_type = 'REAL'
                        elif 'TEXT' in type_str or 'VARCHAR' in type_str or 'CHAR' in type_str:
                            col_type = 'TEXT'
                        elif 'DATE' in type_str or 'TIME' in type_str:
                            col_type = 'TEXT'  # SQLite stores dates as TEXT
                    
                    # Add column (validation happens in add_table_column)
                    if self.is_valid_sql_identifier(col_name):
                        self.add_table_column(table, col_name, filepath)
                        # Use explicit type from CREATE TABLE if available
                        if col_type:
                            self.table_columns[table]["column_types"][col_name] = col_type
    
    def scan_directories(self, dirs: List[str]):
        """Parcourt les rÃ©pertoires et analyse tous les fichiers Python."""
        for directory in dirs:
            dir_path = self.repo_root / directory
            if not dir_path.exists():
                print(f"Warning: Directory {directory} does not exist")
                continue
            
            print(f"Scanning {directory}...")
            for py_file in dir_path.rglob("*.py"):
                self.analyze_file(py_file)
    
    def generate_yaml_manifest(self, output_file: Path):
        """GÃ©nÃ¨re un manifest YAML simple avec colonnes et types infÃ©rÃ©s."""
        
        with open(output_file, 'w', encoding='utf-8') as f:
            # Write header
            f.write("# Schema Hints for Database Migration\n")
            f.write("# Generated by analyze_modules_columns.py\n")
            f.write("#\n")
            f.write("# This file contains expected columns extracted from SQL queries in the code.\n")
            f.write("# You can manually add overrides or aliases in the 'manual_overrides' section.\n")
            f.write("#\n")
            f.write("# Format:\n")
            f.write("#   tables:\n")
            f.write("#     table_name:\n")
            f.write("#       expected_columns:\n")
            f.write("#         column_name:\n")
            f.write("#           type: TEXT|INTEGER|REAL|DATE\n")
            f.write("#           inferred: true|false\n")
            f.write("#\n")
            f.write("# Manual overrides example:\n")
            f.write("#   manual_overrides:\n")
            f.write("#     table_name:\n")
            f.write("#       column_aliases:\n")
            f.write("#         old_name: new_name\n")
            f.write("#       forced_types:\n")
            f.write("#         column_name: REAL\n")
            f.write("\n")
            
            f.write("schema_version: \"1.0\"\n")
            f.write("generated_by: \"analyze_modules_columns.py\"\n")
            f.write("\ntables:\n")
            
            # Write tables
            for table in sorted(self.table_columns.keys()):
                info = self.table_columns[table]
                
                if not info["columns"]:
                    continue
                
                f.write(f"  {table}:\n")
                f.write(f"    expected_columns:\n")
                
                # Write columns
                for col in sorted(info["columns"]):
                    col_type = info["column_types"].get(col, 'TEXT')
                    f.write(f"      {col}:\n")
                    f.write(f"        type: {col_type}\n")
                    f.write(f"        inferred: true\n")
            
            # Add placeholder for manual overrides
            f.write("\n# Manual overrides (edit this section to add custom mappings)\n")
            f.write("manual_overrides: {}\n")
        
        print(f"YAML manifest generated: {output_file}")
    
    def generate_report(self, output_file: Path):
        """GÃ©nÃ¨re un rapport Markdown des tables et colonnes dÃ©tectÃ©es."""
        
        sorted_tables = sorted(self.table_columns.keys())
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Analyse SQL - Tables et Colonnes Detectees\n\n")
            f.write("Ce rapport liste toutes les tables et colonnes referencees dans le code Python.\n")
            f.write("Il sert de reference pour les migrations et la maintenance du schema de base de donnees.\n\n")
            f.write(f"**Nombre total de tables detectees:** {len(sorted_tables)}\n\n")
            
            f.write("## Resume par Table\n\n")
            for table in sorted_tables:
                info = self.table_columns[table]
                col_count = len(info["columns"])
                file_count = len(info["files"])
                f.write(f"- **{table}**: {col_count} colonnes, referencee dans {file_count} fichier(s)\n")
            
            f.write("\n## Details des Tables et Colonnes\n\n")
            
            for table in sorted_tables:
                info = self.table_columns[table]
                f.write(f"### Table: `{table}`\n\n")
                
                if info["columns"]:
                    f.write("**Colonnes detectees:**\n\n")
                    sorted_cols = sorted(info["columns"])
                    for col in sorted_cols:
                        col_type = info["column_types"].get(col, 'TEXT')
                        f.write(f"- `{col}` (type infere: {col_type})\n")
                else:
                    f.write("*Aucune colonne specifique detectee (possiblement SELECT \\*)*\n")
                
                f.write(f"\n**Referencee dans les fichiers:**\n\n")
                sorted_files = sorted(info["files"])
                for filepath in sorted_files:
                    f.write(f"- `{filepath}`\n")
                
                f.write("\n---\n\n")
            
            # Add skipped identifiers section
            if self.skipped_identifiers:
                f.write("\n## Identifiants Invalides Ignores\n\n")
                f.write("Les identifiants suivants ont ete trouves dans le code mais ne correspondent pas\n")
                f.write("au pattern SQL valide (^[A-Za-z_][A-Za-z0-9_]*$) et ont ete ignores:\n\n")
                
                for filepath in sorted(self.skipped_identifiers.keys()):
                    skipped = self.skipped_identifiers[filepath]
                    if skipped:
                        f.write(f"**Fichier: `{filepath}`**\n\n")
                        for item in sorted(skipped):
                            f.write(f"- {item}\n")
                        f.write("\n")
        
        print(f"Report generated: {output_file}")


def main():
    """Point d'entrÃ©e principal du script."""
    # DÃ©tecter la racine du projet
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent
    
    print("=" * 60)
    print("SQL Schema Analyzer - Strict SQL Identifier Extraction")
    print("=" * 60)
    print(f"Repository root: {repo_root}")
    print()
    
    # CrÃ©er l'analyseur
    analyzer = StrictSQLAnalyzer(repo_root)
    
    # RÃ©pertoires Ã  scanner
    directories = ["modules", "ui", "scripts", "lib", "db"]
    
    # Scanner les rÃ©pertoires
    analyzer.scan_directories(directories)
    
    print()
    print(f"Analysis complete. Found {len(analyzer.table_columns)} tables.")
    
    # GÃ©nÃ©rer le rapport Markdown
    report_dir = repo_root / "reports"
    report_dir.mkdir(exist_ok=True)
    output_file = report_dir / "SQL_SCHEMA_HINTS.md"
    
    analyzer.generate_report(output_file)
    
    # GÃ©nÃ©rer le manifest YAML
    db_dir = repo_root / "db"
    db_dir.mkdir(exist_ok=True)
    yaml_file = db_dir / "schema_hints.yaml"
    
    analyzer.generate_yaml_manifest(yaml_file)
    
    print()
    print("=" * 60)
    print(f"Report saved to: {output_file}")
    print(f"YAML manifest saved to: {yaml_file}")
    print("=" * 60)


if __name__ == "__main__":
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/analyze_modules_columns_old.py ===

```python
#!/usr/bin/env python3
"""
Script d'analyse des modules pour dÃ©tecter les tables et colonnes utilisÃ©es.

Ce script parcourt le code Python du projet (modules/, ui/, scripts/, lib/)
et extrait toutes les requÃªtes SQL et rÃ©fÃ©rences aux tables/colonnes pour
produire un rapport dÃ©taillÃ© des schÃ©mas attendus par le code.

Usage:
    python scripts/analyze_modules_columns.py
    
Sortie:
    reports/SQL_SCHEMA_HINTS.md - Rapport lisible avec tables et colonnes dÃ©tectÃ©es
    db/schema_hints.yaml - Manifest machine-readable avec colonnes attendues et types infÃ©rÃ©s
"""

import os
import re
import sys
from collections import defaultdict
from pathlib import Path
import yaml


class SQLAnalyzer:
    """Analyseur de code Python pour extraire les rÃ©fÃ©rences SQL."""
    
    # Common false positives to filter out (Python/Tkinter keywords, UI elements, etc.)
    # This can be extended as needed when new false positives are discovered
    FALSE_POSITIVE_COLUMNS = {
        'padx', 'pady', 'row', 'column', 'text', 'values', 'state', 'side', 'fill', 
        'expand', 'width', 'height', 'command', 'textvariable', 'title', 'header',
        'filetypes', 'defaultextension', 'filepath', 'conn', 'cursor', 'df', 'params',
        'table', 'before', 'after', 'table_matches', 'var', 'on_save', 'CREATE',
    }
    
    # False positive table names to filter out
    FALSE_POSITIVE_TABLES = {'CREATE', 'for', 'tree', 'sqlite_master'}
    
    def __init__(self, repo_root):
        self.repo_root = Path(repo_root)
        self.table_columns = defaultdict(lambda: {"columns": set(), "files": set(), "column_types": {}})
        
        # Patterns pour extraire les requÃªtes SQL
        self.sql_patterns = [
            # SELECT queries
            r'SELECT\s+(?:\*|[\w,.\s*()]+)\s+FROM\s+(\w+)',
            # INSERT INTO
            r'INSERT\s+INTO\s+(\w+)\s*\(([^)]+)\)',
            # UPDATE queries
            r'UPDATE\s+(\w+)\s+SET\s+([^;]+)',
            # ALTER TABLE
            r'ALTER\s+TABLE\s+(\w+)\s+ADD\s+COLUMN\s+(\w+)',
            # CREATE TABLE
            r'CREATE\s+TABLE(?:\s+IF\s+NOT\s+EXISTS)?\s+(\w+)\s*\(([^;]+)\)',
            # PRAGMA table_info
            r'PRAGMA\s+table_info\s*\(\s*(\w+)\s*\)',
        ]
        
        # Pattern pour les rÃ©fÃ©rences de colonnes dans WHERE, SET, etc.
        self.column_ref_pattern = r'\b(\w+)\s*=\s*[?:]'
        
        # Patterns pour infÃ©rer les types de colonnes
        self.type_patterns = {
            'REAL': [
                r'(prix|montant|solde|total|cout|tarif|taux)(_\w+)?$',
                r'(disponible|valeur)(_\w+)?$',
            ],
            'INTEGER': [
                r'(quantite|stock|nombre|count|seuil)(_\w+)?$',
                r'^id(_\w+)?$',
                r'(_id|_count)$',
            ],
            'TEXT': [
                r'(nom|name|prenom|email|adresse|ville|pays)(_\w+)?$',
                r'(commentaire|description|libelle|categorie)(_\w+)?$',
                r'(type|statut|mode|reference|numero)(_\w+)?$',
            ],
            'DATE': [
                r'date(_\w+)?$',
            ],
        }
        
    def infer_column_type(self, column_name):
        """InfÃ¨re le type SQL d'une colonne basÃ© sur son nom."""
        column_lower = column_name.lower()
        
        # Test patterns for each type
        for sql_type, patterns in self.type_patterns.items():
            for pattern in patterns:
                if re.search(pattern, column_lower, re.IGNORECASE):
                    return sql_type
        
        # Default to TEXT if no pattern matches
        return 'TEXT'
    
    def analyze_file(self, filepath):
        """Analyse un fichier Python pour extraire les rÃ©fÃ©rences SQL."""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            print(f"Warning: Could not read {filepath}: {e}")
            return
        
        relative_path = str(filepath.relative_to(self.repo_root))
        
        # Recherche de requÃªtes SQL (souvent dans des chaÃ®nes multi-lignes ou simples)
        # On cherche les patterns SQL dans le contenu
        self._extract_sql_references(content, relative_path)
        
        # Recherche de rÃ©fÃ©rences dictionary-style (row["column"], row.get("column"))
        self._extract_dict_references(content, relative_path)
    
    def _add_column_to_table(self, table, column, infer_type=True):
        """Ajoute une colonne Ã  une table et infÃ¨re son type si nÃ©cessaire."""
        # Skip if no column name provided
        if not column:
            return
        
        # Filter out false positives
        if column.lower() in self.FALSE_POSITIVE_COLUMNS:
            return
        
        # Skip if already exists
        if column in self.table_columns[table]["columns"]:
            return
        
        # Add the column
        self.table_columns[table]["columns"].add(column)
        if infer_type and column not in self.table_columns[table]["column_types"]:
            self.table_columns[table]["column_types"][column] = self.infer_column_type(column)
    
    def _extract_dict_references(self, content, filepath):
        """Extrait les rÃ©fÃ©rences dictionary-style (row["column"], row.get("column"))."""
        
        # Pattern pour row["column"] ou row['column']
        for match in re.finditer(r'row\s*\[\s*["\'](\w+)["\']\s*\]', content, re.IGNORECASE):
            column = match.group(1)
            # Essayer de trouver la table associÃ©e dans le contexte
            before = content[max(0, match.start()-500):match.start()]
            table_matches = list(re.finditer(r'FROM\s+(\w+)', before, re.IGNORECASE))
            if table_matches:
                table = table_matches[-1].group(1)
                self._add_column_to_table(table, column)
        
        # Pattern pour row.get("column") ou row.get('column')
        for match in re.finditer(r'row\.get\s*\(\s*["\'](\w+)["\']\s*[,\)]', content, re.IGNORECASE):
            column = match.group(1)
            before = content[max(0, match.start()-500):match.start()]
            table_matches = list(re.finditer(r'FROM\s+(\w+)', before, re.IGNORECASE))
            if table_matches:
                table = table_matches[-1].group(1)
                self._add_column_to_table(table, column)
    
    def _extract_sql_references(self, content, filepath):
        """Extrait les rÃ©fÃ©rences SQL du contenu du fichier."""
        
        # SELECT FROM
        for match in re.finditer(r'SELECT\s+(?:\*|[\w,.\s*()]+)\s+FROM\s+(\w+)', content, re.IGNORECASE):
            table = match.group(1)
            self.table_columns[table]["files"].add(filepath)
            # Essayer d'extraire les colonnes du SELECT
            select_part = content[match.start():match.end()]
            if '*' not in select_part:
                cols = re.findall(r'SELECT\s+([\w,.\s*()]+)\s+FROM', select_part, re.IGNORECASE)
                if cols:
                    for col in cols[0].split(','):
                        col = col.strip().split()[0].split('(')[0].split(')')[0]
                        if col and col != '*' and not col.upper() in ('AS', 'FROM', 'SELECT'):
                            self._add_column_to_table(table, col)
        
        # INSERT INTO
        for match in re.finditer(r'INSERT\s+INTO\s+(\w+)\s*\(([^)]+)\)', content, re.IGNORECASE):
            table = match.group(1)
            columns = match.group(2)
            self.table_columns[table]["files"].add(filepath)
            for col in columns.split(','):
                col = col.strip()
                if col:
                    self._add_column_to_table(table, col)
        
        # UPDATE SET
        for match in re.finditer(r'UPDATE\s+(\w+)\s+SET\s+([^;]+?)(?:WHERE|;|$)', content, re.IGNORECASE | re.DOTALL):
            table = match.group(1)
            set_clause = match.group(2)
            self.table_columns[table]["files"].add(filepath)
            # Extraire les colonnes du SET
            for col_match in re.finditer(r'(\w+)\s*=', set_clause):
                col = col_match.group(1)
                self._add_column_to_table(table, col)
        
        # ALTER TABLE ADD COLUMN
        for match in re.finditer(r'ALTER\s+TABLE\s+(\w+)\s+ADD\s+COLUMN\s+(\w+)', content, re.IGNORECASE):
            table = match.group(1)
            column = match.group(2)
            self.table_columns[table]["files"].add(filepath)
            self._add_column_to_table(table, column)
        
        # CREATE TABLE
        for match in re.finditer(r'CREATE\s+TABLE(?:\s+IF\s+NOT\s+EXISTS)?\s+(\w+)\s*\(([^;]+)\)', content, re.IGNORECASE | re.DOTALL):
            table = match.group(1)
            columns_def = match.group(2)
            self.table_columns[table]["files"].add(filepath)
            # Extraire les noms de colonnes (premiÃ¨re partie avant le type)
            for line in columns_def.split(','):
                line = line.strip()
                if line and not line.upper().startswith(('PRIMARY', 'FOREIGN', 'UNIQUE', 'CHECK', 'CONSTRAINT')):
                    parts = line.split()
                    if parts:
                        col_name = parts[0].strip()
                        # Extract type if present (second part typically)
                        col_type = None
                        if len(parts) > 1:
                            type_str = parts[1].upper()
                            if 'INTEGER' in type_str or 'INT' in type_str:
                                col_type = 'INTEGER'
                            elif 'REAL' in type_str or 'FLOAT' in type_str or 'DOUBLE' in type_str:
                                col_type = 'REAL'
                            elif 'TEXT' in type_str or 'VARCHAR' in type_str or 'CHAR' in type_str:
                                col_type = 'TEXT'
                            elif 'DATE' in type_str or 'TIME' in type_str:
                                col_type = 'TEXT'  # SQLite stores dates as TEXT
                        
                        if col_name:
                            self._add_column_to_table(table, col_name, infer_type=False)
                            # Use explicit type from CREATE TABLE if available
                            if col_type and col_name not in self.table_columns[table]["column_types"]:
                                self.table_columns[table]["column_types"][col_name] = col_type
                            elif col_name not in self.table_columns[table]["column_types"]:
                                # Infer if not explicitly defined
                                self.table_columns[table]["column_types"][col_name] = self.infer_column_type(col_name)
        
        # PRAGMA table_info
        for match in re.finditer(r'PRAGMA\s+table_info\s*\(\s*["\']?(\w+)["\']?\s*\)', content, re.IGNORECASE):
            table = match.group(1)
            self.table_columns[table]["files"].add(filepath)
        
        # RÃ©fÃ©rences de colonnes dans WHERE et autres clauses
        for match in re.finditer(r'WHERE\s+([^;]+?)(?:ORDER|GROUP|LIMIT|$)', content, re.IGNORECASE):
            where_clause = match.group(1)
            # Chercher les tables mentionnÃ©es avant ce WHERE
            before = content[:match.start()]
            table_matches = list(re.finditer(r'FROM\s+(\w+)', before, re.IGNORECASE))
            if table_matches:
                table = table_matches[-1].group(1)
                for col_match in re.finditer(r'(\w+)\s*[=<>!]', where_clause):
                    col = col_match.group(1)
                    if col and not col.upper() in ('AND', 'OR', 'NOT', 'IN', 'IS', 'NULL', 'LIKE'):
                        self._add_column_to_table(table, col)
    
    def scan_directories(self, dirs):
        """Parcourt les rÃ©pertoires et analyse tous les fichiers Python."""
        for directory in dirs:
            dir_path = self.repo_root / directory
            if not dir_path.exists():
                print(f"Warning: Directory {directory} does not exist")
                continue
            
            print(f"Scanning {directory}...")
            for py_file in dir_path.rglob("*.py"):
                self.analyze_file(py_file)
    
    def generate_yaml_manifest(self, output_file):
        """GÃ©nÃ¨re un manifest YAML machine-readable avec colonnes et types infÃ©rÃ©s."""
        
        # PrÃ©parer les donnÃ©es pour YAML
        manifest = {
            "schema_version": "1.0",
            "generated_by": "analyze_modules_columns.py",
            "tables": {}
        }
        
        for table, info in self.table_columns.items():
            # Skip false positive tables
            if table in self.FALSE_POSITIVE_TABLES:
                continue
                
            if not info["columns"]:
                continue
            
            # Only include tables with at least some reasonable columns (not all false positives)
            valid_columns = [col for col in info["columns"] if col.lower() not in self.FALSE_POSITIVE_COLUMNS]
            
            if not valid_columns:
                continue
                
            manifest["tables"][table] = {
                "expected_columns": {}
            }
            
            # Ajouter chaque colonne avec son type infÃ©rÃ©
            for col in sorted(info["columns"]):
                col_type = info["column_types"].get(col, 'TEXT')
                manifest["tables"][table]["expected_columns"][col] = {
                    "type": col_type,
                    "inferred": col not in info.get("explicit_types", set())
                }
        
        # Ã‰crire le fichier YAML
        with open(output_file, 'w', encoding='utf-8') as f:
            yaml.dump(manifest, f, default_flow_style=False, allow_unicode=True, sort_keys=True)
        
        print(f"YAML manifest generated: {output_file}")
    
    def generate_report(self, output_file):
        """GÃ©nÃ¨re un rapport Markdown des tables et colonnes dÃ©tectÃ©es."""
        
        # Trier les tables par ordre alphabÃ©tique
        sorted_tables = sorted(self.table_columns.keys())
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Analyse SQL - Tables et Colonnes DÃ©tectÃ©es\n\n")
            f.write("Ce rapport liste toutes les tables et colonnes rÃ©fÃ©rencÃ©es dans le code Python.\n")
            f.write("Il sert de rÃ©fÃ©rence pour les migrations et la maintenance du schÃ©ma de base de donnÃ©es.\n\n")
            f.write(f"**Nombre total de tables dÃ©tectÃ©es:** {len(sorted_tables)}\n\n")
            
            f.write("## RÃ©sumÃ© par Table\n\n")
            for table in sorted_tables:
                info = self.table_columns[table]
                col_count = len(info["columns"])
                file_count = len(info["files"])
                f.write(f"- **{table}**: {col_count} colonnes, rÃ©fÃ©rencÃ©e dans {file_count} fichier(s)\n")
            
            f.write("\n## DÃ©tails des Tables et Colonnes\n\n")
            
            for table in sorted_tables:
                info = self.table_columns[table]
                f.write(f"### Table: `{table}`\n\n")
                
                if info["columns"]:
                    f.write("**Colonnes dÃ©tectÃ©es:**\n\n")
                    sorted_cols = sorted(info["columns"])
                    for col in sorted_cols:
                        col_type = info["column_types"].get(col, 'TEXT')
                        f.write(f"- `{col}` (type infÃ©rÃ©: {col_type})\n")
                else:
                    f.write("*Aucune colonne spÃ©cifique dÃ©tectÃ©e (possiblement SELECT \\*)*\n")
                
                f.write(f"\n**RÃ©fÃ©rencÃ©e dans les fichiers:**\n\n")
                sorted_files = sorted(info["files"])
                for filepath in sorted_files:
                    f.write(f"- `{filepath}`\n")
                
                f.write("\n---\n\n")
        
        print(f"Report generated: {output_file}")


def main():
    """Point d'entrÃ©e principal du script."""
    # DÃ©tecter la racine du projet
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent
    
    print("=" * 60)
    print("SQL Schema Analyzer - Module Column Detection")
    print("=" * 60)
    print(f"Repository root: {repo_root}")
    print()
    
    # CrÃ©er l'analyseur
    analyzer = SQLAnalyzer(repo_root)
    
    # RÃ©pertoires Ã  scanner
    directories = ["modules", "ui", "scripts", "lib", "db"]
    
    # Scanner les rÃ©pertoires
    analyzer.scan_directories(directories)
    
    print()
    print(f"Analysis complete. Found {len(analyzer.table_columns)} tables.")
    
    # GÃ©nÃ©rer le rapport Markdown
    report_dir = repo_root / "reports"
    report_dir.mkdir(exist_ok=True)
    output_file = report_dir / "SQL_SCHEMA_HINTS.md"
    
    analyzer.generate_report(output_file)
    
    # GÃ©nÃ©rer le manifest YAML
    db_dir = repo_root / "db"
    db_dir.mkdir(exist_ok=True)
    yaml_file = db_dir / "schema_hints.yaml"
    
    analyzer.generate_yaml_manifest(yaml_file)
    
    print()
    print("=" * 60)
    print(f"Report saved to: {output_file}")
    print(f"YAML manifest saved to: {yaml_file}")
    print("=" * 60)


if __name__ == "__main__":
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/audit_db_usage.py ===

```python
#!/usr/bin/env python3
"""
Database Usage Audit Script

Scans the codebase for:
- sqlite3 usage patterns
- fetch/execute patterns
- row.get usages
- positional indexing (row[0], row[1], etc.)
- Generate reports in reports/SQL_ACCESS_MAP.md and reports/TODOs.md

This script helps identify areas where sqlite3.Row objects are used with .get()
method (which causes AttributeError) and need to be converted to dicts.
"""

import os
import re
import sys
from pathlib import Path
from typing import List, Dict, Tuple, Set
from datetime import datetime


class DBUsageAuditor:
    """Auditor for database access patterns in Python codebase."""
    
    def __init__(self, root_dir: str):
        self.root_dir = Path(root_dir)
        self.results = {
            'sqlite3_imports': [],
            'get_connection_calls': [],
            'fetch_patterns': [],
            'row_get_usage': [],
            'positional_indexing': [],
            'execute_patterns': [],
            'connection_patterns': [],
        }
        
    def scan_file(self, filepath: Path) -> Dict:
        """Scan a single Python file for DB usage patterns."""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
                lines = content.split('\n')
        except (UnicodeDecodeError, PermissionError) as e:
            return {}
        
        rel_path = filepath.relative_to(self.root_dir)
        file_results = {}
        
        # Pattern: import sqlite3
        if re.search(r'import\s+sqlite3', content):
            self.results['sqlite3_imports'].append({
                'file': str(rel_path),
                'line': self._find_line_number(lines, r'import\s+sqlite3')
            })
        
        # Pattern: get_connection()
        for match in re.finditer(r'(\w+\.)?get_connection\(\)', content):
            line_num = self._get_line_number(content, match.start())
            self.results['get_connection_calls'].append({
                'file': str(rel_path),
                'line': line_num,
                'code': lines[line_num - 1].strip() if line_num <= len(lines) else ''
            })
        
        # Pattern: fetchone(), fetchall(), fetchmany()
        for pattern in [r'\.fetchone\(\)', r'\.fetchall\(\)', r'\.fetchmany\(']:
            for match in re.finditer(pattern, content):
                line_num = self._get_line_number(content, match.start())
                self.results['fetch_patterns'].append({
                    'file': str(rel_path),
                    'line': line_num,
                    'pattern': match.group(),
                    'code': lines[line_num - 1].strip() if line_num <= len(lines) else ''
                })
        
        # Pattern: row.get( or row.get('
        for match in re.finditer(r'(\w+)\.get\(["\']', content):
            line_num = self._get_line_number(content, match.start())
            var_name = match.group(1)
            # Check if this might be a row variable
            if var_name in ['row', 'r', 'res', 'result', 'item', 'data'] or 'row' in var_name.lower():
                self.results['row_get_usage'].append({
                    'file': str(rel_path),
                    'line': line_num,
                    'variable': var_name,
                    'code': lines[line_num - 1].strip() if line_num <= len(lines) else ''
                })
        
        # Pattern: row[0], row[1], etc. (positional indexing)
        for match in re.finditer(r'(\w+)\[(\d+)\]', content):
            line_num = self._get_line_number(content, match.start())
            var_name = match.group(1)
            index = match.group(2)
            # Check if this might be a row variable
            if var_name in ['row', 'r', 'res', 'result', 'item', 'data'] or 'row' in var_name.lower():
                self.results['positional_indexing'].append({
                    'file': str(rel_path),
                    'line': line_num,
                    'variable': var_name,
                    'index': index,
                    'code': lines[line_num - 1].strip() if line_num <= len(lines) else ''
                })
        
        # Pattern: .execute(
        for match in re.finditer(r'\.execute\(', content):
            line_num = self._get_line_number(content, match.start())
            # Get the full statement (might span multiple lines)
            code_snippet = self._get_code_snippet(lines, line_num - 1, 3)
            self.results['execute_patterns'].append({
                'file': str(rel_path),
                'line': line_num,
                'code': code_snippet
            })
        
        # Pattern: sqlite3.connect(
        for match in re.finditer(r'sqlite3\.connect\(', content):
            line_num = self._get_line_number(content, match.start())
            self.results['connection_patterns'].append({
                'file': str(rel_path),
                'line': line_num,
                'code': lines[line_num - 1].strip() if line_num <= len(lines) else ''
            })
        
        return file_results
    
    def _find_line_number(self, lines: List[str], pattern: str) -> int:
        """Find the first line number matching a pattern."""
        for i, line in enumerate(lines, 1):
            if re.search(pattern, line):
                return i
        return 0
    
    def _get_line_number(self, content: str, char_pos: int) -> int:
        """Get line number from character position."""
        return content[:char_pos].count('\n') + 1
    
    def _get_code_snippet(self, lines: List[str], start_line: int, num_lines: int = 1) -> str:
        """Get a snippet of code from multiple lines."""
        end_line = min(start_line + num_lines, len(lines))
        return ' '.join(lines[start_line:end_line]).strip()
    
    def scan_directory(self, directory: Path = None):
        """Recursively scan directory for Python files."""
        if directory is None:
            directory = self.root_dir
        
        # Directories to skip
        skip_dirs = {'.git', '__pycache__', 'venv', 'env', '.pytest_cache', 'node_modules', 'dist', 'build'}
        
        for item in directory.iterdir():
            if item.is_dir():
                if item.name not in skip_dirs:
                    self.scan_directory(item)
            elif item.suffix == '.py':
                self.scan_file(item)
    
    def generate_sql_access_map(self) -> str:
        """Generate SQL_ACCESS_MAP.md report."""
        report = []
        report.append("# SQL Access Map\n")
        report.append(f"Generated: {datetime.now().isoformat()}\n")
        report.append("This report maps all database access patterns in the codebase.\n")
        
        report.append("\n## Summary\n")
        report.append(f"- sqlite3 imports: {len(self.results['sqlite3_imports'])}\n")
        report.append(f"- get_connection() calls: {len(self.results['get_connection_calls'])}\n")
        report.append(f"- fetch patterns: {len(self.results['fetch_patterns'])}\n")
        report.append(f"- row.get() usage: {len(self.results['row_get_usage'])}\n")
        report.append(f"- Positional indexing: {len(self.results['positional_indexing'])}\n")
        report.append(f"- execute() calls: {len(self.results['execute_patterns'])}\n")
        report.append(f"- sqlite3.connect() calls: {len(self.results['connection_patterns'])}\n")
        
        # sqlite3 imports
        if self.results['sqlite3_imports']:
            report.append("\n## SQLite3 Imports\n")
            for item in self.results['sqlite3_imports']:
                report.append(f"- `{item['file']}:{item['line']}`\n")
        
        # get_connection calls
        if self.results['get_connection_calls']:
            report.append("\n## get_connection() Calls\n")
            files_with_calls = {}
            for item in self.results['get_connection_calls']:
                file = item['file']
                if file not in files_with_calls:
                    files_with_calls[file] = []
                files_with_calls[file].append(item)
            
            for file, calls in sorted(files_with_calls.items()):
                report.append(f"\n### {file}\n")
                for call in calls:
                    report.append(f"- Line {call['line']}: `{call['code']}`\n")
        
        # Fetch patterns
        if self.results['fetch_patterns']:
            report.append("\n## Fetch Patterns\n")
            files_with_fetches = {}
            for item in self.results['fetch_patterns']:
                file = item['file']
                if file not in files_with_fetches:
                    files_with_fetches[file] = []
                files_with_fetches[file].append(item)
            
            for file, fetches in sorted(files_with_fetches.items()):
                report.append(f"\n### {file}\n")
                for fetch in fetches:
                    report.append(f"- Line {fetch['line']} `{fetch['pattern']}`: `{fetch['code']}`\n")
        
        # Row.get usage (CRITICAL - these will crash)
        if self.results['row_get_usage']:
            report.append("\n## âš ï¸ CRITICAL: row.get() Usage (Will Crash!)\n")
            report.append("These locations use .get() on sqlite3.Row objects, which will cause AttributeError.\n")
            report.append("These MUST be fixed by converting rows to dicts first.\n")
            files_with_get = {}
            for item in self.results['row_get_usage']:
                file = item['file']
                if file not in files_with_get:
                    files_with_get[file] = []
                files_with_get[file].append(item)
            
            for file, gets in sorted(files_with_get.items()):
                report.append(f"\n### {file}\n")
                for get in gets:
                    report.append(f"- Line {get['line']} (var: `{get['variable']}`): `{get['code']}`\n")
        
        # Positional indexing
        if self.results['positional_indexing']:
            report.append("\n## Positional Indexing (row[0], row[1], ...)\n")
            report.append("These use positional access and should continue to work.\n")
            files_with_pos = {}
            for item in self.results['positional_indexing']:
                file = item['file']
                if file not in files_with_pos:
                    files_with_pos[file] = []
                files_with_pos[file].append(item)
            
            for file, positions in sorted(files_with_pos.items()):
                report.append(f"\n### {file}\n")
                unique_lines = {}
                for pos in positions:
                    line_key = f"{pos['line']}"
                    if line_key not in unique_lines:
                        unique_lines[line_key] = pos
                
                for pos in unique_lines.values():
                    report.append(f"- Line {pos['line']}: `{pos['code']}`\n")
        
        return ''.join(report)
    
    def generate_todos(self) -> str:
        """Generate TODOs.md report with action items."""
        report = []
        report.append("# Database Access TODOs\n")
        report.append(f"Generated: {datetime.now().isoformat()}\n")
        report.append("\nThis report lists action items for fixing database access issues.\n")
        
        # Critical fixes needed
        if self.results['row_get_usage']:
            report.append("\n## ðŸ”´ CRITICAL: Fix row.get() Usage\n")
            report.append("Priority: **HIGH** - These will cause AttributeError crashes\n")
            report.append("\nAction: Convert sqlite3.Row to dict before using .get()\n")
            report.append("Solution: Use `_row_to_dict(row)` or `_rows_to_dicts(rows)` from modules/db_row_utils.py\n")
            
            for item in self.results['row_get_usage']:
                report.append(f"\n- [ ] {item['file']}:{item['line']}\n")
                report.append(f"  ```python\n  {item['code']}\n  ```\n")
        
        # Direct sqlite3.connect usage
        if self.results['connection_patterns']:
            report.append("\n## ðŸŸ¡ RECOMMENDED: Standardize Connection Handling\n")
            report.append("Priority: **MEDIUM** - Should use centralized connection management\n")
            report.append("\nAction: Use db.get_connection() or modules.db_api.get_connection() instead of direct sqlite3.connect()\n")
            report.append("Benefit: Automatic WAL mode, busy timeout, and consistent error handling\n")
            
            for item in self.results['connection_patterns']:
                report.append(f"\n- [ ] {item['file']}:{item['line']}\n")
                report.append(f"  ```python\n  {item['code']}\n  ```\n")
        
        # Fetch patterns without conversion
        fetch_files = set(item['file'] for item in self.results['fetch_patterns'])
        get_files = set(item['file'] for item in self.results['row_get_usage'])
        
        # Files with fetch but no documented .get() issues might still be at risk
        at_risk_files = fetch_files - get_files
        if at_risk_files:
            report.append("\n## ðŸŸ¢ LOW PRIORITY: Review Fetch Patterns\n")
            report.append("These files use fetch patterns but don't show .get() usage in this scan.\n")
            report.append("Review to ensure they don't need dict conversion.\n")
            for file in sorted(at_risk_files):
                report.append(f"- [ ] {file}\n")
        
        return ''.join(report)


def main():
    """Main entry point for the audit script."""
    # Find root directory
    script_dir = Path(__file__).parent
    root_dir = script_dir.parent
    
    print("=" * 70)
    print("Database Usage Audit Tool")
    print("=" * 70)
    print(f"\nScanning directory: {root_dir}")
    print("This may take a moment...\n")
    
    # Create auditor and scan
    auditor = DBUsageAuditor(root_dir)
    auditor.scan_directory()
    
    # Create reports directory if it doesn't exist
    reports_dir = root_dir / 'reports'
    reports_dir.mkdir(exist_ok=True)
    
    # Generate and write reports
    print("Generating SQL_ACCESS_MAP.md...")
    sql_map = auditor.generate_sql_access_map()
    sql_map_path = reports_dir / 'SQL_ACCESS_MAP.md'
    with open(sql_map_path, 'w', encoding='utf-8') as f:
        f.write(sql_map)
    print(f"âœ“ Written to {sql_map_path}")
    
    print("\nGenerating TODOs.md...")
    todos = auditor.generate_todos()
    todos_path = reports_dir / 'TODOs.md'
    with open(todos_path, 'w', encoding='utf-8') as f:
        f.write(todos)
    print(f"âœ“ Written to {todos_path}")
    
    print("\n" + "=" * 70)
    print("Audit Complete!")
    print("=" * 70)
    print(f"\nSummary:")
    print(f"  - row.get() issues found: {len(auditor.results['row_get_usage'])}")
    print(f"  - Direct sqlite3.connect() calls: {len(auditor.results['connection_patterns'])}")
    print(f"  - Total fetch patterns: {len(auditor.results['fetch_patterns'])}")
    print(f"\nReview the reports in {reports_dir}/ for details.")
    
    # Return exit code based on critical issues
    if auditor.results['row_get_usage']:
        print("\nâš ï¸  CRITICAL issues found! See TODOs.md for action items.")
        return 1
    else:
        print("\nâœ“ No critical issues found.")
        return 0


if __name__ == '__main__':
    sys.exit(main())

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/auto_fix_buvette_rows.py ===

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Auto-fix script for sqlite3.Row to dict conversions in buvette/inventory modules.

This script heuristically scans modules/ and ui/ directories for patterns where:
- rows = cursor.fetchall() or row = cursor.fetchone() are used
- followed by .get() calls on those rows

For each matching file it:
1. Creates a backup copy <file>.bak
2. Injects imports: from modules.db_row_utils import _row_to_dict, _rows_to_dicts
3. Injects conversions after fetchone/fetchall calls
4. Writes a patch diff file <file>.fix.diff for reviewer
5. Applies the changes to the working file

Note: This script is designed to be safe and non-destructive. It always creates
backups before modifying files and generates diff files for human review.
"""

import difflib
import os
import re
import sys
import shutil
from pathlib import Path
from datetime import datetime


def find_python_files(base_dir, subdirs=None):
    """Find all Python files in specified subdirectories."""
    if subdirs is None:
        subdirs = ['modules', 'ui']
    
    python_files = []
    for subdir in subdirs:
        search_path = os.path.join(base_dir, subdir)
        if os.path.exists(search_path):
            for root, _, files in os.walk(search_path):
                for file in files:
                    if file.endswith('.py'):
                        python_files.append(os.path.join(root, file))
    
    return python_files


def has_fetchall_or_fetchone(content):
    """Check if file contains fetchall() or fetchone() calls."""
    return bool(re.search(r'\.(fetchall|fetchone)\(\)', content))


def has_get_usage(content):
    """Check if file uses .get() method on potential row objects."""
    # Look for patterns like: row.get(, row_var.get(, rows[i].get(, etc.
    return bool(re.search(r'(row|ligne|line|result)[\w]*\.get\(', content))


def needs_db_row_utils_import(content):
    """Check if file needs the db_row_utils import."""
    has_import = re.search(r'from modules\.db_row_utils import', content)
    return not has_import


def inject_import(content):
    """Inject the db_row_utils import after other module imports."""
    # Find the last import statement
    lines = content.split('\n')
    last_import_idx = -1
    
    for idx, line in enumerate(lines):
        if line.strip().startswith(('import ', 'from ')):
            last_import_idx = idx
    
    if last_import_idx >= 0:
        # Insert after the last import
        import_line = 'from modules.db_row_utils import _row_to_dict, _rows_to_dicts'
        lines.insert(last_import_idx + 1, import_line)
        return '\n'.join(lines)
    else:
        # No imports found, insert at top after docstring
        # Find end of docstring if present
        insert_idx = 0
        if content.startswith('"""') or content.startswith("'''"):
            delimiter = '"""' if content.startswith('"""') else "'''"
            end_idx = content.find(delimiter, 3)
            if end_idx > 0:
                insert_idx = content[:end_idx + 3].count('\n')
        
        lines = content.split('\n')
        import_line = 'from modules.db_row_utils import _row_to_dict, _rows_to_dicts'
        lines.insert(insert_idx, import_line)
        lines.insert(insert_idx + 1, '')
        return '\n'.join(lines)


def inject_conversions(content):
    """
    Inject row/rows conversion calls after fetchone/fetchall.
    
    Pattern detection:
    - rows = cursor.fetchall() -> add: rows = _rows_to_dicts(rows)
    - row = cursor.fetchone() -> add: row = _row_to_dict(row)
    """
    lines = content.split('\n')
    new_lines = []
    i = 0
    
    while i < len(lines):
        line = lines[i]
        new_lines.append(line)
        
        # Match patterns like: variable = something.fetchall()
        fetchall_match = re.search(r'(\w+)\s*=\s*.*\.fetchall\(\)', line)
        if fetchall_match:
            var_name = fetchall_match.group(1)
            indent = len(line) - len(line.lstrip())
            conversion = ' ' * indent + f'{var_name} = _rows_to_dicts({var_name})'
            new_lines.append(conversion)
        
        # Match patterns like: variable = something.fetchone()
        fetchone_match = re.search(r'(\w+)\s*=\s*.*\.fetchone\(\)', line)
        if fetchone_match:
            var_name = fetchone_match.group(1)
            indent = len(line) - len(line.lstrip())
            conversion = ' ' * indent + f'{var_name} = _row_to_dict({var_name})'
            new_lines.append(conversion)
        
        i += 1
    
    return '\n'.join(new_lines)


def create_diff(original_content, modified_content, filename):
    """Create a unified diff string."""
    original_lines = original_content.splitlines(keepends=True)
    modified_lines = modified_content.splitlines(keepends=True)
    
    diff = difflib.unified_diff(
        original_lines,
        modified_lines,
        fromfile=f'{filename}.orig',
        tofile=f'{filename}.fixed',
        lineterm=''
    )
    
    return ''.join(diff)


def process_file(filepath, dry_run=False):
    """
    Process a single file: create backup, inject conversions, create diff.
    
    Returns:
        tuple: (was_modified, message)
    """
    try:
        # Read the file
        with open(filepath, 'r', encoding='utf-8') as f:
            original_content = f.read()
        
        # Check if this file needs processing
        has_fetch = has_fetchall_or_fetchone(original_content)
        has_get = has_get_usage(original_content)
        
        if not (has_fetch and has_get):
            return False, "No fetch+get pattern detected"
        
        # Start with original content
        modified_content = original_content
        
        # Inject import if needed
        if needs_db_row_utils_import(modified_content):
            modified_content = inject_import(modified_content)
        
        # Inject conversions
        modified_content = inject_conversions(modified_content)
        
        # Check if anything actually changed
        if modified_content == original_content:
            return False, "No changes after processing"
        
        if dry_run:
            return True, "Would be modified (dry run)"
        
        # Create backup
        backup_path = filepath + '.bak'
        shutil.copy2(filepath, backup_path)
        
        # Write modified file
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(modified_content)
        
        # Create diff file
        diff_content = create_diff(original_content, modified_content, os.path.basename(filepath))
        diff_path = filepath + '.fix.diff'
        with open(diff_path, 'w', encoding='utf-8') as f:
            f.write(diff_content)
        
        return True, f"Modified (backup: {backup_path}, diff: {diff_path})"
    
    except Exception as e:
        return False, f"Error: {e}"


def main():
    """Main function to run the auto-fix script."""
    # Determine base directory (repository root)
    script_dir = os.path.dirname(os.path.abspath(__file__))
    base_dir = os.path.dirname(script_dir)
    
    print("=" * 80)
    print("SQLite3 Row to Dict Auto-Fix Script")
    print("=" * 80)
    print(f"Base directory: {base_dir}")
    print(f"Timestamp: {datetime.now().isoformat()}")
    print()
    
    # Check for dry-run mode
    dry_run = '--dry-run' in sys.argv or '-n' in sys.argv
    if dry_run:
        print("âš  DRY RUN MODE - No files will be modified")
        print()
    
    # Find all Python files in modules/ and ui/
    python_files = find_python_files(base_dir)
    print(f"Found {len(python_files)} Python files in modules/ and ui/")
    print()
    
    # Process each file
    modified_count = 0
    skipped_count = 0
    error_count = 0
    
    for filepath in sorted(python_files):
        rel_path = os.path.relpath(filepath, base_dir)
        was_modified, message = process_file(filepath, dry_run)
        
        if was_modified:
            print(f"âœ“ {rel_path}: {message}")
            modified_count += 1
        elif 'Error' in message:
            print(f"âœ— {rel_path}: {message}")
            error_count += 1
        else:
            # Skip silently or with verbose flag
            if '--verbose' in sys.argv or '-v' in sys.argv:
                print(f"- {rel_path}: {message}")
            skipped_count += 1
    
    # Print summary
    print()
    print("=" * 80)
    print("Summary")
    print("=" * 80)
    print(f"Modified: {modified_count}")
    print(f"Skipped:  {skipped_count}")
    print(f"Errors:   {error_count}")
    print()
    
    if not dry_run and modified_count > 0:
        print("âš  Important:")
        print("  1. Review all .fix.diff files before committing")
        print("  2. Test the changes thoroughly")
        print("  3. Backups are available as .bak files")
        print("  4. To rollback, restore from .bak files")
        print()
    
    return 0 if error_count == 0 else 1


if __name__ == '__main__':
    sys.exit(main())

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/check_buvette.py ===

```python
#!/usr/bin/env python3
"""
Script de vÃ©rification du module buvette.
Ce script exÃ©cute une sÃ©rie de vÃ©rifications automatisÃ©es pour identifier
les problÃ¨mes dans le code du module buvette avant d'appliquer les corrections.

VÃ©rifications effectuÃ©es:
1. ExÃ©cution des tests unitaires (pytest)
2. Recherche de patterns problÃ©matiques dans le code
3. VÃ©rification de la cohÃ©rence entre le schÃ©ma DB et le code

CrÃ©Ã© dans le cadre de la PR de corrections du module buvette.
"""

import os
import sys
import re
import subprocess
from pathlib import Path

# Couleurs pour le terminal
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def print_header(text):
    print(f"\n{Colors.HEADER}{Colors.BOLD}{'='*80}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{text.center(80)}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{'='*80}{Colors.ENDC}\n")

def print_section(text):
    print(f"\n{Colors.OKBLUE}{Colors.BOLD}--- {text} ---{Colors.ENDC}")

def print_ok(text):
    print(f"{Colors.OKGREEN}âœ“ {text}{Colors.ENDC}")

def print_warning(text):
    print(f"{Colors.WARNING}âš  {text}{Colors.ENDC}")

def print_error(text):
    print(f"{Colors.FAIL}âœ— {text}{Colors.ENDC}")

def run_tests():
    """ExÃ©cute les tests unitaires avec pytest."""
    print_section("ExÃ©cution des tests unitaires")
    
    # VÃ©rifier si pytest est installÃ©
    try:
        result = subprocess.run(
            ["python", "-m", "pytest", "--version"],
            capture_output=True,
            text=True,
            timeout=10
        )
        if result.returncode != 0:
            print_warning("pytest n'est pas installÃ©. Installation en cours...")
            subprocess.run(["pip", "install", "-q", "pytest"], check=True)
    except Exception as e:
        print_error(f"Impossible de vÃ©rifier/installer pytest: {e}")
        return False
    
    # ExÃ©cuter les tests
    try:
        result = subprocess.run(
            ["python", "-m", "pytest", "tests/test_buvette_inventaire.py", "-v", "--tb=short"],
            capture_output=True,
            text=True,
            timeout=60
        )
        print(result.stdout)
        if result.stderr:
            print(result.stderr)
        
        if result.returncode == 0:
            print_ok("Tous les tests sont passÃ©s")
            return True
        else:
            print_error("Certains tests ont Ã©chouÃ©")
            return False
    except subprocess.TimeoutExpired:
        print_error("Timeout lors de l'exÃ©cution des tests")
        return False
    except Exception as e:
        print_error(f"Erreur lors de l'exÃ©cution des tests: {e}")
        return False

def check_database_schema():
    """VÃ©rifie le schÃ©ma de la base de donnÃ©es."""
    print_section("VÃ©rification du schÃ©ma de base de donnÃ©es")
    
    db_file = Path("db/db.py")
    if not db_file.exists():
        print_error(f"Fichier {db_file} non trouvÃ©")
        return []
    
    issues = []
    content = db_file.read_text()
    
    # VÃ©rifier la dÃ©finition de buvette_mouvements
    if 'date_mouvement DATE' in content:
        print_ok("Colonne 'date_mouvement' trouvÃ©e dans le schÃ©ma")
    else:
        issues.append("Colonne 'date_mouvement' non trouvÃ©e dans buvette_mouvements")
        print_error(issues[-1])
    
    if 'type_mouvement TEXT' in content:
        print_ok("Colonne 'type_mouvement' trouvÃ©e dans le schÃ©ma")
    else:
        issues.append("Colonne 'type_mouvement' non trouvÃ©e dans buvette_mouvements")
        print_error(issues[-1])
    
    if 'motif TEXT' in content:
        print_ok("Colonne 'motif' trouvÃ©e dans le schÃ©ma (pas 'commentaire')")
    
    return issues

def check_buvette_db_file():
    """VÃ©rifie les patterns problÃ©matiques dans modules/buvette_db.py."""
    print_section("VÃ©rification de modules/buvette_db.py")
    
    db_file = Path("modules/buvette_db.py")
    if not db_file.exists():
        print_error(f"Fichier {db_file} non trouvÃ©")
        return []
    
    issues = []
    content = db_file.read_text()
    lines = content.split('\n')
    
    # Pattern 1: INSERT avec 'date' au lieu de 'date_mouvement'
    insert_pattern = re.compile(r'INSERT\s+INTO\s+buvette_mouvements\s*\([^)]*\bdate\b[^)]*\)', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if insert_pattern.search(line):
            issues.append(f"Ligne {i}: INSERT utilise 'date' au lieu de 'date_mouvement'")
            print_error(issues[-1])
    
    # Pattern 2: UPDATE avec 'date=' au lieu de 'date_mouvement='
    update_pattern = re.compile(r'UPDATE\s+buvette_mouvements\s+SET[^W]*\bdate\s*=', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if update_pattern.search(line):
            issues.append(f"Ligne {i}: UPDATE utilise 'date=' au lieu de 'date_mouvement='")
            print_error(issues[-1])
    
    # Pattern 3: UPDATE avec 'type=' au lieu de 'type_mouvement='
    update_type_pattern = re.compile(r'UPDATE\s+buvette_mouvements\s+SET[^W]*\btype\s*=', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if update_type_pattern.search(line):
            issues.append(f"Ligne {i}: UPDATE utilise 'type=' au lieu de 'type_mouvement='")
            print_error(issues[-1])
    
    # Pattern 4: SELECT sans alias AS date, AS type
    select_mouvements = re.compile(r'def\s+list_mouvements\(\):', re.IGNORECASE)
    found_list_mouvements = False
    for i, line in enumerate(lines, 1):
        if select_mouvements.search(line):
            found_list_mouvements = True
            # VÃ©rifier les 20 lignes suivantes pour les alias
            check_lines = '\n'.join(lines[i:min(i+20, len(lines))])
            if 'AS date' not in check_lines or 'AS type' not in check_lines:
                issues.append(f"Fonction list_mouvements (ligne {i}): manque les alias AS date/AS type")
                print_error(issues[-1])
            else:
                print_ok("list_mouvements contient les alias AS date/AS type")
            break
    
    if not found_list_mouvements:
        issues.append("Fonction list_mouvements non trouvÃ©e")
        print_error(issues[-1])
    
    # Pattern 5: get_mouvement_by_id sans alias
    select_mouvement_by_id = re.compile(r'def\s+get_mouvement_by_id\(', re.IGNORECASE)
    found_get_mouvement = False
    for i, line in enumerate(lines, 1):
        if select_mouvement_by_id.search(line):
            found_get_mouvement = True
            check_lines = '\n'.join(lines[i:min(i+20, len(lines))])
            if 'AS date' not in check_lines or 'AS type' not in check_lines:
                issues.append(f"Fonction get_mouvement_by_id (ligne {i}): manque les alias AS date/AS type")
                print_error(issues[-1])
            else:
                print_ok("get_mouvement_by_id contient les alias AS date/AS type")
            break
    
    if not found_get_mouvement:
        issues.append("Fonction get_mouvement_by_id non trouvÃ©e")
        print_error(issues[-1])
    
    if not issues:
        print_ok("Aucun problÃ¨me trouvÃ© dans buvette_db.py")
    
    return issues

def check_buvette_ui_file():
    """VÃ©rifie les patterns problÃ©matiques dans modules/buvette.py."""
    print_section("VÃ©rification de modules/buvette.py")
    
    ui_file = Path("modules/buvette.py")
    if not ui_file.exists():
        print_error(f"Fichier {ui_file} non trouvÃ©")
        return []
    
    issues = []
    content = ui_file.read_text()
    lines = content.split('\n')
    
    # Pattern 1: InventaireDialog sans columnconfigure
    inventaire_dialog_pattern = re.compile(r'class\s+InventaireDialog\(', re.IGNORECASE)
    found_inventaire = False
    for i, line in enumerate(lines, 1):
        if inventaire_dialog_pattern.search(line):
            found_inventaire = True
            # VÃ©rifier les 50 lignes suivantes
            check_lines = '\n'.join(lines[i:min(i+50, len(lines))])
            if 'columnconfigure' not in check_lines:
                issues.append(f"InventaireDialog (ligne {i}): manque columnconfigure(1, weight=1)")
                print_error(issues[-1])
            else:
                print_ok("InventaireDialog contient columnconfigure")
            
            if 'sticky=' not in check_lines or 'sticky="ew"' not in check_lines:
                issues.append(f"InventaireDialog (ligne {i}): les Entry/Combobox devraient avoir sticky='ew'")
                print_warning(issues[-1])
            break
    
    # Pattern 2: LignesInventaireDialog affiche article_id au lieu de article_name
    lignes_refresh = re.compile(r'def\s+refresh_lignes\(self\):', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if lignes_refresh.search(line):
            check_lines = '\n'.join(lines[i:min(i+20, len(lines))])
            if 'article_id' in check_lines and 'values=' in check_lines:
                if 'article_name' not in check_lines:
                    issues.append(f"LignesInventaireDialog.refresh_lignes (ligne {i}): affiche article_id au lieu de article_name")
                    print_error(issues[-1])
                else:
                    print_ok("refresh_lignes utilise article_name")
            break
    
    # Pattern 3: LigneInventaireDialog utilise Entry pour article_id
    ligne_dialog = re.compile(r'class\s+LigneInventaireDialog\(', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if ligne_dialog.search(line):
            check_lines = '\n'.join(lines[i:min(i+50, len(lines))])
            if 'article_id_var' in check_lines and 'tk.Entry' in check_lines:
                if 'Combobox' not in check_lines or 'list_articles_names' not in check_lines:
                    issues.append(f"LigneInventaireDialog (ligne {i}): devrait utiliser Combobox au lieu de Entry pour article")
                    print_error(issues[-1])
                else:
                    print_ok("LigneInventaireDialog utilise Combobox")
            break
    
    # Pattern 4: MouvementDialog utilise Entry pour article_id
    mouvement_dialog = re.compile(r'class\s+MouvementDialog\(', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if mouvement_dialog.search(line):
            check_lines = '\n'.join(lines[i:min(i+50, len(lines))])
            if 'article_id_var' in check_lines and 'tk.Entry' in check_lines:
                if 'Combobox' not in check_lines or 'list_articles_names' not in check_lines:
                    issues.append(f"MouvementDialog (ligne {i}): devrait utiliser Combobox au lieu de Entry pour article")
                    print_error(issues[-1])
                else:
                    print_ok("MouvementDialog utilise Combobox")
            break
    
    # Pattern 5: refresh_bilan sans protection contre None
    bilan_pattern = re.compile(r'def\s+refresh_bilan\(self\):', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if bilan_pattern.search(line):
            check_lines = '\n'.join(lines[i:min(i+30, len(lines))])
            # VÃ©rifier si sum() est protÃ©gÃ©
            if 'sum(' in check_lines:
                if 'or 0' not in check_lines and 'if' not in check_lines:
                    issues.append(f"refresh_bilan (ligne {i}): sum() devrait Ãªtre protÃ©gÃ© contre None")
                    print_warning(issues[-1])
                else:
                    print_ok("refresh_bilan protÃ¨ge les agrÃ©gations")
            break
    
    if not issues:
        print_ok("Aucun problÃ¨me trouvÃ© dans buvette.py")
    
    return issues

def check_file_structure():
    """VÃ©rifie la structure des fichiers du projet."""
    print_section("VÃ©rification de la structure des fichiers")
    
    required_files = [
        "db/db.py",
        "modules/buvette_db.py",
        "modules/buvette.py",
        "modules/buvette_inventaire_db.py",
        "tests/test_buvette_inventaire.py"
    ]
    
    missing = []
    for file in required_files:
        if Path(file).exists():
            print_ok(f"Fichier trouvÃ©: {file}")
        else:
            missing.append(file)
            print_error(f"Fichier manquant: {file}")
    
    return missing

def generate_summary(all_issues):
    """GÃ©nÃ¨re un rÃ©sumÃ© des problÃ¨mes trouvÃ©s."""
    print_header("RÃ‰SUMÃ‰ DES VÃ‰RIFICATIONS")
    
    total_issues = sum(len(issues) for issues in all_issues.values())
    
    if total_issues == 0:
        print_ok("âœ“ Aucun problÃ¨me dÃ©tectÃ© ! Le module buvette est conforme.")
    else:
        print_error(f"âœ— {total_issues} problÃ¨me(s) dÃ©tectÃ©(s) nÃ©cessitant une correction:")
        
        for category, issues in all_issues.items():
            if issues:
                print(f"\n{Colors.WARNING}{category}:{Colors.ENDC}")
                for issue in issues:
                    print(f"  - {issue}")
    
    return total_issues

def main():
    """Fonction principale du script de vÃ©rification."""
    print_header("SCRIPT DE VÃ‰RIFICATION DU MODULE BUVETTE")
    print("Ce script identifie les incohÃ©rences et problÃ¨mes dans le module buvette")
    print("avant d'appliquer les corrections.\n")
    
    # Changer vers le rÃ©pertoire racine du projet
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    os.chdir(project_root)
    print(f"RÃ©pertoire de travail: {os.getcwd()}\n")
    
    all_issues = {}
    
    # 1. VÃ©rifier la structure des fichiers
    missing_files = check_file_structure()
    if missing_files:
        all_issues["Fichiers manquants"] = missing_files
    
    # 2. VÃ©rifier le schÃ©ma de base de donnÃ©es
    schema_issues = check_database_schema()
    if schema_issues:
        all_issues["SchÃ©ma de base de donnÃ©es"] = schema_issues
    
    # 3. VÃ©rifier buvette_db.py
    db_issues = check_buvette_db_file()
    if db_issues:
        all_issues["modules/buvette_db.py"] = db_issues
    
    # 4. VÃ©rifier buvette.py
    ui_issues = check_buvette_ui_file()
    if ui_issues:
        all_issues["modules/buvette.py"] = ui_issues
    
    # 5. ExÃ©cuter les tests
    tests_passed = run_tests()
    if not tests_passed:
        all_issues["Tests unitaires"] = ["Certains tests ont Ã©chouÃ©"]
    
    # 6. GÃ©nÃ©rer le rÃ©sumÃ©
    total_issues = generate_summary(all_issues)
    
    # Retourner un code de sortie appropriÃ©
    return 0 if total_issues == 0 else 1

if __name__ == "__main__":
    sys.exit(main())

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/collect_inventory_error_reports.py ===

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Inventory Error Report Collector

This script lists recent inventory error reports and prints previews of their content.
Error reports are generated by modules/inventory_lines_dialog.py when inventory
loading fails.

Usage:
    python scripts/collect_inventory_error_reports.py

The script will:
1. Find all reports/inventory_error_*.txt files
2. Sort them by timestamp (newest first)
3. Display a preview of each report

Note: Error reports are not committed to the repository (excluded in .gitignore).
"""

import os
import glob
import itertools
from datetime import datetime


def collect_and_preview_reports(reports_dir="reports", max_preview_lines=30):
    """
    Collect and preview inventory error reports.
    
    Args:
        reports_dir: Directory containing error reports (default: "reports")
        max_preview_lines: Maximum number of lines to show per report (default: 30)
    """
    # Resolve reports directory path
    script_dir = os.path.dirname(os.path.abspath(__file__))
    repo_root = os.path.dirname(script_dir)
    reports_path = os.path.join(repo_root, reports_dir)
    
    # Check if reports directory exists
    if not os.path.exists(reports_path):
        print(f"Reports directory not found: {reports_path}")
        print("No error reports have been generated yet.")
        return
    
    # Find all inventory error reports
    report_pattern = os.path.join(reports_path, "inventory_error_*.txt")
    report_files = glob.glob(report_pattern)
    
    if not report_files:
        print(f"No inventory error reports found in: {reports_path}")
        print("This is good news - no errors have been reported!")
        return
    
    # Sort reports by modification time (newest first)
    report_files.sort(key=lambda f: os.path.getmtime(f), reverse=True)
    
    print("=" * 80)
    print(f"INVENTORY ERROR REPORT SUMMARY")
    print("=" * 80)
    print(f"Reports directory: {reports_path}")
    print(f"Total reports found: {len(report_files)}")
    print("=" * 80)
    print()
    
    # Display each report
    for idx, report_file in enumerate(report_files, start=1):
        filename = os.path.basename(report_file)
        file_size = os.path.getsize(report_file)
        file_mtime = datetime.fromtimestamp(os.path.getmtime(report_file))
        
        print(f"\n{'=' * 80}")
        print(f"REPORT {idx}/{len(report_files)}: {filename}")
        print(f"Modified: {file_mtime.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Size: {file_size} bytes")
        print(f"{'=' * 80}")
        
        # Read and display preview
        try:
            with open(report_file, 'r', encoding='utf-8') as f:
                # Use islice to read only needed lines for memory efficiency
                preview_lines = list(itertools.islice(f, max_preview_lines))
                
                print('\n'.join(line.rstrip() for line in preview_lines))
                
                # Check if there are more lines by trying to read one more
                next_line = f.readline()
                if next_line:
                    print(f"\n... (more lines, file continues)")
                    print(f"\nFull report: {report_file}")
        
        except Exception as e:
            print(f"Error reading report: {e}")
    
    print("\n" + "=" * 80)
    print("END OF REPORT SUMMARY")
    print("=" * 80)


def main():
    """Main entry point for the script."""
    print("Inventory Error Report Collector")
    print("=" * 80)
    print()
    
    collect_and_preview_reports()
    
    print("\n")
    print("Note: These reports help diagnose inventory loading issues.")
    print("See docs/DIAGNOSTICS_INVENTORY.md for more information.")


if __name__ == "__main__":
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/compat_yaml.py ===

```python
#!/usr/bin/env python3
"""
Compatibility YAML loader for schema_hints.yaml.

This module provides a simple YAML loader that tries to use PyYAML if available,
but falls back to a simple parser that can handle the specific format used by
the schema hints file.

Usage:
    from scripts.compat_yaml import load_hints
    
    hints = load_hints('db/schema_hints.yaml')
"""

import re
from pathlib import Path
from typing import Dict, Any, Optional


def load_hints(path: str) -> Optional[Dict[str, Any]]:
    """
    Load schema hints from a YAML file.
    
    Tries to use PyYAML if available, otherwise uses a simple parser
    for the specific format produced by analyze_modules_columns.py.
    
    Args:
        path: Path to the schema_hints.yaml file
        
    Returns:
        Dictionary containing the parsed hints, or None if loading fails
    """
    path_obj = Path(path)
    
    if not path_obj.exists():
        return None
    
    # Try PyYAML first
    try:
        import yaml
        with open(path_obj, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except ImportError:
        pass
    except Exception as e:
        print(f"Warning: PyYAML failed to load {path}: {e}")
    
    # Fall back to simple parser
    try:
        return _simple_yaml_parser(path_obj)
    except Exception as e:
        print(f"Error: Failed to parse {path}: {e}")
        return None


def _simple_yaml_parser(path: Path) -> Dict[str, Any]:
    """
    Simple YAML parser for the specific format used by schema_hints.yaml.
    
    Expected format:
        schema_version: "1.0"
        generated_by: "analyzer"
        tables:
          table_name:
            expected_columns:
              column_name:
                type: "TEXT"
                inferred: true
    
    Args:
        path: Path to the YAML file
        
    Returns:
        Parsed dictionary
    """
    with open(path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    result = {}
    current_dict = result
    stack = [(result, 0)]  # Stack of (dict, indent_level)
    
    for line in content.split('\n'):
        # Skip comments and empty lines
        stripped = line.strip()
        if not stripped or stripped.startswith('#'):
            continue
        
        # Calculate indentation level (spaces, assuming 2-space indent)
        indent = len(line) - len(line.lstrip())
        
        # Parse key-value pairs
        if ':' in line:
            parts = line.split(':', 1)
            key = parts[0].strip()
            value_str = parts[1].strip() if len(parts) > 1 else ''
            
            # Adjust stack based on indentation
            while stack and stack[-1][1] >= indent:
                stack.pop()
            
            # Parse value
            if value_str:
                # Simple value (string, number, boolean)
                value = _parse_value(value_str)
                if stack:
                    stack[-1][0][key] = value
            else:
                # Nested dictionary
                new_dict = {}
                if stack:
                    stack[-1][0][key] = new_dict
                stack.append((new_dict, indent))
    
    return result


def _parse_value(value_str: str) -> Any:
    """
    Parse a simple YAML value.
    
    Args:
        value_str: String representation of the value
        
    Returns:
        Parsed value (str, int, float, bool, or None)
    """
    # Remove quotes if present
    value_str = value_str.strip()
    
    if value_str.startswith('"') and value_str.endswith('"'):
        return value_str[1:-1]
    if value_str.startswith("'") and value_str.endswith("'"):
        return value_str[1:-1]
    
    # Boolean
    if value_str.lower() == 'true':
        return True
    if value_str.lower() == 'false':
        return False
    
    # None/null
    if value_str.lower() in ('null', 'none', '~'):
        return None
    
    # Number
    try:
        if '.' in value_str:
            return float(value_str)
        return int(value_str)
    except ValueError:
        pass
    
    # Default to string
    return value_str


if __name__ == "__main__":
    # Test the loader
    import sys
    
    if len(sys.argv) > 1:
        test_path = sys.argv[1]
    else:
        # Default test path
        repo_root = Path(__file__).parent.parent
        test_path = repo_root / "db" / "schema_hints.yaml"
    
    print(f"Testing YAML loader with: {test_path}")
    hints = load_hints(str(test_path))
    
    if hints:
        print(f"\nSuccessfully loaded hints!")
        print(f"Schema version: {hints.get('schema_version')}")
        print(f"Generated by: {hints.get('generated_by')}")
        
        if 'tables' in hints:
            print(f"\nFound {len(hints['tables'])} tables:")
            for table_name in sorted(hints['tables'].keys())[:5]:
                cols = hints['tables'][table_name].get('expected_columns', {})
                print(f"  - {table_name}: {len(cols)} columns")
            
            if len(hints['tables']) > 5:
                print(f"  ... and {len(hints['tables']) - 5} more tables")
    else:
        print("Failed to load hints")
        sys.exit(1)

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/db_diagnostics.py ===

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Database Diagnostics Script

This script performs health checks on the SQLite database to diagnose
issues related to:
- Database locks
- WAL mode configuration
- Connection settings
- Table integrity
- Common sqlite3.Row conversion issues

Usage:
    python scripts/db_diagnostics.py [--db-path PATH] [--output REPORT_FILE]
    
Example:
    python scripts/db_diagnostics.py
    python scripts/db_diagnostics.py --db-path association.db --output reports/db_health.txt
"""

import sqlite3
import sys
import os
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Tuple, Any

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from db.db import get_db_file, get_connection
from utils.app_logger import get_logger

logger = get_logger("db_diagnostics")


class DBDiagnostics:
    """Database diagnostics and health check utility."""
    
    def __init__(self, db_path: str = None):
        """
        Initialize diagnostics.
        
        Args:
            db_path: Path to database file (optional, uses default if not provided)
        """
        self.db_path = db_path or get_db_file()
        self.results = {
            'timestamp': datetime.now().isoformat(),
            'db_path': self.db_path,
            'checks': {},
            'errors': [],
            'warnings': []
        }
    
    def check_file_exists(self) -> bool:
        """Check if database file exists."""
        exists = os.path.exists(self.db_path)
        self.results['checks']['file_exists'] = exists
        if not exists:
            self.results['errors'].append(f"Database file not found: {self.db_path}")
        return exists
    
    def check_file_permissions(self) -> bool:
        """Check if database file is readable and writable."""
        try:
            readable = os.access(self.db_path, os.R_OK)
            writable = os.access(self.db_path, os.W_OK)
            
            self.results['checks']['file_readable'] = readable
            self.results['checks']['file_writable'] = writable
            
            if not readable:
                self.results['errors'].append("Database file is not readable")
            if not writable:
                self.results['warnings'].append("Database file is not writable")
            
            return readable and writable
        except Exception as e:
            self.results['errors'].append(f"Error checking file permissions: {e}")
            return False
    
    def check_wal_mode(self) -> Tuple[bool, str]:
        """Check if WAL mode is enabled."""
        try:
            conn = sqlite3.connect(self.db_path, timeout=5)
            cursor = conn.cursor()
            cursor.execute("PRAGMA journal_mode;")
            mode = cursor.fetchone()[0]
            conn.close()
            
            is_wal = mode.upper() == 'WAL'
            self.results['checks']['wal_mode'] = mode
            
            if not is_wal:
                self.results['warnings'].append(
                    f"WAL mode not enabled (current: {mode}). "
                    "Consider running scripts/enable_wal.py"
                )
            
            return is_wal, mode
        except Exception as e:
            self.results['errors'].append(f"Error checking WAL mode: {e}")
            return False, "unknown"
    
    def check_busy_timeout(self) -> int:
        """Check busy timeout configuration."""
        try:
            conn = sqlite3.connect(self.db_path, timeout=5)
            cursor = conn.cursor()
            cursor.execute("PRAGMA busy_timeout;")
            timeout = cursor.fetchone()[0]
            conn.close()
            
            self.results['checks']['busy_timeout'] = timeout
            
            if timeout < 5000:
                self.results['warnings'].append(
                    f"Busy timeout is low ({timeout}ms). "
                    "Recommended: 5000ms or higher to reduce lock errors"
                )
            
            return timeout
        except Exception as e:
            self.results['errors'].append(f"Error checking busy timeout: {e}")
            return 0
    
    def check_database_integrity(self) -> bool:
        """Run SQLite integrity check."""
        try:
            conn = sqlite3.connect(self.db_path, timeout=5)
            cursor = conn.cursor()
            cursor.execute("PRAGMA integrity_check;")
            result = cursor.fetchone()[0]
            conn.close()
            
            is_ok = result.lower() == 'ok'
            self.results['checks']['integrity_check'] = result
            
            if not is_ok:
                self.results['errors'].append(f"Database integrity check failed: {result}")
            
            return is_ok
        except Exception as e:
            self.results['errors'].append(f"Error running integrity check: {e}")
            return False
    
    def check_connection(self) -> bool:
        """Test basic database connection."""
        try:
            conn = get_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT 1;")
            cursor.fetchone()
            conn.close()
            
            self.results['checks']['connection_test'] = "OK"
            return True
        except Exception as e:
            self.results['errors'].append(f"Connection test failed: {e}")
            self.results['checks']['connection_test'] = f"FAILED: {e}"
            return False
    
    def check_row_factory(self) -> bool:
        """Check if row_factory is properly configured."""
        try:
            conn = get_connection()
            has_row_factory = conn.row_factory is not None
            factory_type = type(conn.row_factory).__name__ if has_row_factory else "None"
            conn.close()
            
            self.results['checks']['row_factory'] = factory_type
            
            if not has_row_factory:
                self.results['warnings'].append(
                    "No row_factory configured. Consider using sqlite3.Row for named access"
                )
            
            return has_row_factory
        except Exception as e:
            self.results['errors'].append(f"Error checking row_factory: {e}")
            return False
    
    def list_tables(self) -> List[str]:
        """List all tables in the database."""
        try:
            conn = sqlite3.connect(self.db_path, timeout=5)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT name FROM sqlite_master 
                WHERE type='table' 
                ORDER BY name;
            """)
            tables = [row[0] for row in cursor.fetchall()]
            conn.close()
            
            self.results['checks']['table_count'] = len(tables)
            self.results['checks']['tables'] = tables
            
            return tables
        except Exception as e:
            self.results['errors'].append(f"Error listing tables: {e}")
            return []
    
    def check_table_sizes(self) -> Dict[str, int]:
        """Get row counts for all tables."""
        tables = self.list_tables()
        sizes = {}
        
        try:
            conn = sqlite3.connect(self.db_path, timeout=5)
            cursor = conn.cursor()
            
            for table in tables:
                try:
                    # Use identifier quoting to prevent SQL injection
                    # sqlite_master returns trusted table names, but use quoting for safety
                    quoted_table = f'"{table}"'
                    cursor.execute(f"SELECT COUNT(*) FROM {quoted_table};")
                    count = cursor.fetchone()[0]
                    sizes[table] = count
                except Exception as e:
                    sizes[table] = f"Error: {e}"
            
            conn.close()
            self.results['checks']['table_sizes'] = sizes
            
            return sizes
        except Exception as e:
            self.results['errors'].append(f"Error checking table sizes: {e}")
            return {}
    
    def run_all_checks(self) -> Dict[str, Any]:
        """Run all diagnostic checks."""
        print("Running database diagnostics...\n")
        
        # Basic file checks
        print("1. Checking database file...")
        if not self.check_file_exists():
            return self.results
        self.check_file_permissions()
        
        # Configuration checks
        print("2. Checking database configuration...")
        self.check_wal_mode()
        self.check_busy_timeout()
        self.check_row_factory()
        
        # Connection tests
        print("3. Testing database connection...")
        self.check_connection()
        
        # Integrity checks
        print("4. Running integrity check...")
        self.check_database_integrity()
        
        # Table information
        print("5. Gathering table information...")
        self.list_tables()
        self.check_table_sizes()
        
        print("\nDiagnostics complete!\n")
        return self.results
    
    def generate_report(self, output_file: str = None) -> str:
        """
        Generate a human-readable report.
        
        Args:
            output_file: Optional file path to write report to
            
        Returns:
            str: Report text
        """
        lines = []
        lines.append("=" * 80)
        lines.append("DATABASE DIAGNOSTICS REPORT")
        lines.append("=" * 80)
        lines.append(f"Timestamp: {self.results['timestamp']}")
        lines.append(f"Database: {self.results['db_path']}")
        lines.append("")
        
        # Summary
        error_count = len(self.results['errors'])
        warning_count = len(self.results['warnings'])
        
        lines.append("SUMMARY")
        lines.append("-" * 80)
        if error_count == 0 and warning_count == 0:
            lines.append("âœ“ All checks passed!")
        else:
            if error_count > 0:
                lines.append(f"âœ— {error_count} error(s) found")
            if warning_count > 0:
                lines.append(f"âš  {warning_count} warning(s) found")
        lines.append("")
        
        # Errors
        if self.results['errors']:
            lines.append("ERRORS")
            lines.append("-" * 80)
            for error in self.results['errors']:
                lines.append(f"âœ— {error}")
            lines.append("")
        
        # Warnings
        if self.results['warnings']:
            lines.append("WARNINGS")
            lines.append("-" * 80)
            for warning in self.results['warnings']:
                lines.append(f"âš  {warning}")
            lines.append("")
        
        # Detailed checks
        lines.append("DETAILED CHECKS")
        lines.append("-" * 80)
        checks = self.results['checks']
        
        for key, value in checks.items():
            if key == 'tables':
                lines.append(f"Tables: {', '.join(value) if value else 'None'}")
            elif key == 'table_sizes':
                lines.append("Table Sizes:")
                for table, size in value.items():
                    lines.append(f"  - {table}: {size} rows")
            else:
                lines.append(f"{key}: {value}")
        
        lines.append("")
        lines.append("=" * 80)
        
        report = '\n'.join(lines)
        
        # Write to file if requested
        if output_file:
            try:
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write(report)
                print(f"\nReport written to: {output_file}")
            except Exception as e:
                print(f"\nError writing report: {e}")
        
        return report


def main():
    """Main entry point."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Run database diagnostics and health checks"
    )
    parser.add_argument(
        '--db-path',
        help='Path to database file (optional, uses default if not provided)'
    )
    parser.add_argument(
        '--output',
        help='Output file for report (optional, prints to stdout if not provided)'
    )
    
    args = parser.parse_args()
    
    # Run diagnostics
    diagnostics = DBDiagnostics(db_path=args.db_path)
    diagnostics.run_all_checks()
    
    # Generate and display report
    report = diagnostics.generate_report(output_file=args.output)
    print(report)
    
    # Exit with error code if errors found
    if diagnostics.results['errors']:
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == '__main__':
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/enable_wal.py ===

```python
#!/usr/bin/env python3
"""
Utility script to enable WAL (Write-Ahead Logging) mode on a SQLite database.

WAL mode provides better concurrency and reduces database locking issues.
This script can be used to enable WAL mode on any existing database.

Usage:
    python scripts/enable_wal.py [database_path]
    
If no database path is provided, it will use the default application database.
"""

import sqlite3
import os
import sys

# Add parent directory to path to import db module
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from db.db import get_db_file

# Import timeout constant for consistency
try:
    from lib.db_articles import DEFAULT_TIMEOUT
except ImportError:
    DEFAULT_TIMEOUT = 30.0  # Fallback if import fails

def enable_wal(db_path):
    """
    Enable WAL mode on the specified database.
    
    Args:
        db_path: Path to the SQLite database file
        
    Returns:
        bool: True if successful, False otherwise
    """
    if not os.path.exists(db_path):
        print(f"âœ— Error: Database file not found at {db_path}")
        return False
    
    print(f"Database: {db_path}")
    
    try:
        conn = sqlite3.connect(db_path, timeout=DEFAULT_TIMEOUT)
        cursor = conn.cursor()
        
        # Check current journal mode
        cursor.execute("PRAGMA journal_mode;")
        current_mode = cursor.fetchone()[0]
        print(f"Current journal mode: {current_mode}")
        
        if current_mode.upper() == "WAL":
            print("âœ“ WAL mode is already enabled")
            conn.close()
            return True
        
        # Enable WAL mode
        print("â†’ Enabling WAL mode...")
        cursor.execute("PRAGMA journal_mode=WAL;")
        result = cursor.fetchone()[0]
        
        if result.upper() == "WAL":
            print(f"âœ“ Successfully enabled WAL mode")
        else:
            print(f"âš  Warning: Expected WAL but got {result}")
        
        # Set synchronous to NORMAL for better performance
        print("â†’ Setting synchronous mode to NORMAL...")
        cursor.execute("PRAGMA synchronous=NORMAL;")
        print("âœ“ Synchronous mode set to NORMAL")
        
        # Display additional info
        cursor.execute("PRAGMA synchronous;")
        sync_mode = cursor.fetchone()[0]
        print(f"  Synchronous level: {sync_mode}")
        
        conn.close()
        print("\nâœ“ Database optimized for better concurrency")
        return True
        
    except sqlite3.OperationalError as e:
        error_msg = str(e).lower()
        if "database is locked" in error_msg:
            print(f"âœ— Error: Database is currently locked by another process")
            print("  Please close all applications using the database and try again")
        else:
            print(f"âœ— SQLite error: {e}")
        return False
        
    except Exception as e:
        print(f"âœ— Unexpected error: {e}")
        return False

def main():
    """Main entry point for the script."""
    print("=" * 70)
    print("SQLite WAL Mode Enabler")
    print("=" * 70)
    print()
    
    # Determine database path
    if len(sys.argv) > 1:
        db_path = sys.argv[1]
    else:
        db_path = get_db_file()
        print(f"Using default database from configuration")
    
    success = enable_wal(db_path)
    
    print()
    print("=" * 70)
    if success:
        print("âœ“ OPERATION COMPLETED SUCCESSFULLY")
        print("=" * 70)
        sys.exit(0)
    else:
        print("âœ— OPERATION FAILED")
        print("=" * 70)
        sys.exit(1)

if __name__ == "__main__":
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/migrate_add_purchase_price.py ===

```python
#!/usr/bin/env python3
"""
Migration script to add purchase_price column to buvette_articles table.
This script is idempotent - it can be run multiple times safely.

Features:
- Automatic database backup before migration
- Table existence detection with clear error messages
- Adds purchase_price column if missing
- Enables WAL mode for better concurrency
- Transaction-based operations with error handling
"""

import sqlite3
import os
import sys
import shutil
from datetime import datetime

# Add parent directory to path to import db module
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from db.db import get_db_file

# Import timeout constant for consistency
try:
    from lib.db_articles import DEFAULT_TIMEOUT
except ImportError:
    DEFAULT_TIMEOUT = 30.0  # Fallback if import fails

def backup_database(db_path):
    """
    Create a backup of the database file.
    
    Args:
        db_path: Path to the database file
        
    Returns:
        str: Path to the backup file
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = f"{db_path}.{timestamp}.bak"
    
    try:
        shutil.copy2(db_path, backup_path)
        print(f"âœ“ Database backup created: {backup_path}")
        return backup_path
    except Exception as e:
        print(f"âœ— Error creating backup: {e}")
        raise

def enable_wal_mode(conn):
    """
    Enable WAL (Write-Ahead Logging) mode for better concurrency.
    
    Args:
        conn: SQLite connection
    """
    try:
        cursor = conn.cursor()
        cursor.execute("PRAGMA journal_mode=WAL;")
        result = cursor.fetchone()
        print(f"âœ“ WAL mode enabled: {result[0]}")
        
        cursor.execute("PRAGMA synchronous=NORMAL;")
        print(f"âœ“ Synchronous mode set to NORMAL for better performance")
    except Exception as e:
        print(f"âš  Warning: Could not enable WAL mode: {e}")

def migrate_add_purchase_price():
    """
    Add purchase_price column to buvette_articles if it doesn't exist.
    This is a non-destructive migration with automatic backup.
    """
    db_path = get_db_file()
    
    # Check if database file exists
    if not os.path.exists(db_path):
        print(f"âœ— Error: Database file not found at {db_path}")
        print("  Please ensure the database has been initialized.")
        return False
    
    print(f"Database location: {db_path}")
    
    # Create backup
    try:
        backup_path = backup_database(db_path)
    except Exception as e:
        print(f"âœ— Failed to create backup. Migration aborted for safety.")
        return False
    
    conn = None
    try:
        # Connect with a reasonable timeout
        conn = sqlite3.connect(db_path, timeout=DEFAULT_TIMEOUT)
        cursor = conn.cursor()
        
        # Begin transaction
        cursor.execute("BEGIN TRANSACTION;")
        
        # Check if buvette_articles table exists
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='buvette_articles'
        """)
        table_exists = cursor.fetchone()
        
        if not table_exists:
            print("âœ— Error: Table 'buvette_articles' does not exist.")
            print("  Please initialize the database first using init_db.py")
            conn.rollback()
            conn.close()
            return False
        
        print("âœ“ Table 'buvette_articles' found")
        
        # Check if the column already exists
        cursor.execute("PRAGMA table_info(buvette_articles)")
        columns = [row[1] for row in cursor.fetchall()]
        
        if "purchase_price" in columns:
            print("âœ“ Column 'purchase_price' already exists in buvette_articles table.")
            conn.rollback()  # No changes needed
            conn.close()
            print("\nâœ“ No migration needed - database is already up to date")
            return True
        
        # Add the column
        print("â†’ Adding 'purchase_price' column to buvette_articles table...")
        cursor.execute("ALTER TABLE buvette_articles ADD COLUMN purchase_price REAL")
        
        # Commit the transaction
        conn.commit()
        print("âœ“ Successfully added 'purchase_price' column")
        
        # Enable WAL mode for better concurrency
        print("\nâ†’ Optimizing database for better concurrency...")
        enable_wal_mode(conn)
        
        conn.close()
        
        print(f"\nâœ“ Migration completed successfully!")
        print(f"  Backup saved at: {backup_path}")
        print(f"  To rollback, restore from: {backup_path}")
        
        return True
        
    except sqlite3.OperationalError as e:
        error_msg = str(e).lower()
        if "database is locked" in error_msg:
            print(f"âœ— Error: Database is currently locked by another process")
            print("  Please close all applications using the database and try again")
        elif "no such table" in error_msg:
            print(f"âœ— Error: Table 'buvette_articles' does not exist")
            print("  Please initialize the database first")
        else:
            print(f"âœ— SQLite error: {e}")
        
        if conn:
            try:
                conn.rollback()
                conn.close()
            except:
                pass
        return False
        
    except Exception as e:
        print(f"âœ— Unexpected error during migration: {e}")
        if conn:
            try:
                conn.rollback()
                conn.close()
            except:
                pass
        return False

if __name__ == "__main__":
    print("=" * 70)
    print("Database Migration: Add purchase_price column")
    print("=" * 70)
    print()
    
    success = migrate_add_purchase_price()
    
    print()
    print("=" * 70)
    if success:
        print("âœ“ MIGRATION COMPLETED SUCCESSFULLY")
        print("=" * 70)
        sys.exit(0)
    else:
        print("âœ— MIGRATION FAILED")
        print("=" * 70)
        sys.exit(1)

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/migration.py ===

```python
"""
Script de migration pour la base de donnÃ©es Log-Interactif-treso.
- Permet de mettre Ã  jour ou migrer le schÃ©ma de la base SQLite.
- Ã€ lancer manuellement en cas de mise Ã  jour de structure.

Usage :
    python scripts/migration.py
"""

import sqlite3
import sys
import os

DB_PATH = os.environ.get("DB_PATH", "./data/database.db")

MIGRATIONS = [
    # Exemple : Ajout d'une colonne 'description' Ã  la table events
    {
        "desc": "Ajout colonne 'description' Ã  events si absente",
        "sql": [
            "ALTER TABLE events ADD COLUMN description TEXT"
        ],
        "check": "PRAGMA table_info(events);",
        "trigger": lambda columns: not any(c[1]=="description" for c in columns)
    },
    # Ajout du prix d'achat unitaire pour les articles de buvette
    {
        "desc": "Ajout colonne 'purchase_price' Ã  buvette_articles si absente",
        "sql": [
            "ALTER TABLE buvette_articles ADD COLUMN purchase_price REAL"
        ],
        "check": "PRAGMA table_info(buvette_articles);",
        "trigger": lambda columns: not any(c[1]=="purchase_price" for c in columns)
    },
    # Ajouter d'autres migrations ici sous forme de dict
    # ...
]

def get_columns(conn, table):
    return conn.execute(f"PRAGMA table_info({table});").fetchall()

def run_migrations(conn):
    for mig in MIGRATIONS:
        print(f"> VÃ©rification : {mig['desc']}")
        check = mig["check"].split("(")[1].split(")")[0]
        columns = get_columns(conn, check)
        if mig["trigger"](columns):
            print(f"  - Migration nÃ©cessaire, exÃ©cution SQL : {mig['sql'][0]}")
            for sql in mig["sql"]:
                try:
                    conn.execute(sql)
                    print(f"    âœ“ {sql}")
                except Exception as e:
                    print(f"    âš ï¸  Erreur : {e}")
        else:
            print("  - DÃ©jÃ  Ã  jour, rien Ã  faire.")

def main():
    if not os.path.exists(DB_PATH):
        print(f"Base introuvable : {DB_PATH}")
        sys.exit(1)
    conn = sqlite3.connect(DB_PATH)
    try:
        run_migrations(conn)
        conn.commit()
        print("âœ… Migration terminÃ©e.")
    finally:
        conn.close()

if __name__ == "__main__":
    main()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/project_audit.py ===

```python
#!/usr/bin/env python3
"""
Project Audit Script for V2 - Logiciel Tresorerie Interactifs

This script performs a comprehensive audit of the codebase to detect:
- Sensitive files (databases, logs, environment files)
- Large files (>5 MB by default)
- Circular imports
- Orphan modules (rarely imported)
- TODO/FIXME/XXX comments
- Missing or unused dependencies
- Missing tests

The script generates a PROJECT_AUDIT.md report with findings and recommendations.

Usage:
    python scripts/project_audit.py [--output OUTPUT] [--max-size-MB SIZE]

Examples:
    python scripts/project_audit.py
    python scripts/project_audit.py --output PROJECT_AUDIT.md --max-size-MB 5
"""

import os
import sys
import ast
import argparse
from pathlib import Path
from collections import defaultdict
from typing import Dict, List, Set, Tuple, Optional
import re


class ProjectAuditor:
    """Audits a Python project for various issues and generates a report."""
    
    def __init__(self, root_dir: str, max_size_mb: float = 5.0):
        """
        Initialize the auditor.
        
        Args:
            root_dir: Root directory of the project
            max_size_mb: Maximum file size in MB before flagging as large
        """
        self.root_dir = Path(root_dir).resolve()
        self.max_size_bytes = int(max_size_mb * 1024 * 1024)
        
        # Results storage
        self.sensitive_files = {
            'databases': [],
            'logs': [],
            'env_files': [],
        }
        self.large_files = []
        self.import_graph = defaultdict(set)  # module -> set of imported modules
        self.circular_imports = []
        self.orphan_modules = []
        self.todos = []
        self.python_files = []
        self.modules_without_docstring = []
        self.modules_without_main = []
        self.parse_errors = []
        
        # Dependencies analysis
        self.requirements = set()
        self.imported_packages = set()
        
    def scan_files(self):
        """Scan the repository for files to analyze."""
        print("ðŸ” Scanning repository files...")
        
        for root, dirs, files in os.walk(self.root_dir):
            # Skip hidden directories and virtual environments
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['venv', '__pycache__', 'node_modules']]
            
            rel_root = Path(root).relative_to(self.root_dir)
            
            for file in files:
                file_path = Path(root) / file
                rel_path = file_path.relative_to(self.root_dir)
                
                # Check file size
                try:
                    file_size = file_path.stat().st_size
                    if file_size > self.max_size_bytes:
                        self.large_files.append({
                            'path': str(rel_path),
                            'size_mb': file_size / (1024 * 1024)
                        })
                except OSError:
                    pass
                
                # Categorize sensitive files
                if file.endswith(('.db', '.sqlite', '.sqlite3')):
                    self.sensitive_files['databases'].append(str(rel_path))
                elif file.endswith('.log'):
                    self.sensitive_files['logs'].append(str(rel_path))
                elif file in ['.env', 'env', '.env.local', '.env.production'] or file.startswith('env.'):
                    self.sensitive_files['env_files'].append(str(rel_path))
                
                # Track Python files for analysis
                if file.endswith('.py'):
                    self.python_files.append(file_path)
    
    def analyze_python_files(self):
        """Analyze Python files for imports, TODOs, and other issues."""
        print("ðŸ Analyzing Python files...")
        
        for py_file in self.python_files:
            rel_path = py_file.relative_to(self.root_dir)
            
            try:
                with open(py_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # Parse AST
                try:
                    tree = ast.parse(content, filename=str(py_file))
                    self._analyze_ast(tree, py_file, rel_path)
                except SyntaxError as e:
                    self.parse_errors.append({
                        'file': str(rel_path),
                        'error': str(e)
                    })
                
                # Search for TODO/FIXME/XXX comments
                self._find_todos(content, rel_path)
                
            except Exception as e:
                self.parse_errors.append({
                    'file': str(rel_path),
                    'error': f"Failed to read file: {str(e)}"
                })
    
    def _analyze_ast(self, tree: ast.AST, file_path: Path, rel_path: Path):
        """Analyze the AST of a Python file."""
        module_name = self._get_module_name(rel_path)
        
        # Check for module docstring
        has_docstring = (isinstance(tree.body, list) and 
                        len(tree.body) > 0 and 
                        isinstance(tree.body[0], ast.Expr) and 
                        isinstance(tree.body[0].value, (ast.Str, ast.Constant)))
        
        if not has_docstring:
            self.modules_without_docstring.append(str(rel_path))
        
        # Check for main function or if __name__ == "__main__"
        has_main = False
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef) and node.name in ['main', '__main__']:
                has_main = True
                break
            if isinstance(node, ast.If):
                # Check for if __name__ == "__main__"
                if isinstance(node.test, ast.Compare):
                    if hasattr(node.test.left, 'id') and node.test.left.id == '__name__':
                        has_main = True
                        break
        
        if not has_main and str(rel_path) not in ['__init__.py', 'setup.py', 'conftest.py']:
            self.modules_without_main.append(str(rel_path))
        
        # Extract imports
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imported_module = alias.name.split('.')[0]
                    self.import_graph[module_name].add(imported_module)
                    self.imported_packages.add(imported_module)
            
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imported_module = node.module.split('.')[0]
                    self.import_graph[module_name].add(imported_module)
                    self.imported_packages.add(imported_module)
    
    def _get_module_name(self, rel_path: Path) -> str:
        """Convert a file path to a module name."""
        parts = list(rel_path.parts)
        if parts[-1] == '__init__.py':
            parts = parts[:-1]
        else:
            parts[-1] = parts[-1][:-3]  # Remove .py extension
        return '.'.join(parts) if parts else 'root'
    
    def _find_todos(self, content: str, rel_path: Path):
        """Find TODO/FIXME/XXX comments in the content."""
        lines = content.split('\n')
        patterns = [r'#\s*(TODO|FIXME|XXX)', r'"""\s*(TODO|FIXME|XXX)', r"'''\s*(TODO|FIXME|XXX)"]
        
        for line_num, line in enumerate(lines, 1):
            for pattern in patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    self.todos.append({
                        'file': str(rel_path),
                        'line': line_num,
                        'text': line.strip()
                    })
                    break
    
    def detect_circular_imports(self):
        """Detect circular imports in the import graph."""
        print("ðŸ”„ Detecting circular imports...")
        
        visited = set()
        rec_stack = set()
        
        def has_cycle(node, path):
            visited.add(node)
            rec_stack.add(node)
            
            for neighbor in self.import_graph.get(node, []):
                if neighbor not in visited:
                    if has_cycle(neighbor, path + [neighbor]):
                        return True
                elif neighbor in rec_stack:
                    # Found a cycle
                    cycle_start = path.index(neighbor) if neighbor in path else 0
                    cycle = path[cycle_start:] + [neighbor]
                    if cycle not in self.circular_imports:
                        self.circular_imports.append(cycle)
                    return True
            
            rec_stack.remove(node)
            return False
        
        for node in list(self.import_graph.keys()):
            if node not in visited:
                has_cycle(node, [node])
    
    def identify_orphan_modules(self):
        """Identify modules that are rarely or never imported."""
        print("ðŸ” Identifying orphan modules...")
        
        # Count how many times each module is imported
        import_count = defaultdict(int)
        
        for module, imports in self.import_graph.items():
            for imported in imports:
                # Only count internal modules (not external packages)
                if '.' in imported or imported in [self._get_module_name(Path(pf).relative_to(self.root_dir)) for pf in self.python_files]:
                    import_count[imported] += 1
        
        # Find modules with 0-1 imports (potential orphans)
        all_modules = [self._get_module_name(Path(pf).relative_to(self.root_dir)) for pf in self.python_files]
        
        for module in all_modules:
            if import_count[module] <= 1 and module not in ['main', 'root', '__main__']:
                # Exclude common entry points and test files
                if not module.startswith('test_') and 'test' not in module:
                    self.orphan_modules.append({
                        'module': module,
                        'import_count': import_count[module]
                    })
    
    def analyze_dependencies(self):
        """Analyze dependencies from requirements.txt."""
        print("ðŸ“¦ Analyzing dependencies...")
        
        req_file = self.root_dir / 'requirements.txt'
        if req_file.exists():
            try:
                with open(req_file, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            # Extract package name (before ==, >=, etc.)
                            pkg_name = re.split(r'[=><!\[]', line)[0].strip()
                            # Normalize package names (e.g., python-docx -> docx)
                            self.requirements.add(pkg_name.lower().replace('-', '_'))
                            self.requirements.add(pkg_name.lower().replace('_', '-'))
                            self.requirements.add(pkg_name.lower())
            except Exception as e:
                print(f"Warning: Could not read requirements.txt: {e}")
    
    def count_tests(self) -> Dict[str, int]:
        """Count test files and test functions."""
        print("ðŸ§ª Counting tests...")
        
        test_dir = self.root_dir / 'tests'
        test_count = {'files': 0, 'functions': 0}
        
        if not test_dir.exists():
            return test_count
        
        for py_file in test_dir.rglob('*.py'):
            if py_file.name.startswith('test_') or py_file.name.endswith('_test.py'):
                test_count['files'] += 1
                
                try:
                    with open(py_file, 'r', encoding='utf-8') as f:
                        tree = ast.parse(f.read())
                        for node in ast.walk(tree):
                            if isinstance(node, ast.FunctionDef) and node.name.startswith('test_'):
                                test_count['functions'] += 1
                except:
                    pass
        
        return test_count
    
    def generate_report(self, output_file: str):
        """Generate the audit report in Markdown format."""
        print(f"ðŸ“ Generating report: {output_file}")
        
        report = []
        report.append("# PROJECT AUDIT REPORT")
        report.append("")
        report.append("*Generated automatically by `scripts/project_audit.py`*")
        report.append("")
        report.append("---")
        report.append("")
        
        # Executive Summary
        report.append("## ðŸ“Š Executive Summary")
        report.append("")
        
        total_issues = (
            len(self.sensitive_files['databases']) +
            len(self.sensitive_files['logs']) +
            len(self.sensitive_files['env_files']) +
            len(self.large_files) +
            len(self.circular_imports) +
            len(self.orphan_modules) +
            len(self.todos)
        )
        
        report.append(f"- **Total Python files analyzed**: {len(self.python_files)}")
        report.append(f"- **Total issues detected**: {total_issues}")
        report.append(f"- **Sensitive files found**: {len(self.sensitive_files['databases']) + len(self.sensitive_files['logs']) + len(self.sensitive_files['env_files'])}")
        report.append(f"- **Large files (>{self.max_size_bytes / (1024*1024):.0f} MB)**: {len(self.large_files)}")
        report.append(f"- **Circular imports detected**: {len(self.circular_imports)}")
        report.append(f"- **Potential orphan modules**: {len(self.orphan_modules)}")
        report.append(f"- **TODO/FIXME/XXX comments**: {len(self.todos)}")
        report.append("")
        
        # Sensitive Files
        report.append("## ðŸ”’ Security & Sensitive Files")
        report.append("")
        
        if self.sensitive_files['databases']:
            report.append("### Database Files")
            report.append("")
            report.append("âš ï¸ **Warning**: Database files should NOT be committed to the repository!")
            report.append("")
            for db_file in self.sensitive_files['databases']:
                report.append(f"- `{db_file}`")
            report.append("")
        
        if self.sensitive_files['logs']:
            report.append("### Log Files")
            report.append("")
            report.append("âš ï¸ **Warning**: Log files should NOT be committed to the repository!")
            report.append("")
            for log_file in self.sensitive_files['logs']:
                report.append(f"- `{log_file}`")
            report.append("")
        
        if self.sensitive_files['env_files']:
            report.append("### Environment Files")
            report.append("")
            report.append("âš ï¸ **Warning**: Environment files may contain sensitive information!")
            report.append("")
            for env_file in self.sensitive_files['env_files']:
                report.append(f"- `{env_file}`")
            report.append("")
        
        # Large Files
        if self.large_files:
            report.append("## ðŸ“¦ Large Files")
            report.append("")
            report.append(f"Files larger than {self.max_size_bytes / (1024*1024):.0f} MB:")
            report.append("")
            for lf in sorted(self.large_files, key=lambda x: x['size_mb'], reverse=True):
                report.append(f"- `{lf['path']}` - **{lf['size_mb']:.2f} MB**")
            report.append("")
        
        # Circular Imports
        if self.circular_imports:
            report.append("## ðŸ”„ Circular Import Issues")
            report.append("")
            report.append("âš ï¸ **Warning**: Circular imports can cause import errors and make code harder to maintain!")
            report.append("")
            for i, cycle in enumerate(self.circular_imports, 1):
                report.append(f"### Cycle {i}")
                report.append("")
                report.append(" â†’ ".join(cycle))
                report.append("")
        
        # Orphan Modules
        if self.orphan_modules:
            report.append("## ðŸ” Potential Orphan Modules")
            report.append("")
            report.append("Modules that are rarely or never imported by other modules:")
            report.append("")
            for orphan in sorted(self.orphan_modules, key=lambda x: x['import_count']):
                report.append(f"- `{orphan['module']}` (imported {orphan['import_count']} time(s))")
            report.append("")
        
        # Parse Errors
        if self.parse_errors:
            report.append("## âš ï¸ Parse Errors")
            report.append("")
            report.append("Files that could not be parsed:")
            report.append("")
            for error in self.parse_errors:
                report.append(f"- `{error['file']}`: {error['error']}")
            report.append("")
        
        # Modules without docstrings
        if self.modules_without_docstring:
            report.append("## ðŸ“ Code Quality: Missing Module Docstrings")
            report.append("")
            report.append(f"Found {len(self.modules_without_docstring)} Python file(s) without module-level docstrings:")
            report.append("")
            for module in sorted(self.modules_without_docstring)[:10]:
                report.append(f"- `{module}`")
            if len(self.modules_without_docstring) > 10:
                report.append(f"- ... and {len(self.modules_without_docstring) - 10} more")
            report.append("")
        
        # Dependencies Analysis
        report.append("## ðŸ“¦ Dependencies Analysis")
        report.append("")
        
        # Compare requirements with imports
        missing_in_requirements = []
        unused_in_requirements = []
        
        # Standard library modules to exclude
        stdlib_modules = {
            'os', 'sys', 're', 'json', 'csv', 'datetime', 'time', 'math', 'random',
            'collections', 'itertools', 'functools', 'pathlib', 'argparse', 'logging',
            'unittest', 'sqlite3', 'ast', 'io', 'typing', 'tkinter', 'threading',
            'subprocess', 'shutil', 'zipfile', 'tempfile', 'copy', 'pickle', 'hashlib'
        }
        
        for pkg in self.imported_packages:
            if pkg not in stdlib_modules and pkg not in self.requirements:
                # Check if it's an internal module
                if not any(pkg in str(pf) for pf in self.python_files):
                    missing_in_requirements.append(pkg)
        
        for req in self.requirements:
            found = False
            for pkg in self.imported_packages:
                if req in pkg or pkg in req or req.replace('_', '-') == pkg.replace('_', '-'):
                    found = True
                    break
            if not found:
                unused_in_requirements.append(req)
        
        if missing_in_requirements:
            report.append("### Potentially Missing from requirements.txt")
            report.append("")
            for pkg in sorted(set(missing_in_requirements)):
                report.append(f"- `{pkg}`")
            report.append("")
        
        if unused_in_requirements:
            report.append("### Potentially Unused in requirements.txt")
            report.append("")
            report.append("âš ï¸ Note: This is a heuristic check and may have false positives")
            report.append("")
            for pkg in sorted(set(unused_in_requirements)):
                report.append(f"- `{pkg}`")
            report.append("")
        
        # Test Coverage
        report.append("## ðŸ§ª Test Coverage")
        report.append("")
        
        test_stats = self.count_tests()
        report.append(f"- **Test files**: {test_stats['files']}")
        report.append(f"- **Test functions**: {test_stats['functions']}")
        report.append("")
        
        if test_stats['files'] == 0:
            report.append("âš ï¸ **Warning**: No test files found! Consider adding tests to ensure code quality.")
            report.append("")
        elif test_stats['functions'] < 10:
            report.append("âš ï¸ **Warning**: Low test coverage. Consider adding more tests.")
            report.append("")
        
        # TODOs
        if self.todos:
            report.append("## ðŸ“ TODO/FIXME/XXX Comments")
            report.append("")
            report.append(f"Found {len(self.todos)} TODO/FIXME/XXX comment(s):")
            report.append("")
            
            # Show first 20 TODOs
            for todo in self.todos[:20]:
                report.append(f"- `{todo['file']}:{todo['line']}` - {todo['text']}")
            
            if len(self.todos) > 20:
                report.append(f"- ... and {len(self.todos) - 20} more")
            report.append("")
        
        # Recommendations
        report.append("## ðŸ’¡ Recommendations")
        report.append("")
        
        # High Priority
        report.append("### ðŸ”´ High Priority")
        report.append("")
        
        if self.sensitive_files['databases']:
            report.append("1. **Remove database files from repository**")
            report.append("   ```bash")
            report.append("   # Remove from git tracking")
            for db_file in self.sensitive_files['databases']:
                report.append(f"   git rm --cached {db_file}")
            report.append("")
            report.append("   # Add to .gitignore")
            report.append("   echo '*.db' >> .gitignore")
            report.append("   echo '*.sqlite' >> .gitignore")
            report.append("   echo '*.sqlite3' >> .gitignore")
            report.append("   ```")
            report.append("")
        
        if self.sensitive_files['logs']:
            report.append("2. **Remove log files from repository**")
            report.append("   ```bash")
            report.append("   # Remove from git tracking")
            for log_file in self.sensitive_files['logs']:
                report.append(f"   git rm --cached {log_file}")
            report.append("")
            report.append("   # Add to .gitignore")
            report.append("   echo '*.log' >> .gitignore")
            report.append("   echo 'logs/' >> .gitignore")
            report.append("   ```")
            report.append("")
        
        if self.sensitive_files['env_files']:
            report.append("3. **Secure environment files**")
            report.append("   - Review environment files for sensitive information")
            report.append("   - Ensure `.env` files are in `.gitignore`")
            report.append("   - Use `env.example` as a template without sensitive data")
            report.append("")
        
        # Medium Priority
        report.append("### ðŸŸ¡ Medium Priority")
        report.append("")
        
        if self.circular_imports:
            report.append("1. **Refactor circular imports**")
            report.append("   - Review the circular import cycles listed above")
            report.append("   - Consider restructuring code to remove circular dependencies")
            report.append("   - Use dependency injection or move shared code to a common module")
            report.append("")
        
        if self.large_files:
            report.append("2. **Handle large files**")
            report.append("   - Consider using Git LFS for large binary files")
            report.append("   - Move large data files outside the repository")
            report.append("   ```bash")
            report.append("   # Install and use Git LFS")
            report.append("   git lfs install")
            report.append("   git lfs track '*.db'")
            report.append("   ```")
            report.append("")
        
        if test_stats['files'] < 5:
            report.append("3. **Improve test coverage**")
            report.append("   - Add unit tests for critical modules")
            report.append("   - Aim for at least 70% code coverage")
            report.append("   - Use pytest and coverage tools")
            report.append("   ```bash")
            report.append("   pip install pytest pytest-cov")
            report.append("   pytest --cov=. --cov-report=html")
            report.append("   ```")
            report.append("")
        
        # Low Priority
        report.append("### ðŸŸ¢ Low Priority")
        report.append("")
        
        if self.orphan_modules:
            report.append("1. **Review orphan modules**")
            report.append("   - Check if orphan modules are actually unused")
            report.append("   - Remove unused code or document why it's kept")
            report.append("")
        
        if self.todos:
            report.append("2. **Address TODO/FIXME comments**")
            report.append("   - Create issues for important TODOs")
            report.append("   - Remove or complete outdated TODOs")
            report.append("")
        
        if self.modules_without_docstring:
            report.append("3. **Add module docstrings**")
            report.append("   - Document the purpose of each module")
            report.append("   - Follow PEP 257 docstring conventions")
            report.append("")
        
        # How to Run
        report.append("## ðŸš€ How to Run This Audit Locally")
        report.append("")
        report.append("### Prerequisites")
        report.append("")
        report.append("- Python 3.8 or higher")
        report.append("")
        report.append("### Steps")
        report.append("")
        report.append("```bash")
        report.append("# Clone the repository")
        report.append("git clone <repository-url>")
        report.append("cd V2---Logiciel-Tresorerie-interactifs")
        report.append("")
        report.append("# Create and activate virtual environment (optional but recommended)")
        report.append("python -m venv venv")
        report.append("")
        report.append("# On Windows:")
        report.append(".\\venv\\Scripts\\Activate.ps1")
        report.append("# On Linux/Mac:")
        report.append("source venv/bin/activate")
        report.append("")
        report.append("# Install dependencies")
        report.append("pip install -r requirements.txt")
        report.append("")
        report.append("# Run the audit")
        report.append("python scripts/project_audit.py --output PROJECT_AUDIT.md")
        report.append("")
        report.append("# With custom max file size (default is 5 MB)")
        report.append("python scripts/project_audit.py --max-size-MB 10")
        report.append("```")
        report.append("")
        
        report.append("---")
        report.append("")
        report.append(f"*Report generated from: `{self.root_dir}`*")
        report.append("")
        
        # Write report to file
        output_path = self.root_dir / output_file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(report))
        
        print(f"âœ… Report generated: {output_path}")
    
    def print_summary(self):
        """Print a summary to console."""
        print("\n" + "="*60)
        print("PROJECT AUDIT SUMMARY")
        print("="*60)
        print(f"Total Python files: {len(self.python_files)}")
        print(f"Sensitive files: {len(self.sensitive_files['databases']) + len(self.sensitive_files['logs']) + len(self.sensitive_files['env_files'])}")
        print(f"  - Databases: {len(self.sensitive_files['databases'])}")
        print(f"  - Logs: {len(self.sensitive_files['logs'])}")
        print(f"  - Environment: {len(self.sensitive_files['env_files'])}")
        print(f"Large files: {len(self.large_files)}")
        print(f"Circular imports: {len(self.circular_imports)}")
        print(f"Orphan modules: {len(self.orphan_modules)}")
        print(f"TODO/FIXME/XXX: {len(self.todos)}")
        print(f"Parse errors: {len(self.parse_errors)}")
        print("="*60)
        print()
    
    def run_audit(self, output_file: str):
        """Run the complete audit process."""
        print("\nðŸ” Starting project audit...")
        print(f"ðŸ“ Root directory: {self.root_dir}")
        print(f"ðŸ“ Max file size: {self.max_size_bytes / (1024*1024):.1f} MB")
        print()
        
        self.scan_files()
        self.analyze_python_files()
        self.detect_circular_imports()
        self.identify_orphan_modules()
        self.analyze_dependencies()
        
        self.generate_report(output_file)
        self.print_summary()
        
        print(f"âœ… Audit complete! Report saved to: {output_file}")


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description="Audit a Python project for potential issues",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/project_audit.py
  python scripts/project_audit.py --output PROJECT_AUDIT.md --max-size-MB 10

The script will analyze the project and generate a detailed report.
        """
    )
    
    parser.add_argument(
        '--output',
        default='PROJECT_AUDIT.md',
        help='Output file for the audit report (default: PROJECT_AUDIT.md)'
    )
    
    parser.add_argument(
        '--max-size-MB',
        type=float,
        default=5.0,
        help='Maximum file size in MB before flagging as large (default: 5.0)'
    )
    
    args = parser.parse_args()
    
    # Get the root directory (parent of scripts/)
    script_dir = Path(__file__).parent
    root_dir = script_dir.parent
    
    try:
        auditor = ProjectAuditor(root_dir, args.max_size_MB)
        auditor.run_audit(args.output)
        return 0
    except Exception as e:
        print(f"âŒ Error during audit: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/update_db_structure.py ===

```python
#!/usr/bin/env python3
"""
Script de mise Ã  jour sÃ»re de la structure de base de donnÃ©es.

Ce script compare le schÃ©ma attendu (extrait du code ou du rapport d'analyse)
avec le schÃ©ma rÃ©el de la base de donnÃ©es et effectue des migrations sÃ»res
pour ajouter les colonnes manquantes.

FonctionnalitÃ©s:
- DÃ©tection automatique des colonnes manquantes
- Sauvegarde timestampÃ©e avant toute modification
- Transactions avec rollback en cas d'erreur
- Restauration automatique de la sauvegarde si Ã©chec
- Activation WAL mode et optimisation des pragmas
- Rapport dÃ©taillÃ© de migration

Usage:
    python scripts/update_db_structure.py [--db-path path/to/database.db]
"""

import sqlite3
import os
import sys
import shutil
import argparse
import traceback
import subprocess
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple, Set, Optional
from difflib import SequenceMatcher

# Force UTF-8 encoding for stdout/stderr on Windows to avoid encoding errors
try:
    sys.stdout.reconfigure(encoding='utf-8')
    sys.stderr.reconfigure(encoding='utf-8')
except Exception:
    pass

# Try to import compat_yaml for loading hints
try:
    from scripts.compat_yaml import load_hints
except ImportError:
    # Fallback if running from scripts/ directory
    try:
        from compat_yaml import load_hints
    except ImportError:
        load_hints = None

# Valid SQL identifier pattern
SQL_IDENTIFIER_PATTERN = re.compile(r'^[A-Za-z_][A-Za-z0-9_]*$')


# SchÃ©ma de rÃ©fÃ©rence basÃ© sur l'analyse du code et init_db.py
# Format: {table_name: {column_name: (type, default_value)}}
REFERENCE_SCHEMA = {
    "config": {
        "id": ("INTEGER", None),
        "exercice": ("TEXT", "''"),
        "date": ("TEXT", "''"),
        "but_asso": ("TEXT", "''"),
        "cloture": ("INTEGER", "0"),
        "solde_report": ("REAL", "0.0"),
        "disponible_banque": ("REAL", "0.0"),
    },
    "comptes": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "solde": ("REAL", "0.0"),
    },
    "membres": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "prenom": ("TEXT", "''"),
        "email": ("TEXT", "''"),
        "classe": ("TEXT", "''"),
        "cotisation": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "telephone": ("TEXT", "''"),
        "statut": ("TEXT", "''"),
        "date_adhesion": ("TEXT", "''"),
    },
    "events": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "date": ("TEXT", "''"),
        "lieu": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "description": ("TEXT", "''"),
    },
    "event_modules": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "nom_module": ("TEXT", "''"),
        "id_col_total": ("INTEGER", None),
    },
    "event_module_fields": {
        "id": ("INTEGER", None),
        "module_id": ("INTEGER", "0"),
        "nom_champ": ("TEXT", "''"),
        "type_champ": ("TEXT", "''"),
        "prix_unitaire": ("REAL", None),
        "modele_colonne": ("TEXT", None),
    },
    "event_module_data": {
        "module_id": ("INTEGER", "0"),
        "row_index": ("INTEGER", "0"),
        "field_id": ("INTEGER", "0"),
        "valeur": ("TEXT", "''"),
    },
    "event_payments": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "type": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "event_caisses": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "nom_caisse": ("TEXT", "''"),
        "montant_initial": ("REAL", "0.0"),
        "montant_final": ("REAL", "0.0"),
    },
    "event_caisse_details": {
        "id": ("INTEGER", None),
        "caisse_id": ("INTEGER", "0"),
        "type": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "description": ("TEXT", "''"),
    },
    "event_recettes": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "categorie": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "event_depenses": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "categorie": ("TEXT", "''"),
        "fournisseur": ("TEXT", "''"),
        "date_depense": ("TEXT", "''"),
        "paye_par": ("TEXT", "''"),
        "membre_id": ("INTEGER", None),
        "statut_remboursement": ("TEXT", "''"),
        "statut_reglement": ("TEXT", "''"),
        "moyen_paiement": ("TEXT", "''"),
        "numero_cheque": ("TEXT", "''"),
        "numero_facture": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "module_id": ("INTEGER", None),
    },
    "dons_subventions": {
        "id": ("INTEGER", None),
        "donateur": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "depenses_regulieres": {
        "id": ("INTEGER", None),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "categorie": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "fournisseur": ("TEXT", "''"),
        "date_depense": ("TEXT", "''"),
        "paye_par": ("TEXT", "''"),
        "membre_id": ("INTEGER", None),
        "statut_remboursement": ("TEXT", "''"),
        "statut_reglement": ("TEXT", "''"),
        "moyen_paiement": ("TEXT", "''"),
        "numero_cheque": ("TEXT", "''"),
        "numero_facture": ("TEXT", "''"),
        "module_id": ("INTEGER", None),
    },
    "depenses_diverses": {
        "id": ("INTEGER", None),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "categorie": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "fournisseur": ("TEXT", "''"),
        "date_depense": ("TEXT", "''"),
        "paye_par": ("TEXT", "''"),
        "membre_id": ("INTEGER", None),
        "statut_remboursement": ("TEXT", "''"),
        "statut_reglement": ("TEXT", "''"),
        "moyen_paiement": ("TEXT", "''"),
        "numero_cheque": ("TEXT", "''"),
        "numero_facture": ("TEXT", "''"),
        "module_id": ("INTEGER", None),
    },
    "categories": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "parent_id": ("INTEGER", None),
    },
    "stock": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "categorie_id": ("INTEGER", None),
        "quantite": ("INTEGER", "0"),
        "seuil_alerte": ("INTEGER", "0"),
        "date_peremption": ("TEXT", "''"),
        "lot": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "inventaires": {
        "id": ("INTEGER", None),
        "date": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "inventaire_lignes": {
        "id": ("INTEGER", None),
        "inventaire_id": ("INTEGER", "0"),
        "stock_id": ("INTEGER", "0"),
        "quantite": ("INTEGER", "0"),
        "ecart": ("INTEGER", "0"),
    },
    "mouvements_stock": {
        "id": ("INTEGER", None),
        "stock_id": ("INTEGER", "0"),
        "date": ("TEXT", "''"),
        "type": ("TEXT", "''"),
        "quantite": ("INTEGER", "0"),
        "commentaire": ("TEXT", "''"),
    },
    "fournisseurs": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
    },
    "colonnes_modeles": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "type_modele": ("TEXT", "''"),
    },
    "valeurs_modeles_colonnes": {
        "id": ("INTEGER", None),
        "modele_id": ("INTEGER", "0"),
        "valeur": ("TEXT", "''"),
    },
    "depots_retraits_banque": {
        "id": ("INTEGER", None),
        "date": ("TEXT", "''"),
        "type": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "reference": ("TEXT", "''"),
        "banque": ("TEXT", "''"),
        "pointe": ("INTEGER", "0"),
        "commentaire": ("TEXT", "''"),
    },
    "historique_clotures": {
        "id": ("INTEGER", None),
        "date_cloture": ("TEXT", "''"),
    },
    "retrocessions_ecoles": {
        "id": ("INTEGER", None),
        "date": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "ecole": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "buvette_articles": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "categorie": ("TEXT", "''"),
        "unite": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "contenance": ("REAL", None),
        "stock": ("INTEGER", "0"),
        "purchase_price": ("REAL", None),
    },
    "buvette_achats": {
        "id": ("INTEGER", None),
        "article_id": ("INTEGER", "0"),
        "date_achat": ("TEXT", "''"),
        "quantite": ("REAL", "0.0"),
        "prix_unitaire": ("REAL", "0.0"),
        "fournisseur": ("TEXT", "''"),
        "facture": ("TEXT", "''"),
        "exercice": ("TEXT", "''"),
    },
    "buvette_inventaires": {
        "id": ("INTEGER", None),
        "date_inventaire": ("TEXT", "''"),
        "event_id": ("INTEGER", None),
        "type_inventaire": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "buvette_inventaire_lignes": {
        "id": ("INTEGER", None),
        "inventaire_id": ("INTEGER", "0"),
        "article_id": ("INTEGER", "0"),
        "quantite": ("REAL", "0.0"),
        "commentaire": ("TEXT", "''"),
    },
    "buvette_mouvements": {
        "id": ("INTEGER", None),
        "date_mouvement": ("TEXT", "''"),
        "article_id": ("INTEGER", "0"),
        "type_mouvement": ("TEXT", "''"),
        "quantite": ("REAL", "0.0"),
        "motif": ("TEXT", "''"),
        "event_id": ("INTEGER", None),
    },
    "buvette_recettes": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
    },
}


class DatabaseMigrator:
    """Gestionnaire de migration de base de donnÃ©es."""
    
    # SQL reserved words that need quoting (subset of most common ones)
    SQL_RESERVED_WORDS = {
        'add', 'all', 'alter', 'and', 'as', 'asc', 'between', 'by', 'case', 'check',
        'column', 'constraint', 'create', 'cross', 'default', 'delete', 'desc',
        'distinct', 'drop', 'else', 'end', 'exists', 'foreign', 'from', 'full',
        'group', 'having', 'in', 'index', 'inner', 'insert', 'into', 'is', 'join',
        'key', 'left', 'like', 'limit', 'not', 'null', 'on', 'or', 'order', 'outer',
        'primary', 'references', 'right', 'select', 'set', 'table', 'then', 'to',
        'union', 'unique', 'update', 'values', 'when', 'where'
    }
    
    def __init__(self, db_path: str, use_yaml_hints: bool = True, fuzzy_threshold: float = 0.75):
        self.db_path = db_path
        self.backup_path = None
        self.migration_log = []
        self.errors = []
        self.report_path = None
        self.use_yaml_hints = use_yaml_hints
        self.schema_hints = None
        self.column_mappings = {}  # Track old_name -> new_name mappings
        self.fuzzy_threshold = fuzzy_threshold  # Configurable fuzzy matching threshold
        self.skipped_invalid_names = []  # Track invalid column names skipped
    
    def log(self, message: str, level: str = "INFO"):
        """Ajoute un message au log de migration."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {level}: {message}"
        self.migration_log.append(log_entry)
        # Ensure we print without non-ASCII characters that might cause issues
        try:
            print(log_entry)
        except UnicodeEncodeError:
            # Fallback to ASCII-safe printing
            print(log_entry.encode('ascii', errors='replace').decode('ascii'))
    
    def is_valid_sql_identifier(self, identifier: str) -> bool:
        """Validate if an identifier is a valid SQL identifier."""
        if not identifier:
            return False
        return SQL_IDENTIFIER_PATTERN.match(identifier) is not None
    
    def load_schema_hints(self, yaml_path: Optional[str] = None) -> bool:
        """Charge le fichier schema_hints.yaml ou le gÃ©nÃ¨re s'il n'existe pas."""
        if yaml_path is None:
            repo_root = Path(__file__).parent.parent
            yaml_path = repo_root / "db" / "schema_hints.yaml"
        else:
            yaml_path = Path(yaml_path)
        
        if not yaml_path.exists():
            self.log(f"Schema hints file not found at {yaml_path}", "WARNING")
            self.log("Attempting to generate schema hints by running analyze_modules_columns.py...")
            
            try:
                # Run the analyze script to generate the YAML
                script_path = Path(__file__).parent / "analyze_modules_columns.py"
                result = subprocess.run(
                    [sys.executable, str(script_path)],
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                
                if result.returncode != 0:
                    self.log(f"Failed to generate schema hints: {result.stderr}", "ERROR")
                    return False
                
                self.log("Schema hints generated successfully")
            except Exception as e:
                self.log(f"Error generating schema hints: {e}", "ERROR")
                return False
        
        try:
            # Use compat_yaml loader if available
            if load_hints:
                self.schema_hints = load_hints(str(yaml_path))
                if self.schema_hints:
                    self.log(f"Loaded schema hints from {yaml_path} (using compat_yaml)")
                    return True
                else:
                    self.log(f"Failed to load schema hints using compat_yaml", "WARNING")
                    return False
            else:
                # Fallback to direct YAML loading (requires PyYAML)
                try:
                    import yaml
                    with open(yaml_path, 'r', encoding='utf-8') as f:
                        self.schema_hints = yaml.safe_load(f)
                    self.log(f"Loaded schema hints from {yaml_path} (using PyYAML)")
                    return True
                except ImportError:
                    self.log("Neither compat_yaml nor PyYAML available for loading hints", "ERROR")
                    return False
        except Exception as e:
            self.log(f"Error loading schema hints: {e}", "WARNING")
            return False
    
    def fuzzy_match_column(self, target_col: str, existing_cols: Set[str], threshold: Optional[float] = None) -> Optional[str]:
        """
        Trouve une colonne existante qui correspond au nom cible (fuzzy/case-insensitive).
        
        Args:
            target_col: Nom de colonne recherchÃ©
            existing_cols: Ensemble des colonnes existantes dans la table
            threshold: Seuil de similaritÃ© (0.0 Ã  1.0), uses instance default if None
        
        Returns:
            Nom de la colonne correspondante ou None
        """
        if threshold is None:
            threshold = self.fuzzy_threshold
        
        target_lower = target_col.lower()
        
        # 1. Exact match (case-insensitive)
        for col in existing_cols:
            if col.lower() == target_lower:
                return col
        
        # 2. Fuzzy match with SequenceMatcher
        best_match = None
        best_score = 0.0
        
        for col in existing_cols:
            # Calculate similarity ratio
            ratio = SequenceMatcher(None, target_lower, col.lower()).ratio()
            
            if ratio > best_score and ratio >= threshold:
                best_score = ratio
                best_match = col
        
        return best_match
    
    def quote_identifier(self, identifier: str) -> str:
        """
        Quote SQL identifier if it's a reserved word or contains special characters.
        
        Args:
            identifier: Column or table name
            
        Returns:
            Quoted identifier if needed, otherwise original
        """
        # Quote if it's a reserved word
        if identifier.lower() in self.SQL_RESERVED_WORDS:
            return f'"{identifier}"'
        
        # Quote if it contains special characters
        if not identifier.replace('_', '').isalnum():
            return f'"{identifier}"'
        
        return identifier
    
    def get_column_type_from_hints(self, table: str, column: str) -> Optional[str]:
        """RÃ©cupÃ¨re le type d'une colonne depuis les hints YAML."""
        if not self.schema_hints or "tables" not in self.schema_hints:
            return None
        
        if table not in self.schema_hints["tables"]:
            return None
        
        table_info = self.schema_hints["tables"][table]
        if "expected_columns" not in table_info:
            return None
        
        if column not in table_info["expected_columns"]:
            return None
        
        return table_info["expected_columns"][column].get("type", "TEXT")
    
    def create_backup(self) -> bool:
        """CrÃ©e une sauvegarde timestampÃ©e de la base de donnÃ©es."""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.backup_path = f"{self.db_path}.{timestamp}.bak"
            
            self.log(f"Creating backup: {self.backup_path}")
            shutil.copy2(self.db_path, self.backup_path)
            self.log(f"Backup created successfully: {self.backup_path}")
            return True
        except Exception as e:
            self.log(f"Failed to create backup: {e}", "ERROR")
            self.errors.append(f"Backup error: {e}")
            return False
    
    def restore_backup(self) -> bool:
        """Restaure la base de donnÃ©es depuis la sauvegarde."""
        if not self.backup_path or not os.path.exists(self.backup_path):
            self.log("No backup available to restore", "ERROR")
            return False
        
        try:
            self.log(f"Restoring from backup: {self.backup_path}")
            shutil.copy2(self.backup_path, self.db_path)
            self.log("Database restored successfully")
            return True
        except Exception as e:
            self.log(f"Failed to restore backup: {e}", "ERROR")
            self.errors.append(f"Restore error: {e}")
            return False
    
    def get_existing_schema(self, conn: sqlite3.Connection) -> Dict[str, Set[str]]:
        """RÃ©cupÃ¨re le schÃ©ma actuel de la base de donnÃ©es."""
        schema = {}
        
        cursor = conn.cursor()
        
        # Obtenir toutes les tables
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = [row[0] for row in cursor.fetchall()]
        
        for table in tables:
            # Obtenir les colonnes de chaque table
            cursor.execute(f"PRAGMA table_info({table})")
            columns = set(row[1] for row in cursor.fetchall())
            schema[table] = columns
        
        return schema
    
    def check_rename_column_support(self, conn: sqlite3.Connection) -> bool:
        """VÃ©rifie si SQLite supporte ALTER TABLE RENAME COLUMN (version 3.25.0+)."""
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT sqlite_version()")
            version = cursor.fetchone()[0]
            
            # Parse version (e.g., "3.35.5")
            major, minor, patch = map(int, version.split('.'))
            
            # RENAME COLUMN supported since 3.25.0
            supports_rename = (major > 3) or (major == 3 and minor >= 25)
            
            self.log(f"SQLite version: {version}, RENAME COLUMN support: {supports_rename}")
            return supports_rename
        except Exception as e:
            self.log(f"Could not determine SQLite version: {e}", "WARNING")
            return False
    
    def detect_missing_columns(self, existing_schema: Dict[str, Set[str]]) -> Dict[str, List[Tuple[str, str, str, Optional[str]]]]:
        """
        DÃ©tecte les colonnes manquantes par rapport au schÃ©ma de rÃ©fÃ©rence.
        
        Returns:
            Dict mapping table -> List of (col_name, col_type, default_value, fuzzy_match)
            where fuzzy_match is the name of an existing column that closely matches, or None
        """
        missing = {}
        
        # Combine REFERENCE_SCHEMA and YAML hints
        expected_schema = {}
        
        # Start with REFERENCE_SCHEMA
        for table, columns in REFERENCE_SCHEMA.items():
            expected_schema[table] = {}
            for col_name, (col_type, default_value) in columns.items():
                expected_schema[table][col_name] = (col_type, default_value)
        
        # Add columns from YAML hints if available
        if self.schema_hints and "tables" in self.schema_hints:
            for table, table_info in self.schema_hints["tables"].items():
                if "expected_columns" not in table_info:
                    continue
                
                if table not in expected_schema:
                    expected_schema[table] = {}
                
                for col_name, col_info in table_info["expected_columns"].items():
                    if col_name not in expected_schema[table]:
                        col_type = col_info.get("type", "TEXT")
                        # Infer default based on type
                        if col_type == "INTEGER":
                            default_value = "0"
                        elif col_type == "REAL":
                            default_value = "0.0"
                        else:
                            default_value = "''"
                        
                        expected_schema[table][col_name] = (col_type, default_value)
        
        # Now check for missing columns
        for table, expected_columns in expected_schema.items():
            if table not in existing_schema:
                self.log(f"Table '{table}' does not exist (will not be created automatically)", "WARNING")
                continue
            
            existing_cols = existing_schema[table]
            table_missing = []
            
            for col_name, (col_type, default_value) in expected_columns.items():
                # Validate column name before processing
                if not self.is_valid_sql_identifier(col_name):
                    self.log(f"SKIPPING invalid column name '{col_name}' in table '{table}' (does not match SQL identifier pattern)", "WARNING")
                    self.skipped_invalid_names.append(f"{table}.{col_name}")
                    continue
                
                if col_name not in existing_cols:
                    # Try fuzzy matching to find a similar column
                    fuzzy_match = self.fuzzy_match_column(col_name, existing_cols, threshold=0.75)
                    
                    if fuzzy_match:
                        self.log(f"Column '{col_name}' not found in '{table}', but found similar column '{fuzzy_match}'", "INFO")
                    
                    table_missing.append((col_name, col_type, default_value, fuzzy_match))
            
            if table_missing:
                missing[table] = table_missing
        
        return missing
    
    def apply_migrations(self, conn: sqlite3.Connection, missing_columns: Dict[str, List[Tuple[str, str, str, Optional[str]]]]) -> bool:
        """Applique les migrations pour ajouter les colonnes manquantes."""
        if not missing_columns:
            self.log("No missing columns detected. Database is up to date.")
            return True
        
        self.log(f"Found missing columns in {len(missing_columns)} table(s)")
        
        # Check if RENAME COLUMN is supported
        supports_rename = self.check_rename_column_support(conn)
        
        try:
            cursor = conn.cursor()
            
            # SQLite ne supporte pas toujours les transactions pour ALTER TABLE,
            # mais on utilise BEGIN pour grouper les opÃ©rations
            cursor.execute("BEGIN TRANSACTION")
            
            for table, columns in missing_columns.items():
                self.log(f"Processing table '{table}': {len(columns)} column(s) to add")
                
                for col_name, col_type, default_value, fuzzy_match in columns:
                    # Case 1: Fuzzy match found - try to rename or copy
                    if fuzzy_match:
                        self.log(f"  Column '{col_name}' has fuzzy match '{fuzzy_match}'")
                        
                        if supports_rename and fuzzy_match.lower() != col_name.lower():
                            # Try to rename the column
                            rename_sql = f"ALTER TABLE {table} RENAME COLUMN {fuzzy_match} TO {col_name}"
                            
                            try:
                                self.log(f"  Attempting to rename '{fuzzy_match}' to '{col_name}'...")
                                cursor.execute(rename_sql)
                                self.log(f"  [OK] Successfully renamed column '{fuzzy_match}' to '{col_name}'")
                                self.column_mappings[f"{table}.{fuzzy_match}"] = f"{table}.{col_name}"
                                continue
                            except sqlite3.OperationalError as e:
                                self.log(f"  [WARNING] RENAME failed: {e}. Will try ADD + COPY instead.", "WARNING")
                        
                        # If rename not supported or failed, do ADD + COPY
                        quoted_col = self.quote_identifier(col_name)
                        
                        if default_value is None:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type}"
                        else:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type} DEFAULT {default_value}"
                        
                        try:
                            self.log(f"  Adding new column '{col_name}' ({col_type})")
                            cursor.execute(alter_sql)
                            
                            # Copy data from fuzzy_match column to new column
                            # Quote identifiers in case they're reserved words
                            quoted_new = self.quote_identifier(col_name)
                            quoted_old = self.quote_identifier(fuzzy_match)
                            copy_sql = f"UPDATE {table} SET {quoted_new} = {quoted_old}"
                            self.log(f"  Copying data from '{fuzzy_match}' to '{col_name}'...")
                            cursor.execute(copy_sql)
                            
                            self.log(f"  [OK] Added column '{col_name}' and copied data from '{fuzzy_match}'")
                            self.column_mappings[f"{table}.{fuzzy_match}"] = f"{table}.{col_name} (copied)"
                            
                        except sqlite3.OperationalError as e:
                            error_msg = str(e).lower()
                            if "duplicate" in error_msg and "column" in error_msg:
                                self.log(f"  [WARNING] Column '{col_name}' already exists", "WARNING")
                            else:
                                raise
                    
                    # Case 2: No fuzzy match - just add the column
                    else:
                        # Quote column name if it's a reserved word
                        quoted_col = self.quote_identifier(col_name)
                        
                        if default_value is None:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type}"
                        else:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type} DEFAULT {default_value}"
                        
                        try:
                            self.log(f"  Adding column: {col_name} ({col_type})")
                            cursor.execute(alter_sql)
                            self.log(f"  [OK] Successfully added column '{col_name}' to table '{table}'")
                        except sqlite3.OperationalError as e:
                            error_msg = str(e).lower()
                            if "duplicate" in error_msg and "column" in error_msg:
                                self.log(f"  [WARNING] Column '{col_name}' already exists in table '{table}'", "WARNING")
                            else:
                                raise
            
            # Commit toutes les modifications
            conn.commit()
            self.log("All migrations applied successfully")
            return True
            
        except Exception as e:
            self.log(f"Migration failed: {e}", "ERROR")
            self.errors.append(f"Migration error: {e}")
            
            try:
                conn.rollback()
                self.log("Transaction rolled back")
            except Exception as rb_error:
                self.log(f"Rollback failed: {rb_error}", "ERROR")
            
            return False
    
    def optimize_database(self, conn: sqlite3.Connection):
        """Optimise la base de donnÃ©es (WAL mode, pragmas)."""
        try:
            cursor = conn.cursor()
            
            # Activer le mode WAL (Write-Ahead Logging)
            self.log("Enabling WAL mode...")
            try:
                cursor.execute("PRAGMA journal_mode=WAL")
                result = cursor.fetchone()
                self.log(f"Journal mode set to: {result[0]}")
            except Exception as e:
                self.log(f"Could not enable WAL mode: {e}", "WARNING")
            
            # DÃ©finir synchronous Ã  NORMAL pour de meilleures performances
            self.log("Setting synchronous mode to NORMAL...")
            try:
                cursor.execute("PRAGMA synchronous=NORMAL")
                self.log("Synchronous mode set to NORMAL")
            except Exception as e:
                self.log(f"Could not set synchronous mode: {e}", "WARNING")
            
            # Analyser la base de donnÃ©es pour optimiser les requÃªtes
            self.log("Running ANALYZE...")
            try:
                cursor.execute("ANALYZE")
                self.log("Database analysis complete")
            except Exception as e:
                self.log(f"Could not analyze database: {e}", "WARNING")
            
        except Exception as e:
            self.log(f"Database optimization warning: {e}", "WARNING")
    
    def generate_report(self, output_file: str, missing_columns: Dict[str, List[Tuple[str, str, str, Optional[str]]]], success: bool):
        """GÃ©nÃ¨re un rapport dÃ©taillÃ© de la migration."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # CrÃ©er le rÃ©pertoire reports s'il n'existe pas
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Database Migration Report\n\n")
            f.write(f"**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"**Database:** {self.db_path}\n")
            f.write(f"**Status:** {'SUCCESS' if success else 'FAILED'}\n")
            
            if self.backup_path:
                f.write(f"**Backup:** {self.backup_path}\n")
            
            # Environment information
            f.write("\n## Environment\n\n")
            f.write(f"- Python version: {sys.version.split()[0]}\n")
            f.write(f"- Platform: {sys.platform}\n")
            f.write(f"- Script: {__file__}\n")
            try:
                import sqlite3
                f.write(f"- SQLite version: {sqlite3.sqlite_version}\n")
            except:
                pass
            
            f.write("\n## Summary\n\n")
            
            if not missing_columns:
                f.write("No missing columns detected. Database schema is up to date.\n")
            else:
                total_columns = sum(len(cols) for cols in missing_columns.values())
                f.write(f"- Tables requiring updates: {len(missing_columns)}\n")
                f.write(f"- Total columns to add: {total_columns}\n")
                
                if success:
                    f.write("\n[OK] All columns were successfully added.\n")
                else:
                    f.write("\n[FAILED] Migration failed. Changes have been rolled back.\n")
                
                f.write("\n## Changes Applied\n\n")
                for table, columns in missing_columns.items():
                    f.write(f"### Table: `{table}`\n\n")
                    for col_name, col_type, default_value, fuzzy_match in columns:
                        default_str = f" DEFAULT {default_value}" if default_value else ""
                        status_icon = "[OK]" if success else "[FAILED]"
                        
                        if fuzzy_match:
                            mapping_key = f"{table}.{fuzzy_match}"
                            if mapping_key in self.column_mappings:
                                mapping_action = self.column_mappings[mapping_key]
                                f.write(f"- {status_icon} Column: `{col_name}` ({col_type}{default_str}) - Mapped from `{fuzzy_match}` ({mapping_action})\n")
                            else:
                                f.write(f"- {status_icon} Column: `{col_name}` ({col_type}{default_str}) - Fuzzy match: `{fuzzy_match}`\n")
                        else:
                            f.write(f"- {status_icon} Column: `{col_name}` ({col_type}{default_str})\n")
                    f.write("\n")
                
                # Add column mapping summary if any mappings were made
                if self.column_mappings:
                    f.write("\n## Column Mappings\n\n")
                    f.write("The following columns were renamed or had their data copied:\n\n")
                    for old_ref, new_ref in self.column_mappings.items():
                        f.write(f"- `{old_ref}` â†’ `{new_ref}`\n")
                    f.write("\n")
            
            # Add skipped invalid names section
            if self.skipped_invalid_names:
                f.write("\n## Skipped Invalid Identifiers\n\n")
                f.write("The following column names were skipped because they do not match\n")
                f.write("the valid SQL identifier pattern (^[A-Za-z_][A-Za-z0-9_]*$):\n\n")
                for skipped in self.skipped_invalid_names:
                    f.write(f"- `{skipped}`\n")
                f.write("\n")
            
            if self.errors:
                f.write("\n## Errors\n\n")
                for error in self.errors:
                    f.write(f"- [ERROR] {error}\n")
                
                f.write("\n### Recovery Actions\n\n")
                if self.backup_path and os.path.exists(self.backup_path):
                    f.write(f"[OK] Database was restored from backup: {self.backup_path}\n")
                else:
                    f.write("[WARNING] No backup was available for restore.\n")
            
            f.write("\n## Migration Log\n\n")
            f.write("```\n")
            for log_entry in self.migration_log:
                f.write(f"{log_entry}\n")
            f.write("```\n")
            
            if not success:
                f.write("\n## Recommended Actions\n\n")
                f.write("1. Review the errors listed above\n")
                f.write("2. Check database file permissions\n")
                f.write("3. Ensure no other processes are accessing the database\n")
                f.write("4. If the issue persists, please report it with this file\n")
        
        self.log(f"Report generated: {output_file}")
    
    def run_migration(self) -> bool:
        """ExÃ©cute le processus complet de migration."""
        self.log("=" * 60)
        self.log("Database Structure Update - Smart Migration with Fuzzy Matching")
        self.log("=" * 60)
        self.log(f"Database: {self.db_path}")
        
        if not os.path.exists(self.db_path):
            self.log(f"Database file not found: {self.db_path}", "ERROR")
            return False
        
        # Ã‰tape 0: Charger les schema hints si activÃ©
        if self.use_yaml_hints:
            self.load_schema_hints()
        
        # Ã‰tape 1: CrÃ©er une sauvegarde
        if not self.create_backup():
            self.log("Migration aborted: could not create backup", "ERROR")
            return False
        
        success = False
        missing_columns = {}
        
        try:
            # Ã‰tape 2: Analyser le schÃ©ma existant
            self.log("Analyzing current database schema...")
            conn = sqlite3.connect(self.db_path, timeout=30)
            conn.row_factory = sqlite3.Row
            
            existing_schema = self.get_existing_schema(conn)
            self.log(f"Found {len(existing_schema)} tables in database")
            
            # Ã‰tape 3: DÃ©tecter les colonnes manquantes
            self.log("Detecting missing columns...")
            missing_columns = self.detect_missing_columns(existing_schema)
            
            if not missing_columns:
                self.log("[SUCCESS] Database schema is up to date!")
                success = True
            else:
                # Ã‰tape 4: Appliquer les migrations
                self.log("Applying migrations...")
                success = self.apply_migrations(conn, missing_columns)
                
                if success:
                    self.log("[SUCCESS] Migrations completed successfully!")
                    
                    # Ã‰tape 5: Optimiser la base de donnÃ©es
                    self.log("Optimizing database...")
                    self.optimize_database(conn)
                else:
                    self.log("[FAILED] Migration failed, restoring backup...", "ERROR")
                    conn.close()
                    self.restore_backup()
            
            conn.close()
            
        except Exception as e:
            error_trace = traceback.format_exc()
            self.log(f"Unexpected error during migration: {e}", "ERROR")
            self.errors.append(f"Unexpected error: {e}\n{error_trace}")
            
            # Restaurer la sauvegarde en cas d'erreur
            self.log("Restoring backup due to error...", "ERROR")
            self.restore_backup()
            success = False
        
        # GÃ©nÃ©rer le rapport dans le rÃ©pertoire reports/
        report_dir = Path(__file__).parent.parent / "reports"
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        status_suffix = "success" if success else "failed"
        report_file = report_dir / f"migration_report_{status_suffix}_{timestamp}.md"
        self.report_path = str(report_file)
        self.generate_report(self.report_path, missing_columns, success)
        
        self.log("=" * 60)
        if success:
            self.log("Migration completed successfully!")
        else:
            self.log("Migration failed. Check the report for details.", "ERROR")
        self.log("=" * 60)
        
        return success


def get_latest_migration_report(reports_dir: Optional[str] = None) -> Optional[str]:
    """
    RÃ©cupÃ¨re le chemin du dernier rapport de migration gÃ©nÃ©rÃ©.
    
    Args:
        reports_dir: RÃ©pertoire des rapports (dÃ©faut: reports/ Ã  la racine du projet)
        
    Returns:
        Chemin du dernier rapport ou None si aucun rapport trouvÃ©
    """
    if reports_dir is None:
        reports_dir = Path(__file__).parent.parent / "reports"
    else:
        reports_dir = Path(reports_dir)
    
    if not reports_dir.exists():
        return None
    
    # Trouver tous les rapports de migration
    reports = list(reports_dir.glob("migration_report_*.md"))
    
    if not reports:
        return None
    
    # Retourner le plus rÃ©cent
    latest_report = max(reports, key=lambda p: p.stat().st_mtime)
    return str(latest_report)


def main():
    """Point d'entrÃ©e principal."""
    parser = argparse.ArgumentParser(description="Smart database structure migration tool with fuzzy column matching")
    parser.add_argument(
        "--db-path",
        default="association.db",
        help="Path to the database file (default: association.db)"
    )
    parser.add_argument(
        "--no-yaml-hints",
        action="store_true",
        help="Disable loading schema hints from YAML (use only REFERENCE_SCHEMA)"
    )
    
    args = parser.parse_args()
    
    migrator = DatabaseMigrator(args.db_path, use_yaml_hints=not args.no_yaml_hints)
    success = migrator.run_migration()
    
    # Afficher le chemin du rapport pour que l'appelant puisse le rÃ©cupÃ©rer
    if migrator.report_path:
        print(f"\nREPORT_PATH:{migrator.report_path}")
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./scripts/update_db_structure_old.py ===

```python
#!/usr/bin/env python3
"""
Script de mise Ã  jour sÃ»re de la structure de base de donnÃ©es.

Ce script compare le schÃ©ma attendu (extrait du code ou du rapport d'analyse)
avec le schÃ©ma rÃ©el de la base de donnÃ©es et effectue des migrations sÃ»res
pour ajouter les colonnes manquantes.

FonctionnalitÃ©s:
- DÃ©tection automatique des colonnes manquantes
- Sauvegarde timestampÃ©e avant toute modification
- Transactions avec rollback en cas d'erreur
- Restauration automatique de la sauvegarde si Ã©chec
- Activation WAL mode et optimisation des pragmas
- Rapport dÃ©taillÃ© de migration

Usage:
    python scripts/update_db_structure.py [--db-path path/to/database.db]
"""

import sqlite3
import os
import sys
import shutil
import argparse
import traceback
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple, Set, Optional
import yaml
from difflib import SequenceMatcher

# Force UTF-8 encoding for stdout/stderr on Windows to avoid encoding errors
try:
    sys.stdout.reconfigure(encoding='utf-8')
    sys.stderr.reconfigure(encoding='utf-8')
except Exception:
    pass


# SchÃ©ma de rÃ©fÃ©rence basÃ© sur l'analyse du code et init_db.py
# Format: {table_name: {column_name: (type, default_value)}}
REFERENCE_SCHEMA = {
    "config": {
        "id": ("INTEGER", None),
        "exercice": ("TEXT", "''"),
        "date": ("TEXT", "''"),
        "but_asso": ("TEXT", "''"),
        "cloture": ("INTEGER", "0"),
        "solde_report": ("REAL", "0.0"),
        "disponible_banque": ("REAL", "0.0"),
    },
    "comptes": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "solde": ("REAL", "0.0"),
    },
    "membres": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "prenom": ("TEXT", "''"),
        "email": ("TEXT", "''"),
        "classe": ("TEXT", "''"),
        "cotisation": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "telephone": ("TEXT", "''"),
        "statut": ("TEXT", "''"),
        "date_adhesion": ("TEXT", "''"),
    },
    "events": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "date": ("TEXT", "''"),
        "lieu": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "description": ("TEXT", "''"),
    },
    "event_modules": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "nom_module": ("TEXT", "''"),
        "id_col_total": ("INTEGER", None),
    },
    "event_module_fields": {
        "id": ("INTEGER", None),
        "module_id": ("INTEGER", "0"),
        "nom_champ": ("TEXT", "''"),
        "type_champ": ("TEXT", "''"),
        "prix_unitaire": ("REAL", None),
        "modele_colonne": ("TEXT", None),
    },
    "event_module_data": {
        "module_id": ("INTEGER", "0"),
        "row_index": ("INTEGER", "0"),
        "field_id": ("INTEGER", "0"),
        "valeur": ("TEXT", "''"),
    },
    "event_payments": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "type": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "event_caisses": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "nom_caisse": ("TEXT", "''"),
        "montant_initial": ("REAL", "0.0"),
        "montant_final": ("REAL", "0.0"),
    },
    "event_caisse_details": {
        "id": ("INTEGER", None),
        "caisse_id": ("INTEGER", "0"),
        "type": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "description": ("TEXT", "''"),
    },
    "event_recettes": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "categorie": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "event_depenses": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "categorie": ("TEXT", "''"),
        "fournisseur": ("TEXT", "''"),
        "date_depense": ("TEXT", "''"),
        "paye_par": ("TEXT", "''"),
        "membre_id": ("INTEGER", None),
        "statut_remboursement": ("TEXT", "''"),
        "statut_reglement": ("TEXT", "''"),
        "moyen_paiement": ("TEXT", "''"),
        "numero_cheque": ("TEXT", "''"),
        "numero_facture": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "module_id": ("INTEGER", None),
    },
    "dons_subventions": {
        "id": ("INTEGER", None),
        "donateur": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "depenses_regulieres": {
        "id": ("INTEGER", None),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "categorie": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "fournisseur": ("TEXT", "''"),
        "date_depense": ("TEXT", "''"),
        "paye_par": ("TEXT", "''"),
        "membre_id": ("INTEGER", None),
        "statut_remboursement": ("TEXT", "''"),
        "statut_reglement": ("TEXT", "''"),
        "moyen_paiement": ("TEXT", "''"),
        "numero_cheque": ("TEXT", "''"),
        "numero_facture": ("TEXT", "''"),
        "module_id": ("INTEGER", None),
    },
    "depenses_diverses": {
        "id": ("INTEGER", None),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "categorie": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "fournisseur": ("TEXT", "''"),
        "date_depense": ("TEXT", "''"),
        "paye_par": ("TEXT", "''"),
        "membre_id": ("INTEGER", None),
        "statut_remboursement": ("TEXT", "''"),
        "statut_reglement": ("TEXT", "''"),
        "moyen_paiement": ("TEXT", "''"),
        "numero_cheque": ("TEXT", "''"),
        "numero_facture": ("TEXT", "''"),
        "module_id": ("INTEGER", None),
    },
    "categories": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "parent_id": ("INTEGER", None),
    },
    "stock": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "categorie_id": ("INTEGER", None),
        "quantite": ("INTEGER", "0"),
        "seuil_alerte": ("INTEGER", "0"),
        "date_peremption": ("TEXT", "''"),
        "lot": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "inventaires": {
        "id": ("INTEGER", None),
        "date": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "inventaire_lignes": {
        "id": ("INTEGER", None),
        "inventaire_id": ("INTEGER", "0"),
        "stock_id": ("INTEGER", "0"),
        "quantite": ("INTEGER", "0"),
        "ecart": ("INTEGER", "0"),
    },
    "mouvements_stock": {
        "id": ("INTEGER", None),
        "stock_id": ("INTEGER", "0"),
        "date": ("TEXT", "''"),
        "type": ("TEXT", "''"),
        "quantite": ("INTEGER", "0"),
        "commentaire": ("TEXT", "''"),
    },
    "fournisseurs": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
    },
    "colonnes_modeles": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "type_modele": ("TEXT", "''"),
    },
    "valeurs_modeles_colonnes": {
        "id": ("INTEGER", None),
        "modele_id": ("INTEGER", "0"),
        "valeur": ("TEXT", "''"),
    },
    "depots_retraits_banque": {
        "id": ("INTEGER", None),
        "date": ("TEXT", "''"),
        "type": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "reference": ("TEXT", "''"),
        "banque": ("TEXT", "''"),
        "pointe": ("INTEGER", "0"),
        "commentaire": ("TEXT", "''"),
    },
    "historique_clotures": {
        "id": ("INTEGER", None),
        "date_cloture": ("TEXT", "''"),
    },
    "retrocessions_ecoles": {
        "id": ("INTEGER", None),
        "date": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "ecole": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "buvette_articles": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "categorie": ("TEXT", "''"),
        "unite": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "contenance": ("REAL", None),
        "stock": ("INTEGER", "0"),
        "purchase_price": ("REAL", None),
    },
    "buvette_achats": {
        "id": ("INTEGER", None),
        "article_id": ("INTEGER", "0"),
        "date_achat": ("TEXT", "''"),
        "quantite": ("REAL", "0.0"),
        "prix_unitaire": ("REAL", "0.0"),
        "fournisseur": ("TEXT", "''"),
        "facture": ("TEXT", "''"),
        "exercice": ("TEXT", "''"),
    },
    "buvette_inventaires": {
        "id": ("INTEGER", None),
        "date_inventaire": ("TEXT", "''"),
        "event_id": ("INTEGER", None),
        "type_inventaire": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "buvette_inventaire_lignes": {
        "id": ("INTEGER", None),
        "inventaire_id": ("INTEGER", "0"),
        "article_id": ("INTEGER", "0"),
        "quantite": ("REAL", "0.0"),
        "commentaire": ("TEXT", "''"),
    },
    "buvette_mouvements": {
        "id": ("INTEGER", None),
        "date_mouvement": ("TEXT", "''"),
        "article_id": ("INTEGER", "0"),
        "type_mouvement": ("TEXT", "''"),
        "quantite": ("REAL", "0.0"),
        "motif": ("TEXT", "''"),
        "event_id": ("INTEGER", None),
    },
    "buvette_recettes": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
    },
}


class DatabaseMigrator:
    """Gestionnaire de migration de base de donnÃ©es."""
    
    # SQL reserved words that need quoting (subset of most common ones)
    SQL_RESERVED_WORDS = {
        'add', 'all', 'alter', 'and', 'as', 'asc', 'between', 'by', 'case', 'check',
        'column', 'constraint', 'create', 'cross', 'default', 'delete', 'desc',
        'distinct', 'drop', 'else', 'end', 'exists', 'foreign', 'from', 'full',
        'group', 'having', 'in', 'index', 'inner', 'insert', 'into', 'is', 'join',
        'key', 'left', 'like', 'limit', 'not', 'null', 'on', 'or', 'order', 'outer',
        'primary', 'references', 'right', 'select', 'set', 'table', 'then', 'to',
        'union', 'unique', 'update', 'values', 'when', 'where'
    }
    
    def __init__(self, db_path: str, use_yaml_hints: bool = True, fuzzy_threshold: float = 0.75):
        self.db_path = db_path
        self.backup_path = None
        self.migration_log = []
        self.errors = []
        self.report_path = None
        self.use_yaml_hints = use_yaml_hints
        self.schema_hints = None
        self.column_mappings = {}  # Track old_name -> new_name mappings
        self.fuzzy_threshold = fuzzy_threshold  # Configurable fuzzy matching threshold
    
    def log(self, message: str, level: str = "INFO"):
        """Ajoute un message au log de migration."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {level}: {message}"
        self.migration_log.append(log_entry)
        print(log_entry)
    
    def load_schema_hints(self, yaml_path: Optional[str] = None) -> bool:
        """Charge le fichier schema_hints.yaml ou le gÃ©nÃ¨re s'il n'existe pas."""
        if yaml_path is None:
            repo_root = Path(__file__).parent.parent
            yaml_path = repo_root / "db" / "schema_hints.yaml"
        else:
            yaml_path = Path(yaml_path)
        
        if not yaml_path.exists():
            self.log(f"Schema hints file not found at {yaml_path}", "WARNING")
            self.log("Attempting to generate schema hints by running analyze_modules_columns.py...")
            
            try:
                # Run the analyze script to generate the YAML
                script_path = Path(__file__).parent / "analyze_modules_columns.py"
                result = subprocess.run(
                    [sys.executable, str(script_path)],
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                
                if result.returncode != 0:
                    self.log(f"Failed to generate schema hints: {result.stderr}", "ERROR")
                    return False
                
                self.log("Schema hints generated successfully")
            except Exception as e:
                self.log(f"Error generating schema hints: {e}", "ERROR")
                return False
        
        try:
            with open(yaml_path, 'r', encoding='utf-8') as f:
                self.schema_hints = yaml.safe_load(f)
            
            self.log(f"Loaded schema hints from {yaml_path}")
            return True
        except Exception as e:
            self.log(f"Error loading schema hints: {e}", "WARNING")
            return False
    
    def fuzzy_match_column(self, target_col: str, existing_cols: Set[str], threshold: Optional[float] = None) -> Optional[str]:
        """
        Trouve une colonne existante qui correspond au nom cible (fuzzy/case-insensitive).
        
        Args:
            target_col: Nom de colonne recherchÃ©
            existing_cols: Ensemble des colonnes existantes dans la table
            threshold: Seuil de similaritÃ© (0.0 Ã  1.0), uses instance default if None
        
        Returns:
            Nom de la colonne correspondante ou None
        """
        if threshold is None:
            threshold = self.fuzzy_threshold
        
        target_lower = target_col.lower()
        
        # 1. Exact match (case-insensitive)
        for col in existing_cols:
            if col.lower() == target_lower:
                return col
        
        # 2. Fuzzy match with SequenceMatcher
        best_match = None
        best_score = 0.0
        
        for col in existing_cols:
            # Calculate similarity ratio
            ratio = SequenceMatcher(None, target_lower, col.lower()).ratio()
            
            if ratio > best_score and ratio >= threshold:
                best_score = ratio
                best_match = col
        
        return best_match
    
    def quote_identifier(self, identifier: str) -> str:
        """
        Quote SQL identifier if it's a reserved word or contains special characters.
        
        Args:
            identifier: Column or table name
            
        Returns:
            Quoted identifier if needed, otherwise original
        """
        # Quote if it's a reserved word
        if identifier.lower() in self.SQL_RESERVED_WORDS:
            return f'"{identifier}"'
        
        # Quote if it contains special characters
        if not identifier.replace('_', '').isalnum():
            return f'"{identifier}"'
        
        return identifier
    
    def get_column_type_from_hints(self, table: str, column: str) -> Optional[str]:
        """RÃ©cupÃ¨re le type d'une colonne depuis les hints YAML."""
        if not self.schema_hints or "tables" not in self.schema_hints:
            return None
        
        if table not in self.schema_hints["tables"]:
            return None
        
        table_info = self.schema_hints["tables"][table]
        if "expected_columns" not in table_info:
            return None
        
        if column not in table_info["expected_columns"]:
            return None
        
        return table_info["expected_columns"][column].get("type", "TEXT")
    
    def create_backup(self) -> bool:
        """CrÃ©e une sauvegarde timestampÃ©e de la base de donnÃ©es."""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.backup_path = f"{self.db_path}.{timestamp}.bak"
            
            self.log(f"Creating backup: {self.backup_path}")
            shutil.copy2(self.db_path, self.backup_path)
            self.log(f"Backup created successfully: {self.backup_path}")
            return True
        except Exception as e:
            self.log(f"Failed to create backup: {e}", "ERROR")
            self.errors.append(f"Backup error: {e}")
            return False
    
    def restore_backup(self) -> bool:
        """Restaure la base de donnÃ©es depuis la sauvegarde."""
        if not self.backup_path or not os.path.exists(self.backup_path):
            self.log("No backup available to restore", "ERROR")
            return False
        
        try:
            self.log(f"Restoring from backup: {self.backup_path}")
            shutil.copy2(self.backup_path, self.db_path)
            self.log("Database restored successfully")
            return True
        except Exception as e:
            self.log(f"Failed to restore backup: {e}", "ERROR")
            self.errors.append(f"Restore error: {e}")
            return False
    
    def get_existing_schema(self, conn: sqlite3.Connection) -> Dict[str, Set[str]]:
        """RÃ©cupÃ¨re le schÃ©ma actuel de la base de donnÃ©es."""
        schema = {}
        
        cursor = conn.cursor()
        
        # Obtenir toutes les tables
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = [row[0] for row in cursor.fetchall()]
        
        for table in tables:
            # Obtenir les colonnes de chaque table
            cursor.execute(f"PRAGMA table_info({table})")
            columns = set(row[1] for row in cursor.fetchall())
            schema[table] = columns
        
        return schema
    
    def check_rename_column_support(self, conn: sqlite3.Connection) -> bool:
        """VÃ©rifie si SQLite supporte ALTER TABLE RENAME COLUMN (version 3.25.0+)."""
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT sqlite_version()")
            version = cursor.fetchone()[0]
            
            # Parse version (e.g., "3.35.5")
            major, minor, patch = map(int, version.split('.'))
            
            # RENAME COLUMN supported since 3.25.0
            supports_rename = (major > 3) or (major == 3 and minor >= 25)
            
            self.log(f"SQLite version: {version}, RENAME COLUMN support: {supports_rename}")
            return supports_rename
        except Exception as e:
            self.log(f"Could not determine SQLite version: {e}", "WARNING")
            return False
    
    def detect_missing_columns(self, existing_schema: Dict[str, Set[str]]) -> Dict[str, List[Tuple[str, str, str, Optional[str]]]]:
        """
        DÃ©tecte les colonnes manquantes par rapport au schÃ©ma de rÃ©fÃ©rence.
        
        Returns:
            Dict mapping table -> List of (col_name, col_type, default_value, fuzzy_match)
            where fuzzy_match is the name of an existing column that closely matches, or None
        """
        missing = {}
        
        # Combine REFERENCE_SCHEMA and YAML hints
        expected_schema = {}
        
        # Start with REFERENCE_SCHEMA
        for table, columns in REFERENCE_SCHEMA.items():
            expected_schema[table] = {}
            for col_name, (col_type, default_value) in columns.items():
                expected_schema[table][col_name] = (col_type, default_value)
        
        # Add columns from YAML hints if available
        if self.schema_hints and "tables" in self.schema_hints:
            for table, table_info in self.schema_hints["tables"].items():
                if "expected_columns" not in table_info:
                    continue
                
                if table not in expected_schema:
                    expected_schema[table] = {}
                
                for col_name, col_info in table_info["expected_columns"].items():
                    if col_name not in expected_schema[table]:
                        col_type = col_info.get("type", "TEXT")
                        # Infer default based on type
                        if col_type == "INTEGER":
                            default_value = "0"
                        elif col_type == "REAL":
                            default_value = "0.0"
                        else:
                            default_value = "''"
                        
                        expected_schema[table][col_name] = (col_type, default_value)
        
        # Now check for missing columns
        for table, expected_columns in expected_schema.items():
            if table not in existing_schema:
                self.log(f"Table '{table}' does not exist (will not be created automatically)", "WARNING")
                continue
            
            existing_cols = existing_schema[table]
            table_missing = []
            
            for col_name, (col_type, default_value) in expected_columns.items():
                if col_name not in existing_cols:
                    # Try fuzzy matching to find a similar column
                    fuzzy_match = self.fuzzy_match_column(col_name, existing_cols, threshold=0.75)
                    
                    if fuzzy_match:
                        self.log(f"Column '{col_name}' not found in '{table}', but found similar column '{fuzzy_match}'", "INFO")
                    
                    table_missing.append((col_name, col_type, default_value, fuzzy_match))
            
            if table_missing:
                missing[table] = table_missing
        
        return missing
    
    def apply_migrations(self, conn: sqlite3.Connection, missing_columns: Dict[str, List[Tuple[str, str, str, Optional[str]]]]) -> bool:
        """Applique les migrations pour ajouter les colonnes manquantes."""
        if not missing_columns:
            self.log("No missing columns detected. Database is up to date.")
            return True
        
        self.log(f"Found missing columns in {len(missing_columns)} table(s)")
        
        # Check if RENAME COLUMN is supported
        supports_rename = self.check_rename_column_support(conn)
        
        try:
            cursor = conn.cursor()
            
            # SQLite ne supporte pas toujours les transactions pour ALTER TABLE,
            # mais on utilise BEGIN pour grouper les opÃ©rations
            cursor.execute("BEGIN TRANSACTION")
            
            for table, columns in missing_columns.items():
                self.log(f"Processing table '{table}': {len(columns)} column(s) to add")
                
                for col_name, col_type, default_value, fuzzy_match in columns:
                    # Case 1: Fuzzy match found - try to rename or copy
                    if fuzzy_match:
                        self.log(f"  Column '{col_name}' has fuzzy match '{fuzzy_match}'")
                        
                        if supports_rename and fuzzy_match.lower() != col_name.lower():
                            # Try to rename the column
                            rename_sql = f"ALTER TABLE {table} RENAME COLUMN {fuzzy_match} TO {col_name}"
                            
                            try:
                                self.log(f"  Attempting to rename '{fuzzy_match}' to '{col_name}'...")
                                cursor.execute(rename_sql)
                                self.log(f"  [OK] Successfully renamed column '{fuzzy_match}' to '{col_name}'")
                                self.column_mappings[f"{table}.{fuzzy_match}"] = f"{table}.{col_name}"
                                continue
                            except sqlite3.OperationalError as e:
                                self.log(f"  [WARNING] RENAME failed: {e}. Will try ADD + COPY instead.", "WARNING")
                        
                        # If rename not supported or failed, do ADD + COPY
                        quoted_col = self.quote_identifier(col_name)
                        
                        if default_value is None:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type}"
                        else:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type} DEFAULT {default_value}"
                        
                        try:
                            self.log(f"  Adding new column '{col_name}' ({col_type})")
                            cursor.execute(alter_sql)
                            
                            # Copy data from fuzzy_match column to new column
                            # Quote identifiers in case they're reserved words
                            quoted_new = self.quote_identifier(col_name)
                            quoted_old = self.quote_identifier(fuzzy_match)
                            copy_sql = f"UPDATE {table} SET {quoted_new} = {quoted_old}"
                            self.log(f"  Copying data from '{fuzzy_match}' to '{col_name}'...")
                            cursor.execute(copy_sql)
                            
                            self.log(f"  [OK] Added column '{col_name}' and copied data from '{fuzzy_match}'")
                            self.column_mappings[f"{table}.{fuzzy_match}"] = f"{table}.{col_name} (copied)"
                            
                        except sqlite3.OperationalError as e:
                            error_msg = str(e).lower()
                            if "duplicate" in error_msg and "column" in error_msg:
                                self.log(f"  [WARNING] Column '{col_name}' already exists", "WARNING")
                            else:
                                raise
                    
                    # Case 2: No fuzzy match - just add the column
                    else:
                        # Quote column name if it's a reserved word
                        quoted_col = self.quote_identifier(col_name)
                        
                        if default_value is None:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type}"
                        else:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type} DEFAULT {default_value}"
                        
                        try:
                            self.log(f"  Adding column: {col_name} ({col_type})")
                            cursor.execute(alter_sql)
                            self.log(f"  [OK] Successfully added column '{col_name}' to table '{table}'")
                        except sqlite3.OperationalError as e:
                            error_msg = str(e).lower()
                            if "duplicate" in error_msg and "column" in error_msg:
                                self.log(f"  [WARNING] Column '{col_name}' already exists in table '{table}'", "WARNING")
                            else:
                                raise
            
            # Commit toutes les modifications
            conn.commit()
            self.log("All migrations applied successfully")
            return True
            
        except Exception as e:
            self.log(f"Migration failed: {e}", "ERROR")
            self.errors.append(f"Migration error: {e}")
            
            try:
                conn.rollback()
                self.log("Transaction rolled back")
            except Exception as rb_error:
                self.log(f"Rollback failed: {rb_error}", "ERROR")
            
            return False
    
    def optimize_database(self, conn: sqlite3.Connection):
        """Optimise la base de donnÃ©es (WAL mode, pragmas)."""
        try:
            cursor = conn.cursor()
            
            # Activer le mode WAL (Write-Ahead Logging)
            self.log("Enabling WAL mode...")
            try:
                cursor.execute("PRAGMA journal_mode=WAL")
                result = cursor.fetchone()
                self.log(f"Journal mode set to: {result[0]}")
            except Exception as e:
                self.log(f"Could not enable WAL mode: {e}", "WARNING")
            
            # DÃ©finir synchronous Ã  NORMAL pour de meilleures performances
            self.log("Setting synchronous mode to NORMAL...")
            try:
                cursor.execute("PRAGMA synchronous=NORMAL")
                self.log("Synchronous mode set to NORMAL")
            except Exception as e:
                self.log(f"Could not set synchronous mode: {e}", "WARNING")
            
            # Analyser la base de donnÃ©es pour optimiser les requÃªtes
            self.log("Running ANALYZE...")
            try:
                cursor.execute("ANALYZE")
                self.log("Database analysis complete")
            except Exception as e:
                self.log(f"Could not analyze database: {e}", "WARNING")
            
        except Exception as e:
            self.log(f"Database optimization warning: {e}", "WARNING")
    
    def generate_report(self, output_file: str, missing_columns: Dict[str, List[Tuple[str, str, str, Optional[str]]]], success: bool):
        """GÃ©nÃ¨re un rapport dÃ©taillÃ© de la migration."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # CrÃ©er le rÃ©pertoire reports s'il n'existe pas
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Database Migration Report\n\n")
            f.write(f"**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"**Database:** {self.db_path}\n")
            f.write(f"**Status:** {'SUCCESS' if success else 'FAILED'}\n")
            
            if self.backup_path:
                f.write(f"**Backup:** {self.backup_path}\n")
            
            f.write("\n## Summary\n\n")
            
            if not missing_columns:
                f.write("No missing columns detected. Database schema is up to date.\n")
            else:
                total_columns = sum(len(cols) for cols in missing_columns.values())
                f.write(f"- Tables requiring updates: {len(missing_columns)}\n")
                f.write(f"- Total columns to add: {total_columns}\n")
                
                if success:
                    f.write("\n[OK] All columns were successfully added.\n")
                else:
                    f.write("\n[FAILED] Migration failed. Changes have been rolled back.\n")
                
                f.write("\n## Changes Applied\n\n")
                for table, columns in missing_columns.items():
                    f.write(f"### Table: `{table}`\n\n")
                    for col_name, col_type, default_value, fuzzy_match in columns:
                        default_str = f" DEFAULT {default_value}" if default_value else ""
                        status_icon = "[OK]" if success else "[FAILED]"
                        
                        if fuzzy_match:
                            mapping_key = f"{table}.{fuzzy_match}"
                            if mapping_key in self.column_mappings:
                                mapping_action = self.column_mappings[mapping_key]
                                f.write(f"- {status_icon} Column: `{col_name}` ({col_type}{default_str}) - Mapped from `{fuzzy_match}` ({mapping_action})\n")
                            else:
                                f.write(f"- {status_icon} Column: `{col_name}` ({col_type}{default_str}) - Fuzzy match: `{fuzzy_match}`\n")
                        else:
                            f.write(f"- {status_icon} Column: `{col_name}` ({col_type}{default_str})\n")
                    f.write("\n")
                
                # Add column mapping summary if any mappings were made
                if self.column_mappings:
                    f.write("\n## Column Mappings\n\n")
                    f.write("The following columns were renamed or had their data copied:\n\n")
                    for old_ref, new_ref in self.column_mappings.items():
                        f.write(f"- `{old_ref}` â†’ `{new_ref}`\n")
                    f.write("\n")
            
            if self.errors:
                f.write("\n## Errors\n\n")
                for error in self.errors:
                    f.write(f"- [ERROR] {error}\n")
                
                f.write("\n### Recovery Actions\n\n")
                if self.backup_path and os.path.exists(self.backup_path):
                    f.write(f"[OK] Database was restored from backup: {self.backup_path}\n")
                else:
                    f.write("[WARNING] No backup was available for restore.\n")
            
            f.write("\n## Migration Log\n\n")
            f.write("```\n")
            for log_entry in self.migration_log:
                f.write(f"{log_entry}\n")
            f.write("```\n")
            
            if not success:
                f.write("\n## Recommended Actions\n\n")
                f.write("1. Review the errors listed above\n")
                f.write("2. Check database file permissions\n")
                f.write("3. Ensure no other processes are accessing the database\n")
                f.write("4. If the issue persists, please report it with this file\n")
        
        self.log(f"Report generated: {output_file}")
    
    def run_migration(self) -> bool:
        """ExÃ©cute le processus complet de migration."""
        self.log("=" * 60)
        self.log("Database Structure Update - Smart Migration with Fuzzy Matching")
        self.log("=" * 60)
        self.log(f"Database: {self.db_path}")
        
        if not os.path.exists(self.db_path):
            self.log(f"Database file not found: {self.db_path}", "ERROR")
            return False
        
        # Ã‰tape 0: Charger les schema hints si activÃ©
        if self.use_yaml_hints:
            self.load_schema_hints()
        
        # Ã‰tape 1: CrÃ©er une sauvegarde
        if not self.create_backup():
            self.log("Migration aborted: could not create backup", "ERROR")
            return False
        
        success = False
        missing_columns = {}
        
        try:
            # Ã‰tape 2: Analyser le schÃ©ma existant
            self.log("Analyzing current database schema...")
            conn = sqlite3.connect(self.db_path, timeout=30)
            conn.row_factory = sqlite3.Row
            
            existing_schema = self.get_existing_schema(conn)
            self.log(f"Found {len(existing_schema)} tables in database")
            
            # Ã‰tape 3: DÃ©tecter les colonnes manquantes
            self.log("Detecting missing columns...")
            missing_columns = self.detect_missing_columns(existing_schema)
            
            if not missing_columns:
                self.log("[SUCCESS] Database schema is up to date!")
                success = True
            else:
                # Ã‰tape 4: Appliquer les migrations
                self.log("Applying migrations...")
                success = self.apply_migrations(conn, missing_columns)
                
                if success:
                    self.log("[SUCCESS] Migrations completed successfully!")
                    
                    # Ã‰tape 5: Optimiser la base de donnÃ©es
                    self.log("Optimizing database...")
                    self.optimize_database(conn)
                else:
                    self.log("[FAILED] Migration failed, restoring backup...", "ERROR")
                    conn.close()
                    self.restore_backup()
            
            conn.close()
            
        except Exception as e:
            error_trace = traceback.format_exc()
            self.log(f"Unexpected error during migration: {e}", "ERROR")
            self.errors.append(f"Unexpected error: {e}\n{error_trace}")
            
            # Restaurer la sauvegarde en cas d'erreur
            self.log("Restoring backup due to error...", "ERROR")
            self.restore_backup()
            success = False
        
        # GÃ©nÃ©rer le rapport dans le rÃ©pertoire reports/
        report_dir = Path(__file__).parent.parent / "reports"
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        status_suffix = "success" if success else "failed"
        report_file = report_dir / f"migration_report_{status_suffix}_{timestamp}.md"
        self.report_path = str(report_file)
        self.generate_report(self.report_path, missing_columns, success)
        
        self.log("=" * 60)
        if success:
            self.log("Migration completed successfully!")
        else:
            self.log("Migration failed. Check the report for details.", "ERROR")
        self.log("=" * 60)
        
        return success


def get_latest_migration_report(reports_dir: Optional[str] = None) -> Optional[str]:
    """
    RÃ©cupÃ¨re le chemin du dernier rapport de migration gÃ©nÃ©rÃ©.
    
    Args:
        reports_dir: RÃ©pertoire des rapports (dÃ©faut: reports/ Ã  la racine du projet)
        
    Returns:
        Chemin du dernier rapport ou None si aucun rapport trouvÃ©
    """
    if reports_dir is None:
        reports_dir = Path(__file__).parent.parent / "reports"
    else:
        reports_dir = Path(reports_dir)
    
    if not reports_dir.exists():
        return None
    
    # Trouver tous les rapports de migration
    reports = list(reports_dir.glob("migration_report_*.md"))
    
    if not reports:
        return None
    
    # Retourner le plus rÃ©cent
    latest_report = max(reports, key=lambda p: p.stat().st_mtime)
    return str(latest_report)


def main():
    """Point d'entrÃ©e principal."""
    parser = argparse.ArgumentParser(description="Smart database structure migration tool with fuzzy column matching")
    parser.add_argument(
        "--db-path",
        default="association.db",
        help="Path to the database file (default: association.db)"
    )
    parser.add_argument(
        "--no-yaml-hints",
        action="store_true",
        help="Disable loading schema hints from YAML (use only REFERENCE_SCHEMA)"
    )
    
    args = parser.parse_args()
    
    migrator = DatabaseMigrator(args.db_path, use_yaml_hints=not args.no_yaml_hints)
    success = migrator.run_migration()
    
    # Afficher le chemin du rapport pour que l'appelant puisse le rÃ©cupÃ©rer
    if migrator.report_path:
        print(f"\nREPORT_PATH:{migrator.report_path}")
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./tests/test_analyze_modules.py ===

```python
"""
Tests for the analyze_modules_columns script.
"""

import os
import sys
import tempfile
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from scripts.analyze_modules_columns import StrictSQLAnalyzer


def test_sql_analyzer_initialization():
    """Test StrictSQLAnalyzer initialization."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        assert analyzer.repo_root == Path(tmpdir)
        assert len(analyzer.table_columns) == 0


def test_extract_select_queries():
    """Test extraction of SELECT queries."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        content = """
        conn.execute("SELECT id, name, email FROM membres WHERE id = ?", (mid,))
        conn.execute("SELECT * FROM events ORDER BY date DESC")
        """
        
        analyzer._extract_select_statements(content, "test.py")
        
        assert "membres" in analyzer.table_columns
        assert "events" in analyzer.table_columns
        assert "id" in analyzer.table_columns["membres"]["columns"]
        assert "name" in analyzer.table_columns["membres"]["columns"]
        assert "email" in analyzer.table_columns["membres"]["columns"]


def test_extract_insert_queries():
    """Test extraction of INSERT queries."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        content = """
        INSERT INTO members (name, prenom, email) VALUES (?, ?, ?)
        """
        
        analyzer._extract_insert_statements(content, "test.py")
        
        assert "members" in analyzer.table_columns
        assert "name" in analyzer.table_columns["members"]["columns"]
        assert "prenom" in analyzer.table_columns["members"]["columns"]
        assert "email" in analyzer.table_columns["members"]["columns"]


def test_extract_update_queries():
    """Test extraction of UPDATE queries."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        content = """
        UPDATE config SET exercice=?, date=?, disponible_banque=? WHERE id=1
        """
        
        analyzer._extract_update_statements(content, "test.py")
        
        assert "config" in analyzer.table_columns
        assert "exercice" in analyzer.table_columns["config"]["columns"]
        assert "date" in analyzer.table_columns["config"]["columns"]
        assert "disponible_banque" in analyzer.table_columns["config"]["columns"]


def test_extract_alter_table():
    """Test extraction of ALTER TABLE statements - not in StrictSQLAnalyzer scope."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        # StrictSQLAnalyzer focuses on INSERT/UPDATE/SELECT/CREATE TABLE
        # ALTER TABLE is not extracted as it doesn't define expected schema
        content = """
        ALTER TABLE buvette_articles ADD COLUMN stock INTEGER DEFAULT 0
        """
        
        # This test is skipped as ALTER TABLE is not in scope
        pass


def test_extract_create_table():
    """Test extraction of CREATE TABLE statements."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        content = """
        CREATE TABLE IF NOT EXISTS events (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            date TEXT NOT NULL,
            lieu TEXT,
            commentaire TEXT
        )
        """
        
        analyzer._extract_create_table_statements(content, "test.py")
        
        assert "events" in analyzer.table_columns
        assert "id" in analyzer.table_columns["events"]["columns"]
        assert "name" in analyzer.table_columns["events"]["columns"]
        assert "date" in analyzer.table_columns["events"]["columns"]
        assert "lieu" in analyzer.table_columns["events"]["columns"]
        assert "commentaire" in analyzer.table_columns["events"]["columns"]


def test_analyze_file():
    """Test analyzing a complete Python file."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        # Create a test Python file
        test_file = Path(tmpdir) / "test_module.py"
        test_file.write_text("""
import sqlite3

def get_members():
    conn = sqlite3.connect("test.db")
    cursor = conn.execute("SELECT id, name, email FROM membres")
    return cursor.fetchall()

def add_member(name, email):
    conn = sqlite3.connect("test.db")
    conn.execute("INSERT INTO membres (name, email) VALUES (?, ?)", (name, email))
    conn.commit()
""")
        
        analyzer.analyze_file(test_file)
        
        assert "membres" in analyzer.table_columns
        assert "id" in analyzer.table_columns["membres"]["columns"]
        assert "name" in analyzer.table_columns["membres"]["columns"]
        assert "email" in analyzer.table_columns["membres"]["columns"]
        assert "test_module.py" in analyzer.table_columns["membres"]["files"]


def test_generate_report():
    """Test report generation."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        # Add some test data
        analyzer.table_columns["test_table"]["columns"].add("col1")
        analyzer.table_columns["test_table"]["columns"].add("col2")
        analyzer.table_columns["test_table"]["files"].add("test.py")
        
        output_file = Path(tmpdir) / "report.md"
        analyzer.generate_report(str(output_file))
        
        assert output_file.exists()
        content = output_file.read_text()
        assert "# Analyse SQL" in content
        assert "test_table" in content
        assert "col1" in content
        assert "col2" in content
        assert "test.py" in content


if __name__ == "__main__":
    # Run tests
    test_sql_analyzer_initialization()
    print("âœ“ test_sql_analyzer_initialization")
    
    test_extract_select_queries()
    print("âœ“ test_extract_select_queries")
    
    test_extract_insert_queries()
    print("âœ“ test_extract_insert_queries")
    
    test_extract_update_queries()
    print("âœ“ test_extract_update_queries")
    
    test_extract_alter_table()
    print("âœ“ test_extract_alter_table")
    
    test_extract_create_table()
    print("âœ“ test_extract_create_table")
    
    test_analyze_file()
    print("âœ“ test_analyze_file")
    
    test_generate_report()
    print("âœ“ test_generate_report")
    
    print("\nAll tests passed!")

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./tests/test_buvette_inventaire.py ===

```python
import unittest
import sqlite3
import os
import sys

# Mock tkinter before any imports that might use it
sys.modules['tkinter'] = type(sys)('tkinter')
sys.modules['tkinter.messagebox'] = type(sys)('messagebox')

# Add parent directory to path to import modules
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Simple database helper functions to avoid WAL mode issues
def get_test_connection(db_file):
    """Create a simple connection without WAL mode for testing."""
    conn = sqlite3.connect(db_file)
    conn.row_factory = sqlite3.Row
    return conn


class TestBuvetteInventaire(unittest.TestCase):
    """Test suite for buvette inventaire database operations."""
    
    def setUp(self):
        """Set up a fresh test database before each test."""
        self.test_db = f"/tmp/test_buvette_inventaire_{id(self)}.db"
        
        # Create the tables
        conn = get_test_connection(self.test_db)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                date TEXT NOT NULL
            )
        """)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_inventaires (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date_inventaire DATE,
                event_id INTEGER,
                type_inventaire TEXT CHECK(type_inventaire IN ('avant', 'apres', 'hors_evenement')),
                commentaire TEXT,
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        """)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                unite TEXT,
                contenance TEXT,
                commentaire TEXT
            )
        """)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_inventaire_lignes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                inventaire_id INTEGER,
                article_id INTEGER,
                quantite INTEGER,
                commentaire TEXT,
                FOREIGN KEY (inventaire_id) REFERENCES buvette_inventaires(id),
                FOREIGN KEY (article_id) REFERENCES buvette_articles(id)
            )
        """)
        conn.commit()
        conn.close()
    
    def tearDown(self):
        """Clean up test database after each test."""
        if os.path.exists(self.test_db):
            os.remove(self.test_db)
        # Clean up any WAL files
        for ext in ['-wal', '-shm']:
            wal_file = self.test_db + ext
            if os.path.exists(wal_file):
                try:
                    os.remove(wal_file)
                except:
                    pass
    
    def test_insert_inventaire_with_valid_type_hors_evenement(self):
        """Test inserting an inventory with type 'hors_evenement' does not raise IntegrityError."""
        conn = get_test_connection(self.test_db)
        cur = conn.cursor()
        cur.execute("""
            INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
            VALUES (?, ?, ?, ?)
        """, ('2025-01-15', None, 'hors_evenement', 'Test inventory'))
        inv_id = cur.lastrowid
        conn.commit()
        
        self.assertIsNotNone(inv_id)
        self.assertGreater(inv_id, 0)
        
        # Verify it was inserted correctly
        cur.execute("SELECT * FROM buvette_inventaires WHERE id=?", (inv_id,))
        inv = cur.fetchone()
        conn.close()
        
        self.assertIsNotNone(inv)
        self.assertEqual(inv['date_inventaire'], '2025-01-15')
        self.assertEqual(inv['type_inventaire'], 'hors_evenement')
        self.assertEqual(inv['commentaire'], 'Test inventory')
        self.assertIsNone(inv['event_id'])
    
    def test_insert_inventaire_with_valid_type_avant(self):
        """Test inserting an inventory with type 'avant'."""
        conn = get_test_connection(self.test_db)
        cur = conn.cursor()
        cur.execute("""
            INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
            VALUES (?, ?, ?, ?)
        """, ('2025-01-16', None, 'avant', 'Before event'))
        inv_id = cur.lastrowid
        conn.commit()
        
        cur.execute("SELECT * FROM buvette_inventaires WHERE id=?", (inv_id,))
        inv = cur.fetchone()
        conn.close()
        
        self.assertEqual(inv['type_inventaire'], 'avant')
    
    def test_insert_inventaire_with_valid_type_apres(self):
        """Test inserting an inventory with type 'apres'."""
        conn = get_test_connection(self.test_db)
        cur = conn.cursor()
        cur.execute("""
            INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
            VALUES (?, ?, ?, ?)
        """, ('2025-01-17', None, 'apres', 'After event'))
        inv_id = cur.lastrowid
        conn.commit()
        
        cur.execute("SELECT * FROM buvette_inventaires WHERE id=?", (inv_id,))
        inv = cur.fetchone()
        conn.close()
        
        self.assertEqual(inv['type_inventaire'], 'apres')
    
    def test_insert_inventaire_with_invalid_type_raises_error(self):
        """Test that inserting an inventory with invalid type raises IntegrityError."""
        conn = get_test_connection(self.test_db)
        with self.assertRaises(sqlite3.IntegrityError) as context:
            conn.execute("""
                INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
                VALUES (?, ?, ?, ?)
            """, ('2025-01-18', None, 'invalid_type', 'Should fail'))
            conn.commit()
        conn.close()
        
        self.assertIn('CHECK constraint', str(context.exception))
    
    def test_update_inventaire_with_valid_type(self):
        """Test updating an inventory with a valid type."""
        conn = get_test_connection(self.test_db)
        cur = conn.cursor()
        
        # First insert an inventory
        cur.execute("""
            INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
            VALUES (?, ?, ?, ?)
        """, ('2025-01-20', None, 'hors_evenement', 'Original'))
        inv_id = cur.lastrowid
        conn.commit()
        
        # Update it
        cur.execute("""
            UPDATE buvette_inventaires SET date_inventaire=?, event_id=?, type_inventaire=?, commentaire=?
            WHERE id=?
        """, ('2025-01-21', None, 'avant', 'Updated', inv_id))
        conn.commit()
        
        # Verify the update
        cur.execute("SELECT * FROM buvette_inventaires WHERE id=?", (inv_id,))
        inv = cur.fetchone()
        conn.close()
        
        self.assertEqual(inv['date_inventaire'], '2025-01-21')
        self.assertEqual(inv['type_inventaire'], 'avant')
        self.assertEqual(inv['commentaire'], 'Updated')
    
    def test_update_inventaire_with_invalid_type_raises_error(self):
        """Test that updating an inventory with invalid type raises IntegrityError."""
        conn = get_test_connection(self.test_db)
        cur = conn.cursor()
        
        # First insert an inventory
        cur.execute("""
            INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
            VALUES (?, ?, ?, ?)
        """, ('2025-01-22', None, 'hors_evenement', 'Original'))
        inv_id = cur.lastrowid
        conn.commit()
        
        # Try to update with invalid type
        with self.assertRaises(sqlite3.IntegrityError) as context:
            cur.execute("""
                UPDATE buvette_inventaires SET date_inventaire=?, event_id=?, type_inventaire=?, commentaire=?
                WHERE id=?
            """, ('2025-01-23', None, 'invalid_update', 'Should fail', inv_id))
            conn.commit()
        
        conn.close()
        self.assertIn('CHECK constraint', str(context.exception))
    
    def test_list_inventaires(self):
        """Test listing all inventories."""
        conn = get_test_connection(self.test_db)
        cur = conn.cursor()
        
        # Insert multiple inventories
        for date, type_inv, comment in [
            ('2025-01-24', 'hors_evenement', 'First'),
            ('2025-01-25', 'avant', 'Second'),
            ('2025-01-26', 'apres', 'Third')
        ]:
            cur.execute("""
                INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
                VALUES (?, ?, ?, ?)
            """, (date, None, type_inv, comment))
        conn.commit()
        
        # List them
        cur.execute("SELECT * FROM buvette_inventaires ORDER BY date_inventaire DESC")
        inventaires = cur.fetchall()
        conn.close()
        
        self.assertEqual(len(inventaires), 3)


if __name__ == "__main__":
    unittest.main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./tests/test_buvette_purchase_price.py ===

```python
"""
Tests pour la fonctionnalitÃ© du prix d'achat dans le module buvette.

Ce fichier teste:
- La crÃ©ation de la colonne purchase_price (migration)
- L'insertion d'articles avec purchase_price
- La mise Ã  jour d'articles avec purchase_price
- La rÃ©cupÃ©ration d'articles avec purchase_price
"""

import unittest
import sqlite3
import os


def get_test_connection(db_file):
    """Create a simple connection without WAL mode for testing."""
    conn = sqlite3.connect(db_file)
    conn.row_factory = sqlite3.Row
    return conn


class TestBuvettePurchasePrice(unittest.TestCase):
    """Test suite for buvette purchase price management."""
    
    def setUp(self):
        """Set up a fresh test database before each test."""
        self.test_db = f"/tmp/test_buvette_purchase_price_{id(self)}.db"
        
        # Create the tables with purchase_price column
        conn = get_test_connection(self.test_db)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                unite TEXT,
                contenance TEXT,
                commentaire TEXT,
                stock INTEGER DEFAULT 0,
                purchase_price REAL
            )
        """)
        conn.commit()
        conn.close()
    
    def tearDown(self):
        """Clean up test database after each test."""
        if os.path.exists(self.test_db):
            os.remove(self.test_db)
    
    def test_table_has_purchase_price_column(self):
        """Test that buvette_articles table has purchase_price column."""
        conn = get_test_connection(self.test_db)
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns = [row[1] for row in cursor.fetchall()]
        conn.close()
        
        self.assertIn('purchase_price', columns, "purchase_price column should exist")
    
    def test_insert_article_with_purchase_price(self):
        """Test inserting an article with a purchase price."""
        conn = get_test_connection(self.test_db)
        conn.execute("""
            INSERT INTO buvette_articles 
            (name, categorie, unite, commentaire, contenance, purchase_price)
            VALUES (?, ?, ?, ?, ?, ?)
        """, ("Coca-Cola", "Boisson", "canette", "Test", "0.33L", 1.50))
        conn.commit()
        
        # Retrieve the article
        cursor = conn.execute("SELECT * FROM buvette_articles WHERE name = ?", ("Coca-Cola",))
        article = cursor.fetchone()
        conn.close()
        
        self.assertIsNotNone(article, "Article should be inserted")
        self.assertEqual(article['purchase_price'], 1.50, "Purchase price should be 1.50")
    
    def test_insert_article_without_purchase_price(self):
        """Test inserting an article without a purchase price (NULL)."""
        conn = get_test_connection(self.test_db)
        conn.execute("""
            INSERT INTO buvette_articles 
            (name, categorie, unite, commentaire, contenance)
            VALUES (?, ?, ?, ?, ?)
        """, ("Fanta", "Boisson", "canette", "Test", "0.33L"))
        conn.commit()
        
        # Retrieve the article
        cursor = conn.execute("SELECT * FROM buvette_articles WHERE name = ?", ("Fanta",))
        article = cursor.fetchone()
        conn.close()
        
        self.assertIsNotNone(article, "Article should be inserted")
        self.assertIsNone(article['purchase_price'], "Purchase price should be NULL")
    
    def test_update_article_purchase_price(self):
        """Test updating an article's purchase price."""
        conn = get_test_connection(self.test_db)
        
        # Insert article
        conn.execute("""
            INSERT INTO buvette_articles 
            (name, categorie, unite, commentaire, contenance, purchase_price)
            VALUES (?, ?, ?, ?, ?, ?)
        """, ("Sprite", "Boisson", "canette", "Test", "0.33L", 1.25))
        conn.commit()
        
        # Get the article ID
        cursor = conn.execute("SELECT id FROM buvette_articles WHERE name = ?", ("Sprite",))
        article_id = cursor.fetchone()['id']
        
        # Update purchase price
        conn.execute("""
            UPDATE buvette_articles 
            SET purchase_price = ? 
            WHERE id = ?
        """, (1.75, article_id))
        conn.commit()
        
        # Verify update
        cursor = conn.execute("SELECT purchase_price FROM buvette_articles WHERE id = ?", (article_id,))
        updated_price = cursor.fetchone()['purchase_price']
        conn.close()
        
        self.assertEqual(updated_price, 1.75, "Purchase price should be updated to 1.75")
    
    def test_migration_adds_purchase_price_column(self):
        """Test that migration adds purchase_price column to existing table."""
        # Create a database with old schema (without purchase_price)
        old_db = f"/tmp/test_migration_{id(self)}.db"
        conn = get_test_connection(old_db)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                unite TEXT,
                contenance TEXT,
                commentaire TEXT,
                stock INTEGER DEFAULT 0
            )
        """)
        
        # Insert test data
        conn.execute("""
            INSERT INTO buvette_articles 
            (name, categorie, unite, commentaire, contenance, stock)
            VALUES (?, ?, ?, ?, ?, ?)
        """, ("Pepsi", "Boisson", "canette", "Old data", "0.33L", 5))
        conn.commit()
        
        # Verify purchase_price column doesn't exist
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns_before = [row[1] for row in cursor.fetchall()]
        self.assertNotIn('purchase_price', columns_before, "purchase_price should not exist before migration")
        
        # Run migration
        conn.execute("ALTER TABLE buvette_articles ADD COLUMN purchase_price REAL")
        conn.commit()
        
        # Verify purchase_price column exists
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns_after = [row[1] for row in cursor.fetchall()]
        self.assertIn('purchase_price', columns_after, "purchase_price should exist after migration")
        
        # Verify old data is preserved
        cursor = conn.execute("SELECT name, stock, purchase_price FROM buvette_articles WHERE name = ?", ("Pepsi",))
        article = cursor.fetchone()
        conn.close()
        
        self.assertEqual(article['name'], "Pepsi", "Article name should be preserved")
        self.assertEqual(article['stock'], 5, "Article stock should be preserved")
        self.assertIsNone(article['purchase_price'], "Purchase price should be NULL for old data")
        
        # Cleanup
        os.remove(old_db)


if __name__ == '__main__':
    unittest.main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./tests/test_buvette_stock.py ===

```python
"""
Tests pour la fonctionnalitÃ© de gestion du stock dans le module buvette.

Ce fichier teste:
- La crÃ©ation de la colonne stock (migration non destructive)
- La fonction set_article_stock
- La fonction get_article_stock
- L'intÃ©gration avec les lignes d'inventaire
"""

import unittest
import sqlite3
import os
import sys

# Add parent directory to path to import modules
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))


def get_test_connection(db_file):
    """Create a simple connection without WAL mode for testing."""
    conn = sqlite3.connect(db_file)
    conn.row_factory = sqlite3.Row
    return conn


class TestBuvetteStock(unittest.TestCase):
    """Test suite for buvette stock management."""
    
    def setUp(self):
        """Set up a fresh test database before each test."""
        self.test_db = f"/tmp/test_buvette_stock_{id(self)}.db"
        
        # Create the tables
        conn = get_test_connection(self.test_db)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                unite TEXT,
                contenance TEXT,
                commentaire TEXT,
                stock INTEGER DEFAULT 0
            )
        """)
        conn.commit()
        conn.close()
    
    def tearDown(self):
        """Clean up test database after each test."""
        if os.path.exists(self.test_db):
            os.remove(self.test_db)
    
    def test_stock_column_exists_in_new_table(self):
        """Test that stock column exists in newly created table."""
        conn = get_test_connection(self.test_db)
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns = [row[1] for row in cursor.fetchall()]
        conn.close()
        
        self.assertIn('stock', columns)
    
    def test_insert_article_with_default_stock(self):
        """Test that new articles have stock defaulting to 0."""
        conn = get_test_connection(self.test_db)
        conn.execute("""
            INSERT INTO buvette_articles (name, categorie, unite, contenance, commentaire)
            VALUES (?, ?, ?, ?, ?)
        """, ('Coca-Cola', 'Boissons', 'bouteille', '1L', 'Test'))
        conn.commit()
        
        cursor = conn.execute("SELECT stock FROM buvette_articles WHERE name=?", ('Coca-Cola',))
        row = cursor.fetchone()
        conn.close()
        
        self.assertIsNotNone(row)
        self.assertEqual(row['stock'], 0)
    
    def test_insert_article_with_explicit_stock(self):
        """Test inserting an article with explicit stock value."""
        conn = get_test_connection(self.test_db)
        conn.execute("""
            INSERT INTO buvette_articles (name, categorie, unite, contenance, commentaire, stock)
            VALUES (?, ?, ?, ?, ?, ?)
        """, ('Pepsi', 'Boissons', 'canette', '0.33L', 'Test', 50))
        conn.commit()
        
        cursor = conn.execute("SELECT stock FROM buvette_articles WHERE name=?", ('Pepsi',))
        row = cursor.fetchone()
        conn.close()
        
        self.assertEqual(row['stock'], 50)
    
    def test_update_article_stock(self):
        """Test updating the stock of an article."""
        conn = get_test_connection(self.test_db)
        
        # Insert an article
        conn.execute("""
            INSERT INTO buvette_articles (name, categorie, unite, contenance, commentaire, stock)
            VALUES (?, ?, ?, ?, ?, ?)
        """, ('Fanta', 'Boissons', 'bouteille', '1.5L', 'Test', 10))
        conn.commit()
        
        # Get the article ID
        cursor = conn.execute("SELECT id FROM buvette_articles WHERE name=?", ('Fanta',))
        article_id = cursor.fetchone()['id']
        
        # Update the stock
        conn.execute("UPDATE buvette_articles SET stock=? WHERE id=?", (25, article_id))
        conn.commit()
        
        # Verify the update
        cursor = conn.execute("SELECT stock FROM buvette_articles WHERE id=?", (article_id,))
        row = cursor.fetchone()
        conn.close()
        
        self.assertEqual(row['stock'], 25)
    
    def test_stock_column_migration_on_existing_table(self):
        """Test adding stock column to an existing table without it."""
        # Create a table without stock column
        test_db2 = f"/tmp/test_migration_{id(self)}.db"
        conn = get_test_connection(test_db2)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                unite TEXT,
                contenance TEXT,
                commentaire TEXT
            )
        """)
        conn.commit()
        
        # Insert an article without stock
        conn.execute("""
            INSERT INTO buvette_articles (name, categorie, unite, contenance, commentaire)
            VALUES (?, ?, ?, ?, ?)
        """, ('Sprite', 'Boissons', 'bouteille', '1L', 'Test'))
        conn.commit()
        
        # Add stock column (simulating migration)
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns = [row[1] for row in cursor.fetchall()]
        
        if 'stock' not in columns:
            conn.execute("ALTER TABLE buvette_articles ADD COLUMN stock INTEGER DEFAULT 0")
            conn.commit()
        
        # Verify the column was added and default value is applied
        cursor = conn.execute("SELECT stock FROM buvette_articles WHERE name=?", ('Sprite',))
        row = cursor.fetchone()
        conn.close()
        
        # Clean up
        if os.path.exists(test_db2):
            os.remove(test_db2)
        
        self.assertIsNotNone(row)
        self.assertEqual(row['stock'], 0)


if __name__ == "__main__":
    unittest.main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./tests/test_database_migration.py ===

```python
"""
Tests for the database migration script.
"""

import os
import sys
import sqlite3
import tempfile
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from scripts.update_db_structure import DatabaseMigrator, REFERENCE_SCHEMA, get_latest_migration_report


def create_test_database(db_path, missing_columns=True):
    """Create a test database with or without missing columns."""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    if missing_columns:
        # Create tables with some columns missing
        cursor.execute("""
            CREATE TABLE config (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                exercice TEXT,
                date TEXT
            )
        """)
        
        cursor.execute("""
            CREATE TABLE membres (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                prenom TEXT
            )
        """)
    else:
        # Create complete tables
        cursor.execute("""
            CREATE TABLE config (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                exercice TEXT,
                date TEXT,
                but_asso TEXT DEFAULT '',
                cloture INTEGER DEFAULT 0,
                solde_report REAL DEFAULT 0.0,
                disponible_banque REAL DEFAULT 0.0
            )
        """)
        
        cursor.execute("""
            CREATE TABLE membres (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                prenom TEXT,
                email TEXT DEFAULT '',
                classe TEXT DEFAULT '',
                cotisation TEXT DEFAULT '',
                commentaire TEXT DEFAULT '',
                telephone TEXT DEFAULT '',
                statut TEXT DEFAULT '',
                date_adhesion TEXT DEFAULT ''
            )
        """)
    
    conn.commit()
    conn.close()


def test_database_migrator_initialization():
    """Test DatabaseMigrator initialization."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path)
        migrator = DatabaseMigrator(db_path)
        
        assert migrator.db_path == db_path
        assert migrator.backup_path is None
        assert len(migrator.migration_log) == 0
        assert len(migrator.errors) == 0
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_create_backup():
    """Test backup creation."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path)
        migrator = DatabaseMigrator(db_path)
        
        result = migrator.create_backup()
        
        assert result is True
        assert migrator.backup_path is not None
        assert os.path.exists(migrator.backup_path)
        assert migrator.backup_path.endswith(".bak")
        
        # Clean up backup
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_get_existing_schema():
    """Test schema retrieval."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path)
        migrator = DatabaseMigrator(db_path)
        
        conn = sqlite3.connect(db_path)
        schema = migrator.get_existing_schema(conn)
        conn.close()
        
        assert "config" in schema
        assert "membres" in schema
        assert "id" in schema["config"]
        assert "exercice" in schema["config"]
        assert "date" in schema["config"]
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_detect_missing_columns():
    """Test detection of missing columns."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=True)
        migrator = DatabaseMigrator(db_path)
        
        conn = sqlite3.connect(db_path)
        existing_schema = migrator.get_existing_schema(conn)
        conn.close()
        
        missing = migrator.detect_missing_columns(existing_schema)
        
        assert "config" in missing
        assert "membres" in missing
        
        # Check that we detected the missing columns in config
        config_missing_cols = [col[0] for col in missing["config"]]
        assert "but_asso" in config_missing_cols
        assert "cloture" in config_missing_cols
        assert "solde_report" in config_missing_cols
        assert "disponible_banque" in config_missing_cols
        
        # Check that we detected the missing columns in membres
        membres_missing_cols = [col[0] for col in missing["membres"]]
        assert "email" in membres_missing_cols
        assert "classe" in membres_missing_cols
        assert "cotisation" in membres_missing_cols
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_apply_migrations():
    """Test applying migrations."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=True)
        migrator = DatabaseMigrator(db_path)
        
        conn = sqlite3.connect(db_path)
        existing_schema = migrator.get_existing_schema(conn)
        missing = migrator.detect_missing_columns(existing_schema)
        
        result = migrator.apply_migrations(conn, missing)
        
        assert result is True
        
        # Verify columns were added
        cursor = conn.cursor()
        cursor.execute("PRAGMA table_info(config)")
        config_cols = {row[1] for row in cursor.fetchall()}
        
        assert "but_asso" in config_cols
        assert "cloture" in config_cols
        assert "solde_report" in config_cols
        assert "disponible_banque" in config_cols
        
        cursor.execute("PRAGMA table_info(membres)")
        membres_cols = {row[1] for row in cursor.fetchall()}
        
        assert "email" in membres_cols
        assert "classe" in membres_cols
        assert "cotisation" in membres_cols
        
        conn.close()
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_migration_with_data_preservation():
    """Test that migration preserves existing data."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=True)
        
        # Insert some test data
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("INSERT INTO config (exercice, date) VALUES (?, ?)", ("2024-2025", "2024-09-01"))
        cursor.execute("INSERT INTO membres (name, prenom) VALUES (?, ?)", ("Dupont", "Jean"))
        cursor.execute("INSERT INTO membres (name, prenom) VALUES (?, ?)", ("Martin", "Marie"))
        conn.commit()
        conn.close()
        
        # Run migration
        migrator = DatabaseMigrator(db_path)
        migrator.create_backup()
        
        conn = sqlite3.connect(db_path)
        existing_schema = migrator.get_existing_schema(conn)
        missing = migrator.detect_missing_columns(existing_schema)
        migrator.apply_migrations(conn, missing)
        
        # Verify data is still there
        cursor = conn.cursor()
        cursor.execute("SELECT exercice, date, but_asso FROM config")
        row = cursor.fetchone()
        assert row[0] == "2024-2025"
        assert row[1] == "2024-09-01"
        # New column should have default value
        assert row[2] == ""
        
        cursor.execute("SELECT name, prenom, email FROM membres")
        rows = cursor.fetchall()
        assert len(rows) == 2
        assert rows[0][0] == "Dupont"
        assert rows[0][1] == "Jean"
        assert rows[0][2] == ""  # Default value for new column
        
        conn.close()
        
        # Clean up backup
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_no_migration_needed():
    """Test when no migration is needed."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=False)
        migrator = DatabaseMigrator(db_path)
        
        conn = sqlite3.connect(db_path)
        existing_schema = migrator.get_existing_schema(conn)
        missing = migrator.detect_missing_columns(existing_schema)
        
        # Should find no missing columns for these two tables
        if "config" in missing:
            assert len(missing["config"]) == 0
        if "membres" in missing:
            assert len(missing["membres"]) == 0
        
        conn.close()
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_generate_report():
    """Test report generation."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=True)
        migrator = DatabaseMigrator(db_path)
        
        conn = sqlite3.connect(db_path)
        existing_schema = migrator.get_existing_schema(conn)
        missing = migrator.detect_missing_columns(existing_schema)
        conn.close()
        
        with tempfile.NamedTemporaryFile(suffix=".md", delete=False) as report_tmp:
            report_path = report_tmp.name
        
        migrator.generate_report(report_path, missing, True)
        
        assert os.path.exists(report_path)
        
        with open(report_path, 'r') as f:
            content = f.read()
        
        assert "# Database Migration Report" in content
        assert "SUCCESS" in content
        assert "config" in content
        assert "membres" in content
        
        os.unlink(report_path)
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_report_path_in_reports_directory():
    """Test that report is created in the reports directory."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=True)
        migrator = DatabaseMigrator(db_path)
        
        # Run the migration
        success = migrator.run_migration()
        
        assert success is True
        assert migrator.report_path is not None
        
        # Verify the report is in the reports directory
        assert "reports" in migrator.report_path
        assert "migration_report_success_" in migrator.report_path
        assert os.path.exists(migrator.report_path)
        
        # Clean up
        if os.path.exists(migrator.report_path):
            os.unlink(migrator.report_path)
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_failed_migration_report():
    """Test that a failed migration generates an error report."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    # Constants for file permissions
    READ_ONLY_PERMISSIONS = 0o444
    READ_WRITE_PERMISSIONS = 0o644
    
    try:
        create_test_database(db_path, missing_columns=True)
        
        # Make the database read-only to force a migration failure
        os.chmod(db_path, READ_ONLY_PERMISSIONS)
        
        migrator = DatabaseMigrator(db_path)
        success = migrator.run_migration()
        
        # Restore write permissions for cleanup
        os.chmod(db_path, READ_WRITE_PERMISSIONS)
        
        # Migration should fail
        assert success is False
        assert len(migrator.errors) > 0
        assert migrator.report_path is not None
        
        # Verify the report is marked as failed
        assert "migration_report_failed_" in migrator.report_path
        
        # Verify report content contains error information
        if os.path.exists(migrator.report_path):
            with open(migrator.report_path, 'r') as f:
                content = f.read()
            
            assert "FAILED" in content
            assert "## Errors" in content
            assert "## Recommended Actions" in content
            
            # Clean up report
            os.unlink(migrator.report_path)
        
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
    finally:
        if os.path.exists(db_path):
            try:
                os.chmod(db_path, READ_WRITE_PERMISSIONS)
                os.unlink(db_path)
            except Exception:
                pass


def test_report_contains_all_required_sections():
    """Test that generated reports contain all required sections."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=True)
        migrator = DatabaseMigrator(db_path)
        
        success = migrator.run_migration()
        
        assert migrator.report_path is not None
        assert os.path.exists(migrator.report_path)
        
        with open(migrator.report_path, 'r') as f:
            content = f.read()
        
        # Check required sections
        assert "# Database Migration Report" in content
        assert "**Date:**" in content
        assert "**Database:**" in content
        assert "**Status:**" in content
        assert "## Summary" in content
        assert "## Changes Applied" in content
        assert "## Migration Log" in content
        
        # Clean up
        os.unlink(migrator.report_path)
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


if __name__ == "__main__":
    # Run tests
    test_database_migrator_initialization()
    print("âœ“ test_database_migrator_initialization")
    
    test_create_backup()
    print("âœ“ test_create_backup")
    
    test_get_existing_schema()
    print("âœ“ test_get_existing_schema")
    
    test_detect_missing_columns()
    print("âœ“ test_detect_missing_columns")
    
    test_apply_migrations()
    print("âœ“ test_apply_migrations")
    
    test_migration_with_data_preservation()
    print("âœ“ test_migration_with_data_preservation")
    
    test_no_migration_needed()
    print("âœ“ test_no_migration_needed")
    
    test_generate_report()
    print("âœ“ test_generate_report")
    
    test_report_path_in_reports_directory()
    print("âœ“ test_report_path_in_reports_directory")
    
    test_failed_migration_report()
    print("âœ“ test_failed_migration_report")
    
    test_report_contains_all_required_sections()
    print("âœ“ test_report_contains_all_required_sections")
    
    print("\nAll tests passed!")

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./tests/test_db_api_retry.py ===

```python
# -*- coding: utf-8 -*-
"""
Tests for db_api retry logic and error handling.
"""

import pytest
import sqlite3
import time
import tempfile
import os
from unittest.mock import patch, MagicMock
import sys
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from modules.db_api import execute, get_connection, query_one, query_all
from db.db import set_db_file


@pytest.fixture
def temp_db():
    """Create a temporary database for testing."""
    fd, path = tempfile.mkstemp(suffix='.db')
    os.close(fd)
    
    # Set up the database
    set_db_file(path)
    conn = sqlite3.connect(path)
    conn.execute("""
        CREATE TABLE test_table (
            id INTEGER PRIMARY KEY,
            name TEXT,
            value INTEGER
        )
    """)
    conn.execute("INSERT INTO test_table (name, value) VALUES ('test1', 100)")
    conn.execute("INSERT INTO test_table (name, value) VALUES ('test2', 200)")
    conn.commit()
    conn.close()
    
    yield path
    
    # Cleanup
    try:
        os.unlink(path)
    except (OSError, FileNotFoundError):
        # Ignore cleanup errors
        pass


class TestDBApiRetry:
    """Test retry logic in db_api module."""
    
    def test_execute_success_no_retry(self, temp_db):
        """Test that execute works on first attempt when no lock."""
        rows = execute(
            "UPDATE test_table SET value = ? WHERE name = ?",
            (150, 'test1')
        )
        
        assert rows == 1
        
        # Verify the update
        result = query_one("SELECT value FROM test_table WHERE name = ?", ('test1',))
        assert result['value'] == 150
    
    def test_execute_insert(self, temp_db):
        """Test execute with INSERT."""
        rows = execute(
            "INSERT INTO test_table (name, value) VALUES (?, ?)",
            ('test3', 300)
        )
        
        assert rows == 1
        
        # Verify the insert
        result = query_one("SELECT * FROM test_table WHERE name = ?", ('test3',))
        assert result is not None
        assert result['name'] == 'test3'
        assert result['value'] == 300
    
    def test_execute_delete(self, temp_db):
        """Test execute with DELETE."""
        rows = execute("DELETE FROM test_table WHERE name = ?", ('test1',))
        
        assert rows == 1
        
        # Verify the delete
        result = query_one("SELECT * FROM test_table WHERE name = ?", ('test1',))
        assert result is None
    
    def test_execute_without_commit(self, temp_db):
        """Test execute with commit=False."""
        # Note: This is tricky to test as connection is auto-closed
        # Just verify the function accepts the parameter
        rows = execute(
            "UPDATE test_table SET value = ? WHERE name = ?",
            (175, 'test2'),
            commit=True
        )
        
        assert rows == 1
    
    def test_execute_with_custom_retries(self, temp_db):
        """Test that custom retry count is accepted."""
        # This mainly tests the API, not the actual retry behavior
        rows = execute(
            "UPDATE test_table SET value = ? WHERE name = ?",
            (125, 'test1'),
            retries=5,
            retry_delay=0.1
        )
        
        assert rows == 1
    
    @patch('modules.db_api.get_connection')
    def test_execute_retries_on_lock_error(self, mock_get_connection):
        """Test that execute retries on database lock errors."""
        # Create a mock connection that raises OperationalError twice, then succeeds
        attempt_count = [0]
        
        def create_connection():
            conn = MagicMock()
            cursor = MagicMock()
            
            def execute_side_effect(*args, **kwargs):
                attempt_count[0] += 1
                if attempt_count[0] <= 2:
                    # First two attempts fail with lock error
                    raise sqlite3.OperationalError("database is locked")
                # Third attempt succeeds
                return None
            
            cursor.execute.side_effect = execute_side_effect
            cursor.rowcount = 1
            conn.cursor.return_value = cursor
            conn.commit = MagicMock()
            conn.rollback = MagicMock()
            conn.close = MagicMock()
            
            return conn
        
        mock_get_connection.side_effect = create_connection
        
        # Execute should retry and succeed
        start_time = time.time()
        rows = execute(
            "UPDATE test_table SET value = ? WHERE name = ?",
            (200, 'test'),
            retries=3,
            retry_delay=0.1
        )
        elapsed = time.time() - start_time
        
        # Should have succeeded after retries
        assert rows == 1
        assert attempt_count[0] == 3
        
        # Should have taken at least the retry delays (0.1 + 0.2 = 0.3s)
        assert elapsed >= 0.3
    
    @patch('modules.db_api.get_connection')
    def test_execute_fails_after_max_retries(self, mock_get_connection):
        """Test that execute fails after exhausting all retries."""
        def create_failing_connection():
            conn = MagicMock()
            cursor = MagicMock()
            cursor.execute.side_effect = sqlite3.OperationalError("database is locked")
            conn.cursor.return_value = cursor
            conn.close = MagicMock()
            return conn
        
        mock_get_connection.side_effect = create_failing_connection
        
        # Should raise OperationalError after all retries
        with pytest.raises(sqlite3.OperationalError, match="database is locked"):
            execute(
                "UPDATE test_table SET value = ?",
                (300,),
                retries=2,
                retry_delay=0.05
            )
    
    @patch('modules.db_api.get_connection')
    def test_execute_non_lock_error_no_retry(self, mock_get_connection):
        """Test that non-lock errors don't trigger retries."""
        attempt_count = [0]
        
        def create_connection():
            attempt_count[0] += 1
            conn = MagicMock()
            cursor = MagicMock()
            # Raise a non-lock error
            cursor.execute.side_effect = sqlite3.IntegrityError("UNIQUE constraint failed")
            conn.cursor.return_value = cursor
            conn.rollback = MagicMock()
            conn.close = MagicMock()
            return conn
        
        mock_get_connection.side_effect = create_connection
        
        # Should fail immediately without retries
        with pytest.raises(sqlite3.IntegrityError, match="UNIQUE constraint"):
            execute("INSERT INTO test_table VALUES (1, 'dup')", retries=3)
        
        # Should have only tried once (no retries for non-lock errors)
        assert attempt_count[0] == 1
    
    def test_query_one_returns_dict(self, temp_db):
        """Test that query_one returns a dictionary."""
        result = query_one("SELECT * FROM test_table WHERE name = ?", ('test1',))
        
        assert result is not None
        assert isinstance(result, dict)
        assert 'name' in result
        assert 'value' in result
        assert result.get('name') == 'test1'
        assert result.get('value') == 100
    
    def test_query_all_returns_list_of_dicts(self, temp_db):
        """Test that query_all returns a list of dictionaries."""
        results = query_all("SELECT * FROM test_table ORDER BY name")
        
        assert isinstance(results, list)
        assert len(results) == 2
        assert all(isinstance(r, dict) for r in results)
        
        assert results[0].get('name') == 'test1'
        assert results[1].get('name') == 'test2'
    
    def test_query_one_returns_none_for_no_results(self, temp_db):
        """Test that query_one returns None when no results."""
        result = query_one("SELECT * FROM test_table WHERE name = ?", ('nonexistent',))
        assert result is None
    
    def test_query_all_returns_empty_list_for_no_results(self, temp_db):
        """Test that query_all returns empty list when no results."""
        results = query_all("SELECT * FROM test_table WHERE name = ?", ('nonexistent',))
        assert results == []


if __name__ == '__main__':
    pytest.main([__file__, '-v'])

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./tests/test_db_row_utils.py ===

```python
"""
Tests for modules/db_row_utils.py

This test suite validates the _row_to_dict and _rows_to_dicts utility functions.
"""

import unittest
import sqlite3
import tempfile
import os
from modules.db_row_utils import _row_to_dict, _rows_to_dicts


class TestDbRowUtils(unittest.TestCase):
    """Test suite for db_row_utils module."""
    
    def setUp(self):
        """Set up a temporary test database."""
        self.db_fd, self.db_path = tempfile.mkstemp()
        self.conn = sqlite3.connect(self.db_path)
        self.conn.row_factory = sqlite3.Row
        
        # Create test table
        cursor = self.conn.cursor()
        cursor.execute("""
            CREATE TABLE test_table (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                optional_field TEXT,
                number_field INTEGER
            )
        """)
        
        # Insert test data
        cursor.execute(
            "INSERT INTO test_table (name, optional_field, number_field) VALUES (?, ?, ?)",
            ("Test Item 1", "Optional Value", 42)
        )
        cursor.execute(
            "INSERT INTO test_table (name, optional_field, number_field) VALUES (?, ?, ?)",
            ("Test Item 2", None, 100)
        )
        cursor.execute(
            "INSERT INTO test_table (name, number_field) VALUES (?, ?)",
            ("Test Item 3", 200)
        )
        
        self.conn.commit()
    
    def tearDown(self):
        """Clean up the test database."""
        self.conn.close()
        os.close(self.db_fd)
        os.unlink(self.db_path)
    
    def test_row_to_dict_basic(self):
        """Test basic conversion of sqlite3.Row to dict."""
        cursor = self.conn.cursor()
        row = cursor.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Convert to dict
        result = _row_to_dict(row)
        
        # Verify it's a dict
        self.assertIsInstance(result, dict)
        
        # Verify keys and values
        self.assertEqual(result["id"], 1)
        self.assertEqual(result["name"], "Test Item 1")
        self.assertEqual(result["optional_field"], "Optional Value")
        self.assertEqual(result["number_field"], 42)
    
    def test_row_to_dict_with_get_method(self):
        """Test that converted dict supports .get() method."""
        cursor = self.conn.cursor()
        row = cursor.execute("SELECT * FROM test_table WHERE id=2").fetchone()
        
        # Convert to dict
        result = _row_to_dict(row)
        
        # Test .get() with default value
        self.assertEqual(result.get("name"), "Test Item 2")
        # When a field is explicitly NULL in DB, .get() returns None (not the default)
        # because the key exists in the dict, just with None value
        self.assertIsNone(result.get("optional_field"))
        self.assertIsNone(result.get("optional_field", "default"))  # Key exists, value is None
        # For truly nonexistent keys, default is returned
        self.assertEqual(result.get("nonexistent_field", "default"), "default")
    
    def test_row_to_dict_with_none_input(self):
        """Test that _row_to_dict returns None when input is None."""
        result = _row_to_dict(None)
        self.assertIsNone(result)
    
    def test_row_to_dict_with_dict_input(self):
        """Test that _row_to_dict handles dict input (idempotent)."""
        input_dict = {"id": 1, "name": "Test", "value": 42}
        result = _row_to_dict(input_dict)
        
        # Should return the same dict
        self.assertEqual(result, input_dict)
    
    def test_rows_to_dicts_batch_conversion(self):
        """Test batch conversion of multiple rows."""
        cursor = self.conn.cursor()
        rows = cursor.execute("SELECT * FROM test_table ORDER BY id").fetchall()
        
        # Convert all rows
        results = _rows_to_dicts(rows)
        
        # Verify count
        self.assertEqual(len(results), 3)
        
        # Verify all are dicts
        for result in results:
            self.assertIsInstance(result, dict)
        
        # Verify data
        self.assertEqual(results[0]["name"], "Test Item 1")
        self.assertEqual(results[1]["name"], "Test Item 2")
        self.assertEqual(results[2]["name"], "Test Item 3")
        
        # Test .get() on converted dicts
        self.assertEqual(results[0].get("optional_field"), "Optional Value")
        # When field is NULL in DB, .get() returns None (not default) because key exists
        self.assertIsNone(results[1].get("optional_field", "N/A"))
        # Use "or" operator for NULL-coalescing behavior
        self.assertEqual(results[1].get("optional_field") or "N/A", "N/A")
    
    def test_rows_to_dicts_empty_list(self):
        """Test _rows_to_dicts with empty list."""
        result = _rows_to_dicts([])
        self.assertEqual(result, [])
    
    def test_rows_to_dicts_filters_none(self):
        """Test that _rows_to_dicts filters out None values."""
        cursor = self.conn.cursor()
        row1 = cursor.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        row2 = cursor.execute("SELECT * FROM test_table WHERE id=2").fetchone()
        
        # Mix in a None value
        mixed_rows = [row1, None, row2]
        
        # Convert - should filter out None
        results = _rows_to_dicts(mixed_rows)
        
        # Should only have 2 results
        self.assertEqual(len(results), 2)
        self.assertEqual(results[0]["id"], 1)
        self.assertEqual(results[1]["id"], 2)
    
    def test_sqlite_row_bracket_access_still_works(self):
        """Test that original sqlite3.Row bracket access still works before conversion."""
        cursor = self.conn.cursor()
        row = cursor.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Before conversion, bracket access should work
        self.assertEqual(row["name"], "Test Item 1")
        self.assertEqual(row["id"], 1)
    
    def test_sqlite_row_lacks_get_method(self):
        """Verify that sqlite3.Row does not have .get() method."""
        cursor = self.conn.cursor()
        row = cursor.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Confirm Row doesn't have .get() method
        self.assertFalse(hasattr(row, "get") or callable(getattr(row, "get", None)))
    
    def test_conversion_enables_get_method(self):
        """Verify that conversion enables .get() method that was missing."""
        cursor = self.conn.cursor()
        row = cursor.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Convert to dict
        row_dict = _row_to_dict(row)
        
        # Now .get() should work
        self.assertTrue(hasattr(row_dict, "get"))
        self.assertTrue(callable(row_dict.get))
        
        # And it should work as expected
        self.assertEqual(row_dict.get("name"), "Test Item 1")
        self.assertEqual(row_dict.get("nonexistent", "default"), "default")


if __name__ == "__main__":
    unittest.main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./tests/test_inventory_lines_loader.py ===

```python
"""
Tests for modules/inventory_lines_dialog.py

This test suite validates the load_inventory_lines function and error reporting.
"""

import unittest
import sqlite3
import tempfile
import os
import glob
from modules.inventory_lines_dialog import load_inventory_lines, _write_error_report


class TestInventoryLinesLoader(unittest.TestCase):
    """Test suite for inventory_lines_dialog module."""
    
    def setUp(self):
        """Set up a temporary test database with inventory structure."""
        self.db_fd, self.db_path = tempfile.mkstemp()
        self.conn = sqlite3.connect(self.db_path)
        self.conn.row_factory = sqlite3.Row
        
        # Create tables
        cursor = self.conn.cursor()
        
        # Create buvette_inventaires table
        cursor.execute("""
            CREATE TABLE buvette_inventaires (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date_inventaire TEXT NOT NULL,
                event_id INTEGER,
                type_inventaire TEXT NOT NULL,
                commentaire TEXT
            )
        """)
        
        # Create buvette_inventaire_lignes table
        cursor.execute("""
            CREATE TABLE buvette_inventaire_lignes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                inventaire_id INTEGER NOT NULL,
                article_id INTEGER NOT NULL,
                quantite INTEGER NOT NULL,
                commentaire TEXT,
                FOREIGN KEY (inventaire_id) REFERENCES buvette_inventaires(id)
            )
        """)
        
        # Create buvette_articles table for JOIN
        cursor.execute("""
            CREATE TABLE buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                stock INTEGER DEFAULT 0
            )
        """)
        
        # Insert test data
        cursor.execute(
            "INSERT INTO buvette_inventaires (date_inventaire, type_inventaire, commentaire) VALUES (?, ?, ?)",
            ("2024-01-15", "hors_evenement", "Test inventory")
        )
        inventaire_id = cursor.lastrowid
        self.test_inventaire_id = inventaire_id
        
        # Insert articles
        cursor.execute("INSERT INTO buvette_articles (name, categorie, stock) VALUES (?, ?, ?)", ("Coca", "Boisson", 10))
        article1_id = cursor.lastrowid
        cursor.execute("INSERT INTO buvette_articles (name, categorie, stock) VALUES (?, ?, ?)", ("Sprite", "Boisson", 5))
        article2_id = cursor.lastrowid
        
        # Insert inventory lines
        cursor.execute(
            "INSERT INTO buvette_inventaire_lignes (inventaire_id, article_id, quantite) VALUES (?, ?, ?)",
            (inventaire_id, article1_id, 8)
        )
        cursor.execute(
            "INSERT INTO buvette_inventaire_lignes (inventaire_id, article_id, quantite) VALUES (?, ?, ?)",
            (inventaire_id, article2_id, 3)
        )
        
        self.conn.commit()
        
        # Store original DB path for mocking
        self.original_db_path = None
    
    def tearDown(self):
        """Clean up the test database."""
        self.conn.close()
        os.close(self.db_fd)
        os.unlink(self.db_path)
        
        # Clean up any error reports generated during tests
        reports_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "reports")
        if os.path.exists(reports_dir):
            error_reports = glob.glob(os.path.join(reports_dir, "inventory_error_*.txt"))
            for report in error_reports:
                try:
                    os.unlink(report)
                except (OSError, IOError) as e:
                    # Log but don't fail test if cleanup fails
                    print(f"Warning: Could not remove test report {report}: {e}")
    
    def test_load_inventory_lines_returns_dicts(self):
        """Test that load_inventory_lines returns a list of dicts."""
        # Temporarily patch the db module to use our test database
        import modules.buvette_inventaire_db as db_module
        original_get_conn = db_module.get_conn
        
        def mock_get_conn():
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            return conn
        
        try:
            db_module.get_conn = mock_get_conn
            
            # Load inventory lines
            lines = load_inventory_lines(self.test_inventaire_id)
            
            # Verify results
            self.assertIsInstance(lines, list)
            self.assertEqual(len(lines), 2)
            
            # Verify all items are dicts
            for line in lines:
                self.assertIsInstance(line, dict)
                
            # Verify .get() method works
            self.assertEqual(lines[0].get("article_id"), 1)
            self.assertEqual(lines[0].get("quantite"), 8)
            self.assertEqual(lines[1].get("article_id"), 2)
            self.assertEqual(lines[1].get("quantite"), 3)
            
        finally:
            db_module.get_conn = original_get_conn
    
    def test_load_inventory_lines_empty(self):
        """Test loading inventory with no lines."""
        import modules.buvette_inventaire_db as db_module
        original_get_conn = db_module.get_conn
        
        def mock_get_conn():
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            return conn
        
        try:
            db_module.get_conn = mock_get_conn
            
            # Create empty inventory
            cursor = self.conn.cursor()
            cursor.execute(
                "INSERT INTO buvette_inventaires (date_inventaire, type_inventaire) VALUES (?, ?)",
                ("2024-01-20", "hors_evenement")
            )
            empty_inv_id = cursor.lastrowid
            self.conn.commit()
            
            # Load empty inventory
            lines = load_inventory_lines(empty_inv_id)
            
            # Should return empty list
            self.assertEqual(lines, [])
            
        finally:
            db_module.get_conn = original_get_conn
    
    def test_write_error_report(self):
        """Test that error reports are written correctly."""
        # Create a test error
        test_error = ValueError("Test error for reporting")
        
        # Write error report
        _write_error_report(inventaire_id=999, error=test_error, raw_rows=None)
        
        # Check that report was created
        reports_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "reports")
        self.assertTrue(os.path.exists(reports_dir))
        
        # Find the most recent error report
        error_reports = sorted(glob.glob(os.path.join(reports_dir, "inventory_error_*.txt")))
        self.assertGreater(len(error_reports), 0, "Error report should have been created")
        
        # Read the report
        latest_report = error_reports[-1]
        with open(latest_report, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Verify content
        self.assertIn("INVENTORY LOADING ERROR REPORT", content)
        self.assertIn("Inventaire ID: 999", content)
        self.assertIn("ValueError", content)
        self.assertIn("Test error for reporting", content)
        self.assertIn("RECOMMENDED ACTIONS", content)
    
    def test_load_inventory_lines_handles_errors(self):
        """Test that load_inventory_lines properly handles and reports errors."""
        import modules.buvette_inventaire_db as db_module
        original_get_conn = db_module.get_conn
        
        def mock_get_conn_error():
            raise sqlite3.OperationalError("Database is locked")
        
        try:
            db_module.get_conn = mock_get_conn_error
            
            # Attempt to load - should raise error
            with self.assertRaises(sqlite3.OperationalError):
                load_inventory_lines(self.test_inventaire_id)
            
            # Check that error report was created
            reports_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "reports")
            error_reports = glob.glob(os.path.join(reports_dir, "inventory_error_*.txt"))
            self.assertGreater(len(error_reports), 0, "Error report should have been created on failure")
            
        finally:
            db_module.get_conn = original_get_conn


if __name__ == "__main__":
    unittest.main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./tests/test_row_to_dict_conversion.py ===

```python
"""
Test that sqlite3.Row to dict conversion works correctly.

This test validates that the fix for the 'sqlite3.Row' object has no attribute 'get'
error is working correctly by testing the conversion utilities.
"""

import unittest
import sqlite3
import tempfile
import os
from utils.db_helpers import row_to_dict, rows_to_dicts, row_get_safe


class TestRowToDictConversion(unittest.TestCase):
    """Test sqlite3.Row to dict conversion helpers."""
    
    def setUp(self):
        """Create a temporary database for testing."""
        self.db_fd, self.db_path = tempfile.mkstemp(suffix=".db")
        self.conn = sqlite3.connect(self.db_path)
        self.conn.row_factory = sqlite3.Row
        
        # Create test table
        self.conn.execute("""
            CREATE TABLE test_table (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                optional_field TEXT,
                nullable_field TEXT
            )
        """)
        
        # Insert test data
        self.conn.execute("""
            INSERT INTO test_table (id, name, optional_field, nullable_field)
            VALUES (1, 'test1', 'value1', NULL)
        """)
        self.conn.execute("""
            INSERT INTO test_table (id, name, optional_field, nullable_field)
            VALUES (2, 'test2', NULL, 'value2')
        """)
        self.conn.commit()
    
    def tearDown(self):
        """Clean up temporary database."""
        self.conn.close()
        os.close(self.db_fd)
        os.remove(self.db_path)
    
    def test_row_to_dict_basic(self):
        """Test that row_to_dict converts sqlite3.Row to dict."""
        row = self.conn.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Verify it's a Row object
        self.assertIsInstance(row, sqlite3.Row)
        
        # Convert to dict
        row_dict = row_to_dict(row)
        
        # Verify conversion
        self.assertIsInstance(row_dict, dict)
        self.assertEqual(row_dict['id'], 1)
        self.assertEqual(row_dict['name'], 'test1')
        self.assertEqual(row_dict['optional_field'], 'value1')
        self.assertIsNone(row_dict['nullable_field'])
    
    def test_row_to_dict_with_get_method(self):
        """Test that converted dict supports .get() method with default values."""
        row = self.conn.execute("SELECT * FROM test_table WHERE id=2").fetchone()
        row_dict = row_to_dict(row)
        
        # Test .get() with existing key
        self.assertEqual(row_dict.get('name'), 'test2')
        
        # Test .get() with missing key and default
        self.assertEqual(row_dict.get('nonexistent', 'default'), 'default')
        
        # Test .get() with None value
        self.assertIsNone(row_dict.get('optional_field'))
        self.assertEqual(row_dict.get('optional_field', 'default'), None)
    
    def test_row_to_dict_with_none_input(self):
        """Test that row_to_dict handles None input gracefully."""
        result = row_to_dict(None)
        self.assertIsNone(result)
    
    def test_rows_to_dicts_batch_conversion(self):
        """Test that rows_to_dicts converts multiple rows."""
        rows = self.conn.execute("SELECT * FROM test_table").fetchall()
        
        # Verify they're Row objects
        self.assertTrue(all(isinstance(r, sqlite3.Row) for r in rows))
        
        # Convert to dicts
        dicts = rows_to_dicts(rows)
        
        # Verify conversion
        self.assertEqual(len(dicts), 2)
        self.assertTrue(all(isinstance(d, dict) for d in dicts))
        self.assertEqual(dicts[0]['id'], 1)
        self.assertEqual(dicts[1]['id'], 2)
    
    def test_conversion_pattern_consistency(self):
        """Test that the conversion pattern works consistently."""
        row = self.conn.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Test the pattern used in the fix
        row_dict = row_to_dict(row)
        
        self.assertIsInstance(row_dict, dict)
        self.assertEqual(row_dict['id'], 1)
        self.assertEqual(row_dict.get('name'), 'test1')
        
        # Test that the same pattern works for None
        none_dict = row_to_dict(None)
        self.assertIsNone(none_dict)
    
    def test_row_get_safe_helper(self):
        """Test that row_get_safe provides .get()-like interface on Row objects."""
        row = self.conn.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Test with existing column
        self.assertEqual(row_get_safe(row, 'name'), 'test1')
        
        # Test with missing column and default
        self.assertEqual(row_get_safe(row, 'nonexistent', 'default'), 'default')
        
        # Test with None value
        self.assertIsNone(row_get_safe(row, 'nullable_field'))
        self.assertIsNone(row_get_safe(row, 'nullable_field', 'default'))
    
    def test_sqlite_row_does_not_have_get_method(self):
        """Verify that sqlite3.Row indeed lacks the .get() method."""
        row = self.conn.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Verify that calling .get() on Row raises AttributeError
        with self.assertRaises(AttributeError) as ctx:
            row.get('name')
        
        self.assertIn("'sqlite3.Row' object has no attribute 'get'", str(ctx.exception))


if __name__ == '__main__':
    unittest.main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./tests/test_smart_migration.py ===

```python
"""
Tests for smart migration features: fuzzy matching, YAML hints, and column renaming.
"""

import os
import sys
import sqlite3
import tempfile
import yaml
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from scripts.update_db_structure import DatabaseMigrator


def create_test_database_with_typo(db_path):
    """Create a test database with a column name typo (e.g., 'prnom' instead of 'prenom')."""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    cursor.execute("""
        CREATE TABLE membres (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            prnom TEXT,
            emial TEXT
        )
    """)
    
    # Insert test data
    cursor.execute("INSERT INTO membres (name, prnom, emial) VALUES (?, ?, ?)", 
                   ("Dupont", "Jean", "jean@example.com"))
    
    conn.commit()
    conn.close()


def create_yaml_hints(yaml_path):
    """Create a test YAML hints file."""
    hints = {
        "schema_version": "1.0",
        "generated_by": "test",
        "tables": {
            "membres": {
                "expected_columns": {
                    "id": {"type": "INTEGER", "inferred": False},
                    "name": {"type": "TEXT", "inferred": False},
                    "prenom": {"type": "TEXT", "inferred": True},
                    "email": {"type": "TEXT", "inferred": True},
                    "telephone": {"type": "TEXT", "inferred": True},
                }
            }
        }
    }
    
    with open(yaml_path, 'w', encoding='utf-8') as f:
        yaml.dump(hints, f, default_flow_style=False, allow_unicode=True)


def test_fuzzy_column_matching():
    """Test fuzzy matching of column names."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database_with_typo(db_path)
        migrator = DatabaseMigrator(db_path, use_yaml_hints=False)
        
        # Test fuzzy match
        existing_cols = {"id", "name", "prnom", "emial"}
        
        # Should find "prnom" for "prenom"
        match = migrator.fuzzy_match_column("prenom", existing_cols)
        assert match == "prnom", f"Expected 'prnom', got {match}"
        
        # Should find "emial" for "email"
        match = migrator.fuzzy_match_column("email", existing_cols)
        assert match == "emial", f"Expected 'emial', got {match}"
        
        # Should not match unrelated columns
        match = migrator.fuzzy_match_column("telephone", existing_cols)
        assert match is None, f"Expected None, got {match}"
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_case_insensitive_matching():
    """Test case-insensitive column matching."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE test_table (
                ID INTEGER PRIMARY KEY,
                Name TEXT,
                EMail TEXT
            )
        """)
        conn.commit()
        conn.close()
        
        migrator = DatabaseMigrator(db_path, use_yaml_hints=False)
        existing_cols = {"ID", "Name", "EMail"}
        
        # Should find exact match (case-insensitive)
        match = migrator.fuzzy_match_column("id", existing_cols)
        assert match == "ID"
        
        match = migrator.fuzzy_match_column("name", existing_cols)
        assert match == "Name"
        
        match = migrator.fuzzy_match_column("email", existing_cols)
        assert match == "EMail"
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_yaml_hints_loading():
    """Test loading schema hints from YAML."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    with tempfile.NamedTemporaryFile(suffix=".yaml", delete=False, mode='w') as yaml_tmp:
        yaml_path = yaml_tmp.name
    
    try:
        create_test_database_with_typo(db_path)
        create_yaml_hints(yaml_path)
        
        migrator = DatabaseMigrator(db_path, use_yaml_hints=True)
        success = migrator.load_schema_hints(yaml_path)
        
        assert success is True
        assert migrator.schema_hints is not None
        assert "tables" in migrator.schema_hints
        assert "membres" in migrator.schema_hints["tables"]
        
        # Test getting column type from hints
        col_type = migrator.get_column_type_from_hints("membres", "email")
        assert col_type == "TEXT"
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)
        if os.path.exists(yaml_path):
            os.unlink(yaml_path)


def test_column_rename_support_check():
    """Test checking SQLite RENAME COLUMN support."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database_with_typo(db_path)
        migrator = DatabaseMigrator(db_path, use_yaml_hints=False)
        
        conn = sqlite3.connect(db_path)
        supports_rename = migrator.check_rename_column_support(conn)
        conn.close()
        
        # Modern SQLite should support RENAME COLUMN
        assert isinstance(supports_rename, bool)
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_migration_with_fuzzy_match_and_rename():
    """Test migration with fuzzy matching and column renaming."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    with tempfile.NamedTemporaryFile(suffix=".yaml", delete=False, mode='w') as yaml_tmp:
        yaml_path = yaml_tmp.name
    
    try:
        create_test_database_with_typo(db_path)
        create_yaml_hints(yaml_path)
        
        migrator = DatabaseMigrator(db_path, use_yaml_hints=True)
        migrator.load_schema_hints(yaml_path)
        migrator.create_backup()
        
        conn = sqlite3.connect(db_path)
        
        # Check SQLite version for RENAME support
        supports_rename = migrator.check_rename_column_support(conn)
        
        existing_schema = migrator.get_existing_schema(conn)
        missing = migrator.detect_missing_columns(existing_schema)
        
        # Should detect missing columns with fuzzy matches
        assert "membres" in missing
        
        # Find the entries for prenom and email
        membres_missing = missing["membres"]
        prenom_entry = next((e for e in membres_missing if e[0] == "prenom"), None)
        email_entry = next((e for e in membres_missing if e[0] == "email"), None)
        
        assert prenom_entry is not None, "prenom should be detected as missing"
        assert prenom_entry[3] == "prnom", "Should find 'prnom' as fuzzy match for 'prenom'"
        
        assert email_entry is not None, "email should be detected as missing"
        assert email_entry[3] == "emial", "Should find 'emial' as fuzzy match for 'email'"
        
        # Apply migrations
        success = migrator.apply_migrations(conn, missing)
        assert success is True
        
        # Verify the result
        cursor = conn.cursor()
        cursor.execute("PRAGMA table_info(membres)")
        columns = {row[1] for row in cursor.fetchall()}
        
        # Should have correct column names now
        assert "prenom" in columns or "prnom" in columns
        assert "email" in columns or "emial" in columns
        
        # If rename was supported, old names should be gone
        if supports_rename:
            assert "prenom" in columns, "prenom should exist after rename"
            assert "email" in columns, "email should exist after rename"
        
        # Verify data preservation
        cursor.execute("SELECT name FROM membres WHERE id = 1")
        row = cursor.fetchone()
        assert row[0] == "Dupont", "Data should be preserved"
        
        conn.close()
        
        # Clean up backup
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)
        if os.path.exists(yaml_path):
            os.unlink(yaml_path)


def test_migration_without_yaml_hints():
    """Test that migration still works without YAML hints (using only REFERENCE_SCHEMA)."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE config (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                exercice TEXT
            )
        """)
        conn.commit()
        conn.close()
        
        # Run migration without YAML hints
        migrator = DatabaseMigrator(db_path, use_yaml_hints=False)
        success = migrator.run_migration()
        
        # Should still work using REFERENCE_SCHEMA
        assert success is True
        
        # Verify columns were added
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("PRAGMA table_info(config)")
        columns = {row[1] for row in cursor.fetchall()}
        conn.close()
        
        # Should have added missing columns from REFERENCE_SCHEMA
        assert "date" in columns
        assert "but_asso" in columns
        
        # Clean up
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
        if migrator.report_path and os.path.exists(migrator.report_path):
            os.unlink(migrator.report_path)
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_type_inference():
    """Test that column types are correctly inferred from YAML hints."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    with tempfile.NamedTemporaryFile(suffix=".yaml", delete=False, mode='w') as yaml_tmp:
        yaml_path = yaml_tmp.name
    
    try:
        # Create a minimal database
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("CREATE TABLE test_table (id INTEGER PRIMARY KEY)")
        conn.commit()
        conn.close()
        
        # Create YAML with various types
        hints = {
            "schema_version": "1.0",
            "tables": {
                "test_table": {
                    "expected_columns": {
                        "id": {"type": "INTEGER", "inferred": False},
                        "montant": {"type": "REAL", "inferred": True},
                        "quantite": {"type": "INTEGER", "inferred": True},
                        "description": {"type": "TEXT", "inferred": True},
                    }
                }
            }
        }
        
        with open(yaml_path, 'w', encoding='utf-8') as f:
            yaml.dump(hints, f)
        
        migrator = DatabaseMigrator(db_path, use_yaml_hints=True)
        migrator.load_schema_hints(yaml_path)
        
        # Check type retrieval
        assert migrator.get_column_type_from_hints("test_table", "montant") == "REAL"
        assert migrator.get_column_type_from_hints("test_table", "quantite") == "INTEGER"
        assert migrator.get_column_type_from_hints("test_table", "description") == "TEXT"
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)
        if os.path.exists(yaml_path):
            os.unlink(yaml_path)


if __name__ == "__main__":
    # Run tests
    test_fuzzy_column_matching()
    print("âœ“ test_fuzzy_column_matching")
    
    test_case_insensitive_matching()
    print("âœ“ test_case_insensitive_matching")
    
    test_yaml_hints_loading()
    print("âœ“ test_yaml_hints_loading")
    
    test_column_rename_support_check()
    print("âœ“ test_column_rename_support_check")
    
    test_migration_with_fuzzy_match_and_rename()
    print("âœ“ test_migration_with_fuzzy_match_and_rename")
    
    test_migration_without_yaml_hints()
    print("âœ“ test_migration_without_yaml_hints")
    
    test_type_inference()
    print("âœ“ test_type_inference")
    
    print("\nAll smart migration tests passed!")

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./tests/test_startup_schema_check.py ===

```python
"""
Tests for the startup_schema_check module.
"""

import os
import sys
import sqlite3
import tempfile
from pathlib import Path
from unittest.mock import MagicMock

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

# Mock tkinter before importing startup_schema_check
sys.modules['tkinter'] = MagicMock()

from ui.startup_schema_check import (
    get_expected_schema,
    get_real_schema,
    detect_missing_columns
)


def test_get_expected_schema():
    """Test that expected schema is loaded from REFERENCE_SCHEMA."""
    expected = get_expected_schema()
    
    # Should contain tables from REFERENCE_SCHEMA
    assert isinstance(expected, dict)
    assert len(expected) > 0
    
    # Check some known tables exist
    if "events" in expected:
        assert isinstance(expected["events"], set)
        assert "id" in expected["events"]
        assert "name" in expected["events"]


def test_get_real_schema_with_database():
    """Test reading real schema from a database."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        # Create a test database
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE test_table (
                id INTEGER PRIMARY KEY,
                name TEXT,
                email TEXT
            )
        """)
        conn.commit()
        conn.close()
        
        # Get the schema
        schema = get_real_schema(db_path)
        
        assert "test_table" in schema
        assert "id" in schema["test_table"]
        assert "name" in schema["test_table"]
        assert "email" in schema["test_table"]
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_get_real_schema_nonexistent_database():
    """Test that get_real_schema handles nonexistent databases."""
    schema = get_real_schema("/nonexistent/database.db")
    assert schema == {}


def test_detect_missing_columns_no_missing():
    """Test when no columns are missing."""
    expected = {
        "users": {"id", "name", "email"}
    }
    real = {
        "users": {"id", "name", "email", "created_at"}
    }
    
    missing = detect_missing_columns(expected, real)
    
    # No missing columns (real has all expected columns and more)
    assert "users" not in missing or len(missing["users"]) == 0


def test_detect_missing_columns_with_missing():
    """Test when columns are missing."""
    expected = {
        "users": {"id", "name", "email", "phone"}
    }
    real = {
        "users": {"id", "name"}
    }
    
    missing = detect_missing_columns(expected, real)
    
    assert "users" in missing
    assert "email" in missing["users"]
    assert "phone" in missing["users"]


def test_detect_missing_columns_table_not_exists():
    """Test when entire table doesn't exist in real schema."""
    expected = {
        "users": {"id", "name"},
        "products": {"id", "title"}
    }
    real = {
        "users": {"id", "name"}
    }
    
    missing = detect_missing_columns(expected, real)
    
    # products table doesn't exist, so should not be in missing
    # (update_db_structure doesn't create tables)
    assert "products" not in missing


def test_detect_missing_columns_complex():
    """Test with multiple tables and various missing columns."""
    expected = {
        "config": {"id", "exercice", "date", "but_asso"},
        "membres": {"id", "name", "email", "phone"},
        "events": {"id", "name", "date"}
    }
    real = {
        "config": {"id", "exercice"},  # Missing: date, but_asso
        "membres": {"id", "name"},     # Missing: email, phone
        "events": {"id", "name", "date"}  # Complete
    }
    
    missing = detect_missing_columns(expected, real)
    
    assert "config" in missing
    assert set(missing["config"]) == {"date", "but_asso"}
    
    assert "membres" in missing
    assert set(missing["membres"]) == {"email", "phone"}
    
    # events is complete
    assert "events" not in missing or len(missing["events"]) == 0


def test_integration_with_test_database():
    """Integration test with a real test database."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        # Create a test database with missing columns
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE events (
                id INTEGER PRIMARY KEY,
                name TEXT,
                date TEXT
            )
        """)
        conn.commit()
        conn.close()
        
        # Get expected schema (will include 'description' for events)
        expected = get_expected_schema()
        
        # Get real schema
        real = get_real_schema(db_path)
        
        # Detect missing columns
        missing = detect_missing_columns(expected, real)
        
        # Should detect that 'description' is missing if it's in REFERENCE_SCHEMA
        if "events" in expected and "description" in expected["events"]:
            assert "events" in missing
            assert "description" in missing["events"]
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


if __name__ == "__main__":
    # Run tests
    test_get_expected_schema()
    print("âœ“ test_get_expected_schema")
    
    test_get_real_schema_with_database()
    print("âœ“ test_get_real_schema_with_database")
    
    test_get_real_schema_nonexistent_database()
    print("âœ“ test_get_real_schema_nonexistent_database")
    
    test_detect_missing_columns_no_missing()
    print("âœ“ test_detect_missing_columns_no_missing")
    
    test_detect_missing_columns_with_missing()
    print("âœ“ test_detect_missing_columns_with_missing")
    
    test_detect_missing_columns_table_not_exists()
    print("âœ“ test_detect_missing_columns_table_not_exists")
    
    test_detect_missing_columns_complex()
    print("âœ“ test_detect_missing_columns_complex")
    
    test_integration_with_test_database()
    print("âœ“ test_integration_with_test_database")
    
    print("\nAll tests passed!")

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./tests/test_utils.py ===

```python
import unittest
from utils.validation import is_email, is_number, is_integer, is_required

class TestValidation(unittest.TestCase):
    def test_is_email(self):
        self.assertTrue(is_email("test@ex.com"))
        self.assertFalse(is_email("toto"))
        self.assertFalse(is_email("a@b"))
    def test_is_number(self):
        self.assertTrue(is_number("3.14"))
        self.assertTrue(is_number("12"))
        self.assertFalse(is_number("abc"))
    def test_is_integer(self):
        self.assertTrue(is_integer("10"))
        self.assertTrue(is_integer(5))
        self.assertFalse(is_integer("5.7"))
    def test_is_required(self):
        self.assertTrue(is_required("a"))
        self.assertFalse(is_required(""))
        self.assertFalse(is_required(None))

if __name__ == "__main__":
    unittest.main()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./ui/article_dialog.py ===

```python
"""
Article Dialog for Buvette Articles Management.

This dialog allows creating and editing buvette articles with all their properties
including the purchase price per unit. This is a standalone UI component that can
be used independently from the main buvette module.
"""

import tkinter as tk
from tkinter import ttk, messagebox
from lib.db_articles import (
    get_article_by_id, 
    create_article, 
    get_article_by_name
)
from modules.buvette_db import update_article

class ArticleDialog(tk.Toplevel):
    """
    Dialog for creating/editing a buvette article.
    
    Features:
    - Name, category, unit, capacity fields
    - Purchase price per unit field (new feature)
    - Comment field
    - Validation and save to database
    """
    
    def __init__(self, master, article_id=None, on_save=None):
        """
        Initialize the article dialog.
        
        Args:
            master: Parent window
            article_id: ID of article to edit (None for new article)
            on_save: Callback function to call after successful save
        """
        super().__init__(master)
        self.title("Article buvette")
        self.geometry("380x450")
        self.on_save = on_save
        self.article_id = article_id
        
        # Variables for form fields
        self.nom_var = tk.StringVar()
        self.categorie_var = tk.StringVar()
        self.unite_var = tk.StringVar()
        self.contenance_var = tk.StringVar()
        self.purchase_price_var = tk.DoubleVar()
        self.comment_var = tk.StringVar()
        
        self._create_form()
        
        # Load existing article if editing
        if article_id:
            self._load_article()
    
    def _create_form(self):
        """Create the form fields."""
        # Name field
        tk.Label(self, text="Nom :").pack(pady=(10, 4))
        tk.Entry(self, textvariable=self.nom_var, width=30).pack()
        
        # Category field
        tk.Label(self, text="CatÃ©gorie :").pack(pady=(8, 4))
        tk.Entry(self, textvariable=self.categorie_var, width=25).pack()
        
        # Unit field
        tk.Label(self, text="UnitÃ© (ex: canette, bouteille...) :").pack(pady=(8, 4))
        tk.Entry(self, textvariable=self.unite_var, width=18).pack()
        
        # Capacity field with dropdown
        tk.Label(self, text="Contenance :").pack(pady=(8, 4))
        contenance_options = ["0.25L", "0.33L", "0.5L", "0.75L", "1L", "1.5L", "2L"]
        self.contenance_cb = ttk.Combobox(
            self, 
            textvariable=self.contenance_var, 
            values=contenance_options,
            state="readonly", 
            width=10
        )
        self.contenance_cb.pack()
        
        # Purchase price field (NEW FEATURE)
        tk.Label(self, text="Prix achat / unitÃ© (â‚¬) :").pack(pady=(8, 4))
        purchase_price_entry = tk.Entry(self, textvariable=self.purchase_price_var, width=15)
        purchase_price_entry.pack()
        
        # Comment field
        tk.Label(self, text="Commentaire :").pack(pady=(8, 4))
        tk.Entry(self, textvariable=self.comment_var, width=35).pack()
        
        # Buttons
        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=20)
        tk.Button(btn_frame, text="Enregistrer", command=self._save, width=12).pack(side=tk.LEFT, padx=12)
        tk.Button(btn_frame, text="Annuler", command=self.destroy, width=12).pack(side=tk.RIGHT, padx=12)
    
    def _load_article(self):
        """Load article data if editing existing article."""
        try:
            article = get_article_by_id(self.article_id)
            if article:
                self.nom_var.set(article["name"] if article["name"] else "")
                self.categorie_var.set(article["categorie"] if article["categorie"] else "")
                self.unite_var.set(article["unite"] if article["unite"] else "")
                self.contenance_var.set(article["contenance"] if article["contenance"] else "")
                self.comment_var.set(article["commentaire"] if article["commentaire"] else "")
                
                # Load purchase price if it exists
                if "purchase_price" in article.keys() and article["purchase_price"] is not None:
                    self.purchase_price_var.set(article["purchase_price"])
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors du chargement de l'article: {e}")
    
    def _save(self):
        """Save the article to database."""
        # Validate name (required field)
        name = self.nom_var.get().strip()
        if not name:
            messagebox.showerror("Erreur", "Le nom de l'article est obligatoire.")
            return
        
        # Get other fields
        categorie = self.categorie_var.get().strip()
        unite = self.unite_var.get().strip()
        contenance = self.contenance_var.get().strip()
        comment = self.comment_var.get().strip()
        
        # Get purchase price, handling empty or invalid input
        try:
            purchase_price = self.purchase_price_var.get()
            # If the value is 0.0, treat as None (empty field)
            if purchase_price == 0.0:
                purchase_price = None
        except tk.TclError:
            # TclError occurs when the DoubleVar field is empty or contains invalid data
            purchase_price = None
        
        try:
            if self.article_id:
                # Update existing article
                update_article(
                    self.article_id, 
                    name, 
                    categorie, 
                    unite, 
                    comment, 
                    contenance, 
                    purchase_price
                )
            else:
                # Create new article
                # Check if article with same name already exists
                existing = get_article_by_name(name)
                if existing:
                    messagebox.showerror(
                        "Erreur", 
                        f"Un article avec le nom '{name}' existe dÃ©jÃ ."
                    )
                    return
                
                create_article(
                    name, 
                    categorie, 
                    unite, 
                    contenance, 
                    comment, 
                    stock=0,  # Initial stock is 0
                    purchase_price=purchase_price
                )
            
            # Call callback if provided
            if self.on_save:
                self.on_save()
            
            self.destroy()
            
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de l'enregistrement: {e}")

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./ui/inventory_lines_dialog.py ===

```python
"""
Detailed Inventory Lines Dialog for Buvette.

This dialog provides a comprehensive interface for creating detailed inventories with:
- Treeview showing inventory lines with article details
- Add/remove article lines
- Sub-dialog to add articles (existing or new)
- Automatic stock update on save
- Purchase price tracking

This is a separate interface from the existing simple inventory dialog.
"""

import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from datetime import date
from lib.db_articles import (
    get_all_articles,
    get_article_by_id,
    get_article_by_name,
    create_article,
    update_article_stock,
    update_article_purchase_price
)
from modules.buvette_inventaire_db import (
    insert_inventaire,
    update_inventaire,
    list_events,
    list_lignes_inventaire
)
from db.db import get_connection
from utils.app_logger import get_logger
from modules.db_row_utils import _row_to_dict, _rows_to_dicts
from modules.inventory_lines_dialog import load_inventory_lines

logger = get_logger("inventory_lines_dialog")

class InventoryLinesDialog(tk.Toplevel):
    """
    Dialog for creating a detailed inventory with dynamic lines.
    
    This provides a more advanced interface than the simple inventory dialog,
    with support for:
    - Adding existing articles or creating new ones
    - Tracking quantities counted during inventory
    - Automatic stock updates
    - Purchase price management
    """
    
    def __init__(self, master, edit_inventory=None):
        """
        Initialize the detailed inventory dialog.
        
        Args:
            master: Parent window
            edit_inventory: Optional dict with inventory data for edit mode (keys: id, date_inventaire, type_inventaire, event_id, commentaire)
        """
        super().__init__(master)
        self.edit_inventory = edit_inventory
        self.inventory_id = edit_inventory["id"] if edit_inventory else None
        
        if edit_inventory:
            self.title("Modifier inventaire dÃ©taillÃ©")
        else:
            self.title("Nouvel inventaire dÃ©taillÃ©")
        self.geometry("950x700")
        
        # Variables for header fields
        self.date_var = tk.StringVar(value=str(date.today()))
        self.type_var = tk.StringVar(value="hors_evenement")
        self.evt_var = tk.StringVar()
        self.comment_var = tk.StringVar()
        
        # Inventory lines data: list of dicts with keys: article_id, name, categorie, contenance, quantite, purchase_price
        self.inventory_lines = []
        
        self._create_header_section()
        self._create_lines_section()
        self._create_button_section()
        
        # Load existing inventory data if in edit mode
        if edit_inventory:
            self._load_inventory_data()
        
    def _create_header_section(self):
        """Create the header section with date, type, event, and comment fields."""
        frm = tk.Frame(self)
        frm.pack(padx=16, pady=12, fill=tk.X)
        
        tk.Label(frm, text="Inventaire dÃ©taillÃ©", font=("Arial", 14, "bold")).pack(anchor="w", pady=(0, 10))
        
        # Row 0: Date and Type
        row0 = tk.Frame(frm)
        row0.pack(fill=tk.X, pady=2)
        
        tk.Label(row0, text="Date :").pack(side=tk.LEFT, padx=(0, 5))
        tk.Entry(row0, textvariable=self.date_var, width=15).pack(side=tk.LEFT)
        
        tk.Label(row0, text="Type :").pack(side=tk.LEFT, padx=(30, 5))
        type_combo = ttk.Combobox(
            row0,
            textvariable=self.type_var,
            values=["avant", "apres", "hors_evenement"],
            width=16,
            state="readonly"
        )
        type_combo.pack(side=tk.LEFT)
        
        # Row 1: Event
        row1 = tk.Frame(frm)
        row1.pack(fill=tk.X, pady=5)
        
        tk.Label(row1, text="Ã‰vÃ©nement :").pack(side=tk.LEFT, padx=(0, 5))
        self.evt_cb = ttk.Combobox(row1, textvariable=self.evt_var, width=40, state="readonly")
        try:
            events = list_events()
            # Convert Row objects to dicts for safe access
            events = _rows_to_dicts(events)
            self.evt_cb["values"] = [""] + [f"{r['id']} - {r['name']}" for r in events]
        except Exception as e:
            logger.warning(f"Could not load events: {e}")
            self.evt_cb["values"] = [""]
        self.evt_cb.pack(side=tk.LEFT)
        
        # Row 2: Comment
        row2 = tk.Frame(frm)
        row2.pack(fill=tk.X, pady=2)
        
        tk.Label(row2, text="Commentaire :").pack(side=tk.LEFT, padx=(0, 5))
        tk.Entry(row2, textvariable=self.comment_var, width=60).pack(side=tk.LEFT, fill=tk.X, expand=True)
    
    def _create_lines_section(self):
        """Create the lines section with Treeview and buttons."""
        frame = tk.Frame(self)
        frame.pack(padx=16, pady=10, fill=tk.BOTH, expand=True)
        
        tk.Label(frame, text="Articles inventoriÃ©s", font=("Arial", 11, "bold")).pack(anchor="w", pady=(0, 5))
        
        # Treeview for article lines
        tree_frame = tk.Frame(frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, pady=(5, 0))
        
        scrollbar = ttk.Scrollbar(tree_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Columns: name, categorie, contenance, quantite, purchase_price
        self.lines_tree = ttk.Treeview(
            tree_frame,
            columns=("name", "categorie", "contenance", "quantite", "purchase_price"),
            show="headings",
            yscrollcommand=scrollbar.set
        )
        scrollbar.config(command=self.lines_tree.yview)
        
        # Configure columns
        self.lines_tree.column("name", width=200, anchor="w")
        self.lines_tree.column("categorie", width=150, anchor="w")
        self.lines_tree.column("contenance", width=100, anchor="center")
        self.lines_tree.column("quantite", width=100, anchor="center")
        self.lines_tree.column("purchase_price", width=120, anchor="center")
        
        # Set headings
        self.lines_tree.heading("name", text="Article")
        self.lines_tree.heading("categorie", text="CatÃ©gorie")
        self.lines_tree.heading("contenance", text="Contenance")
        self.lines_tree.heading("quantite", text="QuantitÃ© comptÃ©e")
        self.lines_tree.heading("purchase_price", text="Prix achat (â‚¬)")
        
        self.lines_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Buttons for add/remove
        btn_frame = tk.Frame(frame)
        btn_frame.pack(fill=tk.X, pady=(8, 0))
        tk.Button(
            btn_frame, 
            text="Ajouter article", 
            command=self._add_article_line,
            width=15
        ).pack(side=tk.LEFT, padx=5)
        tk.Button(
            btn_frame, 
            text="Supprimer ligne", 
            command=self._remove_line,
            width=15
        ).pack(side=tk.LEFT, padx=5)
        tk.Button(
            btn_frame,
            text="Modifier ligne",
            command=self._edit_line,
            width=15
        ).pack(side=tk.LEFT, padx=5)
    
    def _create_button_section(self):
        """Create the bottom button section."""
        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=16)
        tk.Button(
            btn_frame, 
            text="Enregistrer", 
            command=self._save,
            width=14,
            bg="#4CAF50",
            fg="white",
            font=("Arial", 10, "bold")
        ).pack(side=tk.LEFT, padx=10)
        tk.Button(
            btn_frame, 
            text="Annuler", 
            command=self.destroy,
            width=14
        ).pack(side=tk.LEFT, padx=10)
    
    def _add_article_line(self):
        """Open sub-dialog to add an article line."""
        AddArticleLineDialog(self, self._on_article_added)
    
    def _on_article_added(self, article_data):
        """
        Callback when an article line is added.
        
        Args:
            article_data: Dict with keys: article_id, name, categorie, contenance, quantite, purchase_price
        """
        # Check if article already exists in the list
        for i, line in enumerate(self.inventory_lines):
            if line["article_id"] == article_data["article_id"]:
                # Update existing line
                self.inventory_lines[i] = article_data
                self._refresh_tree()
                return
        
        # Add new line
        self.inventory_lines.append(article_data)
        self._refresh_tree()
    
    def _refresh_tree(self):
        """Refresh the treeview with current inventory lines."""
        # Clear tree
        for item in self.lines_tree.get_children():
            self.lines_tree.delete(item)
        
        # Add lines
        for line in self.inventory_lines:
            purchase_price_display = ""
            if line.get("purchase_price") is not None:
                purchase_price_display = f"{line['purchase_price']:.2f}"
            
            self.lines_tree.insert(
                "", 
                "end",
                values=(
                    line["name"],
                    line.get("categorie", ""),
                    line.get("contenance", ""),
                    line["quantite"],
                    purchase_price_display
                )
            )
    
    def _remove_line(self):
        """Remove the selected line from inventory."""
        selection = self.lines_tree.selection()
        if not selection:
            messagebox.showwarning("SÃ©lection", "Veuillez sÃ©lectionner une ligne Ã  supprimer.")
            return
        
        # Get the index of selected item
        item = selection[0]
        index = self.lines_tree.index(item)
        
        # Remove from data
        if 0 <= index < len(self.inventory_lines):
            del self.inventory_lines[index]
            self._refresh_tree()
    
    def _edit_line(self):
        """Edit the selected line."""
        selection = self.lines_tree.selection()
        if not selection:
            messagebox.showwarning("SÃ©lection", "Veuillez sÃ©lectionner une ligne Ã  modifier.")
            return
        
        # Get the index of selected item
        item = selection[0]
        index = self.lines_tree.index(item)
        
        if 0 <= index < len(self.inventory_lines):
            line_data = self.inventory_lines[index]
            # Open edit dialog with current data
            AddArticleLineDialog(self, self._on_article_added, edit_data=line_data)
    
    def _load_inventory_data(self):
        """Load existing inventory data for edit mode."""
        if not self.edit_inventory:
            return
        
        try:
            # Load header data
            self.date_var.set(self.edit_inventory.get("date_inventaire", ""))
            self.type_var.set(self.edit_inventory.get("type_inventaire", "hors_evenement"))
            self.comment_var.set(self.edit_inventory.get("commentaire", ""))
            
            # Load event if present
            event_id = self.edit_inventory.get("event_id")
            if event_id:
                # Try to find and select the event in combobox
                for val in self.evt_cb["values"]:
                    if val and str(event_id) in val:
                        self.evt_var.set(val)
                        break
            
            # Load inventory lines using robust helper with error reporting
            lines = load_inventory_lines(self.inventory_id)
            
            for line_dict in lines:
                # line_dict is already a dict from load_inventory_lines
                article_id = line_dict.get("article_id")
                if not article_id:
                    logger.warning(f"Skipping line with missing article_id: {line_dict}")
                    continue
                
                # Get article details
                article = get_article_by_id(article_id)
                if article:
                    # Convert article Row to dict for safe .get() access
                    article_dict = _row_to_dict(article)
                    
                    article_data = {
                        "article_id": article_id,
                        "name": article_dict.get("name", ""),
                        "categorie": article_dict.get("categorie", ""),
                        "contenance": article_dict.get("contenance", ""),
                        "quantite": line_dict.get("quantite", 0),
                        "purchase_price": article_dict.get("purchase_price")
                    }
                    self.inventory_lines.append(article_data)
            
            self._refresh_tree()
            
        except Exception as e:
            logger.error(f"Error loading inventory data: {e}")
            messagebox.showerror("Erreur", f"Erreur lors du chargement de l'inventaire: {e}")
    
    def _save(self):
        """Save the inventory to database."""
        # Validate
        date_str = self.date_var.get().strip()
        if not date_str:
            messagebox.showerror("Erreur", "La date est obligatoire.")
            return
        
        type_inv = self.type_var.get().strip()
        if type_inv not in ["avant", "apres", "hors_evenement"]:
            messagebox.showerror("Erreur", "Le type d'inventaire doit Ãªtre: avant, apres ou hors_evenement.")
            return
        
        if not self.inventory_lines:
            messagebox.showwarning("Attention", "L'inventaire ne contient aucun article.")
            return
        
        # Get event_id if selected
        evt_id = None
        evt_str = self.evt_var.get().strip()
        if evt_str:
            try:
                evt_id = int(evt_str.split(" - ")[0])
            except:
                pass
        
        comment = self.comment_var.get().strip()
        
        try:
            conn = get_connection()
            cursor = conn.cursor()
            
            if self.inventory_id:
                # Edit mode: Update existing inventory
                from modules.buvette_inventaire_db import update_inventaire, delete_ligne_inventaire
                
                # Update inventory header
                update_inventaire(self.inventory_id, date_str, evt_id, type_inv, comment)
                
                # Delete existing lines
                cursor.execute("DELETE FROM buvette_inventaire_lignes WHERE inventaire_id=?", (self.inventory_id,))
                
                inv_id = self.inventory_id
            else:
                # Insert mode: Create new inventory
                inv_id = insert_inventaire(date_str, evt_id, type_inv, comment)
            
            # Insert/update inventory lines and update stock
            for line in self.inventory_lines:
                article_id = line["article_id"]
                quantite = line["quantite"]
                
                # Insert line (with commentaire column for consistency)
                cursor.execute("""
                    INSERT INTO buvette_inventaire_lignes (inventaire_id, article_id, quantite, commentaire)
                    VALUES (?, ?, ?, ?)
                """, (inv_id, article_id, quantite, ""))
                
                # Update article stock (stock = quantity counted)
                update_article_stock(article_id, quantite)
                
                # Update purchase price if provided
                if line.get("purchase_price") is not None:
                    update_article_purchase_price(article_id, line["purchase_price"])
            
            conn.commit()
            conn.close()
            
            action = "modifiÃ©" if self.inventory_id else "enregistrÃ©"
            messagebox.showinfo(
                "SuccÃ¨s", 
                f"Inventaire {action} avec succÃ¨s!\n{len(self.inventory_lines)} article(s) traitÃ©(s)."
            )
            self.destroy()
            
        except Exception as e:
            logger.error(f"Error saving inventory: {e}")
            messagebox.showerror("Erreur", f"Erreur lors de l'enregistrement: {e}")


class AddArticleLineDialog(tk.Toplevel):
    """
    Sub-dialog to add an article line to the inventory.
    
    Allows:
    - Selecting an existing article
    - Creating a new article
    - Entering quantity counted
    - Optionally entering/updating purchase price
    """
    
    def __init__(self, master, callback, edit_data=None):
        """
        Initialize the add article line dialog.
        
        Args:
            master: Parent window
            callback: Function to call with article data when done
            edit_data: Optional dict with existing line data for editing
        """
        super().__init__(master)
        self.title("Ajouter/Modifier article inventaire")
        self.geometry("450x500")
        self.callback = callback
        self.edit_data = edit_data
        
        # Variables
        self.mode_var = tk.StringVar(value="existing")  # "existing" or "new"
        self.article_var = tk.StringVar()
        self.new_name_var = tk.StringVar()
        self.new_categorie_var = tk.StringVar()
        self.new_contenance_var = tk.StringVar()
        self.quantite_var = tk.IntVar(value=0)
        self.purchase_price_var = tk.DoubleVar()
        
        # Article lookup dict
        self.articles_dict = {}
        
        self._create_ui()
        
        # Load existing data if editing
        if edit_data:
            self._load_edit_data()
    
    def _create_ui(self):
        """Create the UI elements."""
        # Mode selection
        mode_frame = tk.LabelFrame(self, text="Mode", padx=10, pady=10)
        mode_frame.pack(padx=15, pady=10, fill=tk.X)
        
        tk.Radiobutton(
            mode_frame,
            text="SÃ©lectionner un article existant",
            variable=self.mode_var,
            value="existing",
            command=self._on_mode_change
        ).pack(anchor="w")
        
        tk.Radiobutton(
            mode_frame,
            text="CrÃ©er un nouvel article",
            variable=self.mode_var,
            value="new",
            command=self._on_mode_change
        ).pack(anchor="w")
        
        # Existing article section
        self.existing_frame = tk.LabelFrame(self, text="Article existant", padx=10, pady=10)
        self.existing_frame.pack(padx=15, pady=5, fill=tk.BOTH, expand=True)
        
        tk.Label(self.existing_frame, text="SÃ©lectionner un article :").pack(anchor="w", pady=2)
        self.article_cb = ttk.Combobox(
            self.existing_frame,
            textvariable=self.article_var,
            state="readonly",
            width=35
        )
        self.article_cb.pack(fill=tk.X, pady=2)
        self._load_articles()
        
        # New article section
        self.new_frame = tk.LabelFrame(self, text="Nouvel article", padx=10, pady=10)
        self.new_frame.pack(padx=15, pady=5, fill=tk.BOTH, expand=True)
        self.new_frame.pack_forget()  # Hidden by default
        
        tk.Label(self.new_frame, text="Nom :").pack(anchor="w", pady=2)
        tk.Entry(self.new_frame, textvariable=self.new_name_var, width=30).pack(fill=tk.X, pady=2)
        
        tk.Label(self.new_frame, text="CatÃ©gorie :").pack(anchor="w", pady=2)
        tk.Entry(self.new_frame, textvariable=self.new_categorie_var, width=25).pack(fill=tk.X, pady=2)
        
        tk.Label(self.new_frame, text="Contenance :").pack(anchor="w", pady=2)
        contenance_options = ["0.25L", "0.33L", "0.5L", "0.75L", "1L", "1.5L", "2L"]
        self.new_contenance_cb = ttk.Combobox(
            self.new_frame,
            textvariable=self.new_contenance_var,
            values=contenance_options,
            state="readonly",
            width=10
        )
        self.new_contenance_cb.pack(anchor="w", pady=2)
        
        # Quantity and price section
        qty_frame = tk.LabelFrame(self, text="QuantitÃ© et prix", padx=10, pady=10)
        qty_frame.pack(padx=15, pady=5, fill=tk.X)
        
        tk.Label(qty_frame, text="QuantitÃ© comptÃ©e :").pack(anchor="w", pady=2)
        tk.Entry(qty_frame, textvariable=self.quantite_var, width=15).pack(anchor="w", pady=2)
        
        tk.Label(qty_frame, text="Prix d'achat / unitÃ© (â‚¬) :").pack(anchor="w", pady=2)
        tk.Entry(qty_frame, textvariable=self.purchase_price_var, width=15).pack(anchor="w", pady=2)
        
        # Buttons
        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=15)
        tk.Button(btn_frame, text="Valider", command=self._validate, width=12).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Annuler", command=self.destroy, width=12).pack(side=tk.LEFT, padx=10)
    
    def _load_articles(self):
        """Load existing articles into combobox."""
        try:
            articles = get_all_articles()
            # Convert all Row objects to dicts for safe access
            articles_dicts = _rows_to_dicts(articles)
            
            article_list = []
            self.articles_dict = {}
            
            for art_dict in articles_dicts:
                display_str = f"{art_dict.get('name', '')}"
                if art_dict.get("contenance"):
                    display_str += f" ({art_dict['contenance']})"
                article_list.append(display_str)
                self.articles_dict[display_str] = art_dict
            
            self.article_cb["values"] = article_list
            
        except Exception as e:
            logger.error(f"Error loading articles: {e}")
            messagebox.showerror("Erreur", f"Erreur lors du chargement des articles: {e}")
    
    def _on_mode_change(self):
        """Handle mode change between existing and new article."""
        if self.mode_var.get() == "existing":
            self.existing_frame.pack(padx=15, pady=5, fill=tk.BOTH, expand=True)
            self.new_frame.pack_forget()
        else:
            self.existing_frame.pack_forget()
            self.new_frame.pack(padx=15, pady=5, fill=tk.BOTH, expand=True)
    
    def _load_edit_data(self):
        """Load existing line data for editing."""
        if self.edit_data:
            # Set quantity
            self.quantite_var.set(self.edit_data.get("quantite", 0))
            
            # Set purchase price if available
            if self.edit_data.get("purchase_price") is not None:
                self.purchase_price_var.set(self.edit_data["purchase_price"])
            
            # Try to select the article
            for display_str, art in self.articles_dict.items():
                if art["id"] == self.edit_data["article_id"]:
                    self.article_var.set(display_str)
                    break
    
    def _validate(self):
        """Validate and return the article data."""
        try:
            quantite = self.quantite_var.get()
            if quantite < 0:
                messagebox.showerror("Erreur", "La quantitÃ© ne peut pas Ãªtre nÃ©gative.")
                return
            
            # Get purchase price
            try:
                purchase_price = self.purchase_price_var.get()
                if purchase_price == 0.0:
                    purchase_price = None
            except tk.TclError:
                purchase_price = None
            
            article_id = None
            article_name = ""
            article_categorie = ""
            article_contenance = ""
            
            if self.mode_var.get() == "existing":
                # Existing article
                selected = self.article_var.get()
                if not selected:
                    messagebox.showerror("Erreur", "Veuillez sÃ©lectionner un article.")
                    return
                
                article = self.articles_dict[selected]
                article_id = article["id"]
                article_name = article["name"]
                article_categorie = article["categorie"] if article["categorie"] else ""
                article_contenance = article["contenance"] if article["contenance"] else ""
                
            else:
                # New article
                article_name = self.new_name_var.get().strip()
                if not article_name:
                    messagebox.showerror("Erreur", "Le nom de l'article est obligatoire.")
                    return
                
                # Check if article already exists
                existing = get_article_by_name(article_name)
                if existing:
                    # Convert Row to dict for safe access
                    existing_dict = _row_to_dict(existing)
                    if messagebox.askyesno(
                        "Article existant",
                        f"Un article avec le nom '{article_name}' existe dÃ©jÃ . Voulez-vous l'utiliser?"
                    ):
                        article_id = existing_dict.get("id")
                        article_categorie = existing_dict.get("categorie", "")
                        article_contenance = existing_dict.get("contenance", "")
                    else:
                        return
                else:
                    # Create new article
                    article_categorie = self.new_categorie_var.get().strip()
                    article_contenance = self.new_contenance_var.get().strip()
                    
                    article_id = create_article(
                        name=article_name,
                        categorie=article_categorie,
                        unite="unitÃ©",
                        contenance=article_contenance,
                        commentaire="",
                        stock=0,
                        purchase_price=purchase_price
                    )
            
            # Return article data
            article_data = {
                "article_id": article_id,
                "name": article_name,
                "categorie": article_categorie,
                "contenance": article_contenance,
                "quantite": quantite,
                "purchase_price": purchase_price
            }
            
            self.callback(article_data)
            self.destroy()
            
        except Exception as e:
            logger.error(f"Error validating article line: {e}")
            messagebox.showerror("Erreur", f"Erreur: {e}")

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./ui/startup_schema_check.py ===

```python
#!/usr/bin/env python3
"""
Module de vÃ©rification automatique du schÃ©ma de base de donnÃ©es au dÃ©marrage.

Ce module compare le schÃ©ma attendu par le code (extrait via analyze_modules_columns.py)
avec le schÃ©ma rÃ©el de la base de donnÃ©es. Si des colonnes manquent, une fenÃªtre d'alerte
est affichÃ©e avec les Ã©carts et propose Ã  l'utilisateur d'exÃ©cuter une mise Ã  jour sÃ»re
ou d'ignorer les diffÃ©rences.

Usage:
    from ui import startup_schema_check
    startup_schema_check.run_check(root_window)
"""

import os
import sys
import sqlite3
import subprocess
import re
import importlib.util
import tkinter as tk
from tkinter import Toplevel, Label, Button, Text, Scrollbar, messagebox
from pathlib import Path
from typing import Dict, List, Tuple, Set, Optional
from difflib import SequenceMatcher

# Constants
ERROR_MESSAGE_MAX_LENGTH = 500

# Ensure UTF-8 encoding
try:
    sys.stdout.reconfigure(encoding='utf-8')
    sys.stderr.reconfigure(encoding='utf-8')
except Exception:
    pass


def get_expected_schema() -> Dict[str, Set[str]]:
    """
    Obtient le schÃ©ma attendu en utilisant le schÃ©ma de rÃ©fÃ©rence du script update_db_structure.py.
    
    Returns:
        Dictionnaire {table_name: set(column_names)}
    """
    # Importer le schÃ©ma de rÃ©fÃ©rence depuis update_db_structure.py
    scripts_dir = Path(__file__).parent.parent / "scripts"
    script_path = scripts_dir / "update_db_structure.py"
    
    try:
        # Charger le module de maniÃ¨re dynamique
        spec = importlib.util.spec_from_file_location("update_db_structure", script_path)
        if spec is None or spec.loader is None:
            print(f"Warning: Could not load spec for {script_path}")
            return {}
        
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        # AccÃ©der au REFERENCE_SCHEMA
        REFERENCE_SCHEMA = module.REFERENCE_SCHEMA
        
        # Convertir le format {table: {col: (type, default)}} en {table: set(cols)}
        expected = {}
        for table, columns in REFERENCE_SCHEMA.items():
            expected[table] = set(columns.keys())
        
        return expected
    except Exception as e:
        print(f"Warning: Could not import REFERENCE_SCHEMA: {e}")
        return {}


def get_real_schema(db_path: str) -> Dict[str, Set[str]]:
    """
    Obtient le schÃ©ma rÃ©el de la base de donnÃ©es via PRAGMA table_info.
    
    Args:
        db_path: Chemin vers le fichier de base de donnÃ©es
        
    Returns:
        Dictionnaire {table_name: set(column_names)}
    """
    if not os.path.exists(db_path):
        return {}
    
    schema = {}
    
    try:
        conn = sqlite3.connect(db_path, timeout=10)
        cursor = conn.cursor()
        
        # Obtenir toutes les tables
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = [row[0] for row in cursor.fetchall()]
        
        for table in tables:
            # Valider le nom de la table pour Ã©viter l'injection SQL
            if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', table):
                print(f"Warning: Skipping table with invalid name: {table}")
                continue
            
            # Obtenir les colonnes de chaque table via PRAGMA table_info
            # PRAGMA table_info n'accepte pas les paramÃ¨tres, mais on a validÃ© le nom
            cursor.execute(f"PRAGMA table_info({table})")
            columns = set(row[1] for row in cursor.fetchall())
            schema[table] = columns
        
        conn.close()
        return schema
        
    except Exception as e:
        print(f"Error reading database schema: {e}")
        return {}


def fuzzy_match_column(target_col: str, existing_cols: Set[str], threshold: float = 0.75) -> Optional[str]:
    """
    Trouve une colonne existante qui correspond au nom cible (fuzzy/case-insensitive).
    
    Args:
        target_col: Nom de colonne recherche
        existing_cols: Ensemble des colonnes existantes dans la table
        threshold: Seuil de similarite (0.0 a 1.0)
    
    Returns:
        Nom de la colonne correspondante ou None
    """
    target_lower = target_col.lower()
    
    # 1. Exact match (case-insensitive)
    for col in existing_cols:
        if col.lower() == target_lower:
            return col
    
    # 2. Fuzzy match with SequenceMatcher
    best_match = None
    best_score = 0.0
    
    for col in existing_cols:
        ratio = SequenceMatcher(None, target_lower, col.lower()).ratio()
        if ratio > best_score and ratio >= threshold:
            best_score = ratio
            best_match = col
    
    return best_match


def detect_missing_columns(expected: Dict[str, Set[str]], real: Dict[str, Set[str]]) -> Dict[str, List[Tuple[str, Optional[str]]]]:
    """
    Detecte les colonnes manquantes par rapport au schema attendu.
    
    Args:
        expected: Schema attendu {table: set(columns)}
        real: Schema reel {table: set(columns)}
        
    Returns:
        Dictionnaire {table: [(missing_col, fuzzy_match)]}
        where fuzzy_match is the suggested existing column or None
    """
    missing = {}
    
    for table, expected_cols in expected.items():
        if table not in real:
            # La table n'existe pas, ne pas la signaler
            # (update_db_structure ne cree pas de tables)
            continue
        
        real_cols = real[table]
        missing_cols = expected_cols - real_cols
        
        if missing_cols:
            # Find fuzzy matches for each missing column
            missing_with_matches = []
            for col in sorted(missing_cols):
                fuzzy_match = fuzzy_match_column(col, real_cols)
                missing_with_matches.append((col, fuzzy_match))
            
            missing[table] = missing_with_matches
    
    return missing


class SchemaCheckDialog(Toplevel):
    """Fenetre d'alerte pour les colonnes manquantes dans la base de donnees."""
    
    def __init__(self, parent, missing_columns: Dict[str, List[Tuple[str, Optional[str]]]], db_path: str):
        super().__init__(parent)
        
        self.missing_columns = missing_columns
        self.db_path = db_path
        self.user_choice = None  # 'update' ou 'ignore'
        
        self.title("Verification du schema de base de donnees")
        self.geometry("700x500")
        self.resizable(True, True)
        
        # Rendre la fenÃªtre modale
        self.transient(parent)
        self.grab_set()
        
        self._create_widgets()
        
        # Centrer la fenÃªtre
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (self.winfo_width() // 2)
        y = (self.winfo_screenheight() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")
    
    def _create_widgets(self):
        """CrÃ©e les widgets de la fenÃªtre."""
        
        # En-tÃªte avec icÃ´ne d'avertissement
        header_frame = tk.Frame(self, bg="#fff3cd", padx=10, pady=10)
        header_frame.pack(fill=tk.X, padx=10, pady=10)
        
        warning_label = Label(
            header_frame,
            text="âš  SchÃ©ma de base de donnÃ©es incomplet",
            font=("Arial", 14, "bold"),
            bg="#fff3cd",
            fg="#856404"
        )
        warning_label.pack()
        
        # Message d'information
        info_text = (
            "Des colonnes attendues par le code sont absentes de la base de donnÃ©es.\n"
            "Cela peut causer des erreurs lors de l'utilisation de l'application.\n\n"
            "Colonnes manquantes par table :"
        )
        
        info_label = Label(self, text=info_text, justify="left", wraplength=650)
        info_label.pack(padx=10, pady=(0, 5), anchor="w")
        
        # Zone de texte avec scrollbar pour afficher les colonnes manquantes
        text_frame = tk.Frame(self)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        scrollbar = Scrollbar(text_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.text_widget = Text(
            text_frame,
            wrap=tk.WORD,
            yscrollcommand=scrollbar.set,
            font=("Courier", 10),
            height=12
        )
        self.text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.text_widget.yview)
        
        # Remplir le texte avec les colonnes manquantes
        self._populate_missing_columns()
        self.text_widget.config(state=tk.DISABLED)
        
        # Message de recommandation
        recommendation_text = (
            "\nðŸ’¡ Recommandation : Il est fortement conseillÃ© de mettre Ã  jour la base de donnÃ©es.\n"
            "Une sauvegarde automatique sera crÃ©Ã©e avant toute modification."
        )
        
        recommendation_label = Label(
            self,
            text=recommendation_text,
            justify="left",
            wraplength=650,
            fg="#0056b3"
        )
        recommendation_label.pack(padx=10, pady=10, anchor="w")
        
        # Cadre pour les boutons
        button_frame = tk.Frame(self)
        button_frame.pack(pady=15)
        
        # Bouton "Mettre Ã  jour maintenant"
        update_button = Button(
            button_frame,
            text="Mettre Ã  jour maintenant",
            command=self._on_update,
            bg="#28a745",
            fg="white",
            font=("Arial", 11, "bold"),
            width=22,
            height=2
        )
        update_button.pack(side=tk.LEFT, padx=10)
        
        # Bouton "Ignorer"
        ignore_button = Button(
            button_frame,
            text="Ignorer (non recommandÃ©)",
            command=self._on_ignore,
            bg="#6c757d",
            fg="white",
            font=("Arial", 11),
            width=22,
            height=2
        )
        ignore_button.pack(side=tk.LEFT, padx=10)
        
        # Protocole de fermeture de la fenÃªtre
        self.protocol("WM_DELETE_WINDOW", self._on_ignore)
    
    def _populate_missing_columns(self):
        """Remplit le widget texte avec les colonnes manquantes."""
        for table in sorted(self.missing_columns.keys()):
            columns = self.missing_columns[table]
            self.text_widget.insert(tk.END, f"\nTable: {table}\n", "table")
            for col, fuzzy_match in columns:
                if fuzzy_match:
                    # Show proposed mapping
                    self.text_widget.insert(tk.END, f"   + {col}", "column")
                    self.text_widget.insert(tk.END, f" (mappable depuis: {fuzzy_match})\n", "match")
                else:
                    # New column
                    self.text_widget.insert(tk.END, f"   + {col}", "column")
                    self.text_widget.insert(tk.END, " (nouvelle colonne)\n", "new")
        
        # Configuration des tags pour le formatage
        self.text_widget.tag_config("table", font=("Courier", 10, "bold"), foreground="#0056b3")
        self.text_widget.tag_config("column", font=("Courier", 10, "bold"), foreground="#333333")
        self.text_widget.tag_config("match", font=("Courier", 9), foreground="#28a745")
        self.text_widget.tag_config("new", font=("Courier", 9), foreground="#6c757d")
    
    def _on_update(self):
        """Gestionnaire pour le bouton 'Mettre Ã  jour maintenant'."""
        self.user_choice = "update"
        self.destroy()
    
    def _on_ignore(self):
        """Gestionnaire pour le bouton 'Ignorer'."""
        # Confirmer l'action d'ignorer
        confirm = messagebox.askyesno(
            "Confirmation",
            "ÃŠtes-vous sÃ»r de vouloir ignorer cette mise Ã  jour ?\n\n"
            "Certaines fonctionnalitÃ©s pourraient ne pas fonctionner correctement.",
            icon="warning",
            parent=self
        )
        
        if confirm:
            self.user_choice = "ignore"
            self.destroy()


def _extract_report_path_from_output(output: str) -> Optional[str]:
    """
    Extrait le chemin du rapport depuis la sortie du script de migration.
    
    Args:
        output: Sortie stdout du script
        
    Returns:
        Chemin du rapport ou None si non trouvÃ©
    """
    for line in output.split('\n'):
        if line.startswith('REPORT_PATH:'):
            return line.split('REPORT_PATH:', 1)[1].strip()
    return None


def execute_update(db_path: str, parent_window=None) -> Tuple[bool, str]:
    """
    ExÃ©cute le script update_db_structure.py pour mettre Ã  jour la base de donnÃ©es.
    
    Args:
        db_path: Chemin vers la base de donnÃ©es
        parent_window: FenÃªtre parente pour les messages
        
    Returns:
        Tuple (success, message)
    """
    try:
        # Valider le chemin de la base de donnÃ©es pour Ã©viter l'injection de commandes
        db_path = os.path.abspath(db_path)
        if not os.path.exists(db_path):
            error_msg = f"[ERROR] Le fichier de base de donnees n'existe pas : {db_path}"
            if parent_window:
                messagebox.showerror("Erreur", error_msg, parent=parent_window)
            return False, error_msg
        
        # Construire la commande pour exÃ©cuter le script
        script_path = Path(__file__).parent.parent / "scripts" / "update_db_structure.py"
        
        result = subprocess.run(
            [sys.executable, str(script_path), "--db-path", db_path],
            capture_output=True,
            text=True,
            cwd=str(Path(__file__).parent.parent),
            timeout=120  # Timeout de 2 minutes pour la migration
        )
        
        # Extraire le chemin du rapport depuis la sortie
        report_path = _extract_report_path_from_output(result.stdout)
        
        if result.returncode == 0:
            success_msg = (
                "[SUCCESS] Mise a jour de la base de donnees terminee avec succes !\n\n"
                "Un rapport detaille a ete genere dans le repertoire reports/.\n"
                "Une sauvegarde de votre base a ete creee automatiquement."
            )
            
            if parent_window:
                # Afficher le rapport dans une fenÃªtre dÃ©diÃ©e
                if report_path and os.path.exists(report_path):
                    show_report = messagebox.askyesno(
                        "SuccÃ¨s",
                        success_msg + "\n\nVoulez-vous consulter le rapport de migration ?",
                        parent=parent_window
                    )
                    
                    if show_report:
                        MigrationReportDialog(parent_window, report_path, is_error=False)
                else:
                    messagebox.showinfo("SuccÃ¨s", success_msg, parent=parent_window)
            
            return True, success_msg
        else:
            error_msg = f"[ERROR] La mise a jour a echoue.\n\nDetails :\n{result.stderr[:ERROR_MESSAGE_MAX_LENGTH]}"
            
            if parent_window:
                # Afficher automatiquement le rapport d'erreur dans une fenÃªtre dÃ©diÃ©e
                if report_path and os.path.exists(report_path):
                    MigrationReportDialog(parent_window, report_path, is_error=True)
                else:
                    # Si pas de rapport disponible, afficher l'erreur basique
                    messagebox.showerror("Erreur de migration", error_msg, parent=parent_window)
            
            return False, error_msg
            
    except subprocess.TimeoutExpired:
        error_msg = "[ERROR] La mise a jour a depasse le delai d'attente."
        if parent_window:
            messagebox.showerror("Erreur", error_msg, parent=parent_window)
        return False, error_msg
    except Exception as e:
        error_msg = f"[ERROR] Impossible d'executer la mise a jour : {e}"
        
        if parent_window:
            messagebox.showerror("Erreur", error_msg, parent=parent_window)
        
        return False, error_msg


class MigrationReportDialog(Toplevel):
    """FenÃªtre pour afficher le contenu d'un rapport de migration."""
    
    def __init__(self, parent, report_path: str, is_error: bool = False):
        super().__init__(parent)
        
        self.report_path = report_path
        
        title = "Rapport d'erreur de migration" if is_error else "Rapport de migration"
        self.title(title)
        self.geometry("800x600")
        self.resizable(True, True)
        
        # Rendre la fenÃªtre modale
        if parent:
            self.transient(parent)
            self.grab_set()
        
        self._create_widgets(is_error)
        self._load_report_content()
        
        # Centrer la fenÃªtre
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (self.winfo_width() // 2)
        y = (self.winfo_screenheight() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")
    
    def _create_widgets(self, is_error: bool):
        """CrÃ©e les widgets de la fenÃªtre."""
        
        # En-tÃªte
        header_color = "#f8d7da" if is_error else "#d4edda"
        text_color = "#721c24" if is_error else "#155724"
        icon = "âŒ" if is_error else "âœ…"
        
        header_frame = tk.Frame(self, bg=header_color, padx=10, pady=10)
        header_frame.pack(fill=tk.X, padx=10, pady=10)
        
        title_text = f"{icon} Rapport de migration de la base de donnÃ©es"
        header_label = Label(
            header_frame,
            text=title_text,
            font=("Arial", 12, "bold"),
            bg=header_color,
            fg=text_color
        )
        header_label.pack()
        
        # Message
        if is_error:
            info_text = (
                "La migration de la base de donnÃ©es a Ã©chouÃ©.\n"
                "Veuillez consulter les dÃ©tails ci-dessous pour comprendre la cause du problÃ¨me.\n"
                "La base de donnÃ©es a Ã©tÃ© restaurÃ©e Ã  son Ã©tat prÃ©cÃ©dent."
            )
        else:
            info_text = (
                "La migration de la base de donnÃ©es s'est terminÃ©e avec succÃ¨s.\n"
                "Vous pouvez consulter les dÃ©tails ci-dessous."
            )
        
        info_label = Label(self, text=info_text, justify="left", wraplength=750)
        info_label.pack(padx=10, pady=(0, 10), anchor="w")
        
        # Zone de texte avec scrollbar pour afficher le rapport
        text_frame = tk.Frame(self)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        scrollbar = tk.Scrollbar(text_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.text_widget = tk.Text(
            text_frame,
            wrap=tk.WORD,
            yscrollcommand=scrollbar.set,
            font=("Courier", 9),
            state=tk.DISABLED
        )
        self.text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.text_widget.yview)
        
        # Cadre pour les boutons
        button_frame = tk.Frame(self)
        button_frame.pack(pady=15)
        
        # Bouton "Ouvrir le fichier"
        open_button = Button(
            button_frame,
            text="Ouvrir le fichier complet",
            command=self._open_file,
            font=("Arial", 10),
            width=20
        )
        open_button.pack(side=tk.LEFT, padx=5)
        
        # Bouton "Fermer"
        close_button = Button(
            button_frame,
            text="Fermer",
            command=self.destroy,
            font=("Arial", 10),
            width=15
        )
        close_button.pack(side=tk.LEFT, padx=5)
    
    def _load_report_content(self):
        """Charge et affiche le contenu du rapport."""
        try:
            with open(self.report_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            self.text_widget.config(state=tk.NORMAL)
            self.text_widget.delete(1.0, tk.END)
            self.text_widget.insert(1.0, content)
            self.text_widget.config(state=tk.DISABLED)
        except Exception as e:
            self.text_widget.config(state=tk.NORMAL)
            self.text_widget.delete(1.0, tk.END)
            self.text_widget.insert(1.0, f"Erreur lors de la lecture du rapport :\n{e}")
            self.text_widget.config(state=tk.DISABLED)
    
    def _open_file(self):
        """Ouvre le fichier de rapport avec l'application par dÃ©faut."""
        try:
            if sys.platform == "win32":
                os.startfile(self.report_path)
            elif sys.platform == "darwin":
                subprocess.run(["open", self.report_path], check=False, timeout=5)
            else:
                subprocess.run(["xdg-open", self.report_path], check=False, timeout=5)
        except Exception as e:
            messagebox.showerror(
                "Erreur",
                f"Impossible d'ouvrir le fichier :\n{e}\n\nChemin : {self.report_path}",
                parent=self
            )


def _open_latest_migration_report():
    """Ouvre le dernier rapport de migration gÃ©nÃ©rÃ©."""
    try:
        reports_dir = Path(__file__).parent.parent / "reports"
        
        # Trouver le dernier rapport de migration
        reports = list(reports_dir.glob("migration_report_*.md"))
        
        if reports:
            latest_report = max(reports, key=os.path.getmtime)
            
            # Valider que le fichier existe et est bien dans le rÃ©pertoire reports
            if not latest_report.exists() or not latest_report.is_relative_to(reports_dir):
                print(f"Invalid report path: {latest_report}")
                return
            
            # Ouvrir le fichier avec l'application par dÃ©faut du systÃ¨me
            try:
                if sys.platform == "win32":
                    os.startfile(str(latest_report))
                elif sys.platform == "darwin":
                    subprocess.run(["open", str(latest_report)], check=False, timeout=5)
                else:
                    subprocess.run(["xdg-open", str(latest_report)], check=False, timeout=5)
            except (subprocess.TimeoutExpired, OSError) as e:
                print(f"Could not open report with default application: {e}")
                messagebox.showinfo("Rapport", f"Le rapport est disponible ici :\n{latest_report}")
        else:
            messagebox.showwarning("Rapport introuvable", "Aucun rapport de migration trouvÃ©.")
            
    except Exception as e:
        print(f"Could not open migration report: {e}")


def run_check(parent_window=None, db_path: str = "association.db") -> bool:
    """
    ExÃ©cute la vÃ©rification du schÃ©ma de base de donnÃ©es au dÃ©marrage.
    
    Cette fonction compare le schÃ©ma attendu avec le schÃ©ma rÃ©el et affiche
    une fenÃªtre d'alerte si des colonnes manquent. L'utilisateur peut choisir
    de mettre Ã  jour la base de donnÃ©es ou d'ignorer les diffÃ©rences.
    
    Args:
        parent_window: FenÃªtre parente Tkinter (optionnel)
        db_path: Chemin vers la base de donnÃ©es (dÃ©faut: "association.db")
        
    Returns:
        True si la vÃ©rification s'est bien passÃ©e (pas de colonnes manquantes ou mise Ã  jour rÃ©ussie),
        False sinon
    """
    # VÃ©rifier que la base de donnÃ©es existe
    if not os.path.exists(db_path):
        print(f"Database file not found: {db_path}")
        return True  # Pas d'erreur, la base n'existe pas encore
    
    # Obtenir les schÃ©mas
    expected_schema = get_expected_schema()
    real_schema = get_real_schema(db_path)
    
    if not expected_schema:
        print("Warning: Could not load expected schema")
        return True  # Continuer sans vÃ©rification
    
    # DÃ©tecter les colonnes manquantes
    missing_columns = detect_missing_columns(expected_schema, real_schema)
    
    if not missing_columns:
        # Tout est Ã  jour, pas besoin d'afficher de fenÃªtre
        print("[OK] Database schema is up to date!")
        return True
    
    # Afficher la fenÃªtre d'alerte
    print(f"Warning: Found missing columns in {len(missing_columns)} table(s)")
    
    dialog = SchemaCheckDialog(parent_window, missing_columns, db_path)
    dialog.wait_window()
    
    # Traiter le choix de l'utilisateur
    if dialog.user_choice == "update":
        success, message = execute_update(db_path, parent_window)
        return success
    else:
        # L'utilisateur a choisi d'ignorer
        print("User chose to ignore schema differences")
        return False


if __name__ == "__main__":
    # Test en mode standalone
    print("Testing startup schema check...")
    
    # CrÃ©er une fenÃªtre Tk simple pour le test
    root = tk.Tk()
    root.withdraw()  # Cacher la fenÃªtre principale
    
    result = run_check(root)
    
    print(f"Check result: {result}")
    
    root.destroy()

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./ui/ui_utils.py ===

```python
import tkinter as tk
from tkinter import ttk

def clear_treeview(tree):
    for row in tree.get_children():
        tree.delete(row)

def ask_confirm(title, message):
    from tkinter import messagebox
    return messagebox.askyesno(title, message)

def show_info(title, message):
    from tkinter import messagebox
    messagebox.showinfo(title, message)

def show_error(title, message):
    from tkinter import messagebox
    messagebox.showerror(title, message)

def create_popup(title, message):
    popup = tk.Toplevel()
    popup.title(title)
    tk.Label(popup, text=message, padx=20, pady=20).pack()
    tk.Button(popup, text="Fermer", command=popup.destroy).pack(pady=12)
    popup.grab_set()
    popup.wait_window()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./ui/dialogs/base_list_dialog.py ===

```python
"""
Base List Dialog for Standardized Database List UIs

Provides a reusable base class for dialogs that display database records
in a Treeview widget with standardized error handling and reporting.

Features:
- load_items() helper for loading data from database with automatic conversion
- Error reporting to UTF-8 files in reports/ directory
- Graceful handling of missing columns and database errors
- Standardized logging
"""

import tkinter as tk
from tkinter import ttk, messagebox
from typing import List, Dict, Any, Optional, Tuple, Callable
from datetime import datetime
from pathlib import Path
from db.db import get_connection
from modules.db_row_utils import _rows_to_dicts
from utils.app_logger import get_logger

logger = get_logger("base_list_dialog")


class BaseListDialog:
    """
    Base class for dialogs that display database records in a Treeview.
    
    Provides standardized methods for:
    - Loading items from database with automatic row-to-dict conversion
    - Error handling and reporting
    - Graceful handling of missing columns
    
    Subclasses should:
    1. Set self.tree to their Treeview widget
    2. Call load_items() to populate the tree
    3. Override handle_load_error() for custom error handling (optional)
    """
    
    def __init__(self):
        """Initialize the base dialog."""
        self.tree = None  # Subclass should set this to their Treeview widget
        self.reports_dir = Path(__file__).parent.parent.parent / 'reports'
        self.reports_dir.mkdir(exist_ok=True)
    
    def load_items(
        self,
        tree: ttk.Treeview,
        query: str,
        params: Optional[Tuple] = None,
        columns: Optional[List[str]] = None,
        converter: Optional[Callable] = _rows_to_dicts
    ) -> bool:
        """
        Load items from database into a Treeview widget.
        
        This is the main helper method for loading database records into a tree.
        It handles:
        - Database connection
        - Query execution
        - Row-to-dict conversion (to enable .get() access)
        - Error handling and reporting
        - Graceful handling of missing columns
        
        Args:
            tree: Treeview widget to populate
            query: SQL query to execute
            params: Query parameters (optional)
            columns: List of column names to display (in order)
                    If None, will use tree's configured columns
            converter: Function to convert rows (default: _rows_to_dicts)
                      Set to None to skip conversion
        
        Returns:
            bool: True if successful, False if errors occurred
            
        Example:
            >>> self.load_items(
            ...     self.tree,
            ...     "SELECT id, name, categorie FROM articles",
            ...     columns=['id', 'name', 'categorie']
            ... )
        """
        conn = None
        try:
            # Clear existing items
            for item in tree.get_children():
                tree.delete(item)
            
            # Get connection and execute query
            conn = get_connection()
            cursor = conn.cursor()
            
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            
            rows = cursor.fetchall()
            
            # Convert rows if converter provided
            if converter:
                rows = converter(rows, cursor)
            
            # Determine which columns to display
            if columns is None:
                # Use tree's configured columns
                columns = tree['columns']
            
            # Insert items into tree
            for row in rows:
                # Get ID for the tree item (try 'id' key, fall back to first value)
                if isinstance(row, dict):
                    item_id = row.get('id', '')
                    values = []
                    for col in columns:
                        value = row.get(col, '')
                        # Handle None values
                        if value is None:
                            value = ''
                        values.append(value)
                else:
                    # If not converted to dict, use positional access
                    item_id = row[0] if len(row) > 0 else ''
                    values = list(row[:len(columns)])
                
                tree.insert('', 'end', iid=item_id, values=tuple(values))
            
            return True
            
        except Exception as e:
            error_msg = f"Error loading items: {e}"
            logger.error(error_msg)
            logger.error(f"Query: {query}")
            logger.error(f"Params: {params}")
            
            # Write error report
            self._write_error_report(error_msg, query, params, e)
            
            # Handle error (can be overridden)
            self.handle_load_error(error_msg, e)
            
            return False
            
        finally:
            if conn:
                conn.close()
    
    def handle_load_error(self, error_msg: str, exception: Exception):
        """
        Handle errors during item loading.
        
        Default implementation shows a messagebox.
        Subclasses can override for custom behavior.
        
        Args:
            error_msg: Human-readable error message
            exception: The exception that was raised
        """
        messagebox.showerror(
            "Erreur de chargement",
            f"Impossible de charger les donnÃ©es:\n{error_msg}\n\n"
            f"Voir le fichier de rapport pour plus de dÃ©tails."
        )
    
    def _write_error_report(
        self,
        error_msg: str,
        query: str,
        params: Optional[Tuple],
        exception: Exception
    ):
        """
        Write an error report to the reports directory.
        
        Creates a UTF-8 encoded file with details about the error.
        
        Args:
            error_msg: Human-readable error message
            query: SQL query that failed
            params: Query parameters
            exception: The exception that was raised
        """
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_name = f"db_error_{timestamp}.txt"
            report_path = self.reports_dir / report_name
            
            with open(report_path, 'w', encoding='utf-8') as f:
                f.write("Database Error Report\n")
                f.write("=" * 70 + "\n")
                f.write(f"Timestamp: {datetime.now().isoformat()}\n")
                f.write(f"Dialog: {self.__class__.__name__}\n")
                f.write("\n")
                f.write("Error:\n")
                f.write(f"{error_msg}\n")
                f.write("\n")
                f.write("Exception Type:\n")
                f.write(f"{type(exception).__name__}\n")
                f.write("\n")
                f.write("Query:\n")
                f.write(f"{query}\n")
                f.write("\n")
                f.write("Parameters:\n")
                f.write(f"{params}\n")
                f.write("\n")
                f.write("Exception Details:\n")
                f.write(f"{str(exception)}\n")
            
            logger.info(f"Error report written to {report_path}")
            
        except Exception as report_error:
            logger.error(f"Failed to write error report: {report_error}")
    
    def get_selected_id(self, tree: Optional[ttk.Treeview] = None) -> Optional[str]:
        """
        Get the ID of the selected item in the tree.
        
        Args:
            tree: Treeview widget (default: self.tree)
        
        Returns:
            str or None: ID of selected item, or None if no selection
        """
        if tree is None:
            tree = self.tree
        
        if tree is None:
            return None
        
        selection = tree.selection()
        if not selection:
            return None
        
        return selection[0]
    
    def safe_get_value(
        self,
        row: Dict[str, Any],
        key: str,
        default: Any = ''
    ) -> Any:
        """
        Safely get a value from a row dict with a default.
        
        Handles None values by converting them to the default.
        
        Args:
            row: Row dict
            key: Column name
            default: Default value if key missing or None
        
        Returns:
            Value from row, or default
        """
        value = row.get(key, default)
        if value is None:
            return default
        return value

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./ui/dialogs/__init__.py ===

```python
"""
UI dialogs package for standardized dialog components.
"""

from ui.dialogs.base_list_dialog import BaseListDialog

__all__ = ['BaseListDialog']

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/app_logger.py ===

```python
import logging
import os

def get_logger(name="app", log_level="INFO", log_file="app.log"):
    """CrÃ©e et retourne un logger prÃªt Ã  l'emploi pour tout le projet."""
    logger = logging.getLogger(name)
    if not logger.handlers:
        logger.setLevel(getattr(logging, log_level.upper(), logging.INFO))
        formatter = logging.Formatter('%(asctime)s | %(levelname)s | %(name)s | %(message)s')
        # Console handler
        ch = logging.StreamHandler()
        ch.setLevel(getattr(logging, log_level.upper(), logging.INFO))
        ch.setFormatter(formatter)
        logger.addHandler(ch)
        # File handler
        log_dir = "logs"
        try:
            os.makedirs(log_dir, exist_ok=True)
            fh = logging.FileHandler(os.path.join(log_dir, log_file), encoding='utf-8')
            fh.setLevel(getattr(logging, log_level.upper(), logging.INFO))
            fh.setFormatter(formatter)
            logger.addHandler(fh)
        except Exception:
            pass  # Si le dossier logs n'est pas accessible, on garde la sortie console
    return logger
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/backup_restore.py ===

```python
import os
import shutil
from tkinter import filedialog, messagebox
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("backup_restore")

BACKUP_DIR = "backups"
DEFAULT_DB_FILE = "association.db"

def backup_database(db_file=DEFAULT_DB_FILE):
    """CrÃ©e une copie de sauvegarde de la base au format .bak dans BACKUP_DIR."""
    try:
        if not os.path.exists(db_file):
            messagebox.showerror("Erreur", f"Base de donnÃ©es non trouvÃ©e : {db_file}")
            return
        os.makedirs(BACKUP_DIR, exist_ok=True)
        backup_name = f"{os.path.splitext(os.path.basename(db_file))[0]}_backup.bak"
        backup_path = os.path.join(BACKUP_DIR, backup_name)
        shutil.copy2(db_file, backup_path)
        logger.info(f"Backup crÃ©Ã© : {backup_path}")
        messagebox.showinfo("Sauvegarde", f"Sauvegarde rÃ©ussie dans {backup_path}")
    except Exception as e:
        message = handle_exception(e, "Erreur lors de la sauvegarde de la base.")
        messagebox.showerror("Erreur", message)

def restore_database(db_file=DEFAULT_DB_FILE):
    """Permet de restaurer la base Ã  partir d'un fichier .bak choisi par l'utilisateur."""
    try:
        bak_path = filedialog.askopenfilename(
            title="SÃ©lectionnez le fichier de sauvegarde Ã  restaurer",
            filetypes=[("Fichiers de sauvegarde", "*.bak"), ("Tout", "*.*")]
        )
        if not bak_path:
            return
        if os.path.exists(db_file):
            if not messagebox.askyesno("Confirmation", f"Ã‰craser la base {db_file} par la sauvegarde {os.path.basename(bak_path)} ?"):
                return
        shutil.copy2(bak_path, db_file)
        logger.info(f"Base restaurÃ©e depuis {bak_path} -> {db_file}")
        messagebox.showinfo("Restauration", f"Base restaurÃ©e avec succÃ¨s depuis {bak_path}")
    except Exception as e:
        message = handle_exception(e, "Erreur lors de la restauration de la base.")
        messagebox.showerror("Erreur", message)

def open_database():
    """Permet de choisir et d'utiliser une autre base SQLite existante."""
    try:
        db_path = filedialog.askopenfilename(
            title="SÃ©lectionnez un fichier de base de donnÃ©es SQLite",
            filetypes=[("Bases SQLite", "*.db *.sqlite *.sqlite3"), ("Tout", "*.*")]
        )
        if not db_path:
            return
        from db.db import set_db_file
        set_db_file(db_path)
        logger.info(f"Base de donnÃ©es active changÃ©e pour {db_path}")
        messagebox.showinfo("Changement de base", f"Base de donnÃ©es changÃ©e pour {db_path}")
        # Peut appeler un callback UI pour rafraÃ®chir la barre de statut si besoin
    except Exception as e:
        message = handle_exception(e, "Erreur lors du changement de base.")
        messagebox.showerror("Erreur", message)

def set_status_callback(callback):
    """Permet Ã  l'UI de s'abonner pour Ãªtre notifiÃ©e lors d'un changement de base."""
    global _status_callback
    _status_callback = callback

    # Appelle le callback une premiÃ¨re fois pour initialiser l'Ã©tat
    try:
        if callback:
            callback()
    except Exception:
        pass
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/cloture_exercice.py ===

```python
import os
import shutil
import zipfile
from datetime import datetime
from tkinter import messagebox
from utils.app_logger import get_logger
from utils.error_handler import handle_exception
from db.db import get_db_file

logger = get_logger("cloture_exercice")

EXPORTS_DIR = "exports"

def export_all_tables_to_csv(db_file=None, export_dir=None):
    """
    Exporte toutes les tables SQLite en CSV dans un dossier donnÃ©.
    """
    import sqlite3
    import pandas as pd

    if not db_file:
        db_file = get_db_file()
    if not export_dir:
        export_dir = os.path.join(EXPORTS_DIR, "cloture_" + datetime.now().strftime("%Y%m%d_%H%M%S"))
    os.makedirs(export_dir, exist_ok=True)

    try:
        conn = sqlite3.connect(db_file)
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")
        tables = [row[0] for row in cursor.fetchall()]
        for table in tables:
            df = pd.read_sql_query(f"SELECT * FROM {table}", conn)
            path = os.path.join(export_dir, f"{table}.csv")
            df.to_csv(path, index=False, encoding="utf-8")
        conn.close()
        logger.info(f"Export CSV de toutes les tables terminÃ© dans {export_dir}")
        return export_dir
    except Exception as e:
        handle_exception(e, "Erreur lors de l'export CSV des tables")
        return None

def make_zip_export(src_dir):
    """
    CrÃ©e une archive ZIP de tout le dossier src_dir.
    """
    try:
        zip_name = src_dir.rstrip(os.sep) + ".zip"
        with zipfile.ZipFile(zip_name, "w", zipfile.ZIP_DEFLATED) as zipf:
            for root, _, files in os.walk(src_dir):
                for file in files:
                    abs_path = os.path.join(root, file)
                    rel_path = os.path.relpath(abs_path, src_dir)
                    zipf.write(abs_path, rel_path)
        logger.info(f"Archive ZIP crÃ©Ã©e : {zip_name}")
        return zip_name
    except Exception as e:
        handle_exception(e, "Erreur lors de la crÃ©ation de l'archive ZIP")
        return None

def run_cloture(reset_db=True, export_pdf_callback=None):
    """
    Processus complet de clÃ´ture d'exercice :
    - Export CSV de toutes les tables
    - CrÃ©ation ZIP
    - (optionnel) GÃ©nÃ©ration du bilan PDF
    - (optionnel) Reset de la base
    """
    try:
        db_file = get_db_file()
        export_dir = export_all_tables_to_csv(db_file)
        if not export_dir:
            messagebox.showerror("Erreur", "Ã‰chec de l'export CSV.")
            return
        zip_path = make_zip_export(export_dir)
        if not zip_path:
            messagebox.showerror("Erreur", "Ã‰chec de la crÃ©ation de l'archive ZIP.")
            return

        if export_pdf_callback:
            # Fonction passÃ©e par le module exports pour gÃ©nÃ©rer le PDF bilan argumentÃ©
            try:
                export_pdf_callback(export_dir)
            except Exception as e:
                handle_exception(e, "Erreur lors de l'export du PDF de bilan")

        if reset_db:
            from db.db import drop_tables, init_db, get_connection
            if messagebox.askyesno("RÃ©initialisation", "Voulez-vous rÃ©initialiser la base pour un nouvel exercice ?\nCette opÃ©ration est IRRÃ‰VERSIBLE."):
                conn = get_connection()
                drop_tables(conn)
                conn.close()
                init_db()
                messagebox.showinfo("ClÃ´ture terminÃ©e", "La base a Ã©tÃ© rÃ©initialisÃ©e pour un nouvel exercice.")
        else:
            messagebox.showinfo("ClÃ´ture terminÃ©e", f"Archive et exports gÃ©nÃ©rÃ©s dans {export_dir}")

    except Exception as e:
        message = handle_exception(e, "Erreur lors de la clÃ´ture d'exercice.")
        messagebox.showerror("Erreur", message)
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/csv_helpers.py ===

```python
import csv
import os

def write_csv(filepath, data, header=None, delimiter=",", encoding="utf-8"):
    """
    Ã‰crit des donnÃ©es dans un fichier CSV.
    - filepath : chemin du fichier Ã  Ã©crire
    - data : liste de listes (lignes)
    - header : liste des noms de colonnes (optionnel)
    """
    os.makedirs(os.path.dirname(filepath), exist_ok=True)
    with open(filepath, "w", newline='', encoding=encoding) as csvfile:
        writer = csv.writer(csvfile, delimiter=delimiter)
        if header:
            writer.writerow(header)
        writer.writerows(data)

def read_csv(filepath, delimiter=",", encoding="utf-8"):
    """
    Lit un fichier CSV et retourne une liste de lignes (chacune est une liste).
    """
    with open(filepath, "r", newline='', encoding=encoding) as csvfile:
        reader = csv.reader(csvfile, delimiter=delimiter)
        return [row for row in reader]

def write_dicts_csv(filepath, dict_list, fieldnames, delimiter=",", encoding="utf-8"):
    """
    Ã‰crit une liste de dictionnaires dans un CSV avec les en-tÃªtes fournis.
    """
    os.makedirs(os.path.dirname(filepath), exist_ok=True)
    with open(filepath, "w", newline='', encoding=encoding) as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames, delimiter=delimiter)
        writer.writeheader()
        writer.writerows(dict_list)

def read_dicts_csv(filepath, delimiter=",", encoding="utf-8"):
    """
    Lit un CSV et retourne une liste de dictionnaires.
    """
    with open(filepath, "r", newline='', encoding=encoding) as csvfile:
        reader = csv.DictReader(csvfile, delimiter=delimiter)
        return [row for row in reader]
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/date_helpers.py ===

```python
from datetime import datetime

def parse_date(date_str, formats=None):
    """
    Tente de parser une chaÃ®ne de date dans plusieurs formats usuels.
    Retourne un objet datetime ou None si Ã©chec.
    """
    if not formats:
        formats = [
            "%Y-%m-%d",
            "%d/%m/%Y",
            "%d-%m-%Y",
            "%Y/%m/%d",
            "%m/%d/%Y",
            "%d.%m.%Y",
        ]
    for fmt in formats:
        try:
            return datetime.strptime(date_str, fmt)
        except (ValueError, TypeError):
            continue
    return None

def format_date(date_obj, fmt="%Y-%m-%d"):
    """
    Formate un objet date/datetime en chaÃ®ne selon le format fourni.
    """
    if not date_obj:
        return ""
    return date_obj.strftime(fmt)

def is_date_valid(date_str, formats=None):
    """
    VÃ©rifie si la chaÃ®ne est une date valide dans au moins un format connu.
    """
    return parse_date(date_str, formats) is not None

def today(fmt="%Y-%m-%d"):
    """
    Retourne la date du jour au format spÃ©cifiÃ©.
    """
    return datetime.today().strftime(fmt)
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/db_helpers.py ===

```python
"""
Database helper utilities.

This module provides utility functions for working with database results,
particularly for safely handling sqlite3.Row objects.
"""


def row_to_dict(row):
    """
    Convert sqlite3.Row to dict for safe .get() access.
    
    sqlite3.Row objects support dictionary-style access (row['column']) but
    lack the .get() method that dicts have for optional fields with defaults.
    This function converts a Row to a dict to enable .get() usage.
    
    Args:
        row: sqlite3.Row object or None
        
    Returns:
        dict or None: Dictionary representation of the row, or None if input is None
        
    Example:
        >>> row = cursor.execute("SELECT * FROM table").fetchone()
        >>> row_dict = row_to_dict(row)
        >>> value = row_dict.get('optional_column', 'default')
    """
    if row is None:
        return None
    return dict(row)


def rows_to_dicts(rows):
    """
    Convert list of sqlite3.Row objects to list of dicts.
    
    This is a batch version of row_to_dict() for converting multiple rows.
    
    Args:
        rows: list of sqlite3.Row objects
        
    Returns:
        list of dicts: List of dictionary representations
        
    Example:
        >>> rows = cursor.execute("SELECT * FROM table").fetchall()
        >>> dicts = rows_to_dicts(rows)
        >>> for d in dicts:
        >>>     print(d.get('optional_column', 'N/A'))
    """
    return [dict(row) for row in rows]


def row_get_safe(row, key, default=None):
    """
    Safe accessor for sqlite3.Row that returns default value when column is absent.
    
    This function provides a .get()-like interface directly on Row objects without
    needing to convert the entire row to a dict. Useful when only accessing one
    or two optional fields.
    
    Note: sqlite3.Row raises IndexError (not KeyError) when accessing missing
    columns, whether using string keys or integer indices.
    
    Args:
        row: sqlite3.Row object
        key: column name (string) or index (integer) to access
        default: value to return if column doesn't exist
        
    Returns:
        row[key] if column exists, default otherwise
        
    Example:
        >>> row = cursor.execute("SELECT * FROM table").fetchone()
        >>> name = row_get_safe(row, 'name', 'Unknown')
        >>> first_col = row_get_safe(row, 0, None)
    """
    try:
        return row[key]
    except IndexError:
        return default

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/db_operations.py ===

```python
"""
Centralized database operations with standardized error handling and connection management.

This module provides standard patterns for database operations that:
- Ensure proper connection cleanup
- Provide consistent error handling
- Convert sqlite3.Row to dicts when needed for .get() access
- Minimize lock duration by closing connections promptly
"""

from typing import List, Dict, Any, Optional, Callable
from contextlib import contextmanager
import sqlite3

from db.db import get_connection
from utils.db_helpers import rows_to_dicts, row_to_dict
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("db_operations")


@contextmanager
def db_connection():
    """
    Context manager for database connections.
    
    Ensures connections are always closed, even if an exception occurs.
    Minimizes lock duration.
    
    Usage:
        with db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM table")
            rows = cursor.fetchall()
        # Connection automatically closed here
    """
    conn = None
    try:
        conn = get_connection()
        yield conn
    finally:
        if conn:
            try:
                conn.close()
            except Exception as e:
                logger.warning(f"Error closing connection: {e}")


def execute_query(query: str, params: tuple = None, fetch: str = "all") -> List[Dict[str, Any]]:
    """
    Execute a SELECT query and return results as list of dicts.
    
    Args:
        query: SQL SELECT query
        params: Optional query parameters
        fetch: "all" to fetch all rows, "one" to fetch one row
        
    Returns:
        List of dicts (or single dict if fetch="one")
        
    Example:
        rows = execute_query("SELECT * FROM members WHERE id=?", (1,), fetch="one")
        all_members = execute_query("SELECT * FROM members ORDER BY name")
    """
    with db_connection() as conn:
        cursor = conn.cursor()
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        
        if fetch == "one":
            row = cursor.fetchone()
            return row_to_dict(row) if row else None
        else:
            rows = cursor.fetchall()
            return rows_to_dicts(rows)


def _validate_table_name(table: str) -> None:
    """
    Validate table name to prevent SQL injection.
    
    Table names must contain only alphanumeric characters and underscores.
    
    Args:
        table: Table name to validate
        
    Raises:
        ValueError: If table name is invalid
    """
    import re
    if not re.match(r'^[a-zA-Z0-9_]+$', table):
        raise ValueError(f"Invalid table name: {table}. Table names must contain only alphanumeric characters and underscores.")


def execute_insert(table: str, data: Dict[str, Any]) -> int:
    """
    Execute an INSERT statement and return the new row ID.
    
    Args:
        table: Table name (validated to prevent SQL injection)
        data: Dict of column->value pairs
        
    Returns:
        ID of inserted row
        
    Raises:
        ValueError: If table name is invalid
        
    Example:
        new_id = execute_insert("members", {
            "name": "Dupont",
            "prenom": "Jean",
            "email": "jean@example.com"
        })
    """
    _validate_table_name(table)
    columns = ", ".join(data.keys())
    placeholders = ", ".join(["?" for _ in data])
    query = f"INSERT INTO {table} ({columns}) VALUES ({placeholders})"
    
    with db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute(query, tuple(data.values()))
        conn.commit()
        return cursor.lastrowid


def execute_update(table: str, data: Dict[str, Any], where: Dict[str, Any]) -> int:
    """
    Execute an UPDATE statement and return the number of affected rows.
    
    Args:
        table: Table name (validated to prevent SQL injection)
        data: Dict of column->value pairs to update
        where: Dict of column->value pairs for WHERE clause
        
    Returns:
        Number of rows updated
        
    Raises:
        ValueError: If table name is invalid
        
    Example:
        rows_updated = execute_update(
            "members",
            {"email": "new@example.com"},
            {"id": 1}
        )
    """
    _validate_table_name(table)
    set_clause = ", ".join([f"{k}=?" for k in data.keys()])
    where_clause = " AND ".join([f"{k}=?" for k in where.keys()])
    query = f"UPDATE {table} SET {set_clause} WHERE {where_clause}"
    
    with db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute(query, tuple(data.values()) + tuple(where.values()))
        conn.commit()
        return cursor.rowcount


def execute_delete(table: str, where: Dict[str, Any]) -> int:
    """
    Execute a DELETE statement and return the number of affected rows.
    
    Args:
        table: Table name (validated to prevent SQL injection)
        where: Dict of column->value pairs for WHERE clause
        
    Returns:
        Number of rows deleted
        
    Raises:
        ValueError: If table name is invalid
        
    Example:
        rows_deleted = execute_delete("members", {"id": 1})
    """
    _validate_table_name(table)
    where_clause = " AND ".join([f"{k}=?" for k in where.keys()])
    query = f"DELETE FROM {table} WHERE {where_clause}"
    
    with db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute(query, tuple(where.values()))
        conn.commit()
        return cursor.rowcount


def safe_execute(operation: Callable, error_message: str = "Database operation failed") -> Optional[Any]:
    """
    Safely execute a database operation with error handling.
    
    Args:
        operation: Function to execute
        error_message: Error message to display if operation fails
        
    Returns:
        Result of operation, or None if error occurred
        
    Example:
        def fetch_members():
            return execute_query("SELECT * FROM members")
        
        members = safe_execute(fetch_members, "Failed to load members")
    """
    try:
        return operation()
    except Exception as e:
        logger.error(f"{error_message}: {e}")
        handle_exception(e, error_message)
        return None

```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/error_handler.py ===

```python
import traceback
from utils.app_logger import get_logger
import tkinter as tk
from tkinter import messagebox

logger = get_logger("error_handler")

def handle_exception(e, user_msg="Une erreur est survenue."):
    """
    Centralise la gestion des exceptions :
    - Loggue l'exception (trace complÃ¨te dans logs)
    - Retourne un message utilisateur prÃªt Ã  afficher
    """
    tb_str = traceback.format_exc()
    logger.error(f"{user_msg}\nException: {e}\nTraceback:\n{tb_str}")
    return user_msg
    
def handle_errors(func):
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as ex:
            tb = traceback.format_exc()
            logger.error(f"Erreur: {ex}\nTraceback:\n{tb}")
            messagebox.showerror("Erreur", f"{ex}\n\n{tb}")
    return wrapper

def safe_call(func, *args, user_msg="Une erreur est survenue.", **kwargs):
    """
    ExÃ©cute une fonction de faÃ§on sÃ©curisÃ©e :
    - Si tout va bien, retourne le rÃ©sultat
    - Si exception, loggue et retourne None + affiche un message utilisateur
    """
    try:
        return func(*args, **kwargs)
    except Exception as e:
        handle_exception(e, user_msg)
        return None
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/notify.py ===

```python
import sys

def notify(title, message):
    try:
        if sys.platform.startswith("linux"):
            import subprocess
            subprocess.run(['notify-send', title, message])
        elif sys.platform == "darwin":
            import os
            os.system(f"""osascript -e 'display notification "{message}" with title "{title}"'""")
        elif sys.platform == "win32":
            from win10toast import ToastNotifier
            toaster = ToastNotifier()
            toaster.show_toast(title, message, duration=5)
    except Exception as e:
        print(f"Notification error: {e}")
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/pdf_helpers.py ===

```python
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib import colors

def simple_pdf_table(path, title, df, parent=None):
    styles = getSampleStyleSheet()
    doc = SimpleDocTemplate(path, pagesize=A4)
    elems = []
    elems.append(Paragraph(title, styles["Title"]))
    elems.append(Spacer(1, 12))
    table_data = [list(df.columns)] + df.values.tolist()
    tbl = Table(table_data, hAlign="LEFT")
    tbl.setStyle(TableStyle([
        ("BACKGROUND", (0, 0), (-1, 0), colors.grey),
        ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
        ("ALIGN", (0, 0), (-1, -1), "LEFT"),
        ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
        ("FONTSIZE", (0, 0), (-1, -1), 9),
        ("BOTTOMPADDING", (0, 0), (-1, 0), 10),
        ("BACKGROUND", (0, 1), (-1, -1), colors.beige),
        ("GRID", (0, 0), (-1, -1), 0.5, colors.black),
    ]))
    elems.append(tbl)
    doc.build(elems)
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/validation.py ===

```python
import re
from typing import Any, Dict

def is_email(email):
    """
    VÃ©rifie si la chaÃ®ne est un email valide (format simple, sans DNS check).
    """
    if not email or not isinstance(email, str):
        return False
    # Expression rÃ©guliÃ¨re simple pour les emails valides
    pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
    return re.match(pattern, email) is not None

def is_required(value):
    """
    Retourne True si la valeur est prÃ©sente et non vide.
    """
    return bool(value and str(value).strip())
    
def is_number(val):
    try:
        float(val)
        return True
    except (ValueError, TypeError):
        return False

def is_integer(val):
    """
    VÃ©rifie si la valeur peut Ãªtre convertie en entier.
    Note: Returns False for boolean values to avoid treating True/False as 1/0.
    """
    try:
        # Explicitly exclude booleans (bool is subclass of int in Python)
        if isinstance(val, bool):
            return False
        if isinstance(val, int):
            return True
        if isinstance(val, str):
            int(val)
            return True
        return False
    except (ValueError, TypeError):
        return False

def is_valid_string(s: Any, allow_empty: bool = False) -> bool:
    if not isinstance(s, str):
        return False
    if not allow_empty and s.strip() == '':
        return False
    return True

def validate_record(schema: Dict[str, type], record: Dict[str, Any]) -> bool:
    """Basic schema validation: checks presence and type of keys. Returns True if valid."""
    for k, t in schema.items():
        if k not in record:
            return False
        if not isinstance(record[k], t):
            return False
    return True

def sanitize_string(s: str) -> str:
    # Minimal sanitization: strip control chars and trim
    return ''.join(ch for ch in s if ch.isprintable()).strip()
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/zip_helpers.py ===

```python
import zipfile
import os

def zip_directory(source_dir, zip_path):
    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, _, files in os.walk(source_dir):
            for file in files:
                abs_path = os.path.join(root, file)
                arc_path = os.path.relpath(abs_path, start=source_dir)
                zipf.write(abs_path, arc_path)

def extract_zip(zip_path, dest_dir):
    with zipfile.ZipFile(zip_path, 'r') as zipf:
        zipf.extractall(dest_dir)
```


# ===== FICHIER SUIVANT =====

# === Fichier: ./utils/__init__.py ===

```python
# utils package

```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/buvette.py ===

```python
"""
Module de gestion du module Buvette (UI).

MODIFICATIONS APPLIQUÃ‰ES (PR corrections buvette - copilot/auto-fix-buvette):
- InventaireDialog: ajout de columnconfigure(1, weight=1) et sticky='ew' pour layout amÃ©liorÃ©
- InventaireDialog: remplacement du champ 'Type inventaire' Entry par Combobox (avant/apres/hors_evenement)
- InventaireDialog.save: validation stricte du type d'inventaire
- LignesInventaireDialog.refresh_lignes(): affichage de article_name au lieu de article_id
- LigneInventaireDialog: utilisation de Combobox pour sÃ©lectionner un article
- LigneInventaireDialog.save: appel automatique de set_article_stock() aprÃ¨s enregistrement pour MAJ immÃ©diate
- MouvementDialog: utilisation de Combobox pour sÃ©lectionner un article
- AchatDialog: utilisation de Combobox pour sÃ©lectionner un article
- refresh_bilan(): protection des agrÃ©gations contre les valeurs None
- BuvetteModule.__init__: appel de ensure_stock_column() au dÃ©marrage pour garantir la colonne stock existe
"""

import os
import tkinter as tk
from datetime import datetime
from tkinter import ttk, messagebox
from modules.buvette_db import (
    list_articles, insert_article, update_article, delete_article,
    list_achats, insert_achat, update_achat, delete_achat,
    get_article_by_id, get_achat_by_id,
    list_mouvements, insert_mouvement, update_mouvement, delete_mouvement, get_mouvement_by_id,
    list_articles_names, set_article_stock, ensure_stock_column
)
import modules.buvette_inventaire_db as inv_db
from utils.app_logger import get_logger
from utils.error_handler import handle_exception
# DB functions now return dicts directly, eliminating need for row conversion utilities (row_to_dict, row_get_safe)

logger = get_logger("buvette_module")

class BuvetteModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Gestion Buvette")
        self.notebook = ttk.Notebook(self.top)
        self.notebook.pack(fill=tk.BOTH, expand=True)

        # Assurer que la colonne 'stock' existe dans buvette_articles (migration non destructive)
        try:
            ensure_stock_column()
        except Exception as e:
            logger.warning(f"Erreur lors de la vÃ©rification de la colonne stock: {e}")

        self.create_tab_articles()
        self.create_tab_achats()
        self.create_tab_inventaires()
        self.create_tab_mouvements()
        self.create_tab_bilan()

    # ------------------ TAB ARTICLES ------------------
    def create_tab_articles(self):
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text="Articles")

        self.articles_tree = ttk.Treeview(frame, columns=("name", "categorie", "unite", "contenance", "purchase_price", "commentaire"), show="headings")
        self.articles_tree.heading("name", text="Name")
        self.articles_tree.heading("categorie", text="CatÃ©gorie")
        self.articles_tree.heading("unite", text="UnitÃ©")
        self.articles_tree.heading("contenance", text="Contenance")
        self.articles_tree.heading("purchase_price", text="Prix achat/unitÃ© (â‚¬)")
        self.articles_tree.heading("commentaire", text="Commentaire")
        self.articles_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT, padx=3, pady=3)

        self.refresh_articles()

        btn_frame = tk.Frame(frame)
        btn_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5)
        tk.Button(btn_frame, text="Ajouter", command=self.add_article).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Modifier", command=self.edit_article).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Supprimer", command=self.del_article).pack(fill=tk.X, pady=2)

    def refresh_articles(self):
        try:
            for row in self.articles_tree.get_children():
                self.articles_tree.delete(row)
            for a in list_articles():
                # Use .get() for safe access to optional fields (articles are already dicts)
                purchase_price = a.get("purchase_price")
                purchase_price_display = ""
                if purchase_price is not None:
                    try:
                        purchase_price_display = f"{float(purchase_price):.2f}"
                    except (ValueError, TypeError):
                        pass
                
                self.articles_tree.insert(
                    "", "end", iid=a.get("id", 0),
                    values=(
                        a.get("name", ""),
                        a.get("categorie", ""),
                        a.get("unite", ""),
                        a.get("contenance", ""),
                        purchase_price_display,
                        a.get("commentaire", "")
                    )
                )
        except Exception as e:
            logger.exception("Error refreshing articles list")
            # Write diagnostic report for debugging
            try:
                reports_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "reports")
                os.makedirs(reports_dir, exist_ok=True)
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                report_path = os.path.join(reports_dir, f"inventory_error_refresh_articles_{timestamp}.txt")
                with open(report_path, 'w', encoding='utf-8') as f:
                    f.write(f"Articles Refresh Error Report\n")
                    f.write(f"{'='*60}\n")
                    f.write(f"Timestamp: {datetime.now().isoformat()}\n")
                    f.write(f"Error: {str(e)}\n")
                    f.write(f"Error Type: {type(e).__name__}\n")
                    f.write(f"\nDiagnostic: Error occurred while refreshing articles list.\n")
                    f.write(f"Ensure sqlite3.Row objects are properly converted to dicts.\n")
                logger.info(f"Diagnostic report written to: {report_path}")
            except Exception as report_err:
                logger.error(f"Failed to write diagnostic report: {report_err}")
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des articles. VÃ©rifiez que la structure de la base de donnÃ©es est Ã  jour."))

    def add_article(self):
        ArticleDialog(self.top, self.refresh_articles)

    def edit_article(self):
        sel = self.articles_tree.focus()
        if sel:
            article = get_article_by_id(sel)
            ArticleDialog(self.top, self.refresh_articles, article)
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un article Ã  modifier.")

    def del_article(self):
        sel = self.articles_tree.focus()
        if sel:
            if messagebox.askyesno("Suppression", "Supprimer cet article ?"):
                try:
                    delete_article(sel)
                    self.refresh_articles()
                except Exception as e:
                    messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de l'article."))
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un article Ã  supprimer.")

    # ------------------ TAB ACHATS ------------------
    def create_tab_achats(self):
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text="Achats")

        self.achats_tree = ttk.Treeview(frame, columns=("article_name", "contenance", "date_achat", "quantite", "prix_unitaire", "fournisseur", "facture", "exercice"), show="headings")
        self.achats_tree.heading("article_name", text="Article")
        self.achats_tree.heading("contenance", text="Contenance")
        self.achats_tree.heading("date_achat", text="Date")
        self.achats_tree.heading("quantite", text="QuantitÃ©")
        self.achats_tree.heading("prix_unitaire", text="PU (â‚¬)")
        self.achats_tree.heading("fournisseur", text="Fournisseur")
        self.achats_tree.heading("facture", text="Facture")
        self.achats_tree.heading("exercice", text="Exercice")
        self.achats_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT, padx=3, pady=3)

        self.refresh_achats()

        btn_frame = tk.Frame(frame)
        btn_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5)
        tk.Button(btn_frame, text="Ajouter", command=self.add_achat).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Modifier", command=self.edit_achat).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Supprimer", command=self.del_achat).pack(fill=tk.X, pady=2)

    def refresh_achats(self):
        try:
            for row in self.achats_tree.get_children():
                self.achats_tree.delete(row)
            for ach in list_achats():
                self.achats_tree.insert(
                    "", "end", iid=ach["id"],
                    values=(
                        ach["article_name"],
                        ach["article_contenance"] if "article_contenance" in ach.keys() and ach["article_contenance"] is not None else "",
                        ach["date_achat"],
                        ach["quantite"],
                        ach["prix_unitaire"],
                        ach["fournisseur"],
                        ach["facture"],
                        ach["exercice"]
                    )
                )
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des achats."))

    def add_achat(self):
        AchatDialog(self.top, self.refresh_achats)

    def edit_achat(self):
        sel = self.achats_tree.focus()
        if sel:
            achat = get_achat_by_id(sel)
            AchatDialog(self.top, self.refresh_achats, achat)
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un achat Ã  modifier.")

    def del_achat(self):
        sel = self.achats_tree.focus()
        if sel:
            if messagebox.askyesno("Suppression", "Supprimer cet achat ?"):
                try:
                    delete_achat(sel)
                    self.refresh_achats()
                except Exception as e:
                    messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de l'achat."))
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un achat Ã  supprimer.")

    # ------------------ TAB INVENTAIRES ------------------
    def create_tab_inventaires(self):
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text="Inventaires")

        self.inventaires_tree = ttk.Treeview(frame, columns=("date", "nom", "commentaire"), show="headings")
        self.inventaires_tree.heading("date", text="Date")
        self.inventaires_tree.heading("nom", text="Nom inventaire")
        self.inventaires_tree.heading("commentaire", text="Commentaire")
        self.inventaires_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT, padx=3, pady=3)

        self.refresh_inventaires()

        btn_frame = tk.Frame(frame)
        btn_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5)
        # Removed simple 'Ajouter' button - functionality replaced by detailed inventory dialog below
        tk.Button(btn_frame, text="Modifier", command=self.edit_inventaire).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Supprimer", command=self.del_inventaire).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Voir lignes", command=self.show_lignes_inventaire).pack(fill=tk.X, pady=2)
        # Separator
        ttk.Separator(btn_frame, orient='horizontal').pack(fill=tk.X, pady=10)
        # New detailed inventory button (replaces simple "Ajouter")
        tk.Button(btn_frame, text="Nouvel inventaire\ndÃ©taillÃ©", command=self.add_detailed_inventaire, bg="#4CAF50", fg="white").pack(fill=tk.X, pady=2)

    def refresh_inventaires(self):
        try:
            for row in self.inventaires_tree.get_children():
                self.inventaires_tree.delete(row)
            for inv in inv_db.list_inventaires():
                self.inventaires_tree.insert("", "end", iid=inv["id"], values=(inv["date_inventaire"], inv["type_inventaire"], inv["commentaire"]))
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des inventaires."))

    def add_inventaire(self):
        InventaireDialog(self.top, self.refresh_inventaires)

    def edit_inventaire(self):
        """Open the detailed inventory dialog for editing an existing inventory."""
        sel = self.inventaires_tree.focus()
        if sel:
            inv = None
            for i in inv_db.list_inventaires():
                if str(i["id"]) == str(sel):
                    inv = i
                    break
            if inv:
                # Open detailed dialog with edit mode
                from ui.inventory_lines_dialog import InventoryLinesDialog
                dialog = InventoryLinesDialog(self.top, edit_inventory=inv)
                # Make dialog modal and wait for it to close before refreshing
                dialog.grab_set()
                self.top.wait_window(dialog)
                # Refresh inventory list after dialog closes
                self.refresh_inventaires()
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un inventaire Ã  modifier.")

    def del_inventaire(self):
        sel = self.inventaires_tree.focus()
        if sel:
            if messagebox.askyesno("Suppression", "Supprimer cet inventaire ?"):
                try:
                    inv_db.delete_inventaire(sel)
                    self.refresh_inventaires()
                except Exception as e:
                    messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de l'inventaire."))
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un inventaire Ã  supprimer.")

    def show_lignes_inventaire(self):
        sel = self.inventaires_tree.focus()
        if sel:
            LignesInventaireDialog(self.top, sel)
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un inventaire pour voir les lignes.")

    def add_detailed_inventaire(self):
        """Open the detailed inventory dialog."""
        from ui.inventory_lines_dialog import InventoryLinesDialog
        dialog = InventoryLinesDialog(self.top)
        # Make dialog modal and wait for it to close before refreshing
        dialog.grab_set()
        self.top.wait_window(dialog)
        # Refresh inventory list after dialog closes
        self.refresh_inventaires()

    # ------------------ TAB MOUVEMENTS ------------------
    def create_tab_mouvements(self):
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text="Mouvements")

        self.mouvements_tree = ttk.Treeview(frame, columns=("date", "article_name", "contenance", "type", "quantite", "commentaire"), show="headings")
        self.mouvements_tree.heading("date", text="Date")
        self.mouvements_tree.heading("article_name", text="Article")
        self.mouvements_tree.heading("contenance", text="Contenance")
        self.mouvements_tree.heading("type", text="Type")
        self.mouvements_tree.heading("quantite", text="QuantitÃ©")
        self.mouvements_tree.heading("commentaire", text="Commentaire")
        self.mouvements_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT, padx=3, pady=3)

        self.refresh_mouvements()

        btn_frame = tk.Frame(frame)
        btn_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5)
        tk.Button(btn_frame, text="Ajouter", command=self.add_mouvement).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Modifier", command=self.edit_mouvement).pack(fill=tk.X, pady=2)
        tk.Button(btn_frame, text="Supprimer", command=self.del_mouvement).pack(fill=tk.X, pady=2)

    def refresh_mouvements(self):
        try:
            for row in self.mouvements_tree.get_children():
                self.mouvements_tree.delete(row)
            for mvt in list_mouvements():
                self.mouvements_tree.insert(
                    "", "end", iid=mvt["id"],
                    values=(mvt["date"], mvt["article_name"], mvt["article_contenance"] if "article_contenance" in mvt.keys() and mvt["article_contenance"] is not None else "", mvt["type"], mvt["quantite"], mvt["commentaire"])
                )
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des mouvements."))

    def add_mouvement(self):
        MouvementDialog(self.top, self.refresh_mouvements)

    def edit_mouvement(self):
        sel = self.mouvements_tree.focus()
        if sel:
            mvt = get_mouvement_by_id(sel)
            MouvementDialog(self.top, self.refresh_mouvements, mvt)
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un mouvement Ã  modifier.")

    def del_mouvement(self):
        sel = self.mouvements_tree.focus()
        if sel:
            if messagebox.askyesno("Suppression", "Supprimer ce mouvement ?"):
                try:
                    delete_mouvement(sel)
                    self.refresh_mouvements()
                except Exception as e:
                    messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression du mouvement."))
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner un mouvement Ã  supprimer.")

    # ------------------ TAB BILAN ------------------
    def create_tab_bilan(self):
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text="Bilan")

        self.bilan_text = tk.Text(frame, height=26, width=120, wrap=tk.WORD)
        self.bilan_text.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        tk.Button(frame, text="RafraÃ®chir bilan", command=self.refresh_bilan).pack(pady=3)
        self.refresh_bilan()

    def refresh_bilan(self):
        try:
            # Protection contre None pour les agrÃ©gations
            achats = sum(int(a["quantite"] or 0) for a in list_achats())
            mvts_entree = sum(int(m["quantite"] or 0) for m in list_mouvements() if m["type"] == "entrÃ©e")
            mvts_sortie = sum(int(m["quantite"] or 0) for m in list_mouvements() if m["type"] == "sortie")
            invs = sum(int(l["quantite"] or 0) for inv in inv_db.list_inventaires() for l in inv_db.list_lignes_inventaire(inv["id"]))
            txt = f"Total achats : {achats}\n"
            txt += f"Total mouvements entrÃ©e : {mvts_entree}\n"
            txt += f"Total mouvements sortie : {mvts_sortie}\n"
            txt += f"Total inventaire (toutes lignes) : {invs}\n"
            self.bilan_text.delete(1.0, tk.END)
            self.bilan_text.insert(tk.END, txt)
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du calcul du bilan."))

# ------------------ DIALOGS ------------------

class ArticleDialog(tk.Toplevel):
    def __init__(self, master, on_done, article=None):
        super().__init__(master)
        self.title("Article")
        self.on_done = on_done
        self.article = article

        tk.Label(self, text="Name").grid(row=0, column=0, sticky="w")
        self.name_var = tk.StringVar(value=article["name"] if article else "")
        tk.Entry(self, textvariable=self.name_var).grid(row=0, column=1)

        tk.Label(self, text="CatÃ©gorie").grid(row=1, column=0, sticky="w")
        self.categorie_var = tk.StringVar(value=article["categorie"] if article else "")
        tk.Entry(self, textvariable=self.categorie_var).grid(row=1, column=1)

        tk.Label(self, text="UnitÃ©").grid(row=2, column=0, sticky="w")
        self.unite_var = tk.StringVar(value=article["unite"] if article else "")
        tk.Entry(self, textvariable=self.unite_var).grid(row=2, column=1)

        tk.Label(self, text="Contenance").grid(row=3, column=0, sticky="w")
        contenance_options = ["0.25L", "0.33L", "0.5L", "0.75L", "1L", "1.5L", "2L"]
        self.contenance_var = tk.StringVar(value=article["contenance"] if article and "contenance" in article else contenance_options[0])
        ttk.Combobox(self, textvariable=self.contenance_var, values=contenance_options, state="readonly").grid(row=3, column=1)

        tk.Label(self, text="Commentaire").grid(row=4, column=0, sticky="w")
        self.commentaire_var = tk.StringVar(value=article["commentaire"] if article else "")
        tk.Entry(self, textvariable=self.commentaire_var).grid(row=4, column=1)

        tk.Button(self, text="Enregistrer", command=self.save).grid(row=5, column=0, columnspan=2, pady=8)

    def save(self):
        name = self.name_var.get()
        categorie = self.categorie_var.get()
        unite = self.unite_var.get()
        contenance = self.contenance_var.get()
        commentaire = self.commentaire_var.get()
        if not name:
            messagebox.showwarning("Saisie", "Le nom est obligatoire.")
            return
        try:
            if self.article:
                update_article(self.article["id"], name, categorie, unite, commentaire, contenance)
            else:
                insert_article(name, categorie, unite, commentaire, contenance)
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de l'article."))

# ... autres classes inchangÃ©es ...
class AchatDialog(tk.Toplevel):
    def __init__(self, master, on_done, achat=None):
        super().__init__(master)
        self.title("Achat")
        self.on_done = on_done
        self.achat = achat

        from modules.buvette_db import list_articles_names
        tk.Label(self, text="Article").grid(row=0, column=0, sticky="w")
        articles = list_articles_names()
        self.article_options = [f"{a['name']} (id={a['id']})" for a in articles]
        self.article_id_map = {f"{a['name']} (id={a['id']})": a['id'] for a in articles}
        self.article_contenance_map = {f"{a['name']} (id={a['id']})": a['contenance'] for a in articles}
        default_article = None
        if achat:
            for opt in self.article_options:
                if self.article_id_map[opt] == achat["article_id"]:
                    default_article = opt
                    break
        self.article_var = tk.StringVar(value=default_article if default_article else (self.article_options[0] if self.article_options else ""))
        self.article_combo = ttk.Combobox(self, textvariable=self.article_var, values=self.article_options, state="readonly")
        self.article_combo.grid(row=0, column=1)

        # Affichage de la contenance de l'article sÃ©lectionnÃ© (lecture seule)
        tk.Label(self, text="Contenance").grid(row=1, column=0, sticky="w")
        self.contenance_var = tk.StringVar(value=self.article_contenance_map.get(self.article_var.get(), ""))
        self.contenance_entry = tk.Entry(self, textvariable=self.contenance_var, state="readonly")
        self.contenance_entry.grid(row=1, column=1)

        def update_contenance(*_):
            self.contenance_var.set(self.article_contenance_map.get(self.article_var.get(), ""))
        self.article_var.trace_add("write", update_contenance)

        tk.Label(self, text="Date").grid(row=2, column=0, sticky="w")
        self.date_var = tk.StringVar(value=achat["date_achat"] if achat else "")
        tk.Entry(self, textvariable=self.date_var).grid(row=2, column=1)

        tk.Label(self, text="QuantitÃ©").grid(row=3, column=0, sticky="w")
        self.quantite_var = tk.IntVar(value=achat["quantite"] if achat else 0)
        tk.Entry(self, textvariable=self.quantite_var).grid(row=3, column=1)

        tk.Label(self, text="PU (â‚¬)").grid(row=4, column=0, sticky="w")
        self.prix_unitaire_var = tk.DoubleVar(value=achat["prix_unitaire"] if achat else 0.0)
        tk.Entry(self, textvariable=self.prix_unitaire_var).grid(row=4, column=1)

        tk.Label(self, text="Fournisseur").grid(row=5, column=0, sticky="w")
        self.fournisseur_var = tk.StringVar(value=achat["fournisseur"] if achat else "")
        tk.Entry(self, textvariable=self.fournisseur_var).grid(row=5, column=1)

        tk.Label(self, text="Facture").grid(row=6, column=0, sticky="w")
        self.facture_var = tk.StringVar(value=achat["facture"] if achat else "")
        tk.Entry(self, textvariable=self.facture_var).grid(row=6, column=1)

        tk.Label(self, text="Exercice").grid(row=7, column=0, sticky="w")
        self.exercice_var = tk.StringVar(value=achat["exercice"] if achat else "")
        tk.Entry(self, textvariable=self.exercice_var).grid(row=7, column=1)

        tk.Button(self, text="Enregistrer", command=self.save).grid(row=8, column=0, columnspan=2, pady=8)

    def save(self):
        article_selection = self.article_var.get()
        article_id = self.article_id_map.get(article_selection)
        # contenance = self.article_contenance_map.get(article_selection) # lecture seule, utile si tu veux l'utiliser
        date_achat = self.date_var.get()
        quantite = self.quantite_var.get()
        prix_unitaire = self.prix_unitaire_var.get()
        fournisseur = self.fournisseur_var.get()
        facture = self.facture_var.get()
        exercice = self.exercice_var.get()
        if not article_id or not date_achat:
            messagebox.showwarning("Saisie", "Article et Date sont obligatoires.")
            return
        try:
            if self.achat:
                update_achat(self.achat["id"], article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice)
            else:
                insert_achat(article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice)
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de l'achat."))
            
class InventaireDialog(tk.Toplevel):
    def __init__(self, master, on_done, inventaire=None):
        super().__init__(master)
        self.title("Inventaire")
        self.on_done = on_done
        self.inventaire = inventaire
        
        # Configure grid pour layout extensible
        self.columnconfigure(1, weight=1)

        tk.Label(self, text="Date").grid(row=0, column=0, sticky="w", padx=5, pady=3)
        self.date_var = tk.StringVar(value=inventaire["date_inventaire"] if inventaire else "")
        tk.Entry(self, textvariable=self.date_var).grid(row=0, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="Type inventaire").grid(row=1, column=0, sticky="w", padx=5, pady=3)
        type_options = ["avant", "apres", "hors_evenement"]
        self.nom_var = tk.StringVar(value=inventaire["type_inventaire"] if inventaire else "hors_evenement")
        ttk.Combobox(self, textvariable=self.nom_var, values=type_options, state="readonly").grid(row=1, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="Commentaire").grid(row=2, column=0, sticky="w", padx=5, pady=3)
        self.commentaire_var = tk.StringVar(value=inventaire["commentaire"] if inventaire else "")
        tk.Entry(self, textvariable=self.commentaire_var).grid(row=2, column=1, sticky="ew", padx=5, pady=3)

        tk.Button(self, text="Enregistrer", command=self.save).grid(row=3, column=0, columnspan=2, pady=8)

    def save(self):
        date = self.date_var.get()
        type_inventaire = self.nom_var.get()
        commentaire = self.commentaire_var.get()
        if not date or not type_inventaire:
            messagebox.showwarning("Saisie", "Date et type sont obligatoires.")
            return
        
        # Valider que le type est bien dans les valeurs acceptÃ©es
        if type_inventaire not in ('avant', 'apres', 'hors_evenement'):
            messagebox.showwarning("Saisie", "Le type doit Ãªtre 'avant', 'apres' ou 'hors_evenement'.")
            return
        
        event_id = None  # No event linked for now
        
        try:
            if self.inventaire:
                inv_db.update_inventaire(self.inventaire["id"], date, event_id, type_inventaire, commentaire)
            else:
                # Capture inv_id for potential future use (e.g., adding lignes immediately after creation)
                inv_id = inv_db.insert_inventaire(date, event_id, type_inventaire, commentaire)
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de l'inventaire."))

class LignesInventaireDialog(tk.Toplevel):
    def __init__(self, master, inventaire_id):
        super().__init__(master)
        self.title("Lignes de l'inventaire")
        self.inventaire_id = inventaire_id
        self.create_widgets()
        self.refresh_lignes()

    def create_widgets(self):
        self.lignes_tree = ttk.Treeview(self, columns=("article_id", "quantite", "commentaire"), show="headings")
        self.lignes_tree.heading("article_id", text="Article")
        self.lignes_tree.heading("quantite", text="QuantitÃ©")
        self.lignes_tree.heading("commentaire", text="Commentaire")
        self.lignes_tree.pack(fill=tk.BOTH, expand=True, padx=3, pady=3)
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X, pady=6)
        tk.Button(btn_frame, text="Ajouter", command=self.add_ligne).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Modifier", command=self.edit_ligne).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Supprimer", command=self.del_ligne).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=6)

    def refresh_lignes(self):
        try:
            for row in self.lignes_tree.get_children():
                self.lignes_tree.delete(row)
            for l in inv_db.list_lignes_inventaire(self.inventaire_id):
                # l is already a dict from list_lignes_inventaire (uses rows_to_dicts)
                # Afficher article_name au lieu de article_id pour meilleure lisibilitÃ©
                article_display = l.get("article_name") or f"ID:{l.get('article_id', 'Unknown')}"
                # ID should always be present from DB, but use str() for safety
                line_id = str(l.get("id", 0))
                self.lignes_tree.insert("", "end", iid=line_id, values=(article_display, l.get("quantite", 0), l.get("commentaire", "")))
        except Exception as e:
            logger.exception("Error refreshing inventory lines")
            # Write diagnostic report for debugging
            try:
                reports_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "reports")
                os.makedirs(reports_dir, exist_ok=True)
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                report_path = os.path.join(reports_dir, f"inventory_error_buvette_{timestamp}.txt")
                with open(report_path, 'w', encoding='utf-8') as f:
                    f.write(f"Inventory Lines Refresh Error Report\n")
                    f.write(f"{'='*60}\n")
                    f.write(f"Timestamp: {datetime.now().isoformat()}\n")
                    f.write(f"Inventaire ID: {self.inventaire_id}\n")
                    f.write(f"Error: {str(e)}\n")
                    f.write(f"Error Type: {type(e).__name__}\n")
                    f.write(f"\nDiagnostic: Error occurred while refreshing inventory lines.\n")
                    f.write(f"Ensure sqlite3.Row objects are properly converted to dicts.\n")
                logger.info(f"Diagnostic report written to: {report_path}")
            except Exception as report_err:
                logger.error(f"Failed to write diagnostic report: {report_err}")
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des lignes d'inventaire."))

    def add_ligne(self):
        LigneInventaireDialog(self, self.refresh_lignes, self.inventaire_id)

    def edit_ligne(self):
        sel = self.lignes_tree.focus()
        if sel:
            ligne = None
            for l in inv_db.list_lignes_inventaire(self.inventaire_id):
                if str(l["id"]) == str(sel):
                    ligne = l
                    break
            if ligne:
                LigneInventaireDialog(self, self.refresh_lignes, self.inventaire_id, ligne)
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner une ligne Ã  modifier.")

    def del_ligne(self):
        sel = self.lignes_tree.focus()
        if sel:
            if messagebox.askyesno("Suppression", "Supprimer cette ligne ?"):
                try:
                    inv_db.delete_ligne_inventaire(sel)
                    self.refresh_lignes()
                except Exception as e:
                    messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de la ligne d'inventaire."))
        else:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionner une ligne Ã  supprimer.")

class LigneInventaireDialog(tk.Toplevel):
    def __init__(self, master, on_done, inventaire_id, ligne=None):
        super().__init__(master)
        self.title("Ligne inventaire")
        self.on_done = on_done
        self.inventaire_id = inventaire_id
        self.ligne = ligne

        # Utiliser Combobox pour sÃ©lectionner un article
        tk.Label(self, text="Article").grid(row=0, column=0, sticky="w", padx=5, pady=3)
        articles = list_articles_names()
        self.article_options = [f"{a['name']} ({a['contenance'] or 'N/A'})" for a in articles]
        self.article_id_map = {f"{a['name']} ({a['contenance'] or 'N/A'})": a['id'] for a in articles}
        
        # SÃ©lectionner l'article par dÃ©faut si en mode Ã©dition
        default_article = None
        if ligne:
            for opt in self.article_options:
                if self.article_id_map[opt] == ligne["article_id"]:
                    default_article = opt
                    break
        
        self.article_var = tk.StringVar(value=default_article if default_article else (self.article_options[0] if self.article_options else ""))
        self.article_combo = ttk.Combobox(self, textvariable=self.article_var, values=self.article_options, state="readonly", width=30)
        self.article_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="QuantitÃ©").grid(row=1, column=0, sticky="w", padx=5, pady=3)
        self.quantite_var = tk.IntVar(value=ligne["quantite"] if ligne else 0)
        tk.Entry(self, textvariable=self.quantite_var).grid(row=1, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="Commentaire").grid(row=2, column=0, sticky="w", padx=5, pady=3)
        self.comment_var = tk.StringVar(value=ligne["commentaire"] if ligne else "")
        tk.Entry(self, textvariable=self.comment_var).grid(row=2, column=1, sticky="ew", padx=5, pady=3)

        tk.Button(self, text="Enregistrer", command=self.save).grid(row=3, column=0, columnspan=2, pady=8)

    def save(self):
        article_selection = self.article_var.get()
        article_id = self.article_id_map.get(article_selection)
        quantite = self.quantite_var.get()
        comment = self.comment_var.get()
        if not article_id:
            messagebox.showwarning("Saisie", "Article obligatoire.")
            return
        try:
            if self.ligne:
                inv_db.update_ligne_inventaire(self.ligne["id"], article_id, quantite, comment)
            else:
                inv_db.insert_ligne_inventaire(self.inventaire_id, article_id, quantite, comment)
            
            # Mettre Ã  jour le stock de l'article immÃ©diatement aprÃ¨s l'enregistrement de la ligne d'inventaire
            try:
                set_article_stock(article_id, quantite)
            except Exception as stock_err:
                logger.warning(f"Erreur lors de la mise Ã  jour du stock pour l'article {article_id}: {stock_err}")
            
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de la ligne d'inventaire."))

class MouvementDialog(tk.Toplevel):
    def __init__(self, master, on_done, mvt=None):
        super().__init__(master)
        self.title("Mouvement")
        self.on_done = on_done
        self.mvt = mvt

        tk.Label(self, text="Date").grid(row=0, column=0, sticky="w", padx=5, pady=3)
        self.date_var = tk.StringVar(value=mvt["date"] if mvt else "")
        tk.Entry(self, textvariable=self.date_var).grid(row=0, column=1, sticky="ew", padx=5, pady=3)

        # Utiliser Combobox pour sÃ©lectionner un article
        tk.Label(self, text="Article").grid(row=1, column=0, sticky="w", padx=5, pady=3)
        articles = list_articles_names()
        self.article_options = [f"{a['name']} ({a['contenance'] or 'N/A'})" for a in articles]
        self.article_id_map = {f"{a['name']} ({a['contenance'] or 'N/A'})": a['id'] for a in articles}
        
        # SÃ©lectionner l'article par dÃ©faut si en mode Ã©dition
        default_article = None
        if mvt:
            for opt in self.article_options:
                if self.article_id_map[opt] == mvt["article_id"]:
                    default_article = opt
                    break
        
        self.article_var = tk.StringVar(value=default_article if default_article else (self.article_options[0] if self.article_options else ""))
        self.article_combo = ttk.Combobox(self, textvariable=self.article_var, values=self.article_options, state="readonly", width=30)
        self.article_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="Type").grid(row=2, column=0, sticky="w", padx=5, pady=3)
        self.type_var = tk.StringVar(value=mvt["type"] if mvt else "entrÃ©e")
        type_combo = ttk.Combobox(self, textvariable=self.type_var, values=["entrÃ©e", "sortie"], state="readonly")
        type_combo.grid(row=2, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="QuantitÃ©").grid(row=3, column=0, sticky="w", padx=5, pady=3)
        self.quantite_var = tk.IntVar(value=mvt["quantite"] if mvt else 0)
        tk.Entry(self, textvariable=self.quantite_var).grid(row=3, column=1, sticky="ew", padx=5, pady=3)

        tk.Label(self, text="Commentaire").grid(row=4, column=0, sticky="w", padx=5, pady=3)
        self.comment_var = tk.StringVar(value=mvt["commentaire"] if mvt else "")
        tk.Entry(self, textvariable=self.comment_var).grid(row=4, column=1, sticky="ew", padx=5, pady=3)

        tk.Button(self, text="Enregistrer", command=self.save).grid(row=5, column=0, columnspan=2, pady=8)

    def save(self):
        date = self.date_var.get()
        article_selection = self.article_var.get()
        article_id = self.article_id_map.get(article_selection)
        type_mvt = self.type_var.get()
        quantite = self.quantite_var.get()
        comment = self.comment_var.get()
        if not date or not article_id or not type_mvt or not quantite:
            messagebox.showwarning("Saisie", "Tous les champs sont obligatoires.")
            return
        try:
            if self.mvt:
                update_mouvement(self.mvt["id"], date, article_id, type_mvt, quantite, comment)
            else:
                insert_mouvement(date, article_id, type_mvt, quantite, comment)
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement du mouvement."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/buvette_bilan_db.py ===

```python
"""
Module de gestion de la base de donnÃ©es pour les bilans de la buvette.

STANDARDIZATION (PR copilot/audit-db-access-standardization):
- Improved connection management with try/finally blocks to reduce locks
- Converted sqlite3.Row to dicts for consistent .get() access patterns
- Added docstrings and error handling
"""

from db.db import get_connection
from utils.db_helpers import rows_to_dicts, row_to_dict
from utils.app_logger import get_logger
import sqlite3

logger = get_logger("buvette_bilan_db")

def get_conn():
    conn = get_connection()
    return conn

def list_evenements():
    """Liste tous les Ã©vÃ©nements pour lesquels il existe des inventaires buvette, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("SELECT id, name, date FROM events ORDER BY date DESC").fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_inventaire_par_evenement(event_id, typ):
    """
    RÃ©cupÃ¨re l'inventaire 'avant' ou 'aprÃ¨s' pour un Ã©vÃ©nement, returns dict or None.
    typ = 'avant' ou 'apres'
    """
    conn = None
    try:
        conn = get_conn()
        inv = conn.execute("""
            SELECT * FROM buvette_inventaires
            WHERE event_id=? AND type_inventaire=?
            ORDER BY date_inventaire ASC
            LIMIT 1
        """, (event_id, typ)).fetchone()
        return row_to_dict(inv)
    finally:
        if conn:
            conn.close()

def get_lignes_inventaire(inv_id):
    """
    RÃ©cupÃ¨re les lignes d'inventaire (avec info article) pour un inventaire donnÃ©, returns list of dicts.
    """
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT l.*, a.name as article_name, a.categorie, a.unite
            FROM buvette_inventaire_lignes l
            LEFT JOIN buvette_articles a ON l.article_id = a.id
            WHERE l.inventaire_id=?
            ORDER BY a.name
        """, (inv_id,)).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_prix_moyen_achat(article_id, jusqua_date=None):
    """
    Calcule le prix moyen pondÃ©rÃ© d'achat d'un article jusqu'Ã  une date donnÃ©e.
    Returns float.
    """
    conn = None
    try:
        conn = get_conn()
        q = "SELECT SUM(quantite*prix_unitaire) as total, SUM(quantite) as qte FROM buvette_achats WHERE article_id=?"
        params = [article_id]
        if jusqua_date:
            q += " AND date_achat<=?"
            params.append(jusqua_date)
        row = conn.execute(q, params).fetchone()
        row_dict = row_to_dict(row)
        if row_dict and row_dict.get("qte"):
            return row_dict["total"] / row_dict["qte"]
        return 0.0
    finally:
        if conn:
            conn.close()

def get_recette_buvette(event_id):
    """
    RÃ©cupÃ¨re la somme totale des recettes buvette pour un Ã©vÃ©nement.
    Returns float.
    """
    conn = None
    try:
        conn = get_conn()
        row = conn.execute("""
            SELECT SUM(montant) as recette
            FROM buvette_recettes
            WHERE event_id=?
        """, (event_id,)).fetchone()
        row_dict = row_to_dict(row)
        return row_dict.get("recette", 0.0) if row_dict else 0.0
    finally:
        if conn:
            conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/buvette_bilan_dialogs.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
import sqlite3

def get_conn():
    conn = get_connection()
    return conn

def list_evenements():
    conn = get_conn()
    rows = conn.execute("SELECT id, name, date FROM events ORDER BY date DESC").fetchall()
    conn.close()
    return rows

def get_inventaire_par_evenement(event_id, typ):
    conn = get_conn()
    inv = conn.execute("""
        SELECT * FROM buvette_inventaires
        WHERE event_id=? AND type_inventaire=?
        ORDER BY date_inventaire ASC
        LIMIT 1
    """, (event_id, typ)).fetchone()
    conn.close()
    return inv

def get_lignes_inventaire(inv_id):
    conn = get_conn()
    rows = conn.execute("""
        SELECT l.*, a.name as article_name, a.categorie, a.unite
        FROM buvette_inventaire_lignes l
        LEFT JOIN buvette_articles a ON l.article_id = a.id
        WHERE l.inventaire_id=?
        ORDER BY a.name
    """, (inv_id,)).fetchall()
    conn.close()
    return rows

def get_prix_moyen_achat(article_id, jusqua_date=None):
    conn = get_conn()
    q = "SELECT SUM(quantite*prix_unitaire) as total, SUM(quantite) as qte FROM buvette_achats WHERE article_id=?"
    params = [article_id]
    if jusqua_date:
        q += " AND date_achat<=?"
        params.append(jusqua_date)
    row = conn.execute(q, params).fetchone()
    conn.close()
    if row and row["qte"]:
        return row["total"]/row["qte"]
    return 0.0

def get_recette_buvette(event_id):
    conn = get_conn()
    row = conn.execute("""
        SELECT SUM(montant) as recette
        FROM buvette_recettes
        WHERE event_id=?
    """, (event_id,)).fetchone()
    conn.close()
    return row["recette"] or 0.0

class BuvetteBilanDialog(tk.Toplevel):
    def __init__(self, master):
        super().__init__(master)
        self.title("Bilan Buvette par Ã©vÃ©nement")
        self.geometry("900x600")
        self.create_widgets()

    def create_widgets(self):
        frm_select = tk.Frame(self)
        frm_select.pack(fill=tk.X, padx=10, pady=8)

        tk.Label(frm_select, text="Ã‰vÃ©nement :").pack(side=tk.LEFT)
        self.event_combo = ttk.Combobox(frm_select, state="readonly", width=50)
        events = list_evenements()
        self.events = {f"{ev['date']} - {ev['name']}": ev['id'] for ev in events}
        self.event_combo["values"] = list(self.events.keys())
        self.event_combo.pack(side=tk.LEFT, padx=4)
        tk.Button(frm_select, text="Voir bilan", command=self.display_bilan).pack(side=tk.LEFT, padx=12)

        self.text = tk.Text(self, height=30, width=120)
        self.text.pack(fill=tk.BOTH, expand=True, padx=10, pady=8)

    def display_bilan(self):
        evt_label = self.event_combo.get()
        if not evt_label or evt_label not in self.events:
            messagebox.showwarning("Ã‰vÃ©nement", "SÃ©lectionnez un Ã©vÃ©nement.")
            return
        event_id = self.events[evt_label]

        inv_avant = get_inventaire_par_evenement(event_id, "avant")
        inv_apres = get_inventaire_par_evenement(event_id, "apres")

        bilan_txt = f"BILAN BUVETTE - {evt_label}\n"
        bilan_txt += "\n--- Inventaire AVANT ---\n"
        if inv_avant:
            lignes_avant = get_lignes_inventaire(inv_avant["id"])
            for l in lignes_avant:
                bilan_txt += f"{l['article_name']}: {l['quantite']} {l['unite']} ({l['categorie']})\n"
        else:
            bilan_txt += "Aucun inventaire avant.\n"

        bilan_txt += "\n--- Inventaire APRES ---\n"
        if inv_apres:
            lignes_apres = get_lignes_inventaire(inv_apres["id"])
            for l in lignes_apres:
                bilan_txt += f"{l['article_name']}: {l['quantite']} {l['unite']} ({l['categorie']})\n"
        else:
            bilan_txt += "Aucun inventaire aprÃ¨s.\n"

        bilan_txt += "\n--- Recette Buvette ---\n"
        recette = get_recette_buvette(event_id)
        bilan_txt += f"Total recettes buvette : {recette:.2f} â‚¬\n"

        self.text.delete(1.0, tk.END)
        self.text.insert(tk.END, bilan_txt)
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/buvette_db.py ===

```python
"""
Module de gestion de la base de donnÃ©es pour le module Buvette.

MODIFICATIONS APPLIQUÃ‰ES (PR corrections buvette - copilot/auto-fix-buvette):
- Harmonisation des noms de colonnes pour buvette_mouvements:
  * INSERT et UPDATE utilisent maintenant date_mouvement, type_mouvement, motif
    (au lieu de date, type, commentaire) pour correspondre au schÃ©ma DB
  * Les SELECT ajoutent des alias (AS date, AS type, AS commentaire) pour
    maintenir la compatibilitÃ© avec le code UI existant

- Ajout de la gestion du stock (PR copilot/auto-fix-buvette):
  * Fonction ensure_stock_column(): migration non destructive pour ajouter la colonne 'stock'
  * Fonction set_article_stock(article_id, stock): mise Ã  jour du stock d'un article
  * Fonction get_article_stock(article_id): rÃ©cupÃ©ration du stock actuel d'un article
  * Ces fonctions permettent de suivre les quantitÃ©s en stock aprÃ¨s chaque inventaire

STANDARDIZATION (PR copilot/audit-db-access-standardization):
- Improved connection management with try/finally blocks to reduce locks
- Converted sqlite3.Row to dicts for consistent .get() access patterns
- Centralized error handling
"""

from db.db import get_connection
from utils.db_helpers import rows_to_dicts, row_to_dict
from utils.app_logger import get_logger
import sqlite3

logger = get_logger("buvette_db")

def get_conn():
    conn = get_connection()
    return conn

# ----- ARTICLES -----
def list_articles():
    """List all articles, returns list of dicts for .get() access."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("SELECT * FROM buvette_articles ORDER BY name").fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_article_by_id(article_id):
    """Get article by ID, returns dict or None."""
    conn = None
    try:
        conn = get_conn()
        row = conn.execute("SELECT * FROM buvette_articles WHERE id=?", (article_id,)).fetchone()
        return row_to_dict(row)
    finally:
        if conn:
            conn.close()

def insert_article(name, categorie, unite, commentaire, contenance, purchase_price=None):
    """Insert new article."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            INSERT INTO buvette_articles (name, categorie, unite, commentaire, contenance, purchase_price)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (name, categorie, unite, commentaire, contenance, purchase_price))
        conn.commit()
    finally:
        if conn:
            conn.close()

def update_article(article_id, name, categorie, unite, commentaire, contenance, purchase_price=None):
    """Update existing article."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_articles SET name=?, categorie=?, unite=?, commentaire=?, contenance=?, purchase_price=?
            WHERE id=?
        """, (name, categorie, unite, commentaire, contenance, purchase_price, article_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_article(article_id):
    """Delete article by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_articles WHERE id=?", (article_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- ACHATS -----
def list_achats():
    """List all achats with article info, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT a.*, ar.name AS article_name, ar.contenance AS article_contenance
            FROM buvette_achats a
            LEFT JOIN buvette_articles ar ON a.article_id = ar.id
            ORDER BY a.date_achat DESC
        """).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_achat_by_id(achat_id):
    """Get achat by ID with article info, returns dict or None."""
    conn = None
    try:
        conn = get_conn()
        row = conn.execute("""
            SELECT a.*, ar.name AS article_name, ar.contenance AS article_contenance
            FROM buvette_achats a
            LEFT JOIN buvette_articles ar ON a.article_id = ar.id
            WHERE a.id=?
        """, (achat_id,)).fetchone()
        return row_to_dict(row)
    finally:
        if conn:
            conn.close()

def insert_achat(article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice):
    """Insert new achat."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            INSERT INTO buvette_achats (article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice))
        conn.commit()
    finally:
        if conn:
            conn.close()

def update_achat(achat_id, article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice):
    """Update existing achat."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_achats SET article_id=?, date_achat=?, quantite=?, prix_unitaire=?,
                fournisseur=?, facture=?, exercice=?
            WHERE id=?
        """, (article_id, date_achat, quantite, prix_unitaire, fournisseur, facture, exercice, achat_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_achat(achat_id):
    """Delete achat by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_achats WHERE id=?", (achat_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- MOUVEMENTS -----
def list_mouvements():
    """List all mouvements with article info, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT m.*, 
                   m.date_mouvement AS date, 
                   m.type_mouvement AS type,
                   m.motif AS commentaire,
                   ar.name AS article_name, 
                   ar.contenance AS article_contenance
            FROM buvette_mouvements m
            LEFT JOIN buvette_articles ar ON m.article_id = ar.id
            ORDER BY m.date_mouvement DESC
        """).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_mouvement_by_id(mvt_id):
    """Get mouvement by ID with article info, returns dict or None."""
    conn = None
    try:
        conn = get_conn()
        row = conn.execute("""
            SELECT m.*, 
                   m.date_mouvement AS date, 
                   m.type_mouvement AS type,
                   m.motif AS commentaire,
                   ar.name AS article_name, 
                   ar.contenance AS article_contenance
            FROM buvette_mouvements m
            LEFT JOIN buvette_articles ar ON m.article_id = ar.id
            WHERE m.id=?
        """, (mvt_id,)).fetchone()
        return row_to_dict(row)
    finally:
        if conn:
            conn.close()

def insert_mouvement(date_mouvement, article_id, type_mouvement, quantite, motif):
    """Insert new mouvement."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            INSERT INTO buvette_mouvements (date_mouvement, article_id, type_mouvement, quantite, motif)
            VALUES (?, ?, ?, ?, ?)
        """, (date_mouvement, article_id, type_mouvement, quantite, motif))
        conn.commit()
    finally:
        if conn:
            conn.close()

def update_mouvement(mvt_id, date_mouvement, article_id, type_mouvement, quantite, motif):
    """Update existing mouvement."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_mouvements SET date_mouvement=?, article_id=?, type_mouvement=?, quantite=?, motif=?
            WHERE id=?
        """, (date_mouvement, article_id, type_mouvement, quantite, motif, mvt_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_mouvement(mvt_id):
    """Delete mouvement by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_mouvements WHERE id=?", (mvt_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- INVENTAIRE LIGNES -----
def list_lignes_inventaire(inventaire_id):
    """List inventory lines for a specific inventory, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT l.*, ar.name AS article_name, ar.contenance AS article_contenance
            FROM buvette_inventaire_lignes l
            LEFT JOIN buvette_articles ar ON l.article_id = ar.id
            WHERE l.inventaire_id=?
            ORDER BY l.id
        """, (inventaire_id,)).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def insert_ligne_inventaire(inventaire_id, article_id, quantite, commentaire):
    """Insert new inventory line."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            INSERT INTO buvette_inventaire_lignes (inventaire_id, article_id, quantite, commentaire)
            VALUES (?, ?, ?, ?)
        """, (inventaire_id, article_id, quantite, commentaire))
        conn.commit()
    finally:
        if conn:
            conn.close()

def update_ligne_inventaire(ligne_id, article_id, quantite, commentaire):
    """Update existing inventory line."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_inventaire_lignes SET article_id=?, quantite=?, commentaire=?
            WHERE id=?
        """, (article_id, quantite, commentaire, ligne_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_ligne_inventaire(ligne_id):
    """Delete inventory line by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_inventaire_lignes WHERE id=?", (ligne_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- UTILITY -----
def list_articles_names():
    """List article IDs, names and contenance, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("SELECT id, name, contenance FROM buvette_articles ORDER BY name").fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def ensure_stock_column():
    """
    Migration non destructive: Ajoute la colonne 'stock' Ã  buvette_articles si elle n'existe pas.
    Cette fonction doit Ãªtre appelÃ©e au dÃ©marrage de l'application ou lors de la mise Ã  jour de la DB.
    """
    conn = None
    try:
        conn = get_conn()
        # VÃ©rifier si la colonne stock existe dÃ©jÃ 
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns = [row["name"] for row in cursor.fetchall()]
        
        if "stock" not in columns:
            conn.execute("ALTER TABLE buvette_articles ADD COLUMN stock INTEGER DEFAULT 0")
            conn.commit()
            logger.info("Column 'stock' added to buvette_articles")
            return True  # Colonne ajoutÃ©e
        return False  # Colonne existait dÃ©jÃ 
    except Exception as e:
        if conn:
            conn.rollback()
        logger.error(f"Error ensuring stock column: {e}")
        raise e
    finally:
        if conn:
            conn.close()

def set_article_stock(article_id, stock):
    """
    Met Ã  jour le stock d'un article.
    Cette fonction est appelÃ©e aprÃ¨s l'enregistrement d'un inventaire pour mettre Ã  jour
    le stock de l'article immÃ©diatement.
    
    Args:
        article_id: ID de l'article
        stock: Nouvelle valeur du stock (quantitÃ© en unitÃ©s)
    """
    conn = None
    try:
        conn = get_conn()
        conn.execute("UPDATE buvette_articles SET stock=? WHERE id=?", (stock, article_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def get_article_stock(article_id):
    """
    RÃ©cupÃ¨re le stock actuel d'un article.
    
    Args:
        article_id: ID de l'article
        
    Returns:
        int: Stock actuel de l'article (0 si la colonne n'existe pas ou si l'article n'existe pas)
    """
    conn = None
    try:
        conn = get_conn()
        # VÃ©rifier si la colonne stock existe
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns = [row["name"] for row in cursor.fetchall()]
        
        if "stock" in columns:
            row = conn.execute("SELECT stock FROM buvette_articles WHERE id=?", (article_id,)).fetchone()
            return row_to_dict(row).get("stock", 0) if row else 0
        else:
            return 0
    finally:
        if conn:
            conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/buvette_dialogs.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from datetime import date
import modules.buvette_db as db

# -------- DIALOGUES ARTICLES ----------
class ArticleDialog(tk.Toplevel):
    def __init__(self, master, article_id=None, on_save=None):
        super().__init__(master)
        self.title("Article buvette")
        self.geometry("350x400")
        self.on_save = on_save
        self.article_id = article_id

        self.nom_var = tk.StringVar()
        self.categorie_var = tk.StringVar()
        self.unite_var = tk.StringVar()
        self.contenance_var = tk.StringVar()
        self.comment_var = tk.StringVar()
        self.purchase_price_var = tk.DoubleVar()

        tk.Label(self, text="Name :").pack(pady=4)
        tk.Entry(self, textvariable=self.nom_var, width=30).pack()
        tk.Label(self, text="CatÃ©gorie :").pack(pady=4)
        tk.Entry(self, textvariable=self.categorie_var, width=25).pack()
        tk.Label(self, text="UnitÃ© (ex: canette, bouteille...) :").pack(pady=4)
        tk.Entry(self, textvariable=self.unite_var, width=18).pack()
        tk.Label(self, text="Contenance :").pack(pady=4)
        contenance_options = ["0.25L", "0.33L", "0.5L", "0.75L", "1L", "1.5L", "2L"]
        self.contenance_cb = ttk.Combobox(self, textvariable=self.contenance_var, state="readonly", width=10)
        self.contenance_cb["values"] = contenance_options
        self.contenance_cb.pack()
        tk.Label(self, text="Prix achat / unitÃ© (â‚¬) :").pack(pady=4)
        tk.Entry(self, textvariable=self.purchase_price_var, width=15).pack()
        tk.Label(self, text="Commentaire :").pack(pady=4)
        tk.Entry(self, textvariable=self.comment_var, width=35).pack()

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=14)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=12)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=12)

        if article_id:
            self.load_article()

    def load_article(self):
        r = db.get_article_by_id(self.article_id)
        if r:
            self.nom_var.set(r["name"])
            self.categorie_var.set(r["categorie"])
            self.unite_var.set(r["unite"])
            self.contenance_var.set(r["contenance"] if r["contenance"] else "")
            if "purchase_price" in r.keys() and r["purchase_price"] is not None:
                self.purchase_price_var.set(r["purchase_price"])
            self.comment_var.set(r["commentaire"])

    def save(self):
        name = self.nom_var.get().strip()
        if not name:
            messagebox.showerror("Erreur", "Le nom de l'article est obligatoire.")
            return
        categorie = self.categorie_var.get().strip()
        unite = self.unite_var.get().strip()
        contenance = self.contenance_var.get().strip()
        comment = self.comment_var.get().strip()
        try:
            # Get purchase price, handling empty or invalid input
            purchase_price = self.purchase_price_var.get()
        except tk.TclError:
            # TclError occurs when the DoubleVar field is empty or contains invalid data
            purchase_price = None
        if self.article_id:
            db.update_article(self.article_id, name, categorie, unite, comment, contenance, purchase_price)
        else:
            db.insert_article(name, categorie, unite, comment, contenance, purchase_price)
        if self.on_save:
            self.on_save()
        self.destroy()

# -------- DIALOGUES ACHATS ----------
class AchatDialog(tk.Toplevel):
    def __init__(self, master, achat_id=None, on_save=None):
        super().__init__(master)
        self.title("Achat buvette")
        self.geometry("420x440")
        self.on_save = on_save
        self.achat_id = achat_id

        self.article_var = tk.StringVar()
        self.date_var = tk.StringVar(value=str(date.today()))
        self.qte_var = tk.IntVar()
        self.pu_var = tk.DoubleVar()
        self.fournisseur_var = tk.StringVar()
        self.facture_var = tk.StringVar()
        self.exercice_var = tk.StringVar()
        self.contenance_display_var = tk.StringVar()

        tk.Label(self, text="Article :").pack(pady=4)
        article_list = db.list_articles_names()
        self.articles_dict = {f"{r['name']} (id={r['id']})": r["id"] for r in article_list}
        self.articles_contenance = {f"{r['name']} (id={r['id']})": r["contenance"] for r in article_list}
        self.article_cb = ttk.Combobox(self, textvariable=self.article_var, state="readonly", width=28)
        self.article_cb["values"] = list(self.articles_dict.keys())
        self.article_cb.pack()

        tk.Label(self, text="Contenance :").pack(pady=4)
        self.contenance_display = tk.Entry(self, textvariable=self.contenance_display_var, width=14, state="readonly")
        self.contenance_display.pack()

        def update_contenance_display(*args):
            selected_article = self.article_var.get()
            contenance_val = self.articles_contenance.get(selected_article, "")
            self.contenance_display_var.set(contenance_val if contenance_val else "")
        self.article_var.trace_add("write", update_contenance_display)
        update_contenance_display()

        tk.Label(self, text="Date achat :").pack(pady=4)
        tk.Entry(self, textvariable=self.date_var).pack()
        tk.Label(self, text="QuantitÃ© :").pack(pady=4)
        tk.Entry(self, textvariable=self.qte_var).pack()
        tk.Label(self, text="Prix unitaire (â‚¬) :").pack(pady=4)
        tk.Entry(self, textvariable=self.pu_var).pack()
        tk.Label(self, text="Fournisseur :").pack(pady=4)
        tk.Entry(self, textvariable=self.fournisseur_var).pack()
        tk.Label(self, text="Facture nÂ° :").pack(pady=4)
        tk.Entry(self, textvariable=self.facture_var).pack()
        tk.Label(self, text="Exercice :").pack(pady=4)
        tk.Entry(self, textvariable=self.exercice_var).pack()

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=12)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if achat_id:
            self.load_achat()

    def load_achat(self):
        r = db.get_achat_by_id(self.achat_id)
        if r:
            article_key = None
            for k, v in self.articles_dict.items():
                if v == r["article_id"]:
                    article_key = k
                    break
            if article_key:
                self.article_var.set(article_key)
                self.contenance_display_var.set(self.articles_contenance.get(article_key, ""))
            self.date_var.set(r["date_achat"])
            self.qte_var.set(r["quantite"])
            self.pu_var.set(r["prix_unitaire"])
            self.fournisseur_var.set(r["fournisseur"])
            self.facture_var.set(r["facture"])
            self.exercice_var.set(r["exercice"])

    def save(self):
        article_key = self.article_var.get()
        if not article_key or article_key not in self.articles_dict:
            messagebox.showerror("Erreur", "Article obligatoire.")
            return
        article_id = self.articles_dict[article_key]
        champs = (
            article_id,
            self.date_var.get(),
            self.qte_var.get(),
            self.pu_var.get(),
            self.fournisseur_var.get(),
            self.facture_var.get(),
            self.exercice_var.get()
        )
        if self.achat_id:
            db.update_achat(self.achat_id, *champs)
        else:
            db.insert_achat(*champs)
        if self.on_save:
            self.on_save()
        self.destroy()

# -------- DIALOGUES MOUVEMENTS ----------
class MouvementDialog(tk.Toplevel):
    def __init__(self, master, on_done, mvt=None):
        super().__init__(master)
        self.title("Mouvement")
        self.on_done = on_done
        self.mvt = mvt

        self.article_var = tk.StringVar()
        self.date_var = tk.StringVar(value=mvt["date"] if mvt else "")
        self.type_var = tk.StringVar(value=mvt["type"] if mvt else "")
        self.quantite_var = tk.IntVar(value=mvt["quantite"] if mvt else 0)
        self.comment_var = tk.StringVar(value=mvt["commentaire"] if mvt else "")
        self.contenance_display_var = tk.StringVar()

        tk.Label(self, text="Article :").pack(pady=4)
        article_list = db.list_articles_names()
        self.articles_dict = {f"{r['name']} (id={r['id']})": r["id"] for r in article_list}
        self.articles_contenance = {f"{r['name']} (id={r['id']})": r["contenance"] for r in article_list}
        self.article_cb = ttk.Combobox(self, textvariable=self.article_var, state="readonly", width=28)
        self.article_cb["values"] = list(self.articles_dict.keys())
        self.article_cb.pack()

        tk.Label(self, text="Contenance :").pack(pady=4)
        self.contenance_display = tk.Entry(self, textvariable=self.contenance_display_var, width=14, state="readonly")
        self.contenance_display.pack()

        def update_contenance_display(*args):
            selected_article = self.article_var.get()
            contenance_val = self.articles_contenance.get(selected_article, "")
            self.contenance_display_var.set(contenance_val if contenance_val else "")
        self.article_var.trace_add("write", update_contenance_display)
        update_contenance_display()

        tk.Label(self, text="Date :").pack(pady=4)
        tk.Entry(self, textvariable=self.date_var).pack()
        tk.Label(self, text="Type (entrÃ©e/sortie) :").pack(pady=4)
        tk.Entry(self, textvariable=self.type_var).pack()
        tk.Label(self, text="QuantitÃ© :").pack(pady=4)
        tk.Entry(self, textvariable=self.quantite_var).pack()
        tk.Label(self, text="Commentaire :").pack(pady=4)
        tk.Entry(self, textvariable=self.comment_var).pack()

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=12)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if mvt:
            self.load_mvt()

    def load_mvt(self):
        if self.mvt:
            article_key = None
            for k, v in self.articles_dict.items():
                if v == self.mvt["article_id"]:
                    article_key = k
                    break
            if article_key:
                self.article_var.set(article_key)
                self.contenance_display_var.set(self.articles_contenance.get(article_key, ""))
            self.date_var.set(self.mvt["date"])
            self.type_var.set(self.mvt["type"])
            self.quantite_var.set(self.mvt["quantite"])
            self.comment_var.set(self.mvt["commentaire"])

    def save(self):
        article_key = self.article_var.get()
        if not article_key or article_key not in self.articles_dict:
            messagebox.showerror("Erreur", "Article obligatoire.")
            return
        article_id = self.articles_dict[article_key]
        date = self.date_var.get()
        type_mvt = self.type_var.get()
        quantite = self.quantite_var.get()
        comment = self.comment_var.get()
        if not date or not article_id or not type_mvt or not quantite:
            messagebox.showwarning("Saisie", "Tous les champs sont obligatoires.")
            return
        try:
            if self.mvt:
                db.update_mouvement(self.mvt["id"], date, article_id, type_mvt, quantite, comment)
            else:
                db.insert_mouvement(date, article_id, type_mvt, quantite, comment)
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de l'enregistrement du mouvement : {e}")

# -------- DIALOGUES INVENTAIRE LIGNES ----------
class LigneInventaireDialog(tk.Toplevel):
    def __init__(self, master, on_done, inventaire_id, ligne=None):
        super().__init__(master)
        self.title("Ligne inventaire")
        self.on_done = on_done
        self.inventaire_id = inventaire_id
        self.ligne = ligne

        self.article_var = tk.StringVar()
        self.quantite_var = tk.IntVar(value=ligne["quantite"] if ligne else 0)
        self.comment_var = tk.StringVar(value=ligne["commentaire"] if ligne else "")
        self.contenance_display_var = tk.StringVar()

        tk.Label(self, text="Article :").pack(pady=4)
        article_list = db.list_articles_names()
        self.articles_dict = {f"{r['name']} (id={r['id']})": r["id"] for r in article_list}
        self.articles_contenance = {f"{r['name']} (id={r['id']})": r["contenance"] for r in article_list}
        self.article_cb = ttk.Combobox(self, textvariable=self.article_var, state="readonly", width=28)
        self.article_cb["values"] = list(self.articles_dict.keys())
        self.article_cb.pack()

        tk.Label(self, text="Contenance :").pack(pady=4)
        self.contenance_display = tk.Entry(self, textvariable=self.contenance_display_var, width=14, state="readonly")
        self.contenance_display.pack()

        def update_contenance_display(*args):
            selected_article = self.article_var.get()
            contenance_val = self.articles_contenance.get(selected_article, "")
            self.contenance_display_var.set(contenance_val if contenance_val else "")
        self.article_var.trace_add("write", update_contenance_display)
        update_contenance_display()

        tk.Label(self, text="QuantitÃ© :").pack(pady=4)
        tk.Entry(self, textvariable=self.quantite_var).pack()
        tk.Label(self, text="Commentaire :").pack(pady=4)
        tk.Entry(self, textvariable=self.comment_var).pack()

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=12)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=16)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=16)

        if ligne:
            self.load_ligne()

    def load_ligne(self):
        if self.ligne:
            article_key = None
            for k, v in self.articles_dict.items():
                if v == self.ligne["article_id"]:
                    article_key = k
                    break
            if article_key:
                self.article_var.set(article_key)
                self.contenance_display_var.set(self.articles_contenance.get(article_key, ""))
            self.quantite_var.set(self.ligne["quantite"])
            self.comment_var.set(self.ligne["commentaire"])

    def save(self):
        article_key = self.article_var.get()
        if not article_key or article_key not in self.articles_dict:
            messagebox.showerror("Erreur", "Article obligatoire.")
            return
        article_id = self.articles_dict[article_key]
        quantite = self.quantite_var.get()
        comment = self.comment_var.get()
        if not article_id:
            messagebox.showwarning("Saisie", "Article obligatoire.")
            return
        try:
            if self.ligne:
                db.update_ligne_inventaire(self.ligne["id"], article_id, quantite, comment)
            else:
                db.insert_ligne_inventaire(self.inventaire_id, article_id, quantite, comment)
            self.on_done()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de l'enregistrement de la ligne d'inventaire : {e}")
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/buvette_inventaire_db.py ===

```python
"""
Module de gestion de la base de donnÃ©es pour les inventaires de la buvette.

STANDARDIZATION (PR copilot/audit-db-access-standardization):
- Improved connection management with try/finally blocks to reduce locks
- Converted sqlite3.Row to dicts for consistent .get() access patterns
- Added docstrings and error handling
"""

from db.db import get_connection
from utils.db_helpers import rows_to_dicts, row_to_dict
from utils.app_logger import get_logger
import sqlite3

logger = get_logger("buvette_inventaire_db")

def get_conn():
    conn = get_connection()
    return conn

# ----- INVENTAIRES -----
def list_inventaires():
    """List all inventaires with event info, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT i.*, e.name as event_name, e.date as event_date
            FROM buvette_inventaires i
            LEFT JOIN events e ON i.event_id = e.id
            ORDER BY date_inventaire DESC
        """).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_inventaire_by_id(inv_id):
    """Get inventaire by ID with event info, returns dict or None."""
    conn = None
    try:
        conn = get_conn()
        row = conn.execute("""
            SELECT i.*, e.name as event_name, e.date as event_date
            FROM buvette_inventaires i
            LEFT JOIN events e ON i.event_id = e.id
            WHERE i.id=?
        """, (inv_id,)).fetchone()
        return row_to_dict(row)
    finally:
        if conn:
            conn.close()

def insert_inventaire(date_inventaire, event_id, type_inventaire, commentaire):
    """Insert new inventaire, returns ID of created record."""
    conn = None
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("""
            INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
            VALUES (?, ?, ?, ?)
        """, (date_inventaire, event_id, type_inventaire, commentaire))
        inv_id = cur.lastrowid
        conn.commit()
        return inv_id
    finally:
        if conn:
            conn.close()

def update_inventaire(inv_id, date_inventaire, event_id, type_inventaire, commentaire):
    """Update existing inventaire."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_inventaires SET date_inventaire=?, event_id=?, type_inventaire=?, commentaire=?
            WHERE id=?
        """, (date_inventaire, event_id, type_inventaire, commentaire, inv_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_inventaire(inv_id):
    """Delete inventaire by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_inventaires WHERE id=?", (inv_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- LIGNES D'INVENTAIRE -----
def list_lignes_inventaire(inventaire_id):
    """List inventory lines for specific inventory with article names, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT l.*, a.name as article_name
            FROM buvette_inventaire_lignes l
            LEFT JOIN buvette_articles a ON l.article_id = a.id
            WHERE l.inventaire_id=?
            ORDER BY a.name
        """, (inventaire_id,)).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def insert_ligne_inventaire(inventaire_id, article_id, quantite, commentaire=None):
    """Insert new inventory line."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            INSERT INTO buvette_inventaire_lignes (inventaire_id, article_id, quantite, commentaire)
            VALUES (?, ?, ?, ?)
        """, (inventaire_id, article_id, quantite, commentaire))
        conn.commit()
    finally:
        if conn:
            conn.close()

def update_ligne_inventaire(ligne_id, article_id, quantite, commentaire=None):
    """Update existing inventory line."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_inventaire_lignes SET article_id=?, quantite=?, commentaire=?
            WHERE id=?
        """, (article_id, quantite, commentaire, ligne_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_ligne_inventaire(ligne_id):
    """Delete inventory line by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_inventaire_lignes WHERE id=?", (ligne_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

def upsert_ligne_inventaire(inventaire_id, article_id, quantite, commentaire=None):
    """Insert or update inventory line for article in inventory."""
    conn = None
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("""
            SELECT id FROM buvette_inventaire_lignes WHERE inventaire_id=? AND article_id=?
        """, (inventaire_id, article_id))
        row = cur.fetchone()
        if row:
            cur.execute("""
                UPDATE buvette_inventaire_lignes SET quantite=?, commentaire=?
                WHERE inventaire_id=? AND article_id=?
            """, (quantite, commentaire, inventaire_id, article_id))
        else:
            cur.execute("""
                INSERT INTO buvette_inventaire_lignes (inventaire_id, article_id, quantite, commentaire)
                VALUES (?, ?, ?, ?)
            """, (inventaire_id, article_id, quantite, commentaire))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- EVENEMENTS UTILITY -----
def list_events():
    """List events for dropdown, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("SELECT id, name FROM events ORDER BY date DESC").fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/buvette_inventaire_dialogs.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from datetime import date
import modules.buvette_inventaire_db as db
import modules.buvette_db as buvette_db
from utils.app_logger import get_logger
from modules.db_row_utils import _row_to_dict, _rows_to_dicts
from utils.db_helpers import rows_to_dicts
from modules.inventory_lines_dialog import load_inventory_lines

logger = get_logger("buvette_inventaire_dialogs")

class InventaireDialog(tk.Toplevel):
    """Dialog for creating/editing buvette inventory with dynamic article lines."""
    
    def __init__(self, master, on_save=None, inventaire_id=None):
        super().__init__(master)
        self.title("Inventaire Buvette")
        self.geometry("900x700")
        self.on_save = on_save
        
        # Handle both inventaire_id (int) and inventaire (dict) for backward compatibility
        if inventaire_id is not None:
            if isinstance(inventaire_id, dict):
                # If a dict is passed, extract the id
                self.inventaire_id = inventaire_id.get("id")
            else:
                # It's an int
                self.inventaire_id = inventaire_id
        else:
            self.inventaire_id = None
        
        # Variables for header fields
        self.date_var = tk.StringVar(value=str(date.today()))
        self.type_var = tk.StringVar()
        self.evt_var = tk.StringVar()
        self.comment_var = tk.StringVar()
        
        # Create UI
        self._create_header_section()
        self._create_lines_section()
        self._create_button_section()
        
        # Load data if editing
        if self.inventaire_id:
            self._load_inventaire()
    
    def _create_header_section(self):
        """Create the header section with date, type, event, and comment fields."""
        frm = tk.Frame(self)
        frm.pack(padx=16, pady=8, fill=tk.X)
        
        # Row 0: Date and Type
        tk.Label(frm, text="Date :").grid(row=0, column=0, sticky="e", padx=(0, 5))
        tk.Entry(frm, textvariable=self.date_var, width=15).grid(row=0, column=1, sticky="w")
        
        tk.Label(frm, text="Type :").grid(row=0, column=2, sticky="e", padx=(20, 5))
        type_combo = ttk.Combobox(
            frm, 
            textvariable=self.type_var, 
            values=["avant", "apres", "hors_evenement"],
            width=16,
            state="readonly"
        )
        type_combo.grid(row=0, column=3, sticky="w")
        
        # Row 1: Event
        tk.Label(frm, text="Ã‰vÃ©nement :").grid(row=1, column=0, sticky="e", padx=(0, 5), pady=(5, 0))
        self.evt_cb = ttk.Combobox(frm, textvariable=self.evt_var, width=40, state="readonly")
        try:
            events = db.list_events()
            # Convert Row objects to dicts for safe access
            events = _rows_to_dicts(events)
            self.evt_cb["values"] = [""] + [f"{r['id']} - {r['name']}" for r in events]
        except Exception as e:
            logger.warning(f"Could not load events: {e}")
            self.evt_cb["values"] = [""]
        self.evt_cb.grid(row=1, column=1, columnspan=3, sticky="w", pady=(5, 0))
        
        # Row 2: Comment
        tk.Label(frm, text="Commentaire :").grid(row=2, column=0, sticky="e", padx=(0, 5), pady=(5, 0))
        tk.Entry(frm, textvariable=self.comment_var, width=60).grid(
            row=2, column=1, columnspan=3, sticky="ew", pady=(5, 0)
        )
    
    def _create_lines_section(self):
        """Create the lines section with Treeview and add/remove buttons."""
        frame = tk.Frame(self)
        frame.pack(padx=16, pady=10, fill=tk.BOTH, expand=True)
        
        tk.Label(frame, text="Articles inventoriÃ©s", font=("Arial", 10, "bold")).pack(anchor="w")
        
        # Treeview for article lines
        tree_frame = tk.Frame(frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, pady=(5, 0))
        
        scrollbar = ttk.Scrollbar(tree_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Columns: article_id (hidden), name, categorie, contenance, quantite
        self.lines_tree = ttk.Treeview(
            tree_frame,
            columns=("article_id", "name", "categorie", "contenance", "quantite"),
            show="headings",
            displaycolumns=("name", "categorie", "contenance", "quantite"),  # Hide article_id
            yscrollcommand=scrollbar.set
        )
        scrollbar.config(command=self.lines_tree.yview)
        
        # Configure columns
        self.lines_tree.column("article_id", width=50)  # Hidden via displaycolumns
        self.lines_tree.column("name", width=200, anchor="w")
        self.lines_tree.column("categorie", width=150, anchor="w")
        self.lines_tree.column("contenance", width=100, anchor="w")
        self.lines_tree.column("quantite", width=100, anchor="center")
        
        # Set headings (article_id won't be shown due to displaycolumns)
        self.lines_tree.heading("article_id", text="ID")
        self.lines_tree.heading("name", text="Article")
        self.lines_tree.heading("categorie", text="CatÃ©gorie")
        self.lines_tree.heading("contenance", text="Contenance")
        self.lines_tree.heading("quantite", text="QuantitÃ©")
        
        self.lines_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Buttons for add/remove
        btn_frame = tk.Frame(frame)
        btn_frame.pack(fill=tk.X, pady=(5, 0))
        tk.Button(btn_frame, text="Ajouter ligne", command=self._add_line).pack(side=tk.LEFT, padx=5)
        tk.Button(btn_frame, text="Supprimer ligne", command=self._remove_line).pack(side=tk.LEFT, padx=5)
    
    def _create_button_section(self):
        """Create the bottom button section."""
        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=16)
        tk.Button(btn_frame, text="Enregistrer", command=self._save, width=12).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Annuler", command=self.destroy, width=12).pack(side=tk.LEFT, padx=10)
    
    def _add_line(self):
        """Open dialog to add a new line."""
        AddLineDialog(self, self._refresh_after_line_add)
    
    def _refresh_after_line_add(self, article_id, article_name, categorie, contenance, quantite):
        """Callback after adding a line."""
        # Check if article already exists in tree
        for item in self.lines_tree.get_children():
            values = self.lines_tree.item(item)["values"]
            if values[0] == article_id:
                # Update existing line
                self.lines_tree.item(item, values=(article_id, article_name, categorie, contenance, quantite))
                return
        
        # Add new line
        self.lines_tree.insert("", "end", values=(article_id, article_name, categorie, contenance, quantite))
    
    def _remove_line(self):
        """Remove selected line from tree."""
        selected = self.lines_tree.selection()
        if not selected:
            messagebox.showwarning("SÃ©lection", "Veuillez sÃ©lectionner une ligne Ã  supprimer.")
            return
        
        if messagebox.askyesno("Confirmation", "Supprimer cette ligne ?"):
            for item in selected:
                self.lines_tree.delete(item)
    
    def _load_inventaire(self):
        """Load existing inventory data."""
        try:
            inv = db.get_inventaire_by_id(self.inventaire_id)
            if not inv:
                messagebox.showerror("Erreur", "Inventaire introuvable.")
                self.destroy()
                return
            
            # Convert Row to dict for safe .get() access
            inv = _row_to_dict(inv)
            
            # Load header data
            self.date_var.set(inv["date_inventaire"] or "")
            self.type_var.set(inv["type_inventaire"] or "")
            self.comment_var.set(inv["commentaire"] or "")
            if inv.get("event_id"):
                self.evt_var.set(f"{inv['event_id']} - {inv.get('event_name', '')}")
            
            # Load lines using robust helper function with error reporting
            try:
                # Use load_inventory_lines which converts Rows to dicts and handles errors
                lignes = load_inventory_lines(self.inventaire_id)
                
                for ligne in lignes:
                    # Now ligne is a dict, safe to use .get()
                    article_id = ligne.get("article_id")
                    quantite = ligne.get("quantite", 0)
                    
                    if not article_id:
                        logger.warning(f"Skipping line with missing article_id: {ligne}")
                        continue
                    
                    # Get article details
                    try:
                        article = buvette_db.get_article_by_id(article_id)
                        if article:
                            # Convert Row to dict for safe .get() access
                            article = _row_to_dict(article)
                            self.lines_tree.insert("", "end", values=(
                                article_id,
                                article.get("name", ""),
                                article.get("categorie", ""),
                                article.get("contenance", ""),
                                quantite
                            ))
                    except Exception as e:
                        logger.warning(f"Could not load article {article_id}: {e}")
                        # Add line with minimal info
                        self.lines_tree.insert("", "end", values=(
                            article_id, f"Article #{article_id}", "", "", quantite
                        ))
            except Exception as e:
                # Error already logged and reported by load_inventory_lines
                logger.error(f"Failed to load inventory lines: {e}")
                messagebox.showerror(
                    "Erreur", 
                    f"Impossible de charger les lignes d'inventaire.\n"
                    f"Un rapport d'erreur dÃ©taillÃ© a Ã©tÃ© gÃ©nÃ©rÃ© dans reports/\n\n"
                    f"Erreur: {e}"
                )
        
        except Exception as e:
            logger.error(f"Error loading inventory: {e}")
            messagebox.showerror("Erreur", f"Erreur lors du chargement : {e}")
            self.destroy()
    
    def _save(self):
        """Save inventory and lines."""
        # Validate required fields
        type_inv = self.type_var.get()
        if not type_inv:
            messagebox.showerror("Erreur", "Le type d'inventaire est obligatoire.")
            return
        
        if type_inv not in ["avant", "apres", "hors_evenement"]:
            messagebox.showerror("Erreur", "Type d'inventaire invalide.")
            return
        
        date_inv = self.date_var.get()
        if not date_inv:
            messagebox.showerror("Erreur", "La date est obligatoire.")
            return
        
        commentaire = self.comment_var.get()
        evt = self.evt_var.get()
        event_id = None
        if evt and " - " in evt:
            try:
                event_id = int(evt.split(" - ")[0])
            except ValueError:
                pass
        
        try:
            # Insert or update inventory
            if self.inventaire_id:
                db.update_inventaire(self.inventaire_id, date_inv, event_id, type_inv, commentaire)
                inv_id = self.inventaire_id
            else:
                inv_id = db.insert_inventaire(date_inv, event_id, type_inv, commentaire)
            
            # Save lines
            for item in self.lines_tree.get_children():
                values = self.lines_tree.item(item)["values"]
                article_id = values[0]
                quantite = values[4]
                
                # Upsert line
                db.upsert_ligne_inventaire(inv_id, article_id, quantite)
            
            # Update article stock if quantite field exists
            self._update_article_stock()
            
            messagebox.showinfo("SuccÃ¨s", "Inventaire enregistrÃ© avec succÃ¨s.")
            
            if self.on_save:
                self.on_save()
            
            self.destroy()
        
        except Exception as e:
            logger.error(f"Error saving inventory: {e}")
            messagebox.showerror("Erreur", f"Erreur lors de l'enregistrement : {e}")
    
    def _update_article_stock(self):
        """Update article stock based on inventory quantities (if quantite field exists)."""
        try:
            # Check if buvette_articles has a quantite field
            conn = db.get_conn()
            cursor = conn.cursor()
            cursor.execute("PRAGMA table_info(buvette_articles)")
            columns = [col[1] for col in cursor.fetchall()]
            
            if "quantite" not in columns:
                logger.info("buvette_articles table does not have quantite field, skipping stock update")
                conn.close()
                return
            
            # Update stock for each line
            for item in self.lines_tree.get_children():
                values = self.lines_tree.item(item)["values"]
                article_id = values[0]
                quantite = values[4]
                
                cursor.execute(
                    "UPDATE buvette_articles SET quantite=? WHERE id=?",
                    (quantite, article_id)
                )
            
            conn.commit()
            conn.close()
            logger.info("Article stock updated successfully")
        
        except Exception as e:
            logger.warning(f"Could not update article stock: {e}")


class AddLineDialog(tk.Toplevel):
    """Dialog for adding a line to inventory."""
    
    def __init__(self, master, callback):
        super().__init__(master)
        self.title("Ajouter une ligne")
        self.geometry("500x250")
        self.callback = callback
        
        # Variables
        self.article_var = tk.StringVar()
        self.quantite_var = tk.IntVar(value=0)
        self.create_new_var = tk.BooleanVar(value=False)
        
        # New article fields
        self.new_name_var = tk.StringVar()
        self.new_categorie_var = tk.StringVar()
        self.new_contenance_var = tk.StringVar()
        
        self._create_widgets()
        self._toggle_fields()
    
    def _create_widgets(self):
        """Create dialog widgets."""
        frame = tk.Frame(self, padx=16, pady=16)
        frame.pack(fill=tk.BOTH, expand=True)
        
        # Checkbox to create new article
        tk.Checkbutton(
            frame,
            text="CrÃ©er un nouvel article",
            variable=self.create_new_var,
            command=self._toggle_fields
        ).grid(row=0, column=0, columnspan=2, sticky="w", pady=(0, 10))
        
        # Select existing article
        self.select_label = tk.Label(frame, text="Article :")
        self.select_label.grid(row=1, column=0, sticky="e", padx=(0, 5))
        
        self.article_combo = ttk.Combobox(frame, textvariable=self.article_var, width=40, state="readonly")
        try:
            articles = buvette_db.list_articles()
            # Convert Rows to dicts for safe .get() access
            articles = rows_to_dicts(articles)
            self.article_combo["values"] = [
                f"{a['id']} - {a['name']} ({a.get('contenance', '')})" for a in articles
            ]
        except Exception as e:
            logger.warning(f"Could not load articles: {e}")
            self.article_combo["values"] = []
        self.article_combo.grid(row=1, column=1, sticky="w")
        
        # New article fields
        self.name_label = tk.Label(frame, text="Nom :")
        self.name_label.grid(row=2, column=0, sticky="e", padx=(0, 5), pady=(5, 0))
        self.name_entry = tk.Entry(frame, textvariable=self.new_name_var, width=40)
        self.name_entry.grid(row=2, column=1, sticky="w", pady=(5, 0))
        
        self.categorie_label = tk.Label(frame, text="CatÃ©gorie :")
        self.categorie_label.grid(row=3, column=0, sticky="e", padx=(0, 5), pady=(5, 0))
        self.categorie_entry = tk.Entry(frame, textvariable=self.new_categorie_var, width=40)
        self.categorie_entry.grid(row=3, column=1, sticky="w", pady=(5, 0))
        
        self.contenance_label = tk.Label(frame, text="Contenance :")
        self.contenance_label.grid(row=4, column=0, sticky="e", padx=(0, 5), pady=(5, 0))
        self.contenance_entry = tk.Entry(frame, textvariable=self.new_contenance_var, width=40)
        self.contenance_entry.grid(row=4, column=1, sticky="w", pady=(5, 0))
        
        # Quantity
        tk.Label(frame, text="QuantitÃ© :").grid(row=5, column=0, sticky="e", padx=(0, 5), pady=(10, 0))
        tk.Entry(frame, textvariable=self.quantite_var, width=15).grid(row=5, column=1, sticky="w", pady=(10, 0))
        
        # Buttons
        btn_frame = tk.Frame(frame)
        btn_frame.grid(row=6, column=0, columnspan=2, pady=(20, 0))
        tk.Button(btn_frame, text="Ajouter", command=self._add, width=12).pack(side=tk.LEFT, padx=5)
        tk.Button(btn_frame, text="Annuler", command=self.destroy, width=12).pack(side=tk.LEFT, padx=5)
    
    def _toggle_fields(self):
        """Toggle between existing article selection and new article creation."""
        if self.create_new_var.get():
            # Show new article fields
            self.select_label.config(state="disabled")
            self.article_combo.config(state="disabled")
            self.name_label.config(state="normal")
            self.name_entry.config(state="normal")
            self.categorie_label.config(state="normal")
            self.categorie_entry.config(state="normal")
            self.contenance_label.config(state="normal")
            self.contenance_entry.config(state="normal")
        else:
            # Show existing article selection
            self.select_label.config(state="normal")
            self.article_combo.config(state="readonly")
            self.name_label.config(state="disabled")
            self.name_entry.config(state="disabled")
            self.categorie_label.config(state="disabled")
            self.categorie_entry.config(state="disabled")
            self.contenance_label.config(state="disabled")
            self.contenance_entry.config(state="disabled")
    
    def _add(self):
        """Add the line."""
        quantite = self.quantite_var.get()
        
        try:
            if self.create_new_var.get():
                # Create new article
                name = self.new_name_var.get().strip()
                if not name:
                    messagebox.showerror("Erreur", "Le nom de l'article est obligatoire.")
                    return
                
                categorie = self.new_categorie_var.get().strip()
                contenance = self.new_contenance_var.get().strip()
                
                # Insert new article using existing function
                try:
                    buvette_db.insert_article(
                        name=name, 
                        categorie=categorie, 
                        unite="", 
                        commentaire="", 
                        contenance=contenance
                    )
                    # Get the newly created article's ID
                    articles = buvette_db.list_articles()
                    article = next((a for a in articles if a["name"] == name), None)
                    if not article:
                        messagebox.showerror("Erreur", "Article crÃ©Ã© mais introuvable.")
                        return
                    article_id = article["id"]
                except Exception as e:
                    logger.error(f"Error creating article: {e}")
                    messagebox.showerror("Erreur", f"Erreur lors de la crÃ©ation de l'article : {e}")
                    return
            else:
                # Use existing article
                article_str = self.article_var.get()
                if not article_str:
                    messagebox.showerror("Erreur", "Veuillez sÃ©lectionner un article.")
                    return
                
                article_id = int(article_str.split(" - ")[0])
                article = buvette_db.get_article_by_id(article_id)
                if not article:
                    messagebox.showerror("Erreur", "Article introuvable.")
                    return
                
                # Convert Row to dict for safe .get() access
                article = _row_to_dict(article)
                name = article["name"]
                categorie = article.get("categorie", "")
                contenance = article.get("contenance", "")
            
            # Call callback with article data
            self.callback(article_id, name, categorie, contenance, quantite)
            self.destroy()
        
        except Exception as e:
            logger.error(f"Error adding line: {e}")
            messagebox.showerror("Erreur", f"Erreur : {e}")
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/buvette_mouvements_db.py ===

```python
"""
Module de gestion de la base de donnÃ©es pour les mouvements de stock de la buvette.

STANDARDIZATION (PR copilot/audit-db-access-standardization):
- Improved connection management with try/finally blocks to reduce locks
- Converted sqlite3.Row to dicts for consistent .get() access patterns
- Added docstrings and error handling
"""

from db.db import get_connection
from utils.db_helpers import rows_to_dicts, row_to_dict
from utils.app_logger import get_logger
import sqlite3

logger = get_logger("buvette_mouvements_db")

def get_conn():
    conn = get_connection()
    return conn

# ----- MOUVEMENTS -----
def list_mouvements():
    """List all mouvements with article and event info, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("""
            SELECT m.*, a.name AS article_name, e.name AS event_name, e.date AS event_date
            FROM buvette_mouvements m
            LEFT JOIN buvette_articles a ON m.article_id = a.id
            LEFT JOIN events e ON m.event_id = e.id
            ORDER BY m.date_mouvement DESC
        """).fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def get_mouvement_by_id(mvt_id):
    """Get mouvement by ID with article and event info, returns dict or None."""
    conn = None
    try:
        conn = get_conn()
        row = conn.execute("""
            SELECT m.*, a.name AS article_name, e.name AS event_name, e.date AS event_date
            FROM buvette_mouvements m
            LEFT JOIN buvette_articles a ON m.article_id = a.id
            LEFT JOIN events e ON m.event_id = e.id
            WHERE m.id=?
        """, (mvt_id,)).fetchone()
        return row_to_dict(row)
    finally:
        if conn:
            conn.close()

def insert_mouvement(article_id, date_mouvement, type_mouvement, quantite, motif, event_id):
    """Insert new mouvement."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            INSERT INTO buvette_mouvements (article_id, date_mouvement, type_mouvement, quantite, motif, event_id)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (article_id, date_mouvement, type_mouvement, quantite, motif, event_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def update_mouvement(mvt_id, article_id, date_mouvement, type_mouvement, quantite, motif, event_id):
    """Update existing mouvement."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("""
            UPDATE buvette_mouvements SET article_id=?, date_mouvement=?, type_mouvement=?, quantite=?, motif=?, event_id=?
            WHERE id=?
        """, (article_id, date_mouvement, type_mouvement, quantite, motif, event_id, mvt_id))
        conn.commit()
    finally:
        if conn:
            conn.close()

def delete_mouvement(mvt_id):
    """Delete mouvement by ID."""
    conn = None
    try:
        conn = get_conn()
        conn.execute("DELETE FROM buvette_mouvements WHERE id=?", (mvt_id,))
        conn.commit()
    finally:
        if conn:
            conn.close()

# ----- UTILITY -----
def list_articles():
    """List articles for dropdown, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("SELECT id, name FROM buvette_articles ORDER BY name").fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()

def list_events():
    """List events for dropdown, returns list of dicts."""
    conn = None
    try:
        conn = get_conn()
        rows = conn.execute("SELECT id, name FROM events ORDER BY date DESC").fetchall()
        return rows_to_dicts(rows)
    finally:
        if conn:
            conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/buvette_mouvements_dialogs.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from datetime import date
import modules.buvette_mouvements_db as db
from modules.db_row_utils import _rows_to_dicts

class MouvementDialog(tk.Toplevel):
    def __init__(self, master, mouvement_id=None, on_save=None):
        super().__init__(master)
        self.title("Mouvement de stock buvette")
        self.geometry("400x420")
        self.on_save = on_save
        self.mouvement_id = mouvement_id

        self.article_var = tk.StringVar()
        self.date_var = tk.StringVar(value=str(date.today()))
        self.type_var = tk.StringVar()
        self.qte_var = tk.IntVar()
        self.motif_var = tk.StringVar()
        self.evt_var = tk.StringVar()

        tk.Label(self, text="Article :").pack(pady=4)
        self.article_cb = ttk.Combobox(self, textvariable=self.article_var, state="readonly", width=28)
        self.articles_dict = {str(r["name"]): r["id"] for r in db.list_articles()}
        self.article_cb["values"] = list(self.articles_dict.keys())
        self.article_cb.pack()

        tk.Label(self, text="Date :").pack(pady=4)
        tk.Entry(self, textvariable=self.date_var).pack()
        tk.Label(self, text="Type mouvement :").pack(pady=4)
        self.type_cb = ttk.Combobox(self, textvariable=self.type_var, state="readonly", width=18)
        self.type_cb["values"] = [
            "casse", "consommation_reunion", "don", "peremption", "autre"
        ]
        self.type_cb.pack()
        tk.Label(self, text="QuantitÃ© :").pack(pady=4)
        tk.Entry(self, textvariable=self.qte_var).pack()
        tk.Label(self, text="Motif / commentaire :").pack(pady=4)
        tk.Entry(self, textvariable=self.motif_var).pack()
        tk.Label(self, text="Ã‰vÃ©nement (optionnel) :").pack(pady=4)
        self.evt_cb = ttk.Combobox(self, textvariable=self.evt_var, width=28, state="readonly")
        self.evt_dict = {"": None}
        # Convert Row objects to dicts for safe access
        events = _rows_to_dicts(db.list_events())
        for r in events:
            label = f"{r['id']} - {r['name']}"
            self.evt_dict[label] = r["id"]
        self.evt_cb["values"] = list(self.evt_dict.keys())
        self.evt_cb.pack()

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=14)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=12)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=12)

        if mouvement_id:
            self.load_mouvement()

    def load_mouvement(self):
        mvt = db.get_mouvement_by_id(self.mouvement_id)
        if mvt:
            self.article_var.set(self._find_name_by_id(self.articles_dict, mvt["article_id"]))
            self.date_var.set(mvt["date_mouvement"])
            self.type_var.set(mvt["type_mouvement"])
            self.qte_var.set(mvt["quantite"])
            self.motif_var.set(mvt["motif"])
            self.evt_var.set(self._find_name_by_id(self.evt_dict, mvt["event_id"]))

    def _find_name_by_id(self, d, val):
        for k, v in d.items():
            if v == val:
                return k
        return ""

    def save(self):
        nom_article = self.article_var.get()
        if not nom_article or nom_article not in self.articles_dict:
            messagebox.showerror("Erreur", "Article obligatoire.")
            return
        article_id = self.articles_dict[nom_article]
        date_mvt = self.date_var.get()
        type_mvt = self.type_var.get()
        quantite = self.qte_var.get()
        motif = self.motif_var.get()
        evt_label = self.evt_var.get()
        event_id = self.evt_dict.get(evt_label, None)
        if self.mouvement_id:
            db.update_mouvement(self.mouvement_id, article_id, date_mvt, type_mvt, quantite, motif, event_id)
        else:
            db.insert_mouvement(article_id, date_mvt, type_mvt, quantite, motif, event_id)
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/categories.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
import pandas as pd
from db.db import get_connection
from utils.validation import is_required

class CategoriesModule:
    def __init__(self, master):
        self.master = master
        self.top = tk.Toplevel(master)
        self.top.title("Gestion des CatÃ©gories")
        self.top.geometry("700x400")
        self.create_table()
        self.create_buttons()
        self.refresh_categories()

    def create_table(self):
        style = ttk.Style()
        style.theme_use("default")
        style.configure("Treeview.Heading", font=('Arial', 11, 'bold'))
        style.configure("Treeview", font=('Consolas', 11), rowheight=24)
        style.configure("oddrow", background="#F2F2F2")
        style.configure("evenrow", background="#FFFFFF")

        self.tree = ttk.Treeview(
            self.top, columns=("id", "name", "parent"), show="headings", selectmode="browse"
        )
        self.tree.heading("id", text="ID")
        self.tree.heading("name", text="Name")
        self.tree.heading("parent", text="CatÃ©gorie parente")
        self.tree.column("id", width=40, anchor="center")
        self.tree.column("name", width=180)
        self.tree.column("parent", width=180)
        self.tree.pack(fill=tk.BOTH, expand=True)
        vsb = ttk.Scrollbar(self.top, orient="vertical", command=self.tree.yview)
        vsb.pack(side='right', fill='y')
        self.tree.configure(yscroll=vsb.set)

    def refresh_categories(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        df = pd.read_sql_query("""
            SELECT c.id, c.name, p.name as parent
            FROM categories c
            LEFT JOIN categories p ON c.parent_id = p.id
            ORDER BY COALESCE(p.name, c.name), c.name
        """, conn)
        self.df = df
        for idx, (_, row) in enumerate(df.iterrows()):
            tag = "evenrow" if idx % 2 == 0 else "oddrow"
            self.tree.insert("", "end", values=(
                row['id'], row['name'], row['parent'] if pd.notnull(row['parent']) else ""
            ), tags=(tag,))

    def create_buttons(self):
        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=8)
        tk.Button(btn_frame, text="Ajouter", command=self.add_category).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Modifier", command=self.edit_category).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_category).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=10)

    def add_category(self):
        data = self.category_form()
        if not data:
            return
        if not is_required(data['name']):
            messagebox.showerror("Erreur", "Le name est obligatoire.")
            return
        conn = get_connection()
        cur = conn.cursor()
        cur.execute("INSERT INTO categories (name, parent_id) VALUES (?, ?)", (data['name'], data['parent_id']))
        conn.commit()
        self.refresh_categories()

    def edit_category(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une catÃ©gorie Ã  modifier.")
            return
        item = self.tree.item(selected[0])
        cat_id = item['values'][0]
        row = self.df[self.df['id'] == cat_id].iloc[0]
        data = self.category_form(row)
        if not data:
            return
        if not is_required(data['name']):
            messagebox.showerror("Erreur", "Le name est obligatoire.")
            return
        conn = get_connection()
        cur = conn.cursor()
        cur.execute(
            "UPDATE categories SET name=?, parent_id=? WHERE id=?",
            (data['name'], data['parent_id'], cat_id)
        )
        conn.commit()
        self.refresh_categories()

    def delete_category(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une catÃ©gorie Ã  supprimer.")
            return
        item = self.tree.item(selected[0])
        cat_id = item['values'][0]
        name = item['values'][1]
        # VÃ©rifier si cette catÃ©gorie a des enfants ou des buvette_articles liÃ©s
        conn = get_connection()
        cur = conn.cursor()
        cur.execute("SELECT COUNT(*) FROM categories WHERE parent_id=?", (cat_id,))
        nb_children = cur.fetchone()[0]
        cur.execute("SELECT COUNT(*) FROM stock WHERE categorie_id=?", (cat_id,))
        nb_stock = cur.fetchone()[0]
        if nb_children > 0:
            messagebox.showerror("Erreur", "Impossible de supprimer une catÃ©gorie qui a des sous-catÃ©gories.")
            return
        if nb_stock > 0:
            messagebox.showerror("Erreur", "Impossible de supprimer une catÃ©gorie liÃ©e Ã  des buvette_articles en stock.")
            return
        if messagebox.askyesno("Confirmation", f"Supprimer la catÃ©gorie '{name}' ?"):
            cur.execute("DELETE FROM categories WHERE id=?", (cat_id,))
            conn.commit()
            self.refresh_categories()

    def category_form(self, row=None):
        form = tk.Toplevel(self.top)
        form.title("Saisie CatÃ©gorie")
        conn = get_connection()
        df_cat = pd.read_sql_query("SELECT id, name FROM categories WHERE parent_id IS NULL", conn)
        # PrÃ©remplissage
        values = [
            row['name'] if row is not None else "",
            row['parent'] if row is not None else "",  # CatÃ©gorie parente
        ]
        tk.Label(form, text="Name").grid(row=0, column=0, sticky="w", pady=3, padx=5)
        nom_entry = tk.Entry(form, width=30)
        nom_entry.grid(row=0, column=1, pady=3, padx=5)
        nom_entry.insert(0, values[0])

        tk.Label(form, text="CatÃ©gorie parente (optionnel)").grid(row=1, column=0, sticky="w", pady=3, padx=5)
        parent_var = tk.StringVar()
        parent_cb = ttk.Combobox(form, textvariable=parent_var, values=list(df_cat['name']), state="readonly", width=27)
        parent_cb.grid(row=1, column=1, pady=3, padx=5)
        if values[1] and values[1] in df_cat['name'].values:
            parent_cb.set(values[1])
        else:
            parent_cb.set("")

        result = {}
        def validate():
            result['name'] = nom_entry.get().strip()
            parent_nom = parent_var.get().strip()
            if not result['name']:
                messagebox.showerror("Erreur", "Le name est obligatoire.")
                return
            if parent_nom:
                parent_row = df_cat[df_cat['name'] == parent_nom]
                if not parent_row.empty:
                    result['parent_id'] = int(parent_row.iloc[0]['id'])
                else:
                    result['parent_id'] = None
            else:
                result['parent_id'] = None
            form.destroy()
        tk.Button(form, text="Valider", command=validate).grid(row=2, column=0, pady=10)
        tk.Button(form, text="Annuler", command=lambda: form.destroy()).grid(row=2, column=1, pady=10)
        form.grab_set()
        form.wait_window()
        if result:
            return result
        else:
            return None
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/cloture_exercice.py ===

```python
import tkinter as tk
from tkinter import messagebox, filedialog
import zipfile
import os
import pandas as pd

from db.db import get_connection
from exports.exports import (
    export_bilan_reporte_pdf,
    export_bilan_argumente_pdf,
    export_bilan_argumente_word
)
from dialogs.cloture_confirm_dialog import ClotureConfirmDialog

class ClotureExerciceModule:
    def __init__(self, master, visualisation_mode=False):
        self.master = master
        self.visualisation_mode = visualisation_mode
        self.top = tk.Toplevel(master)
        self.top.title("ClÃ´ture de l'exercice")
        self.top.geometry("520x420")
        self.create_widgets()

    def create_widgets(self):
        row = 0
        tk.Label(self.top, text="ClÃ´ture d'exercice annuel", font=("Arial", 15, "bold")).grid(row=row, column=0, columnspan=2, pady=14)
        row += 1
        tk.Label(self.top, text="â€¢ Cette opÃ©ration va :\n"
                               "- Exporter toutes les tables de la base sous forme CSV\n"
                               "- GÃ©nÃ©rer une archive ZIP pour archivage ou visualisation\n"
                               "- Permettre l'Ã©dition d'un bilan PDF rÃ©digÃ©\n"
                               "- Permettre l'Ã©dition d'un bilan FIN D'EXERCICE argumentÃ© PDF ou Word\n"
                               "- (Optionnel) RÃ©initialiser les donnÃ©es pour le nouvel exercice\n\n"
                               "âš ï¸ Cette opÃ©ration est IRRÃ‰VERSIBLE", fg="red").grid(row=row, column=0, columnspan=2, pady=8)
        row += 1
        tk.Button(self.top, text="Exporter l'exercice en ZIP", command=self.export_zip, width=36).grid(row=row, column=0, columnspan=2, pady=18)
        row += 1
        tk.Button(self.top, text="Exporter le bilan PDF rÃ©digÃ©", command=self.export_bilan_pdf, width=36).grid(row=row, column=0, columnspan=2, pady=10)
        row += 1
        tk.Button(self.top, text="Exporter le bilan FIN D'EXERCICE (argumentÃ© PDF)", command=export_bilan_argumente_pdf, width=36).grid(row=row, column=0, columnspan=2, pady=10)
        row += 1
        tk.Button(self.top, text="Exporter le bilan FIN D'EXERCICE (argumentÃ© Word)", command=export_bilan_argumente_word, width=36).grid(row=row, column=0, columnspan=2, pady=10)
        row += 1
        tk.Button(self.top, text="RÃ©initialiser la base de donnÃ©es", command=self.cloture_confirm, width=36, fg="red").grid(row=row, column=0, columnspan=2, pady=14)
        row += 1
        tk.Button(self.top, text="Fermer", command=self.top.destroy, width=16).grid(row=row, column=1, pady=6, sticky="e")


    def export_zip(self):
        tables = [
            "events", "event_modules", "event_module_fields", "event_module_data",
            "members", "dons_subventions", "depenses_regulieres", "depenses_diverses",
            "journal", "categories", "stock"
        ]
        file_path = filedialog.asksaveasfilename(
            title="Enregistrer l'exercice (ZIP)",
            defaultextension=".zip",
            filetypes=[("Archive ZIP", "*.zip")]
        )
        if not file_path:
            return
        tmp_dir = "tmp_cloture_export"
        os.makedirs(tmp_dir, exist_ok=True)
        conn = get_connection()
        for tab in tables:
            df = pd.read_sql_query(f"SELECT * FROM {tab}", conn)
            df.to_csv(os.path.join(tmp_dir, f"{tab}.csv"), index=False, encoding="utf-8")
        conn.close()
        with zipfile.ZipFile(file_path, "w", zipfile.ZIP_DEFLATED) as zf:
            for tab in tables:
                zf.write(os.path.join(tmp_dir, f"{tab}.csv"), arcname=f"{tab}.csv")
        # Clean temp
        for tab in tables:
            try:
                os.remove(os.path.join(tmp_dir, f"{tab}.csv"))
            except Exception:
                pass
        try:
            os.rmdir(tmp_dir)
        except Exception:
            pass
        messagebox.showinfo("ClÃ´ture", f"Archive exportÃ©e :\n{file_path}")

    def export_bilan_pdf(self):
        # Tu peux adapter ici pour rassembler les synthÃ¨ses nÃ©cessaires
        # Par exemple, synthÃ¨se Ã©vÃ©nements, dÃ©penses, dons...
        # Ici, on mocke des DataFrames pour la dÃ©monstration
        synth_evt = pd.DataFrame([
            {"evenement": "MarchÃ© de NoÃ«l", "recettes": 1200, "depenses": 400, "solde": 800},
            {"evenement": "Vente de gÃ¢teaux", "recettes": 450, "depenses": 100, "solde": 350}
        ])
        synth_dep = pd.DataFrame([
            {"origine": "MarchÃ© de NoÃ«l", "categorie": "Fournitures", "total": 300},
            {"origine": "Vente de gÃ¢teaux", "categorie": "IngrÃ©dients", "total": 100}
        ])
        recap = {"synth_evt": synth_evt, "synth_dep": synth_dep}
        exercice = "2023-2024"
        date = "2023-09-01"
        date_fin = "2024-08-31"
        export_bilan_reporte_pdf(recap, self.top, exercice, date, date_fin)

    def cloture_confirm(self):
        ClotureConfirmDialog(self.top)
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/db_api.py ===

```python
"""
Central Database API Module

Provides centralized database connection management with:
- WAL mode for better concurrency
- Busy timeout to reduce lock errors
- Query helper functions (query_one, query_all)
- Transaction context manager

This module is the recommended way to interact with the database
across the application, ensuring consistent connection configuration
and error handling.
"""

import sqlite3
import time
from typing import Optional, List, Dict, Any, Callable, Tuple
from contextlib import contextmanager
from db.db import get_db_file
from utils.app_logger import get_logger
from modules.db_row_utils import _row_to_dict, _rows_to_dicts

logger = get_logger("db_api")


def get_connection(row_factory: Optional[Any] = sqlite3.Row) -> sqlite3.Connection:
    """
    Get a database connection with optimal settings.
    
    Sets:
    - PRAGMA journal_mode=WAL (Write-Ahead Logging for better concurrency)
    - PRAGMA busy_timeout=5000 (Wait up to 5 seconds if DB is locked)
    - row_factory=sqlite3.Row by default (for named column access)
    
    Args:
        row_factory: Factory for row objects (default: sqlite3.Row)
                     Set to None for tuples, or provide custom factory
    
    Returns:
        sqlite3.Connection: Configured database connection
        
    Example:
        >>> conn = get_connection()
        >>> cursor = conn.cursor()
        >>> cursor.execute("SELECT * FROM articles")
        >>> row = cursor.fetchone()
        >>> print(row['name'])  # Named access works
    """
    try:
        db_file = get_db_file()
        conn = sqlite3.connect(
            db_file, 
            timeout=10, 
            detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES
        )
        
        # Set row factory for named column access
        if row_factory is not None:
            conn.row_factory = row_factory
        
        # Set pragmas for better concurrency and reliability
        try:
            conn.execute("PRAGMA journal_mode=WAL;")
            conn.execute("PRAGMA busy_timeout=5000;")
        except Exception as pragma_exc:
            logger.warning(f"Failed to set PRAGMAs: {pragma_exc}")
        
        return conn
    except Exception as e:
        logger.error(f"Error connecting to database: {e}")
        raise


def query_one(
    query: str, 
    params: Optional[Tuple] = None,
    converter: Optional[Callable] = None
) -> Optional[Dict[str, Any]]:
    """
    Execute a query and return a single row as a dict.
    
    Args:
        query: SQL query string
        params: Query parameters (optional)
        converter: Optional converter function (default: _row_to_dict)
                   Set to None to disable conversion
    
    Returns:
        dict or None: Single row as dict, or None if no results
        
    Example:
        >>> article = query_one("SELECT * FROM articles WHERE id = ?", (1,))
        >>> print(article.get('name', 'Unknown'))
    """
    if converter is None:
        converter = _row_to_dict
    
    conn = None
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        
        row = cursor.fetchone()
        
        if row is None:
            return None
        
        # Convert if converter provided
        if converter:
            return converter(row, cursor)
        else:
            return row
        
    except Exception as e:
        logger.error(f"Error executing query_one: {e}")
        logger.error(f"Query: {query}")
        logger.error(f"Params: {params}")
        raise
    finally:
        if conn:
            conn.close()


def query_all(
    query: str, 
    params: Optional[Tuple] = None,
    converter: Optional[Callable] = None
) -> List[Dict[str, Any]]:
    """
    Execute a query and return all rows as a list of dicts.
    
    Args:
        query: SQL query string
        params: Query parameters (optional)
        converter: Optional converter function (default: _rows_to_dicts)
                   Set to None to disable conversion
    
    Returns:
        list of dicts: All rows as dicts
        
    Example:
        >>> articles = query_all("SELECT * FROM articles WHERE categorie = ?", ('Boisson',))
        >>> for article in articles:
        >>>     print(article.get('name', 'Unknown'))
    """
    if converter is None:
        converter = _rows_to_dicts
    
    conn = None
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        
        rows = cursor.fetchall()
        
        # Convert if converter provided
        if converter:
            return converter(rows, cursor)
        else:
            return rows if rows else []
        
    except Exception as e:
        logger.error(f"Error executing query_all: {e}")
        logger.error(f"Query: {query}")
        logger.error(f"Params: {params}")
        raise
    finally:
        if conn:
            conn.close()


@contextmanager
def transaction(conn: Optional[sqlite3.Connection] = None):
    """
    Context manager for database transactions.
    
    Automatically commits on success, rolls back on exception.
    If no connection provided, creates one.
    
    Args:
        conn: Optional existing connection to use
    
    Yields:
        sqlite3.Connection: Database connection for transaction
        
    Example:
        >>> with transaction() as conn:
        >>>     cursor = conn.cursor()
        >>>     cursor.execute("INSERT INTO articles (...) VALUES (...)")
        >>>     cursor.execute("UPDATE stock SET ...")
        >>> # Automatically committed
        
        >>> # Or with existing connection:
        >>> conn = get_connection()
        >>> with transaction(conn):
        >>>     # Do multiple operations
        >>>     pass
    """
    if conn is None:
        conn = get_connection()
        close_after = True
    else:
        close_after = False
    
    try:
        yield conn
        conn.commit()
    except Exception as e:
        logger.error(f"Transaction failed, rolling back: {e}")
        conn.rollback()
        raise
    finally:
        if close_after:
            conn.close()


def execute_query(
    query: str,
    params: Optional[Tuple] = None,
    commit: bool = True
) -> int:
    """
    Execute a query (INSERT, UPDATE, DELETE) and return rows affected.
    
    Args:
        query: SQL query string
        params: Query parameters (optional)
        commit: Whether to commit the transaction (default: True)
    
    Returns:
        int: Number of rows affected
        
    Example:
        >>> rows_updated = execute_query(
        ...     "UPDATE articles SET stock = ? WHERE id = ?",
        ...     (50, 1)
        ... )
        >>> print(f"Updated {rows_updated} rows")
    """
    conn = None
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        
        rows_affected = cursor.rowcount
        
        if commit:
            conn.commit()
        
        return rows_affected
        
    except Exception as e:
        logger.error(f"Error executing query: {e}")
        logger.error(f"Query: {query}")
        logger.error(f"Params: {params}")
        if conn:
            conn.rollback()
        raise
    finally:
        if conn:
            conn.close()


def execute(
    query: str,
    params: Optional[Tuple] = None,
    commit: bool = True,
    retries: int = 3,
    retry_delay: float = 0.5
) -> int:
    """
    Execute a query with retry logic for database lock errors.
    
    This function attempts to execute a query multiple times if it encounters
    a "database is locked" error, with exponential backoff between retries.
    
    Args:
        query: SQL query string (INSERT, UPDATE, DELETE)
        params: Query parameters (optional)
        commit: Whether to commit the transaction (default: True)
        retries: Number of retry attempts on lock errors (default: 3)
        retry_delay: Initial delay between retries in seconds (default: 0.5)
                     Delay doubles with each retry (exponential backoff)
    
    Returns:
        int: Number of rows affected
        
    Raises:
        sqlite3.OperationalError: If database remains locked after all retries
        Exception: Any other database error
        
    Example:
        >>> # Simple usage with default retries
        >>> rows = execute(
        ...     "UPDATE articles SET stock = ? WHERE id = ?",
        ...     (50, 1)
        ... )
        
        >>> # Custom retry configuration for critical operations
        >>> rows = execute(
        ...     "INSERT INTO orders (...) VALUES (...)",
        ...     params,
        ...     retries=5,
        ...     retry_delay=1.0
        ... )
    """
    last_exception = None
    delay = retry_delay
    
    for attempt in range(retries):
        conn = None
        try:
            conn = get_connection()
            cursor = conn.cursor()
            
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            
            rows_affected = cursor.rowcount
            
            if commit:
                conn.commit()
            
            # Success - return result
            return rows_affected
            
        except sqlite3.OperationalError as e:
            last_exception = e
            error_msg = str(e).lower()
            
            # Check if this is a "database is locked" error
            if "locked" in error_msg and attempt < retries - 1:
                logger.warning(
                    f"Database locked on attempt {attempt + 1}/{retries}. "
                    f"Retrying in {delay}s... Query: {query[:100]}"
                )
                if conn:
                    try:
                        conn.close()
                    except sqlite3.Error:
                        # Ignore errors when closing connection
                        pass
                time.sleep(delay)
                delay *= 2  # Exponential backoff
                continue
            else:
                # Not a lock error or final attempt - log and raise
                logger.error(f"Database error after {attempt + 1} attempts: {e}")
                logger.error(f"Query: {query}")
                logger.error(f"Params: {params}")
                if conn:
                    try:
                        conn.rollback()
                    except sqlite3.Error:
                        # Ignore errors during rollback
                        pass
                raise
                
        except Exception as e:
            # Non-lock error - log and raise immediately
            logger.error(f"Error executing query: {e}")
            logger.error(f"Query: {query}")
            logger.error(f"Params: {params}")
            if conn:
                try:
                    conn.rollback()
                except sqlite3.Error:
                    # Ignore errors during rollback
                    pass
            raise
        finally:
            if conn:
                try:
                    conn.close()
                except sqlite3.Error:
                    # Ignore errors when closing connection
                    pass


# Convenience aliases
fetch_one = query_one
fetch_all = query_all

```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/db_row_utils.py ===

```python
"""
Database row utility functions for safe sqlite3.Row conversions.

This module provides utility functions to safely convert sqlite3.Row objects
to dictionaries, enabling the use of .get() method for optional field access.

Note: This module duplicates functionality from utils.db_helpers for module-specific
use. The underscore prefix (_row_to_dict, _rows_to_dicts) indicates these are
internal utilities specific to the modules/ directory. The utils.db_helpers versions
(row_to_dict, rows_to_dicts) remain available for general use throughout the codebase.

Functions:
    _row_to_dict: Convert a single sqlite3.Row to dict
    _rows_to_dicts: Convert a list of sqlite3.Row objects to list of dicts
"""

from typing import Any, Dict, List, Optional
import sqlite3


def _row_to_dict(row: Optional[sqlite3.Row], cursor: Optional[Any] = None) -> Optional[Dict[str, Any]]:
    """
    Convert sqlite3.Row to dict for safe .get() access.
    
    sqlite3.Row objects support dictionary-style access (row['column']) but
    lack the .get() method that dicts have for optional fields with defaults.
    This function converts a Row to a dict to enable .get() usage.
    
    Args:
        row: sqlite3.Row object, tuple, or None
        cursor: Optional cursor with description for tuple fallback
        
    Returns:
        dict or None: Dictionary representation of the row, or None if input is None
        
    Example:
        >>> row = cursor.execute("SELECT * FROM table").fetchone()
        >>> row_dict = _row_to_dict(row)
        >>> value = row_dict.get('optional_column', 'default')
        
        >>> # With cursor fallback for plain tuples:
        >>> cursor = conn.cursor()
        >>> cursor.execute("SELECT * FROM table")
        >>> row = cursor.fetchone()
        >>> row_dict = _row_to_dict(row, cursor)
    """
    if row is None:
        return None
    
    # Handle both sqlite3.Row and tuple types
    if isinstance(row, dict):
        # Already a dict, return as-is
        return row
    
    try:
        # Convert Row to dict
        return dict(row)
    except (TypeError, ValueError) as e:
        # Fallback for other sequence types (tuples, etc.) using cursor.description
        if cursor and hasattr(cursor, 'description') and cursor.description:
            try:
                return {cursor.description[i][0]: row[i] for i in range(len(row))}
            except (IndexError, TypeError):
                pass
        # If it's a tuple and we don't have column names, return None
        # In practice, sqlite3.Row should always work with dict()
        if hasattr(row, '__iter__') and not isinstance(row, (str, bytes)):
            return None
        raise TypeError(f"Cannot convert {type(row)} to dict: {e}")


def _rows_to_dicts(rows: List[sqlite3.Row], cursor: Optional[Any] = None) -> List[Dict[str, Any]]:
    """
    Convert list of sqlite3.Row objects to list of dicts.
    
    This is a batch version of _row_to_dict() for converting multiple rows.
    Filters out None values automatically.
    
    Args:
        rows: list of sqlite3.Row objects or tuples
        cursor: Optional cursor with description for tuple fallback
        
    Returns:
        list of dicts: List of dictionary representations
        
    Example:
        >>> rows = cursor.execute("SELECT * FROM table").fetchall()
        >>> dicts = _rows_to_dicts(rows)
        >>> for d in dicts:
        >>>     print(d.get('optional_column', 'N/A'))
        
        >>> # With cursor fallback:
        >>> cursor = conn.cursor()
        >>> cursor.execute("SELECT * FROM table")
        >>> rows = cursor.fetchall()
        >>> dicts = _rows_to_dicts(rows, cursor)
    """
    if not rows:
        return []
    
    result = []
    for row in rows:
        converted = _row_to_dict(row, cursor)
        if converted is not None:
            result.append(converted)
    
    return result

```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/depenses_diverses.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
from dialogs.depense_dialog import DepenseDialog

class DepensesDiversesModule:
    def __init__(self, master):
        self.columns = (
            "id", "categorie", "module_id", "montant", "fournisseur", "date_depense",
            "paye_par", "membre_id", "statut_remboursement", "statut_reglement",
            "moyen_paiement", "numero_cheque", "numero_facture", "commentaire"
        )
        self.top = tk.Toplevel(master)
        self.top.title("DÃ©penses Diverses")
        self.top.geometry("900x500")
        self.create_widgets()
        self.refresh_list()

    def create_widgets(self):
        self.tree = ttk.Treeview(self.top, columns=self.columns, show="headings")
        headers = [
            ("id", "ID"), ("categorie", "CatÃ©gorie"), ("module_id", "Module liÃ©"),
            ("montant", "Montant (â‚¬)"), ("fournisseur", "Fournisseur"),
            ("date_depense", "Date de la dÃ©pense"),
            ("paye_par", "PayÃ© par"), ("membre_id", "Membre"),
            ("statut_remboursement", "Statut remboursement"),
            ("statut_reglement", "Statut rÃ¨glement"),
            ("moyen_paiement", "Moyen paiement"), ("numero_cheque", "NÂ° chÃ¨que"),
            ("numero_facture", "NÂ° facture"), ("commentaire", "Commentaire")
        ]
        for col, text in headers:
            self.tree.heading(col, text=text)
            self.tree.column(col, width=120, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=6)
        tk.Button(btn_frame, text="Ajouter DÃ©pense Diverses", command=self.add_depense).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Ã‰diter sÃ©lection", command=self.edit_depense).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Supprimer sÃ©lection", command=self.delete_selected).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=8)

    def get_module_choices(self):
        conn = get_connection()
        modules = conn.execute("SELECT id, nom_module FROM event_modules ORDER BY nom_module").fetchall()
        conn.close()
        return [("", "Aucun")] + [(str(m["id"]), m["nom_module"]) for m in modules]

    def get_fournisseur_choices(self):
        conn = get_connection()
        fournisseurs = conn.execute("SELECT name FROM fournisseurs ORDER BY name").fetchall()
        conn.close()
        return [f["name"] for f in fournisseurs]

    def get_membre_choices(self):
        conn = get_connection()
        membres = conn.execute("SELECT id, name, prenom FROM membres ORDER BY name, prenom").fetchall()
        conn.close()
        return [(str(m["id"]), f"{m['prenom']} {m['name']}") for m in membres]

    def add_depense(self):
        DepenseDialog(
            self.top,
            table="depenses_diverses",
            module_choices=self.get_module_choices(),
            fournisseur_choices=self.get_fournisseur_choices(),
            membre_choices=self.get_membre_choices(),
            on_save=self.refresh_list,
            fields={
                "categorie": True,
                "module_id": True,
                "montant": True,
                "fournisseur": True,
                "date_depense": True,
                "paye_par": True,
                "moyen_paiement": True,
                "numero_cheque": True,
                "numero_facture": True,
                "commentaire": True,
            }
        )

    def edit_depense(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne Ã  Ã©diter.")
            return
        item = self.tree.item(sel[0])
        depense_id = item["values"][0]
        if not messagebox.askyesno("Confirmation", "Voulez-vous vraiment modifier cette dÃ©penseâ€¯?"):
            return
        DepenseDialog(
            self.top,
            table="depenses_diverses",
            depense_id=depense_id,
            module_choices=self.get_module_choices(),
            fournisseur_choices=self.get_fournisseur_choices(),
            membre_choices=self.get_membre_choices(),
            on_save=self.refresh_list,
            fields={
                "categorie": True,
                "module_id": True,
                "montant": True,
                "fournisseur": True,
                "date_depense": True,
                "paye_par": True,
                "moyen_paiement": True,
                "numero_cheque": True,
                "numero_facture": True,
                "commentaire": True,
            }
        )

    def delete_selected(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne Ã  supprimer.")
            return
        item = self.tree.item(sel[0])
        id_ = item["values"][0]
        if not messagebox.askyesno("Confirmer", "Supprimer cette dÃ©pense ?"):
            return
        conn = get_connection()
        conn.execute("DELETE FROM depenses_diverses WHERE id = ?", (id_,))
        conn.commit()
        conn.close()
        self.refresh_list()

    def refresh_list(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        items = conn.execute(
            "SELECT id, categorie, module_id, montant, fournisseur, date_depense, paye_par, membre_id, statut_remboursement, statut_reglement, moyen_paiement, numero_cheque, numero_facture, commentaire FROM depenses_diverses ORDER BY date_depense DESC, id DESC"
        ).fetchall()
        for item in items:
            module_name = ""
            membre_nom = ""
            if item["module_id"]:
                mod = conn.execute("SELECT nom_module FROM event_modules WHERE id=?", (item["module_id"],)).fetchone()
                if mod:
                    module_name = mod["nom_module"]
            if item["membre_id"]:
                mem = conn.execute("SELECT name, prenom FROM membres WHERE id=?", (item["membre_id"],)).fetchone()
                if mem:
                    membre_nom = f"{mem['prenom']} {mem['name']}"
            self.tree.insert(
                "", "end",
                values=[
                    item["id"], item["categorie"], module_name, f"{item['montant']:.2f}",
                    item["fournisseur"] or "", item["date_depense"] or "", item["paye_par"] or "",
                    membre_nom, item["statut_remboursement"] or "", item["statut_reglement"] or "",
                    item["moyen_paiement"] or "", item["numero_cheque"] or "",
                    item["numero_facture"] or "", item["commentaire"] or ""
                ]
            )
        conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/depenses_regulieres.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
from dialogs.depense_dialog import DepenseDialog

class DepensesRegulieresModule:
    def __init__(self, master):
        self.columns = (
            "id", "categorie", "module_id", "montant", "fournisseur", "date_depense",
            "paye_par", "membre_id", "statut_remboursement", "statut_reglement",
            "moyen_paiement", "numero_cheque", "numero_facture", "commentaire"
        )
        self.top = tk.Toplevel(master)
        self.top.title("DÃ©penses RÃ©guliÃ¨res")
        self.top.geometry("900x500")
        self.create_widgets()
        self.refresh_list()

    def create_widgets(self):
        self.tree = ttk.Treeview(self.top, columns=self.columns, show="headings")
        headers = [
            ("id", "ID"), ("categorie", "CatÃ©gorie"), ("module_id", "Module liÃ©"),
            ("montant", "Montant (â‚¬)"), ("fournisseur", "Fournisseur"),
            ("date_depense", "Date de la dÃ©pense"),
            ("paye_par", "PayÃ© par"), ("membre_id", "Membre"),
            ("statut_remboursement", "Statut remboursement"),
            ("statut_reglement", "Statut rÃ¨glement"),
            ("moyen_paiement", "Moyen paiement"), ("numero_cheque", "NÂ° chÃ¨que"),
            ("numero_facture", "NÂ° facture"), ("commentaire", "Commentaire")
        ]
        for col, text in headers:
            self.tree.heading(col, text=text)
            self.tree.column(col, width=120, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=6)
        tk.Button(btn_frame, text="Ajouter DÃ©pense RÃ©guliÃ¨re", command=self.add_depense).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Ã‰diter sÃ©lection", command=self.edit_depense).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Supprimer sÃ©lection", command=self.delete_selected).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=8)

    def get_module_choices(self):
        conn = get_connection()
        modules = conn.execute("SELECT id, nom_module FROM event_modules ORDER BY nom_module").fetchall()
        conn.close()
        return [("", "Aucun")] + [(str(m["id"]), m["nom_module"]) for m in modules]

    def get_fournisseur_choices(self):
        conn = get_connection()
        fournisseurs = conn.execute("SELECT name FROM fournisseurs ORDER BY name").fetchall()
        conn.close()
        return [f["name"] for f in fournisseurs]

    def get_membre_choices(self):
        conn = get_connection()
        membres = conn.execute("SELECT id, name, prenom FROM membres ORDER BY name, prenom").fetchall()
        conn.close()
        return [(str(m["id"]), f"{m['prenom']} {m['name']}") for m in membres]

    def add_depense(self):
        DepenseDialog(
            self.top,
            table="depenses_regulieres",
            module_choices=self.get_module_choices(),
            fournisseur_choices=self.get_fournisseur_choices(),
            membre_choices=self.get_membre_choices(),
            on_save=self.refresh_list,
            fields={
                "categorie": True,
                "module_id": True,
                "montant": True,
                "fournisseur": True,
                "date_depense": True,
                "paye_par": True,
                "moyen_paiement": True,
                "numero_cheque": True,
                "numero_facture": True,
                "commentaire": True,
            }
        )

    def edit_depense(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne Ã  Ã©diter.")
            return
        item = self.tree.item(sel[0])
        depense_id = item["values"][0]
        if not messagebox.askyesno("Confirmation", "Voulez-vous vraiment modifier cette dÃ©penseâ€¯?"):
            return
        DepenseDialog(
            self.top,
            table="depenses_regulieres",
            depense_id=depense_id,
            module_choices=self.get_module_choices(),
            fournisseur_choices=self.get_fournisseur_choices(),
            membre_choices=self.get_membre_choices(),
            on_save=self.refresh_list,
            fields={
                "categorie": True,
                "module_id": True,
                "montant": True,
                "fournisseur": True,
                "date_depense": True,
                "paye_par": True,
                "moyen_paiement": True,
                "numero_cheque": True,
                "numero_facture": True,
                "commentaire": True,
            }
        )

    def delete_selected(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne Ã  supprimer.")
            return
        item = self.tree.item(sel[0])
        id_ = item["values"][0]
        if not messagebox.askyesno("Confirmer", "Supprimer cette dÃ©pense rÃ©guliÃ¨re ?"):
            return
        conn = get_connection()
        conn.execute("DELETE FROM depenses_regulieres WHERE id = ?", (id_,))
        conn.commit()
        conn.close()
        self.refresh_list()

    def refresh_list(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        items = conn.execute(
            "SELECT id, categorie, module_id, montant, fournisseur, date_depense, paye_par, membre_id, statut_remboursement, statut_reglement, moyen_paiement, numero_cheque, numero_facture, commentaire FROM depenses_regulieres ORDER BY date_depense DESC, id DESC"
        ).fetchall()
        for item in items:
            module_name = ""
            membre_nom = ""
            if item["module_id"]:
                mod = conn.execute("SELECT nom_module FROM event_modules WHERE id=?", (item["module_id"],)).fetchone()
                if mod:
                    module_name = mod["nom_module"]
            if item["membre_id"]:
                mem = conn.execute("SELECT name, prenom FROM membres WHERE id=?", (item["membre_id"],)).fetchone()
                if mem:
                    membre_nom = f"{mem['prenom']} {mem['name']}"
            self.tree.insert(
                "", "end",
                values=[
                    item["id"], item["categorie"], module_name, f"{item['montant']:.2f}",
                    item["fournisseur"] or "", item["date_depense"] or "", item["paye_par"] or "",
                    membre_nom, item["statut_remboursement"] or "", item["statut_reglement"] or "",
                    item["moyen_paiement"] or "", item["numero_cheque"] or "",
                    item["numero_facture"] or "", item["commentaire"] or ""
                ]
            )
        conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/depots_retraits_banque.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_df_or_sql, get_connection
import pandas as pd
from datetime import date

class DepotsRetraitsBanqueModule:
    def __init__(self, master):
        self.master = master
        self.top = tk.Toplevel(master)
        self.top.title("Suivi des DÃ©pÃ´ts/Retraits Ã  la Banque")
        self.top.geometry("900x500")
        self.create_widgets()
        self.refresh_table()

    def create_widgets(self):
        frm_btn = tk.Frame(self.top)
        frm_btn.pack(fill=tk.X, pady=4)

        tk.Button(frm_btn, text="Ajouter Mouvement", command=self.ajouter_mouvement).pack(side=tk.LEFT, padx=5)
        tk.Button(frm_btn, text="Supprimer sÃ©lection", command=self.supprimer_selection).pack(side=tk.LEFT, padx=5)
        tk.Button(frm_btn, text="Exporter Excel", command=self.exporter_excel).pack(side=tk.LEFT, padx=5)
        tk.Label(frm_btn, text="Filtrer par banque:").pack(side=tk.LEFT, padx=10)
        self.var_banque = tk.StringVar()
        self.cmb_banque = ttk.Combobox(frm_btn, textvariable=self.var_banque, width=15, state="readonly")
        self.cmb_banque.pack(side=tk.LEFT)
        self.cmb_banque.bind("<<ComboboxSelected>>", lambda e: self.refresh_table())
        tk.Button(frm_btn, text="Tout afficher", command=lambda: self.var_banque.set('')).pack(side=tk.LEFT, padx=3)

        self.tree = ttk.Treeview(
            self.top,
            columns=("id", "date", "type", "montant", "reference", "banque", "pointe", "commentaire"),
            show="headings", selectmode="browse"
        )
        for col, w in zip(
            ("id", "date", "type", "montant", "reference", "banque", "pointe", "commentaire"),
            [0, 90, 120, 90, 110, 90, 60, 250]
        ):
            self.tree.heading(col, text=col.capitalize())
            self.tree.column(col, width=w)
        self.tree["displaycolumns"] = ("date", "type", "montant", "reference", "banque", "pointe", "commentaire")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        self.tree.bind("<Double-1>", self.toggle_pointage)

    def refresh_table(self):
        banque = self.var_banque.get()
        query = "SELECT * FROM depots_retraits_banque"
        if banque:
            query += " WHERE banque = ?"
            df = pd.read_sql_query(query, get_connection(), params=(banque,))
        else:
            df = get_df_or_sql("depots_retraits_banque")

        banques = sorted(get_df_or_sql("SELECT DISTINCT banque FROM depots_retraits_banque WHERE banque IS NOT NULL AND banque!=''")["banque"].unique().tolist())
        self.cmb_banque["values"] = [""] + banques

        self.tree.delete(*self.tree.get_children())
        for _, row in df.iterrows():
            self.tree.insert(
                "", "end", iid=row["id"],
                values=(
                    row["id"],
                    row["date"],
                    row["type"],
                    f"{row['montant']:.2f}",
                    row.get("reference", ""),
                    row.get("banque", ""),
                    "Oui" if row.get("pointe", 0) else "Non",
                    row.get("commentaire", "")
                )
            )

    def ajouter_mouvement(self):
        win = tk.Toplevel(self.top)
        win.title("Ajouter un dÃ©pÃ´t/retrait")
        win.transient(self.top)

        tk.Label(win, text="Date (AAAA-MM-JJ):").grid(row=0, column=0, sticky="e")
        ent_date = tk.Entry(win)
        ent_date.insert(0, date.today().isoformat())
        ent_date.grid(row=0, column=1)

        tk.Label(win, text="Type:").grid(row=1, column=0, sticky="e")
        cmb_type = ttk.Combobox(win, values=["DÃ©pÃ´t chÃ¨que", "DÃ©pÃ´t espÃ¨ces", "Retrait espÃ¨ces"], state="readonly")
        cmb_type.grid(row=1, column=1)
        cmb_type.set("DÃ©pÃ´t chÃ¨que")

        tk.Label(win, text="Montant (â‚¬):").grid(row=2, column=0, sticky="e")
        ent_montant = tk.Entry(win)
        ent_montant.grid(row=2, column=1)

        tk.Label(win, text="RÃ©fÃ©rence (bordereau, etc.):").grid(row=3, column=0, sticky="e")
        ent_reference = tk.Entry(win)
        ent_reference.grid(row=3, column=1)

        tk.Label(win, text="Banque:").grid(row=4, column=0, sticky="e")
        ent_banque = tk.Entry(win)
        ent_banque.grid(row=4, column=1)

        tk.Label(win, text="Commentaire:").grid(row=5, column=0, sticky="e")
        ent_comment = tk.Entry(win)
        ent_comment.grid(row=5, column=1)

        def valider():
            try:
                montant = float(ent_montant.get().replace(",", "."))
                if not ent_date.get():
                    raise ValueError("Date obligatoire")
                if montant == 0:
                    raise ValueError("Montant nul")
                conn = get_connection()
                c = conn.cursor()
                c.execute(
                    """INSERT INTO depots_retraits_banque (date, type, montant, reference, banque, commentaire)
                    VALUES (?, ?, ?, ?, ?, ?)""",
                    (
                        ent_date.get(),
                        cmb_type.get(),
                        montant,
                        ent_reference.get(),
                        ent_banque.get(),
                        ent_comment.get(),
                    ),
                )
                conn.commit()
                conn.close()
                win.destroy()
                self.refresh_table()
            except Exception as e:
                messagebox.showerror("Erreur", str(e))

        tk.Button(win, text="Enregistrer", command=valider).grid(row=6, column=0, columnspan=2, pady=8)

    def supprimer_selection(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showinfo("Suppression", "SÃ©lectionnez une ligne Ã  supprimer.")
            return
        if messagebox.askyesno("Suppression", "Supprimer cet enregistrement ?"):
            id_ = sel[0]
            conn = get_connection()
            c = conn.cursor()
            c.execute("DELETE FROM depots_retraits_banque WHERE id=?", (id_,))
            conn.commit()
            conn.close()
            self.refresh_table()

    def toggle_pointage(self, event):
        item = self.tree.identify_row(event.y)
        if not item:
            return
        id_ = int(item)
        conn = get_connection()
        c = conn.cursor()
        c.execute("SELECT pointe FROM depots_retraits_banque WHERE id=?", (id_,))
        row = c.fetchone()
        if row:
            new_val = 0 if row[0] else 1
            c.execute("UPDATE depots_retraits_banque SET pointe=? WHERE id=?", (new_val, id_))
            conn.commit()
        conn.close()
        self.refresh_table()

    def exporter_excel(self):
        df = get_df_or_sql("depots_retraits_banque")
        try:
            df.to_excel("depots_retraits_banque.xlsx", index=False)
            messagebox.showinfo("Export", "Export Excel effectuÃ© dans le fichier depots_retraits_banque.xlsx")
        except Exception as e:
            messagebox.showerror("Export", "Erreur export : " + str(e))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/dons_subventions.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
from utils.validation import is_required, is_number

class DonsSubventionsModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Dons et Subventions")
        self.top.geometry("700x400")
        self.create_widgets()
        self.refresh_list()

    def create_widgets(self):
        columns = ("id", "type", "source", "montant", "date", "justificatif")
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings")
        for col, text, w in zip(
            columns,
            ["ID", "Type", "Source", "Montant (â‚¬)", "Date", "Justificatif"],
            [50, 80, 180, 100, 100, 150]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=6)
        tk.Button(btn_frame, text="Ajouter Don/Subvention", command=self.add_don_subvention).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Supprimer sÃ©lection", command=self.delete_selected).pack(side=tk.LEFT, padx=8)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=8)

    def add_don_subvention(self):
        AddDonSubventionDialog(self.top, self.refresh_list)

    def delete_selected(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne Ã  supprimer.")
            return
        item = self.tree.item(sel[0])
        id_ = item["values"][0]
        if not messagebox.askyesno("Confirmer", "Supprimer ce don/subvention ?"):
            return
        conn = get_connection()
        conn.row_factory = None
        conn.execute("DELETE FROM dons_subventions WHERE id = ?", (id_,))
        conn.commit()
        conn.close()
        self.refresh_list()

    def refresh_list(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        conn.row_factory = None
        items = conn.execute(
            "SELECT id, type, source, montant, date, justificatif FROM dons_subventions ORDER BY date DESC, id DESC"
        ).fetchall()
        conn.close()
        for item in items:
            self.tree.insert("", "end", values=item)

class AddDonSubventionDialog(tk.Toplevel):
    def __init__(self, master, on_save):
        super().__init__(master)
        self.title("Ajouter un Don/Subvention")
        self.resizable(False, False)
        self.on_save = on_save

        tk.Label(self, text="Type (Don/Subvention) *").grid(row=0, column=0, sticky="e", pady=4, padx=6)
        self.type_var = tk.StringVar()
        self.type_combo = ttk.Combobox(self, textvariable=self.type_var, values=["Don", "Subvention"], width=20, state="readonly")
        self.type_combo.grid(row=0, column=1, pady=4)
        self.type_combo.current(0)

        tk.Label(self, text="Source (name, organisme) *").grid(row=1, column=0, sticky="e", pady=4, padx=6)
        self.source_var = tk.StringVar()
        tk.Entry(self, textvariable=self.source_var, width=28).grid(row=1, column=1, pady=4)

        tk.Label(self, text="Montant (â‚¬) *").grid(row=2, column=0, sticky="e", pady=4, padx=6)
        self.montant_var = tk.StringVar()
        tk.Entry(self, textvariable=self.montant_var, width=15).grid(row=2, column=1, pady=4)

        tk.Label(self, text="Date (YYYY-MM-DD) *").grid(row=3, column=0, sticky="e", pady=4, padx=6)
        self.date_var = tk.StringVar()
        tk.Entry(self, textvariable=self.date_var, width=15).grid(row=3, column=1, pady=4)

        tk.Label(self, text="Justificatif (facultatif)").grid(row=4, column=0, sticky="e", pady=4, padx=6)
        self.justif_var = tk.StringVar()
        tk.Entry(self, textvariable=self.justif_var, width=28).grid(row=4, column=1, pady=4)

        btn_frame = tk.Frame(self)
        btn_frame.grid(row=5, column=0, columnspan=2, pady=12)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=12)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.LEFT, padx=12)

    def save(self):
        type_ = self.type_var.get().strip()
        source = self.source_var.get().strip()
        montant_str = self.montant_var.get().replace(",", ".").strip()
        try:
            montant = float(montant_str)
        except Exception:
            montant = None
        date = self.date_var.get().strip()
        justificatif = self.justif_var.get().strip()
        if not is_required(type_) or not is_required(source) or montant is None or not is_required(date):
            messagebox.showerror("Erreur", "Champs obligatoires manquants ou montant invalide.")
            return
        conn = get_connection()
        conn.row_factory = None
        conn.execute(
            "INSERT INTO dons_subventions (type, source, montant, date, justificatif) VALUES (?, ?, ?, ?, ?)",
            (type_, source, montant, date, justificatif)
        )
        conn.commit()
        conn.close()
        messagebox.showinfo("AjoutÃ©", "Don/Subvention enregistrÃ©.")
        self.destroy()
        if self.on_save:
            self.on_save()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/events.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
from modules.event_modules import EventModulesWindow
from modules.event_payments import PaymentsWindow
from modules.event_caisses import EventCaissesWindow
from modules.event_recettes import EventRecettesWindow
from modules.event_depenses import EventDepensesWindow
from utils.app_logger import get_logger
from utils.error_handler import handle_exception
from utils.date_helpers import parse_date, today

logger = get_logger("events_module")

class EventsWindow(tk.Toplevel):
    def __init__(self, master):
        super().__init__(master)
        self.title("Gestion des Ã©vÃ©nements")
        self.geometry("1100x500")
        self.minsize(900, 300)
        self.create_widgets()
        self.refresh_events()

    def create_widgets(self):
        # --- Barre du haut ---
        top_frame = tk.Frame(self)
        top_frame.pack(side=tk.TOP, fill=tk.X)

        tk.Button(top_frame, text="Nouvel Ã©vÃ©nement", command=self.add_event).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(top_frame, text="Ã‰diter", command=self.edit_event).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(top_frame, text="Supprimer", command=self.delete_event).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(top_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)

        # --- Tableau au centre ---
        tree_frame = tk.Frame(self)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=0)

        columns = ("id", "name", "date", "lieu", "description", "recettes", "depenses", "gain")
        self.tree = ttk.Treeview(tree_frame, columns=columns, show="headings")
        headings = [
            ("id", "ID"),
            ("name", "Name"),
            ("date", "Date"),
            ("lieu", "Lieu"),
            ("description", "Description"),
            ("recettes", "Recettes (â‚¬)"),
            ("depenses", "DÃ©penses (â‚¬)"),
            ("gain", "Gain (â‚¬)")
        ]
        for col, lbl in headings:
            self.tree.heading(col, text=lbl)
            if col == "id":
                self.tree.column(col, width=50, anchor="center", stretch=False)
            elif col in ("recettes", "depenses", "gain"):
                self.tree.column(col, width=100, anchor="e", stretch=False)
            else:
                self.tree.column(col, width=140, stretch=True)
        self.tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)

        vsb = ttk.Scrollbar(tree_frame, orient="vertical", command=self.tree.yview)
        hsb = ttk.Scrollbar(tree_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        vsb.pack(side=tk.RIGHT, fill=tk.Y)
        hsb.pack(side=tk.BOTTOM, fill=tk.X)

        # --- Barre du bas faÃ§on dashboard ---
        bottom_frame = tk.Frame(self)
        bottom_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(12, 10))
        btn_style = {"font": ("Arial", 10, "bold"), "height": 2, "width": 20}

        tk.Button(bottom_frame, text="Modules personnalisÃ©s", command=self.open_modules, **btn_style).pack(side=tk.LEFT, padx=6)
        tk.Button(bottom_frame, text="Paiements", command=self.open_payments, **btn_style).pack(side=tk.LEFT, padx=6)
        tk.Button(bottom_frame, text="Caisses Ã©vÃ©nement", command=self.open_caisses, **btn_style).pack(side=tk.LEFT, padx=6)
        tk.Button(bottom_frame, text="Recettes Ã©vÃ©nement", command=self.open_recettes, **btn_style).pack(side=tk.LEFT, padx=6)
        tk.Button(bottom_frame, text="DÃ©penses Ã©vÃ©nement", command=self.open_depenses, **btn_style).pack(side=tk.LEFT, padx=6)

    def refresh_events(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            events = conn.execute("SELECT * FROM events ORDER BY date DESC").fetchall()
            for ev in events:
                event_id = ev["id"]
                recettes = conn.execute(
                    "SELECT COALESCE(SUM(montant), 0) FROM event_recettes WHERE event_id = ?", (event_id,)
                ).fetchone()[0]
                depenses = conn.execute(
                    "SELECT COALESCE(SUM(montant), 0) FROM event_depenses WHERE event_id = ?", (event_id,)
                ).fetchone()[0]
                gain = recettes - depenses
                self.tree.insert(
                    "", "end",
                    values=(
                        ev["id"],
                        ev["name"],
                        ev["date"],
                        ev["lieu"],
                        ev["description"],
                        f"{recettes:.2f}",
                        f"{depenses:.2f}",
                        f"{gain:.2f}"
                    )
                )
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des Ã©vÃ©nements."))

    def get_selected_event_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_event(self):
        EventDialog(self, on_save=self.refresh_events)

    def edit_event(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        EventDialog(self, event_id=eid, on_save=self.refresh_events)

    def delete_event(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer cet Ã©vÃ©nement ?"):
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM events WHERE id = ?", (eid,))
            conn.commit()
            conn.close()
            logger.info(f"Ã‰vÃ©nement supprimÃ© id {eid}")
            self.refresh_events()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de l'Ã©vÃ©nement."))

    def open_modules(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        EventModulesWindow(self, event_id=eid)

    def open_payments(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        PaymentsWindow(self, event_id=eid)
        
    def open_caisses(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        EventCaissesWindow(self, event_id=eid)    

    def open_recettes(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        EventRecettesWindow(self, event_id=eid)

    def open_depenses(self):
        eid = self.get_selected_event_id()
        if not eid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un Ã©vÃ©nement.")
            return
        EventDepensesWindow(self, event_id=eid)        

class EventDialog(tk.Toplevel):
    def __init__(self, master, event_id=None, on_save=None):
        super().__init__(master)
        self.title("Ã‰vÃ©nement" if not event_id else "Ã‰diter l'Ã©vÃ©nement")
        self.event_id = event_id
        self.on_save = on_save
        self.geometry("420x320")
        self.resizable(False, False)

        self.name_var = tk.StringVar()
        self.date_var = tk.StringVar()
        self.lieu_var = tk.StringVar()
        self.desc_var = tk.StringVar()

        tk.Label(self, text="Name :").pack(pady=6)
        tk.Entry(self, textvariable=self.name_var, width=40).pack()
        tk.Label(self, text="Date (yyyy-mm-dd) :").pack(pady=6)
        tk.Entry(self, textvariable=self.date_var, width=20).pack()
        tk.Label(self, text="Lieu :").pack(pady=6)
        tk.Entry(self, textvariable=self.lieu_var, width=30).pack()
        tk.Label(self, text="Description :").pack(pady=6)
        tk.Entry(self, textvariable=self.desc_var, width=45).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=36, pady=16)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=36, pady=16)

        if self.event_id:
            self.load_event()

    def load_event(self):
        try:
            conn = get_connection()
            ev = conn.execute("SELECT * FROM events WHERE id = ?", (self.event_id,)).fetchone()
            conn.close()
            if ev:
                self.name_var.set(ev["name"])
                self.date_var.set(ev["date"])
                self.lieu_var.set(ev["lieu"])
                self.desc_var.set(ev["description"])
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement de l'Ã©vÃ©nement."))

    def save(self):
        name = self.name_var.get().strip()
        date = self.date_var.get().strip() or today()
        lieu = self.lieu_var.get().strip()
        desc = self.desc_var.get().strip()
        if not name:
            messagebox.showerror("Erreur", "Le nom de l'Ã©vÃ©nement est obligatoire.")
            return
        if not parse_date(date):
            messagebox.showerror("Erreur", "Date invalide (format attendu : YYYY-MM-DD).")
            return
        try:
            conn = get_connection()
            if self.event_id:
                conn.execute(
                    "UPDATE events SET name=?, date=?, lieu=?, description=? WHERE id=?",
                    (name, date, lieu, desc, self.event_id)
                )
            else:
                conn.execute(
                    "INSERT INTO events (name, date, lieu, description) VALUES (?, ?, ?, ?)",
                    (name, date, lieu, desc)
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de l'Ã©vÃ©nement."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/event_caisses.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("event_caisses")

class EventCaissesWindow(tk.Toplevel):
    def __init__(self, master, event_id):
        super().__init__(master)
        self.title(f"Caisses de l'Ã©vÃ©nement {event_id}")
        self.geometry("700x400")
        self.event_id = event_id
        self.create_widgets()
        self.refresh_caisses()

    def create_widgets(self):
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X)
        tk.Button(btn_frame, text="Nouvelle caisse", command=self.add_caisse).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Ã‰diter", command=self.edit_caisse).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_caisse).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)

        columns = ("id", "nom", "solde_initial", "responsable")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        self.tree.heading("id", text="ID")
        self.tree.heading("nom", text="Nom de la caisse")
        self.tree.heading("solde_initial", text="Solde initial (â‚¬)")
        self.tree.heading("responsable", text="Responsable")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

    def refresh_caisses(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            caisses = conn.execute(
                "SELECT * FROM event_caisses WHERE event_id = ? ORDER BY id", (self.event_id,)
            ).fetchall()
            for caisse in caisses:
                self.tree.insert(
                    "", "end",
                    values=(
                        caisse["id"],
                        caisse["nom"],
                        f"{caisse['solde_initial']:.2f}" if caisse["solde_initial"] is not None else "",
                        caisse["responsable"] or ""
                    )
                )
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des caisses."))

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_caisse(self):
        CaisseDialog(self, event_id=self.event_id, on_save=self.refresh_caisses)

    def edit_caisse(self):
        cid = self.get_selected_id()
        if not cid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une caisse Ã  Ã©diter.")
            return
        CaisseDialog(self, event_id=self.event_id, caisse_id=cid, on_save=self.refresh_caisses)

    def delete_caisse(self):
        cid = self.get_selected_id()
        if not cid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une caisse Ã  supprimer.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer cette caisse ?"):
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM event_caisses WHERE id=? AND event_id=?", (cid, self.event_id))
            conn.commit()
            conn.close()
            logger.info(f"Caisse supprimÃ©e id {cid}, event_id {self.event_id}")
            self.refresh_caisses()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de la caisse."))

class CaisseDialog(tk.Toplevel):
    def __init__(self, master, event_id, caisse_id=None, on_save=None):
        super().__init__(master)
        self.title("Caisse" if caisse_id is None else "Ã‰diter caisse")
        self.event_id = event_id
        self.caisse_id = caisse_id
        self.on_save = on_save
        self.geometry("340x260")
        self.resizable(False, False)

        self.nom_var = tk.StringVar()
        self.solde_var = tk.StringVar()
        self.resp_var = tk.StringVar()

        tk.Label(self, text="Nom de la caisse :").pack(pady=8)
        tk.Entry(self, textvariable=self.nom_var, width=30).pack()
        tk.Label(self, text="Solde initial (â‚¬) :").pack(pady=8)
        tk.Entry(self, textvariable=self.solde_var, width=15).pack()
        tk.Label(self, text="Responsable :").pack(pady=8)
        tk.Entry(self, textvariable=self.resp_var, width=25).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=30, pady=18)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=30, pady=18)

        if self.caisse_id:
            self.load_caisse()

    def load_caisse(self):
        try:
            conn = get_connection()
            caisse = conn.execute(
                "SELECT nom, solde_initial, responsable FROM event_caisses WHERE id=? AND event_id=?",
                (self.caisse_id, self.event_id)
            ).fetchone()
            conn.close()
            if caisse:
                self.nom_var.set(caisse["nom"])
                self.solde_var.set(f"{caisse['solde_initial']:.2f}" if caisse["solde_initial"] is not None else "")
                self.resp_var.set(caisse["responsable"] or "")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement de la caisse."))

    def save(self):
        nom = self.nom_var.get().strip()
        solde = self.solde_var.get().replace(",", ".").strip()
        resp = self.resp_var.get().strip()
        if not nom:
            messagebox.showerror("Erreur", "Le nom de la caisse est obligatoire.")
            return
        try:
            solde_float = float(solde) if solde else 0.0
        except Exception:
            messagebox.showerror("Erreur", "Solde initial invalide.")
            return
        try:
            conn = get_connection()
            if self.caisse_id:
                conn.execute(
                    "UPDATE event_caisses SET nom=?, solde_initial=?, responsable=? WHERE id=? AND event_id=?",
                    (nom, solde_float, resp, self.caisse_id, self.event_id)
                )
            else:
                conn.execute(
                    "INSERT INTO event_caisses (event_id, nom, solde_initial, responsable) VALUES (?, ?, ?, ?)",
                    (self.event_id, nom, solde_float, resp)
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de la caisse."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/event_caisse_details.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("event_caisse_details")

class EventCaisseDetailsWindow(tk.Toplevel):
    def __init__(self, master, caisse_id):
        super().__init__(master)
        self.caisse_id = caisse_id
        self.title(f"DÃ©tails de la caisse {caisse_id}")
        self.geometry("800x450")
        self.create_widgets()
        self.refresh_details()

    def create_widgets(self):
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X)
        tk.Button(btn_frame, text="Nouvelle opÃ©ration", command=self.add_operation).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_operation).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)

        columns = ("id", "date", "type_op", "montant", "description", "justificatif")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        self.tree.heading("id", text="ID")
        self.tree.heading("date", text="Date")
        self.tree.heading("type_op", text="Type opÃ©ration")
        self.tree.heading("montant", text="Montant (â‚¬)")
        self.tree.heading("description", text="Description")
        self.tree.heading("justificatif", text="Justificatif")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

    def refresh_details(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            ops = conn.execute(
                "SELECT * FROM event_caisse_details WHERE caisse_id = ? ORDER BY date, id", (self.caisse_id,)
            ).fetchall()
            for op in ops:
                self.tree.insert(
                    "", "end",
                    values=(
                        op["id"],
                        op["date"],
                        op["type_op"],
                        f"{op['montant']:.2f}" if op["montant"] is not None else "",
                        op["description"] or "",
                        op["justificatif"] or ""
                    )
                )
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des opÃ©rations de caisse."))

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_operation(self):
        OperationDialog(self, caisse_id=self.caisse_id, on_save=self.refresh_details)

    def delete_operation(self):
        oid = self.get_selected_id()
        if not oid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une opÃ©ration Ã  supprimer.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer cette opÃ©ration ?"):
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM event_caisse_details WHERE id=? AND caisse_id=?", (oid, self.caisse_id))
            conn.commit()
            conn.close()
            logger.info(f"OpÃ©ration supprimÃ©e id {oid}, caisse_id {self.caisse_id}")
            self.refresh_details()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de l'opÃ©ration."))

class OperationDialog(tk.Toplevel):
    def __init__(self, master, caisse_id, operation_id=None, on_save=None):
        super().__init__(master)
        self.title("OpÃ©ration" if operation_id is None else "Ã‰diter opÃ©ration")
        self.caisse_id = caisse_id
        self.operation_id = operation_id
        self.on_save = on_save
        self.geometry("380x320")
        self.resizable(False, False)

        self.date_var = tk.StringVar()
        self.type_var = tk.StringVar()
        self.montant_var = tk.StringVar()
        self.desc_var = tk.StringVar()
        self.justif_var = tk.StringVar()

        tk.Label(self, text="Date (YYYY-MM-DD) :").pack(pady=6)
        tk.Entry(self, textvariable=self.date_var, width=20).pack()
        tk.Label(self, text="Type opÃ©ration :").pack(pady=6)
        type_ops = ["EntrÃ©e", "Sortie"]
        ttk.Combobox(self, textvariable=self.type_var, values=type_ops, state="readonly", width=15).pack()
        tk.Label(self, text="Montant (â‚¬) :").pack(pady=6)
        tk.Entry(self, textvariable=self.montant_var, width=14).pack()
        tk.Label(self, text="Description :").pack(pady=6)
        tk.Entry(self, textvariable=self.desc_var, width=30).pack()
        tk.Label(self, text="Justificatif :").pack(pady=6)
        tk.Entry(self, textvariable=self.justif_var, width=30).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=36, pady=16)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=36, pady=16)

        if self.operation_id:
            self.load_operation()

    def load_operation(self):
        try:
            conn = get_connection()
            op = conn.execute(
                "SELECT * FROM event_caisse_details WHERE id=? AND caisse_id=?",
                (self.operation_id, self.caisse_id)
            ).fetchone()
            conn.close()
            if op:
                self.date_var.set(op["date"])
                self.type_var.set(op["type_op"])
                self.montant_var.set(f"{op['montant']:.2f}" if op["montant"] is not None else "")
                self.desc_var.set(op["description"] or "")
                self.justif_var.set(op["justificatif"] or "")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement de l'opÃ©ration."))

    def save(self):
        date = self.date_var.get().strip()
        typ = self.type_var.get().strip()
        montant = self.montant_var.get().replace(",", ".").strip()
        desc = self.desc_var.get().strip()
        justif = self.justif_var.get().strip()
        if not date or not typ or not montant:
            messagebox.showerror("Erreur", "Date, type et montant sont obligatoires.")
            return
        try:
            montant_float = float(montant)
        except Exception:
            messagebox.showerror("Erreur", "Montant invalide.")
            return
        try:
            conn = get_connection()
            if self.operation_id:
                conn.execute(
                    "UPDATE event_caisse_details SET date=?, type_op=?, montant=?, description=?, justificatif=? WHERE id=? AND caisse_id=?",
                    (date, typ, montant_float, desc, justif, self.operation_id, self.caisse_id)
                )
            else:
                conn.execute(
                    "INSERT INTO event_caisse_details (caisse_id, date, type_op, montant, description, justificatif) VALUES (?, ?, ?, ?, ?, ?)",
                    (self.caisse_id, date, typ, montant_float, desc, justif)
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de l'opÃ©ration."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/event_depenses.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("event_depenses")

class EventDepensesWindow(tk.Toplevel):
    def __init__(self, master, event_id):
        super().__init__(master)
        self.title(f"DÃ©penses de l'Ã©vÃ©nement {event_id}")
        self.geometry("860x480")
        self.event_id = event_id
        self.create_widgets()
        self.refresh_depenses()

    def create_widgets(self):
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X)
        tk.Button(btn_frame, text="Nouvelle dÃ©pense", command=self.add_depense).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Ã‰diter", command=self.edit_depense).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_depense).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)

        columns = ("id", "date", "fournisseur", "categorie", "montant", "description", "justificatif")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        self.tree.heading("id", text="ID")
        self.tree.heading("date", text="Date")
        self.tree.heading("fournisseur", text="Fournisseur")
        self.tree.heading("categorie", text="CatÃ©gorie")
        self.tree.heading("montant", text="Montant (â‚¬)")
        self.tree.heading("description", text="Description")
        self.tree.heading("justificatif", text="Justificatif")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

    def refresh_depenses(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            depenses = conn.execute(
                "SELECT * FROM event_depenses WHERE event_id = ? ORDER BY date, id", (self.event_id,)
            ).fetchall()
            for dep in depenses:
                self.tree.insert(
                    "", "end",
                    values=(
                        dep["id"],
                        dep["date"],
                        dep["fournisseur"] or "",
                        dep["categorie"] or "",
                        f"{dep['montant']:.2f}" if dep["montant"] is not None else "",
                        dep["description"] or "",
                        dep["justificatif"] or ""
                    )
                )
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des dÃ©penses."))

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_depense(self):
        DepenseDialog(self, event_id=self.event_id, on_save=self.refresh_depenses)

    def edit_depense(self):
        did = self.get_selected_id()
        if not did:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une dÃ©pense Ã  Ã©diter.")
            return
        DepenseDialog(self, event_id=self.event_id, depense_id=did, on_save=self.refresh_depenses)

    def delete_depense(self):
        did = self.get_selected_id()
        if not did:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une dÃ©pense Ã  supprimer.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer cette dÃ©pense ?"):
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM event_depenses WHERE id=? AND event_id=?", (did, self.event_id))
            conn.commit()
            conn.close()
            logger.info(f"DÃ©pense supprimÃ©e id {did}, event_id {self.event_id}")
            self.refresh_depenses()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de la dÃ©pense."))

class DepenseDialog(tk.Toplevel):
    def __init__(self, master, event_id, depense_id=None, on_save=None):
        super().__init__(master)
        self.title("DÃ©pense" if depense_id is None else "Ã‰diter dÃ©pense")
        self.event_id = event_id
        self.depense_id = depense_id
        self.on_save = on_save
        self.geometry("410x370")
        self.resizable(False, False)

        self.date_var = tk.StringVar()
        self.fournisseur_var = tk.StringVar()
        self.categorie_var = tk.StringVar()
        self.montant_var = tk.StringVar()
        self.desc_var = tk.StringVar()
        self.justif_var = tk.StringVar()

        tk.Label(self, text="Date (YYYY-MM-DD) :").pack(pady=6)
        tk.Entry(self, textvariable=self.date_var, width=20).pack()
        tk.Label(self, text="Fournisseur :").pack(pady=6)
        tk.Entry(self, textvariable=self.fournisseur_var, width=32).pack()
        tk.Label(self, text="CatÃ©gorie :").pack(pady=6)
        tk.Entry(self, textvariable=self.categorie_var, width=28).pack()
        tk.Label(self, text="Montant (â‚¬) :").pack(pady=6)
        tk.Entry(self, textvariable=self.montant_var, width=14).pack()
        tk.Label(self, text="Description :").pack(pady=6)
        tk.Entry(self, textvariable=self.desc_var, width=36).pack()
        tk.Label(self, text="Justificatif :").pack(pady=6)
        tk.Entry(self, textvariable=self.justif_var, width=36).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=36, pady=16)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=36, pady=16)

        if self.depense_id:
            self.load_depense()

    def load_depense(self):
        try:
            conn = get_connection()
            dep = conn.execute(
                "SELECT * FROM event_depenses WHERE id=? AND event_id=?",
                (self.depense_id, self.event_id)
            ).fetchone()
            conn.close()
            if dep:
                self.date_var.set(dep["date"])
                self.fournisseur_var.set(dep["fournisseur"] or "")
                self.categorie_var.set(dep["categorie"] or "")
                self.montant_var.set(f"{dep['montant']:.2f}" if dep["montant"] is not None else "")
                self.desc_var.set(dep["description"] or "")
                self.justif_var.set(dep["justificatif"] or "")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement de la dÃ©pense."))

    def save(self):
        date = self.date_var.get().strip()
        fournisseur = self.fournisseur_var.get().strip()
        categorie = self.categorie_var.get().strip()
        montant = self.montant_var.get().replace(",", ".").strip()
        desc = self.desc_var.get().strip()
        justif = self.justif_var.get().strip()
        if not date or not montant:
            messagebox.showerror("Erreur", "Date et montant sont obligatoires.")
            return
        try:
            montant_float = float(montant)
        except Exception:
            messagebox.showerror("Erreur", "Montant invalide.")
            return
        try:
            conn = get_connection()
            if self.depense_id:
                conn.execute(
                    "UPDATE event_depenses SET date=?, fournisseur=?, categorie=?, montant=?, description=?, justificatif=? WHERE id=? AND event_id=?",
                    (date, fournisseur, categorie, montant_float, desc, justif, self.depense_id, self.event_id)
                )
            else:
                conn.execute(
                    "INSERT INTO event_depenses (event_id, date, fournisseur, categorie, montant, description, justificatif) VALUES (?, ?, ?, ?, ?, ?, ?)",
                    (self.event_id, date, fournisseur, categorie, montant_float, desc, justif)
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de la dÃ©pense."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/event_modules.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection
from modules.model_colonnes import GestionModelColonnes, ask_add_custom_column, get_choix_pour_colonne
from dialogs.add_row_dialog import AddRowDialog
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("event_modules")

class ChoiceDialog(tk.Toplevel):
    def __init__(self, master, label, choices):
        super().__init__(master)
        self.title("Choix")
        self.result = None
        self.var = tk.StringVar()
        tk.Label(self, text=label).pack(padx=10, pady=10)
        cb = ttk.Combobox(self, textvariable=self.var, values=choices, state="readonly")
        cb.pack(padx=10, pady=6)
        if choices:
            cb.current(0)
        btnf = tk.Frame(self)
        btnf.pack(pady=8)
        tk.Button(btnf, text="OK", command=self.on_ok).pack(side="left", padx=5)
        tk.Button(btnf, text="Annuler", command=self.on_cancel).pack(side="right", padx=5)
        self.bind("<Return>", lambda e: self.on_ok())
        self.bind("<Escape>", lambda e: self.on_cancel())
        self.grab_set()
        self.wait_window(self)

    def on_ok(self):
        self.result = self.var.get()
        self.destroy()

    def on_cancel(self):
        self.result = None
        self.destroy()

class EventModulesWindow(tk.Toplevel):
    def __init__(self, master, event_id):
        super().__init__(master)
        self.title("Modules/Tableaux personnalisÃ©s de l'Ã©vÃ©nement")
        self.geometry("800x500")
        self.event_id = event_id
        self.create_widgets()
        self.refresh_modules()

    def create_widgets(self):
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X)
        tk.Button(btn_frame, text="Nouveau module", command=self.add_module).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Ã‰diter", command=self.edit_module).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_module).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Ouvrir", command=self.open_module).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)

        self.tree = ttk.Treeview(self, columns=("id", "nom_module"), show="headings")
        self.tree.heading("id", text="ID")
        self.tree.heading("nom_module", text="Nom du module/tableau")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

    def refresh_modules(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            mods = conn.execute("SELECT * FROM event_modules WHERE event_id = ?", (self.event_id,)).fetchall()
            for mod in mods:
                self.tree.insert("", "end", values=(mod["id"], mod["nom_module"]))
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la rÃ©cupÃ©ration des modules personnalisÃ©s."))

    def get_selected_module_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_module(self):
        try:
            name = simpledialog.askstring("Module/Tableau", "Nom du module/tableau :")
            if not name:
                return
            conn = get_connection()
            conn.execute(
                "INSERT INTO event_modules (event_id, nom_module) VALUES (?, ?)",
                (self.event_id, name)
            )
            conn.commit()
            conn.close()
            self.refresh_modules()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'ajout du module."))

    def edit_module(self):
        mid = self.get_selected_module_id()
        if not mid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un module.")
            return
        name = simpledialog.askstring("Modifier nom", "Nouveau nom du module/tableau :")
        if not name:
            return
        try:
            conn = get_connection()
            conn.execute("UPDATE event_modules SET nom_module=? WHERE id=?", (name, mid))
            conn.commit()
            conn.close()
            self.refresh_modules()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la modification du module."))

    def delete_module(self):
        mid = self.get_selected_module_id()
        if not mid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un module.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer ce module/tableau ?"):
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM event_modules WHERE id=?", (mid,))
            conn.execute("DELETE FROM event_module_fields WHERE module_id=?", (mid,))
            conn.execute("DELETE FROM event_module_data WHERE module_id=?", (mid,))
            conn.commit()
            conn.close()
            self.refresh_modules()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression du module."))

    def open_module(self):
        mid = self.get_selected_module_id()
        if not mid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un module.")
            return
        ModuleTableWindow(self, module_id=mid)

class TypeChampDialog(simpledialog.Dialog):
    def body(self, master):
        tk.Label(master, text="Type du champ :", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="w", columnspan=2)
        self.type_var = tk.StringVar(value="TEXT")
        types = [("TEXT", "pour du texte (chaÃ®nes de caractÃ¨res)"),
                 ("INTEGER", "pour les nombres entiers"),
                 ("REAL", "pour les nombres dÃ©cimaux (ex: 3.14)")]
        for i, (val, desc) in enumerate(types):
            tk.Radiobutton(master, text=val, variable=self.type_var, value=val).grid(row=i+1, column=0, sticky="w")
            tk.Label(master, text=desc).grid(row=i+1, column=1, sticky="w")
        return None

    def apply(self):
        self.result = self.type_var.get()

class PrixUnitaireDialog(simpledialog.Dialog):
    def body(self, master):
        tk.Label(master, text="Associer un prix unitaire Ã  cette colonne ?", font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=2)
        tk.Label(master, text="Prix unitaire (â‚¬) (laisser vide pour aucun) :").grid(row=1, column=0, sticky="w")
        self.prix_var = tk.StringVar()
        tk.Entry(master, textvariable=self.prix_var, width=10).grid(row=1, column=1)
        return None

    def apply(self):
        try:
            self.result = float(self.prix_var.get().replace(",", "."))
        except Exception:
            self.result = None

class ModuleTableWindow(tk.Toplevel):
    def __init__(self, master, module_id):
        super().__init__(master)
        self.title("Gestion du tableau personnalisÃ©")
        self.geometry("1000x650")
        self.module_id = module_id
        self.editing_entry = None  # Pour l'Ã©dition de cellule
        self.id_col_total = self.get_id_col_total()  # id field de la colonne "Montant total" (ou None)
        self.create_widgets()
        self.refresh_fields()
        self.refresh_data()

    def create_widgets(self):
        btnf = tk.Frame(self)
        btnf.pack(fill=tk.X)
        tk.Button(btnf, text="Ajouter colonne", command=self.add_field).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Supprimer colonne", command=self.delete_field).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Ã‰diter colonne", command=self.edit_field).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="DÃ©finir colonne Montant total", command=self.set_total_column).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Ã‰diter prix", command=self.edit_column_price).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Ajouter ligne", command=self.add_row).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Supprimer ligne", command=self.delete_row).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Exporter PDF", command=self.export_pdf).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Exporter Excel", command=self.export_excel).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="ModÃ¨les de colonnes", command=self.open_model_colonnes).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Button(btnf, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=4)

        self.fields = []
        self.tree = ttk.Treeview(self, columns=[], show="headings", selectmode="browse")
        self.tree.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)
        self.tree.bind("<Double-1>", self.on_cell_double_click)

    def open_model_colonnes(self):
        GestionModelColonnes(self)

    def refresh_fields(self):
        try:
            conn = get_connection()
            self.fields = conn.execute(
                "SELECT * FROM event_module_fields WHERE module_id = ? ORDER BY id", (self.module_id,)
            ).fetchall()
            conn.close()
            # Update tree columns
            self.tree["columns"] = [f["id"] for f in self.fields]
            for f in self.fields:
                titre = f["nom_champ"]
                if self.id_col_total and int(f["id"]) == self.id_col_total:
                    titre += " (Montant total)"
                else:
                    val_prix = f["prix_unitaire"] if "prix_unitaire" in f.keys() else None
                    if val_prix not in (None, "", 0):
                        try:
                            titre += f" ({float(val_prix):.2f}â‚¬)"
                        except Exception:
                            titre += f" ({val_prix}â‚¬)"
                self.tree.heading(f["id"], text=titre)
                self.tree.column(f["id"], width=120)
            self.tree["show"] = "headings"
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la rÃ©cupÃ©ration des colonnes du module."))

    def refresh_data(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            rows = conn.execute(
                "SELECT row_index FROM event_module_data WHERE module_id = ? GROUP BY row_index ORDER BY row_index", (self.module_id,)
            ).fetchall()
            for row in rows:
                values = []
                for f in self.fields:
                    val = conn.execute(
                        "SELECT valeur FROM event_module_data WHERE module_id = ? AND row_index = ? AND field_id = ?",
                        (self.module_id, row["row_index"], f["id"])
                    ).fetchone()
                    values.append("" if not val else val["valeur"])
                self.tree.insert("", "end", iid=row["row_index"], values=values)
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du rafraÃ®chissement des donnÃ©es du module."))

    def get_id_col_total(self):
        conn = get_connection()
        id_col = conn.execute("SELECT id_col_total FROM event_modules WHERE id=?", (self.module_id,)).fetchone()
        conn.close()
        return id_col["id_col_total"] if id_col and id_col["id_col_total"] else None

    def add_field(self):
        try:
            res = ask_add_custom_column(self)
            if not res:
                return
            name = res["name"]
            typ = res["type"]
            modele_colonne = res.get("modele_colonne")
            dlg_prix = PrixUnitaireDialog(self)
            prix = dlg_prix.result
            conn = get_connection()
            conn.execute(
                "INSERT INTO event_module_fields (module_id, nom_champ, type_champ, prix_unitaire, modele_colonne) VALUES (?, ?, ?, ?, ?)",
                (self.module_id, name, typ, prix, modele_colonne)
            )
            conn.commit()
            conn.close()
            self.refresh_fields()
            self.refresh_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'ajout de colonne."))

    def delete_field(self):
        try:
            if not self.fields:
                messagebox.showwarning("Suppression", "Aucune colonne Ã  supprimer.")
                return
            ch = [f"{f['nom_champ']} (id {f['id']})" for f in self.fields]
            idx = simpledialog.askinteger("Index colonne Ã  supprimer", f"Index (1-{len(self.fields)}) :\n"+"\n".join(f"{i+1}. {ch[i]}" for i in range(len(ch))))
            if not idx or idx < 1 or idx > len(self.fields):
                return
            field_id = self.fields[idx-1]["id"]
            conn = get_connection()
            conn.execute("DELETE FROM event_module_data WHERE module_id=? AND field_id=?", (self.module_id, field_id))
            conn.execute("DELETE FROM event_module_fields WHERE id=?", (field_id,))
            if self.id_col_total and int(field_id) == self.id_col_total:
                conn.execute("UPDATE event_modules SET id_col_total=NULL WHERE id=?", (self.module_id,))
                self.id_col_total = None
            conn.commit()
            conn.close()
            self.refresh_fields()
            self.refresh_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de colonne."))

    def edit_field(self):
        try:
            if not self.fields:
                messagebox.showwarning("Ã‰diter colonne", "Aucune colonne Ã  Ã©diter.")
                return
            ch = [f"{f['nom_champ']} (id {f['id']})" for f in self.fields]
            idx = simpledialog.askinteger(
                "Ã‰diter colonne",
                f"Index de la colonne Ã  Ã©diter (1-{len(self.fields)}) :\n" +
                "\n".join(f"{i+1}. {ch[i]}" for i in range(len(ch)))
            )
            if not idx or idx < 1 or idx > len(self.fields):
                return
            field = self.fields[idx-1]
            from dialogs.edit_field_dialog import EditFieldDialog
            def refresh_all():
                self.refresh_fields()
                self.recompute_all_totals()
                self.refresh_data()
            EditFieldDialog(
                self,
                self.module_id,
                field_id=field["id"],
                on_save=refresh_all,
                with_modele_colonne=True
            )
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'Ã©dition de colonne."))

    def set_total_column(self):
        try:
            if not self.fields:
                messagebox.showwarning("Montant total", "Ajoute d'abord des colonnes.")
                return
            ch = [f"{f['nom_champ']} (id {f['id']})" for f in self.fields]
            idx = simpledialog.askinteger("Colonne total", f"Quelle colonne doit contenir le montant total ?\nIndex (1-{len(self.fields)}) :\n"+"\n".join(f"{i+1}. {ch[i]}" for i in range(len(ch))))
            if not idx or idx < 1 or idx > len(self.fields):
                return
            field_id = int(self.fields[idx-1]["id"])
            conn = get_connection()
            conn.execute("UPDATE event_modules SET id_col_total=? WHERE id=?", (field_id, self.module_id))
            conn.commit()
            conn.close()
            self.id_col_total = field_id
            self.recompute_all_totals()
            self.refresh_fields()
            self.refresh_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la dÃ©finition de la colonne total."))

    def add_row(self):
        try:
            if not self.fields:
                messagebox.showwarning("Champs", "Ajoute d'abord des colonnes.")
                return
            def get_choices(modele_colonne_nom):
                conn = get_connection()
                row = conn.execute("SELECT id FROM colonnes_modeles WHERE name=?", (modele_colonne_nom,)).fetchone()
                if not row:
                    return []
                modele_id = row["id"]
                choix = [v["valeur"] for v in conn.execute("SELECT valeur FROM valeurs_modeles_colonnes WHERE modele_id=?", (modele_id,)).fetchall()]
                conn.close()
                return choix
            dlg = AddRowDialog(self, self.fields, get_choices)
            if not dlg.result:
                return
            conn = get_connection()
            row_idx = conn.execute(
                "SELECT MAX(row_index) as mx FROM event_module_data WHERE module_id = ?", (self.module_id,)
            ).fetchone()
            next_row = 1 if not row_idx or not row_idx["mx"] else row_idx["mx"] + 1
            for f in self.fields:
                val = dlg.result.get(f["id"], "")
                conn.execute(
                    "INSERT INTO event_module_data (module_id, row_index, field_id, valeur) VALUES (?, ?, ?, ?)",
                    (self.module_id, next_row, f["id"], val)
                )
            conn.commit()
            if self.id_col_total:
                self.recompute_total_for_row(next_row)
            conn.close()
            self.refresh_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'ajout de ligne."))

    def delete_row(self):
        try:
            sel = self.tree.selection()
            if not sel:
                messagebox.showwarning("SÃ©lection", "SÃ©lectionne une ligne Ã  supprimer.")
                return
            row_idx = int(sel[0])
            conn = get_connection()
            conn.execute("DELETE FROM event_module_data WHERE module_id=? AND row_index=?", (self.module_id, row_idx))
            conn.commit()
            conn.close()
            self.refresh_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de ligne."))

    def on_cell_double_click(self, event):
        if self.editing_entry is not None:
            return
        region = self.tree.identify_region(event.x, event.y)
        if region != "cell":
            return
        col = self.tree.identify_column(event.x)
        rowid = self.tree.identify_row(event.y)
        if not rowid or not col:
            return
        col_idx = int(col.replace('#', '')) - 1
        if col_idx < 0 or col_idx >= len(self.fields):
            return
        selected_field = self.fields[col_idx]
        x, y, width, height = self.tree.bbox(rowid, col)
        value = self.tree.set(rowid, selected_field["id"])
        entry = tk.Entry(self.tree, width=16)
        entry.place(x=x, y=y, width=width, height=height)
        entry.insert(0, value)
        entry.focus()
        entry.select_range(0, tk.END)
        self.editing_entry = entry

        def on_validate(e=None):
            try:
                new_value = entry.get()
                conn = get_connection()
                res = conn.execute(
                    "SELECT id FROM event_module_data WHERE module_id=? AND row_index=? AND field_id=?",
                    (self.module_id, int(rowid), selected_field["id"])
                ).fetchone()
                if res:
                    conn.execute(
                        "UPDATE event_module_data SET valeur=? WHERE id=?",
                        (new_value, res["id"])
                    )
                else:
                    conn.execute(
                        "INSERT INTO event_module_data (module_id, row_index, field_id, valeur) VALUES (?, ?, ?, ?)",
                        (self.module_id, int(rowid), selected_field["id"], new_value)
                    )
                conn.commit()
                conn.close()
                entry.destroy()
                self.editing_entry = None
                if self.id_col_total:
                    self.recompute_total_for_row(int(rowid))
                self.refresh_data()
            except Exception as e:
                entry.destroy()
                self.editing_entry = None
                messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la modification de cellule."))

        def on_cancel(e=None):
            entry.destroy()
            self.editing_entry = None

        entry.bind("<Return>", on_validate)
        entry.bind("<FocusOut>", on_cancel)

    def edit_column_price(self):
        try:
            if not self.fields:
                messagebox.showwarning("Prix unitaire", "Aucune colonne Ã  Ã©diter.")
                return
            ch = [f"{f['nom_champ']} (id {f['id']})" for f in self.fields]
            idx = simpledialog.askinteger(
                "Ã‰diter prix",
                f"Index de la colonne (1-{len(self.fields)}) :\n" +
                "\n".join(f"{i+1}. {ch[i]}" for i in range(len(ch)))
            )
            if not idx or idx < 1 or idx > len(self.fields):
                return
            field_id = self.fields[idx-1]["id"]
            old_price = self.fields[idx-1]["prix_unitaire"]
            new_price = simpledialog.askstring(
                "Prix unitaire",
                f"Nouveau prix unitaire (â‚¬) pour {self.fields[idx-1]['nom_champ']} (laisse vide pour aucun) :",
                initialvalue=old_price if old_price not in (None, "") else ""
            )
            if new_price is None:
                return  # AnnulÃ©
            conn = get_connection()
            conn.execute("UPDATE event_module_fields SET prix_unitaire=? WHERE id=?", (new_price if new_price else None, field_id))
            conn.commit()
            conn.close()
            self.refresh_fields()
            self.recompute_all_totals()
            self.refresh_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la modification du prix de colonne."))

    def recompute_total_for_row(self, rowid):
        try:
            if not self.id_col_total:
                return
            conn = get_connection()
            total = 0.0
            for f in self.fields:
                val_prix = f["prix_unitaire"] if "prix_unitaire" in f.keys() else None
                if val_prix not in (None, "", 0):
                    try:
                        prix = float(val_prix)
                    except Exception:
                        prix = 0
                    val_row = conn.execute(
                        "SELECT valeur FROM event_module_data WHERE module_id=? AND row_index=? AND field_id=?",
                        (self.module_id, rowid, f["id"])
                    ).fetchone()
                    try:
                        qte = float(val_row["valeur"]) if val_row and val_row["valeur"] not in (None, "") else 0
                    except Exception:
                        qte = 0
                    total += qte * prix
            res_total = conn.execute(
                "SELECT id FROM event_module_data WHERE module_id=? AND row_index=? AND field_id=?",
                (self.module_id, rowid, self.id_col_total)
            ).fetchone()
            if res_total:
                conn.execute(
                    "UPDATE event_module_data SET valeur=? WHERE id=?",
                    (f"{total:.2f}", res_total["id"])
                )
            else:
                conn.execute(
                    "INSERT INTO event_module_data (module_id, row_index, field_id, valeur) VALUES (?, ?, ?, ?)",
                    (self.module_id, rowid, self.id_col_total, f"{total:.2f}")
                )
            conn.commit()
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du calcul du total ligne."))

    def recompute_all_totals(self):
        try:
            if not self.id_col_total:
                return
            conn = get_connection()
            rows = conn.execute(
                "SELECT row_index FROM event_module_data WHERE module_id = ? GROUP BY row_index ORDER BY row_index", (self.module_id,)
            ).fetchall()
            conn.close()
            for row in rows:
                self.recompute_total_for_row(row["row_index"])
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du recalcul des totaux."))

    def export_pdf(self):
        try:
            import sys, os
            parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
            if parent_dir not in sys.path:
                sys.path.append(parent_dir)
            from exports.exports import export_dataframe_to_pdf
        except ImportError as e:
            messagebox.showerror("Export PDF", "Le module d'export PDF n'est pas disponible.")
            return

        try:
            conn = get_connection()
            fields = conn.execute(
                "SELECT * FROM event_module_fields WHERE module_id = ? ORDER BY id", (self.module_id,)
            ).fetchall()
            rows = conn.execute(
                "SELECT row_index FROM event_module_data WHERE module_id = ? GROUP BY row_index ORDER BY row_index", (self.module_id,)
            ).fetchall()
            headers = [f["nom_champ"] for f in fields]
            data = []
            for row in rows:
                values = []
                for f in fields:
                    val = conn.execute(
                        "SELECT valeur FROM event_module_data WHERE module_id=? AND row_index=? AND field_id=?",
                        (self.module_id, row["row_index"], f["id"])
                    ).fetchone()
                    values.append("" if not val else val["valeur"])
                data.append(values)
            import pandas as pd
            df = pd.DataFrame(data, columns=headers)
            conn.close()
            export_dataframe_to_pdf(df, title="Export PDF - Module personnalisÃ©")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'export PDF du module personnalisÃ©."))

    def export_excel(self):
        try:
            import sys, os
            parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
            if parent_dir not in sys.path:
                sys.path.append(parent_dir)
            from exports.exports import export_dataframe_to_excel
        except ImportError as e:
            from tkinter import messagebox
            messagebox.showerror("Export Excel", "Le module d'export Excel n'est pas disponible.")
            return

        try:
            conn = get_connection()
            fields = conn.execute(
                "SELECT * FROM event_module_fields WHERE module_id = ? ORDER BY id", (self.module_id,)
            ).fetchall()
            rows = conn.execute(
                "SELECT row_index FROM event_module_data WHERE module_id = ? GROUP BY row_index ORDER BY row_index", (self.module_id,)
            ).fetchall()
            headers = [f["nom_champ"] for f in fields]
            data = []
            for row in rows:
                values = []
                for f in fields:
                    val = conn.execute(
                        "SELECT valeur FROM event_module_data WHERE module_id=? AND row_index=? AND field_id=?",
                        (self.module_id, row["row_index"], f["id"])
                    ).fetchone()
                    values.append("" if not val else val["valeur"])
                data.append(values)
            import pandas as pd
            df = pd.DataFrame(data, columns=headers)
            conn.close()
            export_dataframe_to_excel(df, title="Export Excel - Module personnalisÃ©")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'export Excel du module personnalisÃ©."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/event_module_data.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
import pandas as pd
from db.db import get_connection, DataSource, get_df_or_sql
from utils.error_handler import handle_exception
from utils.app_logger import get_logger

logger = get_logger("event_module_data")

def ask_choice_value(parent, champ, choix):
    class ChoiceDialog(simpledialog.Dialog):
        def body(self, master):
            tk.Label(master, text=f"Valeur pour {champ} :").pack()
            self.var = tk.StringVar()
            self.combo = ttk.Combobox(master, textvariable=self.var, values=choix, state="readonly")
            self.combo.pack()
            if choix:
                self.combo.current(0)
            return self.combo
        def apply(self):
            self.result = self.var.get()
    d = ChoiceDialog(parent)
    return d.result

class EventModuleDataWindow(tk.Toplevel):
    def __init__(self, master, module_id):
        super().__init__(master)
        self.title("DonnÃ©es du module personnalisÃ©")
        self.module_id = module_id
        try:
            self.fields = self.load_fields()
            self.create_widgets()
            self.load_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'initialisation de la fenÃªtre de donnÃ©es du module."))

    def load_fields(self):
        try:
            conn = get_connection()
            df = pd.read_sql_query(
                "SELECT id, nom_champ, modele_colonne FROM event_module_fields WHERE module_id=?",
                conn, params=(self.module_id,)
            )
            conn.close()
            return df.to_records(index=False)
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement des colonnes du module."))
            return []

    def create_widgets(self):
        cols = ["row_index"] + [f[1] for f in self.fields]
        self.tree = ttk.Treeview(self, columns=cols, show="headings", selectmode="browse")
        for col in cols:
            self.tree.heading(col, text=col.capitalize())
            self.tree.column(col, width=110)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X, pady=6)
        tk.Button(btn_frame, text="Ajouter", command=self.add_row).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Modifier", command=self.edit_row).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_row).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=6)

    def load_data(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            df = pd.read_sql_query("SELECT * FROM event_module_data WHERE module_id=? ORDER BY row_index", conn, params=(self.module_id,))
            conn.close()
            grouped = {}
            for _, row in df.iterrows():
                idx = row["row_index"]
                if idx not in grouped:
                    grouped[idx] = {}
                grouped[idx][row["field_id"]] = row["valeur"]
            for idx in sorted(grouped):
                vals = [idx] + [grouped[idx].get(f[0], "") for f in self.fields]
                self.tree.insert("", "end", values=vals)
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des donnÃ©es du module."))

    def get_selected_row_index(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne.")
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_row(self):
        try:
            # DÃ©termine le prochain row_index
            conn = get_connection()
            res = conn.execute("SELECT MAX(row_index) FROM event_module_data WHERE module_id=?", (self.module_id,)).fetchone()
            next_idx = (res[0] or 0) + 1
            conn.close()

            row_values = []
            for field in self.fields:
                field_id, nom_champ, modele_colonne = field
                if modele_colonne:
                    # RÃ©cupÃ¨re les valeurs du modÃ¨le
                    conn = get_connection()
                    res = conn.execute(
                        "SELECT valeur FROM valeurs_modeles_colonnes WHERE modele_id=(SELECT id FROM colonnes_modeles WHERE name=?)",
                        (modele_colonne,)
                    ).fetchall()
                    conn.close()
                    choix = [r["valeur"] for r in res]
                    valeur = ask_choice_value(self, nom_champ, choix)
                else:
                    valeur = simpledialog.askstring("Saisie", f"Valeur pour {nom_champ} :", parent=self)
                if valeur is None:
                    return  # AnnulÃ©
                row_values.append((field_id, valeur))

            # Enregistre chaque valeur dans event_module_data
            conn = get_connection()
            for field_id, valeur in row_values:
                conn.execute(
                    "INSERT INTO event_module_data (module_id, row_index, field_id, valeur) VALUES (?, ?, ?, ?)",
                    (self.module_id, next_idx, field_id, valeur)
                )
            conn.commit()
            conn.close()
            self.load_data()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'ajout d'une ligne."))

    def edit_row(self):
        messagebox.showinfo("Non implÃ©mentÃ©", "L'Ã©dition des lignes n'est pas encore implÃ©mentÃ©e !")

    def delete_row(self):
        rowidx = self.get_selected_row_index()
        if rowidx is not None and messagebox.askyesno("Suppression", f"Supprimer la ligne {rowidx}â€¯?"):
            try:
                conn = get_connection()
                conn.execute("DELETE FROM event_module_data WHERE module_id=? AND row_index=?", (self.module_id, rowidx))
                conn.commit()
                conn.close()
                self.load_data()
            except Exception as e:
                messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de la ligne."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/event_module_fields.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection, DataSource, get_df_or_sql
from dialogs.edit_field_dialog import EditFieldDialog
from utils.error_handler import handle_exception
from utils.app_logger import get_logger

logger = get_logger("event_module_fields")

class EventModuleFieldsWindow(tk.Toplevel):
    def __init__(self, master, module_id):
        super().__init__(master)
        self.title("Champs du module personnalisÃ©")
        self.module_id = module_id
        self.create_widgets()
        self.refresh_fields()

    def create_widgets(self):
        columns = ("id", "nom_champ", "type_champ", "prix_unitaire", "modele_colonne")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        self.tree.heading("id", text="ID")
        self.tree.column("id", width=60)
        self.tree.heading("nom_champ", text="Nom")
        self.tree.column("nom_champ", width=180)
        self.tree.heading("type_champ", text="Type")
        self.tree.column("type_champ", width=80)
        self.tree.heading("prix_unitaire", text="Prix unitaire (â‚¬)")
        self.tree.column("prix_unitaire", width=120)
        self.tree.heading("modele_colonne", text="ModÃ¨le colonne")
        self.tree.column("modele_colonne", width=140)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X, pady=6)
        tk.Button(btn_frame, text="Ajouter", command=self.add_field).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Modifier", command=self.edit_field).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_field).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Ã‰diter prix", command=self.edit_field_price).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=6)

    def refresh_fields(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            if getattr(DataSource, "is_visualisation", False):
                df = get_df_or_sql("event_module_fields")
                dict_items = df[df["module_id"] == self.module_id].to_dict("records")
            else:
                conn = get_connection()
                dict_items = conn.execute(
                    "SELECT id, nom_champ, type_champ, prix_unitaire, modele_colonne FROM event_module_fields WHERE module_id=? ORDER BY id", (self.module_id,)
                ).fetchall()
                conn.close()
            for item in dict_items:
                prix = item["prix_unitaire"] if isinstance(item, dict) else item[3]
                prix_aff = f"{float(prix):.2f}" if prix not in (None, "", 0) else ""
                modele = item["modele_colonne"] if isinstance(item, dict) else item[4]
                vals = [
                    item["id"] if isinstance(item, dict) else item[0],
                    item["nom_champ"] if isinstance(item, dict) else item[1],
                    item["type_champ"] if isinstance(item, dict) else item[2],
                    prix_aff,
                    modele or ""
                ]
                self.tree.insert("", "end", values=vals)
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des champs du module."))

    def get_selected_field_id(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un champ.")
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_field(self):
        try:
            EditFieldDialog(self, self.module_id, None, on_save=self.refresh_fields, with_modele_colonne=True)
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'ajout d'un champ."))

    def edit_field(self):
        fid = self.get_selected_field_id()
        if fid is not None:
            try:
                EditFieldDialog(self, self.module_id, fid, on_save=self.refresh_fields, with_modele_colonne=True)
            except Exception as e:
                messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la modification du champ."))

    def delete_field(self):
        fid = self.get_selected_field_id()
        if fid is not None and messagebox.askyesno("Suppression", "Supprimer ce champâ€¯?"):
            try:
                conn = get_connection()
                conn.execute("DELETE FROM event_module_fields WHERE id=?", (fid,))
                conn.commit()
                conn.close()
                self.refresh_fields()
            except Exception as e:
                messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression du champ."))

    def edit_field_price(self):
        fid = self.get_selected_field_id()
        if fid is None:
            return
        try:
            conn = get_connection()
            champ = conn.execute("SELECT nom_champ, prix_unitaire FROM event_module_fields WHERE id=?", (fid,)).fetchone()
            conn.close()
            if champ is None:
                return
            old_price = champ["prix_unitaire"]
            new_price = simpledialog.askstring(
                "Prix unitaire",
                f"Nouveau prix unitaire (â‚¬) pour Â«Â {champ['nom_champ']}Â Â» (laisser vide pour aucun) :",
                initialvalue=str(old_price) if old_price not in (None, "") else ""
            )
            if new_price is None:
                return  # AnnulÃ©
            conn = get_connection()
            conn.execute("UPDATE event_module_fields SET prix_unitaire=? WHERE id=?", (new_price if new_price else None, fid))
            conn.commit()
            conn.close()
            self.refresh_fields()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la modification du prix du champ."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/event_payments.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("event_payments")

class PaymentsWindow(tk.Toplevel):
    def __init__(self, master, event_id):
        super().__init__(master)
        self.title("Paiements de l'Ã©vÃ©nement")
        self.geometry("900x500")
        self.event_id = event_id
        self.create_widgets()
        self.refresh_payments()

    def create_widgets(self):
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X)
        tk.Button(btn_frame, text="Ajouter paiement", command=self.add_payment).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Ã‰diter", command=self.edit_payment).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_payment).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)

        cols = ("id", "nom_payeuse", "classe", "mode_paiement", "banque", "numero_cheque", "montant", "commentaire")
        labels = ("ID", "Name", "Classe", "Mode", "Banque", "NÂ° ChÃ¨que", "Montant", "Commentaire")
        self.tree = ttk.Treeview(self, columns=cols, show="headings")
        for c, l in zip(cols, labels):
            self.tree.heading(c, text=l)
            self.tree.column(c, width=120 if c=="montant" else 110)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=7, pady=7)

    def refresh_payments(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            pays = conn.execute(
                "SELECT * FROM event_payments WHERE event_id = ? ORDER BY id DESC", (self.event_id,)
            ).fetchall()
            for p in pays:
                self.tree.insert("", "end", values=(
                    p["id"], p["nom_payeuse"], p["classe"], p["mode_paiement"], p["banque"], p["numero_cheque"], p["montant"], p["commentaire"]
                ))
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des paiements."))

    def get_selected_payment_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_payment(self):
        PaymentDialog(self, event_id=self.event_id, on_save=self.refresh_payments)

    def edit_payment(self):
        pid = self.get_selected_payment_id()
        if not pid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un paiement.")
            return
        PaymentDialog(self, event_id=self.event_id, payment_id=pid, on_save=self.refresh_payments)

    def delete_payment(self):
        pid = self.get_selected_payment_id()
        if not pid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un paiement.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer ce paiement ?"):
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM event_payments WHERE id=?", (pid,))
            conn.commit()
            conn.close()
            self.refresh_payments()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression du paiement."))

class PaymentDialog(tk.Toplevel):
    def __init__(self, master, event_id, payment_id=None, on_save=None):
        super().__init__(master)
        self.title("Paiement")
        self.event_id = event_id
        self.payment_id = payment_id
        self.on_save = on_save
        self.geometry("500x420")
        self.resizable(False, False)

        self.nom_var = tk.StringVar()
        self.classe_var = tk.StringVar()
        self.mode_var = tk.StringVar()
        self.banque_var = tk.StringVar()
        self.numero_var = tk.StringVar()
        self.montant_var = tk.DoubleVar()
        self.comment_var = tk.StringVar()

        tk.Label(self, text="Name payeur.se :").pack(pady=5)
        tk.Entry(self, textvariable=self.nom_var, width=40).pack()
        tk.Label(self, text="Classe :").pack(pady=5)
        tk.Entry(self, textvariable=self.classe_var, width=20).pack()
        tk.Label(self, text="Mode paiement (C/E/autre) :").pack(pady=5)
        tk.Entry(self, textvariable=self.mode_var, width=8).pack()
        tk.Label(self, text="Banque :").pack(pady=5)
        tk.Entry(self, textvariable=self.banque_var, width=20).pack()
        tk.Label(self, text="NÂ° chÃ¨que :").pack(pady=5)
        tk.Entry(self, textvariable=self.numero_var, width=20).pack()
        tk.Label(self, text="Montant :").pack(pady=5)
        tk.Entry(self, textvariable=self.montant_var, width=10).pack()
        tk.Label(self, text="Commentaire :").pack(pady=5)
        tk.Entry(self, textvariable=self.comment_var, width=35).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=36, pady=16)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=36, pady=16)

        if self.payment_id:
            self.load_payment()

    def load_payment(self):
        try:
            conn = get_connection()
            p = conn.execute("SELECT * FROM event_payments WHERE id=?", (self.payment_id,)).fetchone()
            conn.close()
            if p:
                self.nom_var.set(p["nom_payeuse"])
                self.classe_var.set(p["classe"])
                self.mode_var.set(p["mode_paiement"])
                self.banque_var.set(p["banque"])
                self.numero_var.set(p["numero_cheque"])
                self.montant_var.set(p["montant"])
                self.comment_var.set(p["commentaire"])
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement du paiement."))

    def save(self):
        d = dict(
            name=self.nom_var.get().strip(),
            classe=self.classe_var.get().strip(),
            mode=self.mode_var.get().strip(),
            banque=self.banque_var.get().strip(),
            numero=self.numero_var.get().strip(),
            montant=self.montant_var.get(),
            comment=self.comment_var.get().strip()
        )
        if not d["name"]:
            messagebox.showerror("Erreur", "Name obligatoire.")
            return
        if not d["mode"]:
            messagebox.showerror("Erreur", "Mode de paiement obligatoire.")
            return
        try:
            conn = get_connection()
            if self.payment_id:
                conn.execute(
                    "UPDATE event_payments SET nom_payeuse=?, classe=?, mode_paiement=?, banque=?, numero_cheque=?, montant=?, commentaire=? WHERE id=?",
                    (d["name"], d["classe"], d["mode"], d["banque"], d["numero"], d["montant"], d["comment"], self.payment_id)
                )
            else:
                conn.execute(
                    "INSERT INTO event_payments (event_id, nom_payeuse, classe, mode_paiement, banque, numero_cheque, montant, commentaire) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                    (self.event_id, d["name"], d["classe"], d["mode"], d["banque"], d["numero"], d["montant"], d["comment"])
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement du paiement."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/event_recettes.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

logger = get_logger("event_recettes")

def update_vente_sur_place_recette(event_id):
    """Calcule le gain de toutes les caisses et l'ajoute/actualise la recette 'Vente sur place'."""
    try:
        conn = get_connection()
        gain_total = 0
        caisses = conn.execute("SELECT id FROM event_caisses WHERE event_id=?", (event_id,)).fetchall()
        for caisse in caisses:
            cid = caisse["id"]
            r = conn.execute(
                "SELECT SUM(CASE WHEN type='cheque' THEN valeur ELSE valeur*quantite END) AS tot FROM event_caisse_details WHERE caisse_id=? AND moment='debut'", (cid,)
            ).fetchone()
            fond_debut = r["tot"] if r["tot"] else 0
            r = conn.execute(
                "SELECT SUM(CASE WHEN type='cheque' THEN valeur ELSE valeur*quantite END) AS tot FROM event_caisse_details WHERE caisse_id=? AND moment='fin'", (cid,)
            ).fetchone()
            fond_fin = r["tot"] if r["tot"] else 0
            gain_total += (fond_fin - fond_debut)
        exist = conn.execute("SELECT id FROM event_recettes WHERE event_id=? AND source='Vente sur place'", (event_id,)).fetchone()
        if exist:
            conn.execute("UPDATE event_recettes SET montant=? WHERE id=?", (gain_total, exist["id"]))
        else:
            conn.execute("INSERT INTO event_recettes (event_id, source, montant) VALUES (?, 'Vente sur place', ?)", (event_id, gain_total))
        conn.commit()
        conn.close()
    except Exception as e:
        logger.error(f"Erreur update_vente_sur_place_recette: {e}")

class EventRecettesWindow(tk.Toplevel):
    def __init__(self, master, event_id):
        super().__init__(master)
        self.title("Recettes de l'Ã©vÃ©nement")
        self.geometry("850x400")
        self.event_id = event_id

        try:
            update_vente_sur_place_recette(self.event_id)
        except Exception as e:
            logger.error(f"Erreur lors de l'update automatique 'Vente sur place': {e}")

        self.create_widgets()
        self.refresh_recettes()

    def create_widgets(self):
        btn_frame = tk.Frame(self)
        btn_frame.pack(fill=tk.X)
        tk.Button(btn_frame, text="Ajouter recette", command=self.add_recette).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Ã‰diter", command=self.edit_recette).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_recette).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(btn_frame, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=5, pady=5)
        self.tree = ttk.Treeview(self, columns=("id", "source", "module", "montant", "commentaire"), show="headings")
        for col, lbl in zip(("id", "source", "module", "montant", "commentaire"),
                            ("ID", "Source", "Module liÃ©", "Montant (â‚¬)", "Commentaire")):
            self.tree.heading(col, text=lbl)
            self.tree.column(col, width=120 if col in ("montant", "module") else 170)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

    def refresh_recettes(self):
        try:
            self.tree.delete(*self.tree.get_children())
            conn = get_connection()
            recettes = conn.execute("SELECT * FROM event_recettes WHERE event_id=? ORDER BY source", (self.event_id,)).fetchall()
            for r in recettes:
                module_name = ""
                if r["module_id"]:
                    mod = conn.execute("SELECT nom_module FROM event_modules WHERE id=?", (r["module_id"],)).fetchone()
                    if mod:
                        module_name = mod["nom_module"]
                self.tree.insert("", "end", values=(r["id"], r["source"], module_name, f"{r['montant']:.2f}", r["commentaire"] if r["commentaire"] else ""))
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des recettes."))

    def get_selected_recette_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_recette(self):
        RecetteDialog(self, event_id=self.event_id, on_save=self.refresh_recettes)

    def edit_recette(self):
        rid = self.get_selected_recette_id()
        if not rid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une recette.")
            return
        RecetteDialog(self, event_id=self.event_id, recette_id=rid, on_save=self.refresh_recettes)

    def delete_recette(self):
        rid = self.get_selected_recette_id()
        if not rid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne une recette.")
            return
        try:
            conn = get_connection()
            r = conn.execute("SELECT source FROM event_recettes WHERE id=?", (rid,)).fetchone()
            if r and r["source"] == "Vente sur place":
                messagebox.showerror("Erreur", "Impossible de supprimer la recette automatique 'Vente sur place'.")
                conn.close()
                return
            conn.execute("DELETE FROM event_recettes WHERE id=?", (rid,))
            conn.commit()
            conn.close()
            self.refresh_recettes()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression de la recette."))

class RecetteDialog(tk.Toplevel):
    def __init__(self, master, event_id, recette_id=None, on_save=None):
        super().__init__(master)
        self.title("Recette" if not recette_id else "Ã‰diter la recette")
        self.event_id = event_id
        self.recette_id = recette_id
        self.on_save = on_save
        self.geometry("460x350")
        self.resizable(False, False)
        self.source_var = tk.StringVar()
        self.montant_var = tk.DoubleVar()
        self.comment_var = tk.StringVar()
        self.module_var = tk.StringVar()
        self.colonne_var = tk.StringVar()
        self.module_choices = []
        self.colonnes_choices = []

        tk.Label(self, text="Source :").pack(pady=4)
        tk.Entry(self, textvariable=self.source_var, width=35).pack()

        tk.Label(self, text="Module liÃ© :").pack(pady=4)
        self.module_menu = ttk.Combobox(self, textvariable=self.module_var, state="readonly")
        self.module_menu.pack()
        self.module_menu.bind("<<ComboboxSelected>>", self.on_module_selected)

        self.colonne_frame = tk.Frame(self)
        self.colonne_label = tk.Label(self.colonne_frame, text="Colonne Ã  sommer :")
        self.colonne_menu = ttk.Combobox(self.colonne_frame, textvariable=self.colonne_var, state="readonly")
        self.colonne_label.pack(side=tk.LEFT)
        self.colonne_menu.pack(side=tk.LEFT)
        self.colonne_frame.pack(pady=4)
        self.colonne_frame.pack_forget()  # cachÃ©e par dÃ©faut
        self.colonne_menu.bind("<<ComboboxSelected>>", self.update_montant_from_colonne)

        tk.Label(self, text="Montant (â‚¬) :").pack(pady=4)
        self.montant_entry = tk.Entry(self, textvariable=self.montant_var, width=20)
        self.montant_entry.pack()

        tk.Label(self, text="Commentaire :").pack(pady=4)
        tk.Entry(self, textvariable=self.comment_var, width=45).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=30, pady=14)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=30, pady=14)

        self.populate_module_menu()
        if self.recette_id:
            self.load_recette()

    def populate_module_menu(self):
        try:
            conn = get_connection()
            mods = conn.execute("SELECT id, nom_module FROM event_modules WHERE event_id=?", (self.event_id,)).fetchall()
            self.module_choices = [("", "Aucun")] + [(str(m["id"]), m["nom_module"]) for m in mods]
            self.module_menu['values'] = [name for _, name in self.module_choices]
            self.module_menu.current(0)
            conn.close()
            self.hide_colonne_menu()
        except Exception as e:
            logger.error(f"Erreur populate_module_menu: {e}")

    def populate_colonne_menu(self, module_id):
        try:
            conn = get_connection()
            fields = conn.execute("SELECT id, nom_champ FROM event_module_fields WHERE module_id=?", (module_id,)).fetchall()
            conn.close()
            self.colonnes_choices = [(str(f["id"]), f["nom_champ"]) for f in fields]
            if not self.colonnes_choices:
                self.hide_colonne_menu()
                return
            self.colonne_menu['values'] = [name for _, name in self.colonnes_choices]
            self.colonne_menu.current(0)
            self.show_colonne_menu()
            self.update_montant_from_colonne()
        except Exception as e:
            logger.error(f"Erreur populate_colonne_menu: {e}")

    def hide_colonne_menu(self):
        self.colonne_frame.pack_forget()

    def show_colonne_menu(self):
        self.colonne_frame.pack(pady=4)

    def on_module_selected(self, event=None):
        idx = self.module_menu.current()
        if idx > 0:
            module_id = int(self.module_choices[idx][0])
            self.populate_colonne_menu(module_id)
            self.montant_entry.config(state="readonly")
        else:
            self.hide_colonne_menu()
            self.montant_entry.config(state="normal")

    def update_montant_from_colonne(self, event=None):
        module_idx = self.module_menu.current()
        colonne_idx = self.colonne_menu.current()
        if module_idx > 0 and colonne_idx >= 0 and self.colonnes_choices:
            module_id = int(self.module_choices[module_idx][0])
            field_id = int(self.colonnes_choices[colonne_idx][0])
            try:
                conn = get_connection()
                rows = conn.execute(
                    "SELECT valeur FROM event_module_data WHERE module_id=? AND field_id=?", (module_id, field_id)
                ).fetchall()
                somme = 0.0
                for r in rows:
                    try:
                        somme += float(r["valeur"])
                    except (TypeError, ValueError):
                        pass
                conn.close()
                self.montant_var.set(round(somme, 2))
            except Exception as e:
                logger.error(f"Erreur update_montant_from_colonne: {e}")

    def load_recette(self):
        try:
            conn = get_connection()
            r = conn.execute("SELECT * FROM event_recettes WHERE id=?", (self.recette_id,)).fetchone()
            conn.close()
            if r:
                self.source_var.set(r["source"])
                self.montant_var.set(r["montant"])
                self.comment_var.set(r["commentaire"] or "")
                if r["module_id"]:
                    for i, (mid, name) in enumerate(self.module_choices):
                        if mid and int(mid) == r["module_id"]:
                            self.module_menu.current(i)
                            self.populate_colonne_menu(int(mid))
                            break
        except Exception as e:
            logger.error(f"Erreur load_recette: {e}")

    def save(self):
        source = self.source_var.get().strip()
        montant = self.montant_var.get()
        comment = self.comment_var.get().strip()
        module_idx = self.module_menu.current()
        module_id = None
        if module_idx > 0:
            module_id = int(self.module_choices[module_idx][0])
        else:
            self.hide_colonne_menu()
        if not source:
            messagebox.showerror("Erreur", "Source obligatoire.")
            return
        if source.lower() == "vente sur place":
            messagebox.showerror("Erreur", "La recette 'Vente sur place' est gÃ©rÃ©e automatiquement.")
            return
        try:
            conn = get_connection()
            if self.recette_id:
                conn.execute(
                    "UPDATE event_recettes SET source=?, montant=?, commentaire=?, module_id=? WHERE id=?",
                    (source, montant, comment, module_id, self.recette_id)
                )
            else:
                conn.execute(
                    "INSERT INTO event_recettes (event_id, source, montant, commentaire, module_id) VALUES (?, ?, ?, ?, ?)",
                    (self.event_id, source, montant, comment, module_id)
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement de la recette."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/exports.py ===

```python
import pandas as pd
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from db.db import get_connection

# ========== EXPORTS BILAN EVENEMENT ==========

def export_bilan_evenement(event_id, format="xlsx", filename=None):
    conn = get_connection()
    # RÃ©cup info Ã©vÃ©nement
    event = conn.execute("SELECT * FROM events WHERE id=?", (event_id,)).fetchone()
    if not event:
        messagebox.showerror("Erreur", "Ã‰vÃ©nement introuvable.")
        return

    # DonnÃ©es recettes
    recettes = pd.read_sql_query(
        "SELECT source, montant, commentaire, module_id FROM event_recettes WHERE event_id=?",
        conn, params=(event_id,)
    )
    # DonnÃ©es dÃ©penses
    depenses = pd.read_sql_query(
        "SELECT categorie, montant, fournisseur, date_depense, paye_par, membre_id, commentaire FROM event_depenses WHERE event_id=?",
        conn, params=(event_id,)
    )
    # DonnÃ©es caisses
    caisses = pd.read_sql_query(
        "SELECT id, nom_caisse, commentaire FROM event_caisses WHERE event_id=?",
        conn, params=(event_id,)
    )
    # DÃ©tail fond de caisse
    caisses_details = []
    for _, caisse in caisses.iterrows():
        cid = caisse["id"]
        debut = conn.execute(
            "SELECT SUM(CASE WHEN type='cheque' THEN valeur ELSE valeur*quantite END) as total FROM event_caisse_details WHERE caisse_id=? AND moment='debut'", (cid,)
        ).fetchone()["total"] or 0.0
        fin = conn.execute(
            "SELECT SUM(CASE WHEN type='cheque' THEN valeur ELSE valeur*quantite END) as total FROM event_caisse_details WHERE caisse_id=? AND moment='fin'", (cid,)
        ).fetchone()["total"] or 0.0
        caisses_details.append({
            "Caisse": caisse["nom_caisse"],
            "Fond dÃ©but (â‚¬)": f"{debut:.2f}",
            "Fond fin (â‚¬)": f"{fin:.2f}",
            "Gain (â‚¬)": f"{fin-debut:.2f}",
            "Commentaire": caisse["commentaire"],
        })
    caisses_details_df = pd.DataFrame(caisses_details)

    conn.close()

    if filename is None:
        ext = "." + format
        filename = filedialog.asksaveasfilename(
            defaultextension=ext,
            filetypes=[("Excel", "*.xlsx"), ("CSV", "*.csv"), ("PDF", "*.pdf")],
            title="Exporter bilan Ã©vÃ©nement",
            initialfile=f"Bilan_{event['name'].replace(' ', '_')}{ext}"
        )
    if not filename:
        return

    if format == "xlsx":
        with pd.ExcelWriter(filename) as writer:
            pd.DataFrame([dict(event)]).to_excel(writer, sheet_name="Ã‰vÃ©nement", index=False)
            recettes.to_excel(writer, sheet_name="Recettes", index=False)
            depenses.to_excel(writer, sheet_name="DÃ©penses", index=False)
            caisses_details_df.to_excel(writer, sheet_name="Caisses", index=False)
        messagebox.showinfo("Export", f"Bilan Ã©vÃ©nement exportÃ© :\n{filename}")
    elif format == "csv":
        recettes.to_csv(filename.replace(".csv", "_recettes.csv"), index=False, encoding="utf-8")
        depenses.to_csv(filename.replace(".csv", "_depenses.csv"), index=False, encoding="utf-8")
        caisses_details_df.to_csv(filename.replace(".csv", "_caisses.csv"), index=False, encoding="utf-8")
        messagebox.showinfo("Export", f"Bilans CSV exportÃ©s.")
    elif format == "pdf":
        try:
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.pagesizes import A4
            from reportlab.lib import colors
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle

            doc = SimpleDocTemplate(filename, pagesize=A4, rightMargin=24, leftMargin=24, topMargin=24, bottomMargin=24)
            styles = getSampleStyleSheet()
            styles.add(ParagraphStyle(name='Justify', alignment=4))

            elements = []

            # Titre principal
            elements.append(Paragraph(f"<b>Bilan de l'Ã©vÃ©nement : {event['name']}</b>", styles["Title"]))
            elements.append(Paragraph(f"<i>Date : {event['date']} | Lieu : {event['lieu']}</i>", styles["Normal"]))
            elements.append(Spacer(1, 10))
            elements.append(Paragraph(f"{event['description']}", styles["BodyText"]))
            elements.append(Spacer(1, 16))

            # === TABLEAU SYNTHÃ‰TIQUE (Recette/DÃ©pense/Gain) ===
            total_recettes = recettes["montant"].sum() if not recettes.empty else 0.0
            total_depenses = depenses["montant"].sum() if not depenses.empty else 0.0
            gain = total_recettes - total_depenses

            synth_data = [
                ["Recettes (â‚¬)", "DÃ©penses (â‚¬)", "Gain (â‚¬)"],
                [f"{total_recettes:.2f}", f"{total_depenses:.2f}", f"{gain:.2f}"]
            ]
            synth_table = Table(synth_data, hAlign="LEFT", colWidths=[90, 90, 90])
            synth_table.setStyle(TableStyle([
                ("GRID", (0,0), (-1,-1), 1, colors.black),
                ("BACKGROUND", (0,0), (-1,0), colors.HexColor("#cce6ff")),
                ("FONTNAME", (0,0), (-1,0), "Helvetica-Bold"),
                ("ALIGN", (0,0), (-1,-1), "CENTER"),
                ("FONTSIZE", (0,0), (-1,-1), 11),
                ("BOTTOMPADDING", (0,0), (-1,0), 6)
            ]))
            elements.append(synth_table)
            elements.append(Spacer(1, 18))

            # Recettes
            elements.append(Paragraph("<b>Recettes</b>", styles["Heading2"]))
            if not recettes.empty:
                recettes_data = [recettes.columns.tolist()] + [
                    [
                        Paragraph(str(row[0]), styles["Normal"]),
                        Paragraph(str(row[1]), styles["Normal"]),
                        Paragraph(str(row[2]), styles["Normal"]),
                        Paragraph(str(row[3]), styles["Normal"])
                    ] for row in recettes.values
                ]
                t = Table(recettes_data, hAlign="LEFT", colWidths=[110, 70, 220, 60])
                t.setStyle(TableStyle([
                    ("GRID", (0,0), (-1,-1), 0.7, colors.grey),
                    ("BACKGROUND", (0,0), (-1,0), colors.HexColor("#e0e0e0")),
                    ("FONTNAME", (0,0), (-1,0), "Helvetica-Bold"),
                    ("ALIGN", (0,0), (-1,0), "CENTER"),
                    ("ALIGN", (1,1), (1,-1), "RIGHT"),  # montant Ã  droite
                    ("VALIGN", (0,0), (-1,-1), "TOP"),
                    ("FONTSIZE", (0,0), (-1,-1), 9),
                    ("LEFTPADDING", (0,0), (-1,-1), 6),
                    ("RIGHTPADDING", (0,0), (-1,-1), 6),
                    ("ROWBACKGROUNDS", (0,1), (-1,-1), [colors.whitesmoke, colors.lightgrey])
                ]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune recette.", styles["Normal"]))
            elements.append(Spacer(1, 16))

            # DÃ©penses
            elements.append(Paragraph("<b>DÃ©penses</b>", styles["Heading2"]))
            if not depenses.empty:
                depenses_data = [depenses.columns.tolist()] + [
                    [
                        Paragraph(str(row[0]), styles["Normal"]),  # categorie
                        Paragraph(str(row[1]), styles["Normal"]),  # montant
                        Paragraph(str(row[2]), styles["Normal"]),  # fournisseur
                        Paragraph(str(row[3]), styles["Normal"]),  # date_depense
                        Paragraph(str(row[4]), styles["Normal"]),  # paye_par
                        Paragraph(str(row[5]), styles["Normal"]),  # membre_id
                        Paragraph(str(row[6]), styles["Normal"])   # commentaire
                    ] for row in depenses.values
                ]
                t = Table(depenses_data, hAlign="LEFT", colWidths=[75, 60, 90, 60, 60, 50, 160])
                t.setStyle(TableStyle([
                    ("GRID", (0,0), (-1,-1), 0.7, colors.grey),
                    ("BACKGROUND", (0,0), (-1,0), colors.HexColor("#e0e0e0")),
                    ("FONTNAME", (0,0), (-1,0), "Helvetica-Bold"),
                    ("ALIGN", (1,1), (1,-1), "RIGHT"),  # montant Ã  droite
                    ("VALIGN", (0,0), (-1,-1), "TOP"),
                    ("FONTSIZE", (0,0), (-1,-1), 8),
                    ("LEFTPADDING", (0,0), (-1,-1), 4),
                    ("RIGHTPADDING", (0,0), (-1,-1), 4),
                    ("ROWBACKGROUNDS", (0,1), (-1,-1), [colors.whitesmoke, colors.lightgrey])
                ]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune dÃ©pense.", styles["Normal"]))
            elements.append(Spacer(1, 18))

            # Caisses
            elements.append(Paragraph("<b>Caisses</b>", styles["Heading2"]))
            if not caisses_details_df.empty:
                caisses_data = [caisses_details_df.columns.tolist()] + [
                    [
                        Paragraph(str(row[0]), styles["Normal"]),
                        Paragraph(str(row[1]), styles["Normal"]),
                        Paragraph(str(row[2]), styles["Normal"]),
                        Paragraph(str(row[3]), styles["Normal"]),
                        Paragraph(str(row[4]), styles["Normal"])
                    ] for row in caisses_details_df.values
                ]
                t = Table(caisses_data, hAlign="LEFT", colWidths=[110, 60, 60, 60, 180])
                t.setStyle(TableStyle([
                    ("GRID", (0,0), (-1,-1), 0.7, colors.grey),
                    ("BACKGROUND", (0,0), (-1,0), colors.HexColor("#e0e0e0")),
                    ("FONTNAME", (0,0), (-1,0), "Helvetica-Bold"),
                    ("ALIGN", (1,1), (3,-1), "RIGHT"),
                    ("VALIGN", (0,0), (-1,-1), "TOP"),
                    ("FONTSIZE", (0,0), (-1,-1), 9),
                    ("LEFTPADDING", (0,0), (-1,-1), 4),
                    ("RIGHTPADDING", (0,0), (-1,-1), 4),
                    ("ROWBACKGROUNDS", (0,1), (-1,-1), [colors.whitesmoke, colors.lightgrey])
                ]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune caisse.", styles["Normal"]))

            doc.build(elements)
            messagebox.showinfo("Export", f"Bilan PDF exportÃ©Â :\n{filename}")
        except ImportError:
            messagebox.showerror("Export", "Le module reportlab n'est pas installÃ©.")

# ========== EXPORTS GLOBAUX DÃ‰PENSES / SUBVENTIONS ==========

def export_depenses_global(format="xlsx", filename=None):
    conn = get_connection()
    depenses = pd.read_sql_query("""
        SELECT 
            date_depense as date,
            categorie,
            montant,
            fournisseur,
            paye_par,
            membre_id,
            commentaire,
            'RÃ©guliÃ¨re' as type_depense
        FROM depenses_regulieres
        UNION ALL
        SELECT 
            date_depense as date,
            categorie,
            montant,
            fournisseur,
            paye_par,
            membre_id,
            commentaire,
            'Diverse' as type_depense
        FROM depenses_diverses
    """, conn)
    conn.close()
    if filename is None:
        ext = "." + format
        filename = filedialog.asksaveasfilename(
            defaultextension=ext,
            filetypes=[("Excel", "*.xlsx"), ("CSV", "*.csv"), ("PDF", "*.pdf")],
            title="Exporter toutes les dÃ©penses",
            initialfile="Toutes_depenses" + ext
        )
    if not filename:
        return
    if format == "xlsx":
        depenses.to_excel(filename, index=False)
        messagebox.showinfo("Export", f"Export Excel terminÃ© :\n{filename}")
    elif format == "csv":
        depenses.to_csv(filename, index=False, encoding="utf-8")
        messagebox.showinfo("Export", f"Export CSV terminÃ© :\n{filename}")
    elif format == "pdf":
        try:
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.pagesizes import A4
            from reportlab.lib import colors
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle

            doc = SimpleDocTemplate(filename, pagesize=A4, rightMargin=24, leftMargin=24, topMargin=24, bottomMargin=24)
            styles = getSampleStyleSheet()
            styles.add(ParagraphStyle(name='Justify', alignment=4))

            elements = []
            elements.append(Paragraph("<b>Toutes les dÃ©penses</b>", styles["Title"]))
            elements.append(Spacer(1, 14))

            if not depenses.empty:
                data = [depenses.columns.tolist()] + [
                    [
                        Paragraph(str(row[0]), styles["Normal"]), # date
                        Paragraph(str(row[1]), styles["Normal"]), # categorie
                        Paragraph(str(row[2]), styles["Normal"]), # montant
                        Paragraph(str(row[3]), styles["Normal"]), # fournisseur
                        Paragraph(str(row[4]), styles["Normal"]), # paye_par
                        Paragraph(str(row[5]), styles["Normal"]), # membre_id
                        Paragraph(str(row[6]), styles["Normal"]), # commentaire
                        Paragraph(str(row[7]), styles["Normal"])  # type_depense
                    ]
                    for row in depenses.values
                ]
                # Largeurs proportionnelles : les 6 premiÃ¨res colonnes restent fixes, la colonne "commentaire" et "type_depense" adaptatives
                t = Table(
                    data,
                    hAlign="LEFT",
                    colWidths=[55, 75, 55, 90, 60, 45, "*", 60]  # "*" donne tout l'espace restant Ã  "commentaire"
                )
                t.setStyle(TableStyle([
                    ("GRID", (0,0), (-1,-1), 0.7, colors.grey),
                    ("BACKGROUND", (0,0), (-1,0), colors.HexColor("#cce6ff")),
                    ("FONTNAME", (0,0), (-1,0), "Helvetica-Bold"),
                    ("ALIGN", (2,1), (2,-1), "RIGHT"),    # montant Ã  droite
                    ("ALIGN", (0,0), (-1,0), "CENTER"),   # en-tÃªtes centrÃ©es
                    ("VALIGN", (0,0), (-1,-1), "TOP"),
                    ("FONTSIZE", (0,0), (-1,-1), 9),
                    ("LEFTPADDING", (0,0), (-1,-1), 5),
                    ("RIGHTPADDING", (0,0), (-1,-1), 5),
                    ("ROWBACKGROUNDS", (0,1), (-1,-1), [colors.whitesmoke, colors.lightgrey]),
                    ("BOTTOMPADDING", (0,0), (-1,0), 6),
                    ("TOPPADDING", (0,0), (-1,0), 6)
                ]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune dÃ©pense.", styles["Normal"]))

            doc.build(elements)
            messagebox.showinfo("Export", f"Export PDF terminÃ© :\n{filename}")
        except ImportError:
            messagebox.showerror("Export", "Le module reportlab n'est pas installÃ©.")

def export_subventions_global(format="xlsx", filename=None):
    conn = get_connection()
    subventions = pd.read_sql_query("SELECT * FROM dons_subventions", conn)
    conn.close()
    if filename is None:
        ext = "." + format
        filename = filedialog.asksaveasfilename(
            defaultextension=ext,
            filetypes=[("Excel", "*.xlsx"), ("CSV", "*.csv"), ("PDF", "*.pdf")],
            title="Exporter toutes les subventions",
            initialfile="Toutes_subventions" + ext
        )
    if not filename:
        return
    if format == "xlsx":
        subventions.to_excel(filename, index=False)
        messagebox.showinfo("Export", f"Export Excel terminÃ© :\n{filename}")
    elif format == "csv":
        subventions.to_csv(filename, index=False, encoding="utf-8")
        messagebox.showinfo("Export", f"Export CSV terminÃ© :\n{filename}")
    elif format == "pdf":
        try:
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.pagesizes import A4
            from reportlab.lib import colors
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle

            doc = SimpleDocTemplate(filename, pagesize=A4, rightMargin=24, leftMargin=24, topMargin=24, bottomMargin=24)
            styles = getSampleStyleSheet()
            styles.add(ParagraphStyle(name='Justify', alignment=4))

            elements = []
            elements.append(Paragraph("<b>Toutes les subventions et dons</b>", styles["Title"]))
            elements.append(Spacer(1, 12))

            if not subventions.empty:
                data = [subventions.columns.tolist()] + [
                    [Paragraph(str(col), styles["Normal"]) for col in row]
                    for row in subventions.values
                ]
                t = Table(data, hAlign="LEFT", colWidths=[65, 120, 70, 70, 110, 80])
                t.setStyle(TableStyle([
                    ("GRID", (0,0), (-1,-1), 0.7, colors.grey),
                    ("BACKGROUND", (0,0), (-1,0), colors.HexColor("#e0e0e0")),
                    ("FONTNAME", (0,0), (-1,0), "Helvetica-Bold"),
                    ("ALIGN", (2,1), (2,-1), "RIGHT"),  # montant Ã  droite
                    ("VALIGN", (0,0), (-1,-1), "TOP"),
                    ("FONTSIZE", (0,0), (-1,-1), 9),
                    ("LEFTPADDING", (0,0), (-1,-1), 4),
                    ("RIGHTPADDING", (0,0), (-1,-1), 4),
                    ("ROWBACKGROUNDS", (0,1), (-1,-1), [colors.whitesmoke, colors.lightgrey])
                ]))
                elements.append(t)
            else:
                elements.append(Paragraph("Aucune subvention ni don.", styles["Normal"]))

            doc.build(elements)
            messagebox.showinfo("Export", f"Export PDF terminÃ© :\n{filename}")
        except ImportError:
            messagebox.showerror("Export", "Le module reportlab n'est pas installÃ©.")

# ========== EXPORTS MULTI-EVENEMENTS EN LOT ==========

def export_tous_bilans_evenements(format="xlsx", dossier=None):
    conn = get_connection()
    events = conn.execute("SELECT id, name FROM events ORDER BY date DESC").fetchall()
    conn.close()
    if dossier is None:
        dossier = filedialog.askdirectory(title="Choisir le dossier d'export pour tous les bilans Ã©vÃ©nements")
    if not dossier:
        return
    for ev in events:
        name = ev["name"].replace(" ", "_")
        fname = f"{dossier}/Bilan_{name}.{format}"
        export_bilan_evenement(ev["id"], format=format, filename=fname)
    messagebox.showinfo("Export", f"Tous les bilans Ã©vÃ©nements exportÃ©s dansÂ :\n{dossier}")
    
class ExportsWindow(tk.Toplevel):
    def __init__(self, master=None):
        super().__init__(master)
        self.title("Exports et Bilans")
        self.geometry("640x520")
        self.resizable(False, False)
        self.create_widgets()
        self.populate_events()

    def create_widgets(self):
        frm = tk.Frame(self)
        frm.pack(fill="both", expand=True, padx=20, pady=16)

        # SÃ©lection d'un Ã©vÃ©nement
        tk.Label(frm, text="Bilan par Ã©vÃ©nement :", font=("Arial", 12, "bold")).pack(anchor="w", pady=(0, 4))
        sel_frame = tk.Frame(frm)
        sel_frame.pack(anchor="w", pady=(0, 10))
        self.event_var = tk.StringVar()
        self.event_cb = ttk.Combobox(sel_frame, textvariable=self.event_var, state="readonly", width=38)
        self.event_cb.pack(side="left")
        tk.Button(sel_frame, text="Exporter Excel", command=lambda: export_bilan_evenement(self.get_selected_event_id(), "xlsx")).pack(side="left", padx=3)
        tk.Button(sel_frame, text="Exporter CSV", command=lambda: export_bilan_evenement(self.get_selected_event_id(), "csv")).pack(side="left", padx=3)
        tk.Button(sel_frame, text="Exporter PDF", command=lambda: export_bilan_evenement(self.get_selected_event_id(), "pdf")).pack(side="left", padx=3)

        # Export tous bilans Ã©vÃ©nements
        tk.Label(frm, text="Exporter tous les bilans Ã©vÃ©nements :", font=("Arial", 12, "bold")).pack(anchor="w", pady=(16, 4))
        all_ev_frame = tk.Frame(frm)
        all_ev_frame.pack(anchor="w", pady=(0, 10))
        tk.Button(all_ev_frame, text="Tous en Excel", command=lambda: export_tous_bilans_evenements("xlsx")).pack(side="left", padx=3)
        tk.Button(all_ev_frame, text="Tous en CSV", command=lambda: export_tous_bilans_evenements("csv")).pack(side="left", padx=3)
        tk.Button(all_ev_frame, text="Tous en PDF", command=lambda: export_tous_bilans_evenements("pdf")).pack(side="left", padx=3)

        # Export global dÃ©penses
        tk.Label(frm, text="Exporter toutes les dÃ©penses :", font=("Arial", 12, "bold")).pack(anchor="w", pady=(16, 4))
        dep_frame = tk.Frame(frm)
        dep_frame.pack(anchor="w", pady=(0, 10))
        tk.Button(dep_frame, text="Excel", command=lambda: export_depenses_global("xlsx")).pack(side="left", padx=3)
        tk.Button(dep_frame, text="CSV", command=lambda: export_depenses_global("csv")).pack(side="left", padx=3)
        tk.Button(dep_frame, text="PDF", command=lambda: export_depenses_global("pdf")).pack(side="left", padx=3)

        # Export global subventions/dons
        tk.Label(frm, text="Exporter tous les dons/subventions :", font=("Arial", 12, "bold")).pack(anchor="w", pady=(16, 4))
        sub_frame = tk.Frame(frm)
        sub_frame.pack(anchor="w", pady=(0, 10))
        tk.Button(sub_frame, text="Excel", command=lambda: export_subventions_global("xlsx")).pack(side="left", padx=3)
        tk.Button(sub_frame, text="CSV", command=lambda: export_subventions_global("csv")).pack(side="left", padx=3)
        tk.Button(sub_frame, text="PDF", command=lambda: export_subventions_global("pdf")).pack(side="left", padx=3)

        # Bouton fermer
        tk.Button(frm, text="Fermer", command=self.destroy).pack(side="bottom", pady=8)

    def populate_events(self):
        conn = get_connection()
        events = conn.execute("SELECT id, name, date FROM events ORDER BY date DESC").fetchall()
        conn.close()
        self.event_list = [(str(ev["id"]), f"{ev['date']} - {ev['name']}") for ev in events]
        self.event_cb["values"] = [ev[1] for ev in self.event_list]
        if self.event_list:
            self.event_cb.current(0)

    def get_selected_event_id(self):
        idx = self.event_cb.current()
        if idx < 0 or not self.event_list:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un Ã©vÃ©nement.")
            return None
        return int(self.event_list[idx][0])
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/fournisseurs.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog, filedialog
import pandas as pd
from db.db import get_connection

class FournisseursWindow(tk.Toplevel):
    def __init__(self, master=None):
        super().__init__(master)
        self.title("Gestion des fournisseurs")
        self.geometry("430x400")
        self.resizable(False, False)
        self.create_widgets()
        self.refresh_fournisseurs()

    def create_widgets(self):
        frame = tk.Frame(self)
        frame.pack(fill=tk.BOTH, expand=True, padx=12, pady=10)

        self.tree = ttk.Treeview(frame, columns=("id", "name"), show="headings", selectmode="browse")
        self.tree.heading("id", text="ID")
        self.tree.heading("name", text="Nom du fournisseur")
        self.tree.column("id", width=50)
        self.tree.column("name", width=260)
        self.tree.pack(fill=tk.BOTH, expand=True, pady=8)

        btns = tk.Frame(frame)
        btns.pack(fill=tk.X, pady=8)
        tk.Button(btns, text="Ajouter", command=self.add_fournisseur).pack(side=tk.LEFT, padx=4)
        tk.Button(btns, text="Renommer", command=self.edit_fournisseur).pack(side=tk.LEFT, padx=4)
        tk.Button(btns, text="Supprimer", command=self.delete_fournisseur).pack(side=tk.LEFT, padx=4)
        tk.Button(btns, text="Ajout Liste", command=self.add_fournisseurs_mass).pack(side=tk.LEFT, padx=4)
        tk.Button(btns, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=4)

    def refresh_fournisseurs(self):
        self.tree.delete(*self.tree.get_children())
        conn = get_connection()
        fournisseurs = conn.execute("SELECT * FROM fournisseurs ORDER BY name").fetchall()
        for f in fournisseurs:
            self.tree.insert("", "end", values=(f["id"], f["name"]))
        conn.close()

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionne un fournisseur.")
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_fournisseur(self):
        name = tk.simpledialog.askstring("Ajouter fournisseur", "Nom du fournisseur :")
        if not name:
            return
        conn = get_connection()
        try:
            conn.execute("INSERT INTO fournisseurs (name) VALUES (?)", (name.strip(),))
            conn.commit()
        except Exception as e:
            messagebox.showerror("Erreur", f"Impossible d'ajouter : {e}")
        conn.close()
        self.refresh_fournisseurs()

    def add_fournisseurs_mass(self):
        win = tk.Toplevel(self)
        win.title("Ajout de fournisseurs en masse")
        win.geometry("320x330")
        tk.Label(win, text="Collez ici la liste des fournisseurs (un par ligne) :", font=("Arial", 11)).pack(pady=8)
        txt = tk.Text(win, width=36, height=12, font=("Arial", 11))
        txt.pack(padx=10, pady=5, fill=tk.BOTH, expand=True)
        txt.focus_set()
        def valider():
            lines = txt.get("1.0", "end-1c").splitlines()
            fournisseurs = [l.strip() for l in lines if l.strip()]
            if not fournisseurs:
                messagebox.showinfo("Aucun fournisseur", "Aucun nom Ã  ajouter.")
                return
            conn = get_connection()
            c = conn.cursor()
            n_inserted = 0
            for name in fournisseurs:
                try:
                    c.execute("INSERT OR IGNORE INTO fournisseurs (name) VALUES (?)", (name,))
                    n_inserted += c.rowcount
                except Exception:
                    pass
            conn.commit()
            conn.close()
            messagebox.showinfo("Import", f"{n_inserted} fournisseurs importÃ©s.")
            self.refresh_fournisseurs()
            win.destroy()
        tk.Button(win, text="Ajouter Ã  la base", command=valider, font=("Arial", 11, "bold"), bg="#4c9ed9", fg="white").pack(pady=12)
        win.grab_set()
        win.wait_window()

    def edit_fournisseur(self):
        fid = self.get_selected_id()
        if not fid:
            return
        conn = get_connection()
        old = conn.execute("SELECT name FROM fournisseurs WHERE id=?", (fid,)).fetchone()
        conn.close()
        if not old:
            return
        new_nom = tk.simpledialog.askstring("Renommer fournisseur", "Nouveau name :", initialvalue=old["name"])
        if not new_nom or new_nom.strip() == old["name"]:
            return
        conn = get_connection()
        try:
            conn.execute("UPDATE fournisseurs SET name=? WHERE id=?", (new_nom.strip(), fid))
            conn.commit()
        except Exception as e:
            messagebox.showerror("Erreur", f"Impossible de renommer : {e}")
        conn.close()
        self.refresh_fournisseurs()

    def delete_fournisseur(self):
        fid = self.get_selected_id()
        if not fid:
            return
        if not messagebox.askyesno("Supprimer", "ÃŠtes-vous sÃ»r de vouloir supprimer ce fournisseur ?"):
            return
        confirm = simpledialog.askstring("Confirmation", "Retapez SUPPRIMER pour confirmer la suppression du fournisseur :", parent=self)
        if (confirm or "").strip().upper() != "SUPPRIMER":
            messagebox.showinfo("AnnulÃ©", "Suppression annulÃ©e.")
            return
        conn = get_connection()
        try:
            conn.execute("DELETE FROM fournisseurs WHERE id=?", (fid,))
            conn.commit()
        except Exception as e:
            messagebox.showerror("Erreur", f"Impossible de supprimer : {e}")
        conn.close()
        self.refresh_fournisseurs()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/historique_clotures.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection

class HistoriqueCloturesModule(tk.Toplevel):
    def __init__(self, master=None):
        super().__init__(master)
        self.title("Gestion des dates de clÃ´ture")
        self.geometry("480x350")
        self.resizable(False, False)
        self.create_widgets()
        self.refresh_list()

    def create_widgets(self):
        frame = tk.Frame(self)
        frame.pack(fill=tk.BOTH, expand=True, padx=14, pady=12)
        self.tree = ttk.Treeview(frame, columns=("id", "date_cloture"), show="headings", selectmode="browse")
        self.tree.heading("id", text="ID")
        self.tree.heading("date_cloture", text="Date de clÃ´ture")
        self.tree.column("id", width=60)
        self.tree.column("date_cloture", width=180)
        self.tree.pack(fill=tk.BOTH, expand=True, pady=8)

        btns = tk.Frame(frame)
        btns.pack(fill=tk.X, pady=10)
        tk.Button(btns, text="Ajouter", command=self.add_cloture).pack(side=tk.LEFT, padx=6)
        tk.Button(btns, text="Modifier", command=self.edit_cloture).pack(side=tk.LEFT, padx=6)
        tk.Button(btns, text="Supprimer", command=self.delete_cloture).pack(side=tk.LEFT, padx=6)
        tk.Button(btns, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=6)

    def refresh_list(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        clotures = conn.execute("SELECT id, date_cloture FROM historique_clotures ORDER BY date_cloture DESC").fetchall()
        for c in clotures:
            self.tree.insert("", "end", values=(c["id"], c["date_cloture"]))
        conn.close()

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une clÃ´ture.")
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_cloture(self):
        date = simpledialog.askstring("Ajouter une clÃ´ture", "Date de clÃ´ture (YYYY-MM-DD) :")
        if not date:
            return
        conn = get_connection()
        conn.execute("INSERT INTO historique_clotures (date_cloture) VALUES (?)", (date,))
        conn.commit()
        conn.close()
        self.refresh_list()

    def edit_cloture(self):
        cid = self.get_selected_id()
        if not cid:
            return
        conn = get_connection()
        old = conn.execute("SELECT date_cloture FROM historique_clotures WHERE id=?", (cid,)).fetchone()
        conn.close()
        if not old:
            return
        new_date = simpledialog.askstring("Modifier clÃ´ture", "Nouvelle date (YYYY-MM-DD) :", initialvalue=old["date_cloture"])
        if not new_date or new_date == old["date_cloture"]:
            return
        conn = get_connection()
        conn.execute("UPDATE historique_clotures SET date_cloture=? WHERE id=?", (new_date, cid))
        conn.commit()
        conn.close()
        self.refresh_list()

    def delete_cloture(self):
        cid = self.get_selected_id()
        if not cid:
            return
        if not messagebox.askyesno("Supprimer", "Supprimer cette clÃ´ture ?"):
            return
        conn = get_connection()
        conn.execute("DELETE FROM historique_clotures WHERE id=?", (cid,))
        conn.commit()
        conn.close()
        self.refresh_list()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/historique_inventaire.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
import pandas as pd
from db.db import get_connection

class HistoriqueInventairesModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Historique des inventaires")
        self.top.geometry("900x500")
        self.create_table()
        self.refresh_inventaires()

    def create_table(self):
        style = ttk.Style()
        style.theme_use("default")
        style.configure("Treeview.Heading", font=('Arial', 11, 'bold'))
        style.configure("Treeview", font=('Consolas', 11), rowheight=22)
        style.configure("oddrow", background="#F2F2F2")
        style.configure("evenrow", background="#FFFFFF")

        columns = ("id", "date", "evenement", "nb_lignes", "commentaire")
        self.tree = ttk.Treeview(
            self.top, columns=columns, show="headings", selectmode="browse"
        )
        for col, text, w in zip(
            columns,
            ["ID", "Date", "Ã‰vÃ©nement", "Nb buvette_articles", "Commentaire"],
            [40, 120, 160, 100, 340]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True)
        vsb = ttk.Scrollbar(self.top, orient="vertical", command=self.tree.yview)
        vsb.pack(side='right', fill='y')
        self.tree.configure(yscroll=vsb.set)
        self.tree.bind("<Double-1>", self.show_lignes_inventaire)

        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=8)
        tk.Button(btn_frame, text="Afficher les lignes", command=self.show_lignes_inventaire).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=10)

    def refresh_inventaires(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        df = pd.read_sql_query(
            """
            SELECT i.id, i.date_inventaire as date, e.name as evenement, i.commentaire,
                (SELECT COUNT(*) FROM inventaire_lignes WHERE inventaire_id = i.id) as nb_lignes
            FROM inventaires i
            LEFT JOIN events e ON i.event_id = e.id
            ORDER BY i.date_inventaire DESC, i.id DESC
            """, conn
        )
        self.df = df
        for idx, (_, row) in enumerate(df.iterrows()):
            tag = "evenrow" if idx % 2 == 0 else "oddrow"
            self.tree.insert(
                "", "end",
                values=(
                    row['id'],
                    row['date'][:10] if pd.notnull(row['date']) else "",
                    row['evenement'] if pd.notnull(row['evenement']) else "",
                    row['nb_lignes'],
                    row['commentaire'] if pd.notnull(row['commentaire']) else ""
                ),
                tags=(tag,)
            )

    def show_lignes_inventaire(self, event=None):
        sel = self.tree.selection()
        if not sel:
            messagebox.showinfo("SÃ©lection", "SÃ©lectionnez un inventaire Ã  afficher.")
            return
        item = self.tree.item(sel[0])
        inv_id = item["values"][0]
        LignesInventaireDialog(self.top, inv_id)

class LignesInventaireDialog(tk.Toplevel):
    def __init__(self, master, inventaire_id):
        super().__init__(master)
        self.title(f"Lignes de l'inventaire nÂ°{inventaire_id}")
        self.geometry("750x400")
        self.create_table()
        self.refresh_lignes(inventaire_id)

    def create_table(self):
        columns = ("stock_id", "name", "categorie", "quantite_constatee")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        for col, text, w in zip(
            columns,
            ["ID stock", "Name article", "CatÃ©gorie", "QtÃ© constatÃ©e"],
            [60, 220, 160, 100]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True)

    def refresh_lignes(self, inventaire_id):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        lignes = conn.execute(
            """
            SELECT l.stock_id, s.name, c.name as categorie, l.quantite_constatee
            FROM inventaire_lignes l
            LEFT JOIN stock s ON l.stock_id = s.id
            LEFT JOIN categories c ON s.categorie_id = c.id
            WHERE l.inventaire_id = ?
            ORDER BY s.name
            """, (inventaire_id,)
        ).fetchall()
        for l in lignes:
            self.tree.insert("", "end", values=(l["stock_id"], l["name"], l["categorie"], l["quantite_constatee"]))
        conn.close()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/inventaire.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
try:
    import pandas as pd
except ModuleNotFoundError:
    print("Le module 'pandas' est requis pour la gestion des inventaires. Installe-le : python -m pip install pandas")
    raise
from db.db import get_connection

class InventaireModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Nouvel inventaire")
        self.top.geometry("900x600")
        self.create_widgets()
        self.load_stock()

    def create_widgets(self):
        form = tk.Frame(self.top)
        form.pack(fill=tk.X, pady=6)
        tk.Label(form, text="Date de l'inventaire (YYYY-MM-DD) :").grid(row=0, column=0, sticky="e", padx=8, pady=2)
        self.date_var = tk.StringVar()
        tk.Entry(form, textvariable=self.date_var, width=16).grid(row=0, column=1, sticky="w")

        tk.Label(form, text="Ã‰vÃ©nement liÃ© (optionnel) :").grid(row=0, column=2, sticky="e", padx=8, pady=2)
        self.evt_var = tk.StringVar()
        self.evt_cb = ttk.Combobox(form, textvariable=self.evt_var, width=26, state="readonly")
        self.evt_cb.grid(row=0, column=3, sticky="w")
        self.evt_cb["values"] = self.get_events()
        self.evt_cb.set("")

        tk.Label(form, text="Commentaire :").grid(row=1, column=0, sticky="e", padx=8, pady=2)
        self.comment_var = tk.StringVar()
        tk.Entry(form, textvariable=self.comment_var, width=60).grid(row=1, column=1, columnspan=3, sticky="w")

        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=10)
        tk.Button(btn_frame, text="Enregistrer inventaire", command=self.save_inventaire).pack(side=tk.LEFT, padx=12)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=12)

        # Tableau des buvette_articles
        columns = ("stock_id", "name", "categorie", "quantite_stock", "quantite_constatee")
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings", selectmode="browse")
        for col, text, w in zip(
            columns,
            ["ID stock", "Name article", "CatÃ©gorie", "QuantitÃ© stock", "QtÃ© constatÃ©e"],
            [60, 220, 160, 100, 120]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True)

        self.tree.bind("<Double-1>", self.edit_qte_constatee)

    def get_events(self):
        conn = get_connection()
        evts = conn.execute("SELECT name FROM events ORDER BY date DESC").fetchall()
        conn.close()
        return [e["name"] for e in evts]

    def load_stock(self):
        conn = get_connection()
        self.stock_df = pd.read_sql_query("""
            SELECT s.id as stock_id, s.name, c.name as categorie, s.quantite
            FROM stock s LEFT JOIN categories c ON s.categorie_id = c.id
            ORDER BY s.name
        """, conn)
        conn.close()
        for row in self.tree.get_children():
            self.tree.delete(row)
        for _, row in self.stock_df.iterrows():
            self.tree.insert(
                "", "end",
                values=(row["stock_id"], row["name"], row["categorie"], row["quantite"], row["quantite"])
            )

    def edit_qte_constatee(self, event=None):
        sel = self.tree.selection()
        if not sel:
            return
        item = self.tree.item(sel[0])
        qte = item["values"][4]
        qte_new = simpledialog.askinteger("Saisie", "Nouvelle quantitÃ© constatÃ©e :", initialvalue=qte)
        if qte_new is not None:
            vals = list(item["values"])
            vals[4] = qte_new
            self.tree.item(sel[0], values=vals)

    def save_inventaire(self):
        date = self.date_var.get().strip()
        evt_name = self.evt_var.get().strip()
        comment = self.comment_var.get().strip()
        if not date:
            messagebox.showerror("Erreur", "Date obligatoire.")
            return
        conn = get_connection()
        evt_id = None
        if evt_name:
            row = conn.execute("SELECT id FROM events WHERE name=?", (evt_name,)).fetchone()
            if row:
                evt_id = row["id"]
        # Insert inventaire
        conn.execute(
            "INSERT INTO inventaires (date_inventaire, event_id, commentaire) VALUES (?, ?, ?)",
            (date, evt_id, comment)
        )
        inv_id = conn.execute("SELECT last_insert_rowid()").fetchone()[0]
        # Insert lignes
        for row_id in self.tree.get_children():
            vals = self.tree.item(row_id)["values"]
            stock_id = vals[0]
            qte_constatee = vals[4]
            conn.execute(
                "INSERT INTO inventaire_lignes (inventaire_id, stock_id, quantite_constatee) VALUES (?, ?, ?)",
                (inv_id, stock_id, qte_constatee)
            )
        conn.commit()
        conn.close()
        messagebox.showinfo("OK", "Inventaire enregistrÃ© !")
        self.top.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/inventory_lines_dialog.py ===

```python
"""
Helper module for loading inventory lines safely.

This module provides robust functions for loading inventory data with proper
error handling and reporting. It ensures that sqlite3.Row objects are properly
converted to dictionaries before any .get() operations are performed.

Functions:
    load_inventory_lines: Load inventory lines with error handling and reporting
"""

import os
from datetime import datetime
from typing import List, Dict, Any, Optional
from utils.app_logger import get_logger
from modules.db_row_utils import _row_to_dict, _rows_to_dicts
from modules.buvette_inventaire_db import list_lignes_inventaire as _list_lignes_inventaire

logger = get_logger("inventory_lines_dialog")


def load_inventory_lines(inventaire_id: int) -> List[Dict[str, Any]]:
    """
    Load inventory lines with robust error handling and conversion.
    
    This function:
    1. Fetches inventory lines from the database
    2. Converts sqlite3.Row objects to dicts using _rows_to_dicts
    3. Handles errors gracefully with detailed reporting
    4. Writes error reports to reports/inventory_error_<timestamp>.txt on failure
    
    Args:
        inventaire_id: The ID of the inventory to load lines for
        
    Returns:
        List of dicts representing inventory lines, with keys:
        - id: line ID
        - inventaire_id: inventory ID
        - article_id: article ID
        - quantite: quantity counted
        - commentaire: optional comment
        - article_name: article name (from JOIN)
        
    Raises:
        Exception: Re-raises any exception after writing an error report
        
    Example:
        >>> try:
        >>>     lines = load_inventory_lines(inventory_id=42)
        >>>     for line in lines:
        >>>         article_id = line.get('article_id', 0)
        >>>         quantity = line.get('quantite', 0)
        >>> except Exception as e:
        >>>     logger.error(f"Failed to load inventory: {e}")
    """
    raw_rows = None  # Initialize for error reporting scope
    try:
        # Fetch raw rows from database
        logger.info(f"Loading inventory lines for inventaire_id={inventaire_id}")
        raw_rows = _list_lignes_inventaire(inventaire_id)
        
        if not raw_rows:
            logger.info(f"No lines found for inventaire_id={inventaire_id}")
            return []
        
        # Convert Row objects to dicts for safe .get() access
        lines_dicts = _rows_to_dicts(raw_rows)
        
        logger.info(f"Successfully loaded {len(lines_dicts)} inventory lines")
        return lines_dicts
        
    except Exception as e:
        # Log the error
        logger.error(f"Error loading inventory lines for inventaire_id={inventaire_id}: {e}", exc_info=True)
        
        # Write detailed error report
        _write_error_report(inventaire_id, e, raw_rows)
        
        # Re-raise the exception so callers can handle it
        raise


def _write_error_report(
    inventaire_id: int, 
    error: Exception, 
    raw_rows: Optional[List] = None
) -> None:
    """
    Write a detailed error report to reports/inventory_error_<timestamp>.txt.
    
    Args:
        inventaire_id: The inventory ID that failed to load
        error: The exception that occurred
        raw_rows: Optional raw rows data for debugging (if available)
    """
    try:
        # Ensure reports directory exists
        reports_dir = os.path.join(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
            "reports"
        )
        os.makedirs(reports_dir, exist_ok=True)
        
        # Generate error report filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_filename = f"inventory_error_{timestamp}.txt"
        report_path = os.path.join(reports_dir, report_filename)
        
        # Compile error report
        report_lines = [
            "=" * 80,
            "INVENTORY LOADING ERROR REPORT",
            "=" * 80,
            f"Timestamp: {datetime.now().isoformat()}",
            f"Inventaire ID: {inventaire_id}",
            "",
            "ERROR DETAILS:",
            f"Exception Type: {type(error).__name__}",
            f"Exception Message: {str(error)}",
            "",
        ]
        
        # Add raw rows information if available
        if raw_rows is not None:
            report_lines.extend([
                "RAW ROWS DATA:",
                f"Number of rows: {len(raw_rows)}",
                f"Row type: {type(raw_rows[0]).__name__ if raw_rows else 'N/A'}",
                "",
            ])
            
            # Try to show sample data (safely)
            if raw_rows:
                report_lines.append("First row sample (if accessible):")
                try:
                    first_row = raw_rows[0]
                    # Try to convert to dict
                    row_dict = _row_to_dict(first_row)
                    if row_dict:
                        for key, value in row_dict.items():
                            report_lines.append(f"  {key}: {value}")
                    else:
                        report_lines.append(f"  Could not convert row to dict: {first_row}")
                except Exception as row_error:
                    report_lines.append(f"  Error accessing row data: {row_error}")
                report_lines.append("")
        
        report_lines.extend([
            "RECOMMENDED ACTIONS:",
            "1. Check that the database connection is properly configured",
            "2. Verify that buvette_inventaire_lignes table exists and has expected columns",
            "3. Ensure sqlite3.Row factory is properly set on database connections",
            "4. Check for any database migration issues",
            "",
            "=" * 80,
        ])
        
        # Write report to file
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(report_lines))
        
        logger.info(f"Error report written to: {report_path}")
        
    except Exception as report_error:
        # If we can't write the report, at least log it
        logger.error(f"Failed to write error report: {report_error}")

```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/journal.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import pandas as pd
from db.db import get_connection
from exports.exports import (
    export_dataframe_to_excel,
    export_dataframe_to_pdf,
    export_dataframe_to_csv
)

class JournalModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Journal GÃ©nÃ©ral")
        self.top.geometry("1200x700")
        self.create_widgets()
        self.refresh_journal()

    def create_widgets(self):
        # Zone filtres/recherche/export
        filter_frame = tk.Frame(self.top)
        filter_frame.pack(fill=tk.X, padx=8, pady=4)
        tk.Label(filter_frame, text="Recherche :").pack(side=tk.LEFT)
        self.search_var = tk.StringVar()
        search_entry = tk.Entry(filter_frame, textvariable=self.search_var, width=32)
        search_entry.pack(side=tk.LEFT, padx=5)
        search_entry.bind('<Return>', lambda e: self.apply_filter())
        tk.Button(filter_frame, text="Filtrer", command=self.apply_filter).pack(side=tk.LEFT, padx=4)
        tk.Button(filter_frame, text="Effacer", command=self.clear_filter).pack(side=tk.LEFT, padx=4)
        tk.Button(filter_frame, text="Exporter Excel", command=self.export_excel).pack(side=tk.RIGHT, padx=4)
        tk.Button(filter_frame, text="Exporter PDF", command=self.export_pdf).pack(side=tk.RIGHT, padx=4)
        tk.Button(filter_frame, text="Exporter CSV", command=self.export_csv).pack(side=tk.RIGHT, padx=4)

        # Tableau principal
        columns = ("date", "type", "libelle", "montant", "justificatif")
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings")
        for col, text, w, anchor in zip(
            columns,
            ["Date", "Type", "LibellÃ©", "Montant (â‚¬)", "Justificatif/Commentaire"],
            [100, 150, 290, 120, 470],
            ["center", "w", "w", "e", "w"]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor=anchor)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=6, pady=3)

        # Scrollbars
        vsb = ttk.Scrollbar(self.top, orient="vertical", command=self.tree.yview)
        hsb = ttk.Scrollbar(self.top, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        vsb.pack(side='right', fill='y')
        hsb.pack(side='bottom', fill='x')

        # Ligne de total et solde progressif
        self.total_var = tk.StringVar()
        self.recette_var = tk.StringVar()
        self.depense_var = tk.StringVar()
        self.solde_ouv_var = tk.StringVar()
        total_frame = tk.Frame(self.top)
        total_frame.pack(fill=tk.X, padx=6, pady=3)
        tk.Label(total_frame, textvariable=self.solde_ouv_var, anchor="e", fg="orange").pack(side=tk.LEFT, padx=(0, 15))
        tk.Label(total_frame, textvariable=self.recette_var, anchor="e", fg="green").pack(side=tk.LEFT)
        tk.Label(total_frame, textvariable=self.depense_var, anchor="e", fg="red").pack(side=tk.LEFT, padx=(15,0))
        tk.Label(total_frame, textvariable=self.total_var, anchor="e", fg="blue").pack(side=tk.RIGHT)

        # Double-clic pour dÃ©tail
        self.tree.bind("<Double-1>", self.show_detail)

        # Bouton fermer
        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=4)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=10)

    def refresh_journal(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        # RÃ©cupÃ©rer le solde d'ouverture
        solde_ouverture = 0.0
        try:
            row = conn.execute("SELECT solde_report FROM config ORDER BY id DESC LIMIT 1").fetchone()
            if row and row[0] is not None:
                solde_ouverture = float(row[0])
        except Exception:
            pass
        df = pd.read_sql_query("""
            SELECT date, 'Recette' as type, source as libelle, montant, justificatif FROM dons_subventions
            UNION ALL
            SELECT e.date as date, 'Recette Ã©vÃ¨nement', er.source, er.montant, er.commentaire
                FROM event_recettes er
                JOIN events e ON er.event_id = e.id
            UNION ALL
            SELECT date_depense as date, 'DÃ©pense rÃ©guliÃ¨re', categorie, -montant, commentaire AS justificatif FROM depenses_regulieres
            UNION ALL
            SELECT date_depense as date, 'DÃ©pense diverse', commentaire, -montant, commentaire AS justificatif FROM depenses_diverses
            UNION ALL
            SELECT e.date as date, 'DÃ©pense Ã©vÃ¨nement', ed.categorie, -ed.montant, ed.commentaire
                FROM event_depenses ed
                JOIN events e ON ed.event_id = e.id
            ORDER BY date
        """, conn)
        # Ajout du solde progressif avec solde d'ouverture
        df = df.copy()
        try:
            df["montant"] = df["montant"].astype(float)
        except Exception:
            pass
        df["Solde"] = df["montant"].cumsum() + solde_ouverture
        self.df = df
        self.solde_ouverture = solde_ouverture
        self.populate_table(self.df)
        conn.close()

    def populate_table(self, df):
        self.tree.delete(*self.tree.get_children())
        total = self.solde_ouverture
        total_recettes = 0
        total_depenses = 0
        for _, row in df.iterrows():
            montant = row["montant"]
            try:
                montant_float = float(montant)
            except Exception:
                montant_float = 0
            total += montant_float
            if montant_float > 0:
                total_recettes += montant_float
            else:
                total_depenses += montant_float  # nÃ©gatif
            # Couleur selon type
            tags = []
            if montant_float > 0:
                tags.append("recette")
            elif montant_float < 0:
                tags.append("depense")
            self.tree.insert(
                "", "end",
                values=(row["date"], row["type"], row["libelle"], f"{montant_float:.2f}", row["justificatif"]),
                tags=tags
            )
        self.tree.tag_configure('depense', background="#ffeaea")
        self.tree.tag_configure('recette', background="#eaffea")
        self.solde_ouv_var.set(f"Solde d'ouverture : {self.solde_ouverture:.2f} â‚¬")
        self.total_var.set(f"Solde global : {total:.2f} â‚¬")
        self.recette_var.set(f"Total recettes : {total_recettes:.2f} â‚¬")
        self.depense_var.set(f"Total dÃ©penses : {abs(total_depenses):.2f} â‚¬")

    def apply_filter(self):
        term = self.search_var.get().lower()
        if not term:
            self.populate_table(self.df)
            return
        mask = self.df.apply(lambda row: row.astype(str).str.lower().str.contains(term).any(), axis=1)
        filtered = self.df[mask]
        self.populate_table(filtered)

    def clear_filter(self):
        self.search_var.set("")
        self.populate_table(self.df)

    def export_excel(self):
        if hasattr(self, 'df') and not self.df.empty:
            export_dataframe_to_excel(self.df, title="Export Excel - Journal GÃ©nÃ©ral")

    def export_pdf(self):
        if hasattr(self, 'df') and not self.df.empty:
            export_dataframe_to_pdf(self.df, title="Export PDF - Journal GÃ©nÃ©ral")

    def export_csv(self):
        if hasattr(self, 'df') and not self.df.empty:
            export_dataframe_to_csv(self.df, title="Export CSV - Journal GÃ©nÃ©ral")

    def show_detail(self, event):
        item = self.tree.identify_row(event.y)
        if item:
            vals = self.tree.item(item)['values']
            cols = ["Date", "Type", "LibellÃ©", "Montant (â‚¬)", "Justificatif/Commentaire"]
            tk.messagebox.showinfo("DÃ©tail Ã©criture", "\n".join(f"{c} : {v}" for c, v in zip(cols, vals)))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/members.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection
import pandas as pd
from utils.validation import is_email, is_required
from utils.app_logger import get_logger
from utils.error_handler import handle_exception

STATUTS = [
    "PrÃ©sidente", "PrÃ©sident", "Vice-PrÃ©sidente", "Vice-PrÃ©sident",
    "SecrÃ©taire", "SecrÃ©taire-Adjointe", "SecrÃ©taire-Adjoint",
    "TrÃ©soriÃ¨re", "TrÃ©sorier", "TrÃ©soriÃ¨re-Adjointe", "TrÃ©sorier-Adjoint",
    "Membre"
]
COTISATION_ETATS = ["RÃ©glÃ©", "Non rÃ©glÃ©", "ExemptÃ©"]

logger = get_logger("members_module")

class MembersModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Gestion des Membres")
        self.top.geometry("980x520")
        self.create_table()
        self.create_buttons()
        self.refresh_members()

    def create_table(self):
        columns = (
            "id", "name", "prenom", "email", "cotisation", "commentaire",
            "telephone", "statut", "date_adhesion"
        )
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings")
        headings = [
            ("ID", 40), ("Name", 140), ("PrÃ©nom", 130), ("Email", 180),
            ("Cotisation", 90), ("Commentaire", 140),
            ("TÃ©lÃ©phone", 110), ("Statut", 110), ("Date adhÃ©sion", 110)
        ]
        for idx, (col, w) in enumerate(zip(columns, [h[1] for h in headings])):
            self.tree.heading(col, text=headings[idx][0])
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True)
        vsb = ttk.Scrollbar(self.top, orient="vertical", command=self.tree.yview)
        vsb.pack(side='right', fill='y')
        self.tree.configure(yscroll=vsb.set)

    def create_buttons(self):
        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=8)
        tk.Button(btn_frame, text="Ajouter membre", command=self.add_member).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Modifier", command=self.edit_member).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_member).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Exporter CSV", command=self.export_csv).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=10)

    def refresh_members(self):
        try:
            for row in self.tree.get_children():
                self.tree.delete(row)
            conn = get_connection()
            df = pd.read_sql_query("SELECT * FROM membres ORDER BY name, prenom", conn)
            self.df = df
            for _, row in df.iterrows():
                self.tree.insert(
                    "", "end",
                    values=(
                        row["id"], row["name"], row["prenom"], row["email"], row.get("cotisation", ""),
                        row.get("commentaire", ""), row.get("telephone", ""), row.get("statut", ""),
                        row.get("date_adhesion", "")
                    )
                )
            conn.close()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'affichage des membres."))

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_member(self):
        EditMemberDialog(self.top, member_id=None, on_save=self.refresh_members)

    def edit_member(self):
        mid = self.get_selected_id()
        if not mid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un membre Ã  modifier.")
            return
        EditMemberDialog(self.top, member_id=mid, on_save=self.refresh_members)

    def delete_member(self):
        mid = self.get_selected_id()
        if not mid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un membre Ã  supprimer.")
            return
        if not messagebox.askyesno("Confirmer", "ÃŠtes-vous sÃ»r de vouloir supprimer ce membre ?"):
            return
        confirm = simpledialog.askstring(
            "Confirmation",
            "Retapez SUPPRIMER pour confirmer la suppression du membre :",
            parent=self.top
        )
        if (confirm or "").strip().upper() != "SUPPRIMER":
            messagebox.showinfo("AnnulÃ©", "Suppression annulÃ©e.")
            return
        try:
            conn = get_connection()
            conn.execute("DELETE FROM membres WHERE id=?", (mid,))
            conn.commit()
            conn.close()
            logger.info(f"Membre supprimÃ© id {mid}")
            self.refresh_members()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de la suppression du membre."))

    def export_csv(self):
        from tkinter import filedialog
        from utils.csv_helpers import write_csv
        try:
            filepath = filedialog.asksaveasfilename(
                title="Exporter membres en CSV",
                defaultextension=".csv",
                filetypes=[("CSV", "*.csv")]
            )
            if not filepath:
                return
            df = getattr(self, "df", None)
            if df is not None and not df.empty:
                write_csv(filepath, df.values.tolist(), header=list(df.columns))
                messagebox.showinfo("Export CSV", f"Export rÃ©ussi dans {filepath}")
            else:
                messagebox.showwarning("Alerte", "Aucun membre Ã  exporter.")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'export CSV."))

class EditMemberDialog(tk.Toplevel):
    def __init__(self, master, member_id=None, on_save=None):
        super().__init__(master)
        self.title("Membre" if member_id is None else "Modifier membre")
        self.member_id = member_id
        self.on_save = on_save
        self.geometry("420x440")
        self.resizable(False, False)

        self.nom_var = tk.StringVar()
        self.prenom_var = tk.StringVar()
        self.email_var = tk.StringVar()
        self.cotisation_var = tk.StringVar()
        self.commentaire_var = tk.StringVar()
        self.tel_var = tk.StringVar()
        self.statut_var = tk.StringVar()
        self.date_var = tk.StringVar()

        tk.Label(self, text="Name :").pack(pady=4)
        tk.Entry(self, textvariable=self.nom_var, width=30).pack()
        tk.Label(self, text="PrÃ©nom :").pack(pady=4)
        tk.Entry(self, textvariable=self.prenom_var, width=30).pack()
        tk.Label(self, text="Email :").pack(pady=4)
        tk.Entry(self, textvariable=self.email_var, width=35).pack()
        tk.Label(self, text="Cotisation :").pack(pady=4)
        cotisation_menu = ttk.Combobox(
            self, textvariable=self.cotisation_var, values=COTISATION_ETATS, state="readonly", width=16
        )
        cotisation_menu.pack()
        tk.Label(self, text="Commentaire :").pack(pady=4)
        tk.Entry(self, textvariable=self.commentaire_var, width=35).pack()
        tk.Label(self, text="TÃ©lÃ©phone :").pack(pady=4)
        tk.Entry(self, textvariable=self.tel_var, width=18).pack()
        tk.Label(self, text="Statut :").pack(pady=4)
        statut_menu = ttk.Combobox(
            self, textvariable=self.statut_var, values=STATUTS, state="readonly", width=24
        )
        statut_menu.pack()
        tk.Label(self, text="Date adhÃ©sion (YYYY-MM-DD) :").pack(pady=4)
        tk.Entry(self, textvariable=self.date_var, width=20).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=36, pady=16)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=36, pady=16)

        if self.member_id is not None:
            self.load_member()

    def load_member(self):
        try:
            conn = get_connection()
            row = conn.execute(
                "SELECT name, prenom, email, cotisation, commentaire, telephone, statut, date_adhesion FROM membres WHERE id=?",
                (self.member_id,)
            ).fetchone()
            conn.close()
            if row is not None:
                self.nom_var.set(row[0])
                self.prenom_var.set(row[1])
                self.email_var.set(row[2] if row[2] else "")
                self.cotisation_var.set(row[3] if row[3] else COTISATION_ETATS[1])  # dÃ©faut: "Non rÃ©glÃ©"
                self.commentaire_var.set(row[4] if row[4] else "")
                self.tel_var.set(row[5] if row[5] else "")
                self.statut_var.set(row[6] if row[6] else STATUTS[0])
                self.date_var.set(row[7] if row[7] else "")
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors du chargement du membre."))

    def save(self):
        name = self.nom_var.get().strip()
        prenom = self.prenom_var.get().strip()
        email = self.email_var.get().strip()
        cotisation = self.cotisation_var.get().strip()
        commentaire = self.commentaire_var.get().strip()
        tel = self.tel_var.get().strip()
        statut = self.statut_var.get().strip()
        date_adh = self.date_var.get().strip()
        if not is_required(name) or not is_required(prenom) or not is_required(date_adh):
            messagebox.showerror("Erreur", "Name, prÃ©nom et date d'adhÃ©sion sont obligatoires.")
            return
        if not cotisation:
            cotisation = COTISATION_ETATS[1]  # dÃ©faut: "Non rÃ©glÃ©"
        if not statut:
            statut = STATUTS[0]
        if email and not is_email(email):
            messagebox.showerror("Erreur", "Email invalide.")
            return
        try:
            conn = get_connection()
            if self.member_id is not None:
                conn.execute(
                    "UPDATE membres SET name=?, prenom=?, email=?, cotisation=?, commentaire=?, telephone=?, statut=?, date_adhesion=? WHERE id=?",
                    (name, prenom, email, cotisation, commentaire, tel, statut, date_adh, self.member_id)
                )
            else:
                conn.execute(
                    "INSERT INTO membres (name, prenom, email, cotisation, commentaire, telephone, statut, date_adhesion) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                    (name, prenom, email, cotisation, commentaire, tel, statut, date_adh)
                )
            conn.commit()
            conn.close()
            if self.on_save:
                self.on_save()
            self.destroy()
        except Exception as e:
            messagebox.showerror("Erreur", handle_exception(e, "Erreur lors de l'enregistrement du membre."))
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/model_colonnes.py ===

```python
"""
Module pour la gestion centralisÃ©e des modÃ¨les de colonnes et de leurs listes de choix.
Utilise les tables colonnes_modeles et valeurs_modeles_colonnes pour cohÃ©rence avec le reste de l'application.
"""
import tkinter as tk
from tkinter import ttk, simpledialog, messagebox
from db.db import get_connection

def create_tables_if_needed():
    conn = get_connection()
    conn.execute("""
        CREATE TABLE IF NOT EXISTS colonnes_modeles (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE NOT NULL,
            type_modele TEXT DEFAULT 'TEXT'
        )
    """)
    conn.execute("""
        CREATE TABLE IF NOT EXISTS valeurs_modeles_colonnes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            modele_id INTEGER,
            valeur TEXT,
            FOREIGN KEY(modele_id) REFERENCES colonnes_modeles(id)
        )
    """)
    conn.commit()
    conn.close()

def get_colonnes_connues():
    conn = get_connection()
    res = conn.execute("SELECT * FROM colonnes_modeles ORDER BY name").fetchall()
    conn.close()
    return res

def get_choix_pour_colonne(modele_id):
    conn = get_connection()
    res = conn.execute("SELECT valeur FROM valeurs_modeles_colonnes WHERE modele_id=? ORDER BY valeur", (modele_id,)).fetchall()
    conn.close()
    return [r['valeur'] for r in res]

def ajouter_modele_colonne(name, typ, valeurs):
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("INSERT OR IGNORE INTO colonnes_modeles (name, type_modele) VALUES (?, ?)", (name, typ))
    modele_id = cur.execute("SELECT id FROM colonnes_modeles WHERE name=?", (name,)).fetchone()["id"]
    # Efface anciennes valeurs
    cur.execute("DELETE FROM valeurs_modeles_colonnes WHERE modele_id=?", (modele_id,))
    for v in valeurs:
        cur.execute("INSERT INTO valeurs_modeles_colonnes (modele_id, valeur) VALUES (?, ?)", (modele_id, v))
    conn.commit()
    conn.close()

class GestionModelColonnes(tk.Toplevel):
    def __init__(self, master):
        super().__init__(master)
        self.title("Gestion des modÃ¨les de colonnes")
        self.geometry("650x420")
        self.minsize(400, 200)
        self.maxsize(900, 600)
        create_tables_if_needed()
        self.frame = tk.Frame(self)
        self.frame.pack(fill="both", expand=True, padx=10, pady=10)
        self.refresh_list()
        btns = tk.Frame(self)
        btns.pack(fill="x")
        tk.Button(btns, text="Ajouter un modÃ¨le", command=self.ajouter).pack(side="left", padx=5, pady=8)
        tk.Button(btns, text="Fermer", command=self.destroy).pack(side="right", padx=5, pady=8)

    def refresh_list(self):
        for w in self.frame.winfo_children():
            w.destroy()
        tk.Label(self.frame, text="ModÃ¨les existants :", font=("Arial", 10, "bold")).pack(anchor="w", pady=(0, 6))
        colonnes = get_colonnes_connues()
        for c in colonnes:
            frm = tk.Frame(self.frame)
            frm.pack(fill="x", pady=2, anchor="w")
            tk.Label(frm, text=f"{c['name']} ({c['type_modele']})", anchor="w").pack(side="left")
            choix = get_choix_pour_colonne(c["id"])
            if choix:
                tk.Button(frm, text="Voir la liste", command=lambda cid=c["id"]: self.voir_liste_choix(cid)).pack(side="left", padx=4)
            tk.Button(frm, text="Modifier", command=lambda cid=c['id']: self.modifier(cid)).pack(side="left", padx=2)
            tk.Button(frm, text="Supprimer", command=lambda cid=c['id']: self.supprimer(cid)).pack(side="left", padx=2)

    def ajouter(self):
        ModeleColonneDialog(self, callback=self.refresh_list)

    def modifier(self, modele_id):
        ModeleColonneDialog(self, modele_id=modele_id, callback=self.refresh_list)

    def supprimer(self, modele_id):
        if messagebox.askyesno("Suppression", "Supprimer ce modÃ¨le ?"):
            conn = get_connection()
            conn.execute("DELETE FROM colonnes_modeles WHERE id=?", (modele_id,))
            conn.execute("DELETE FROM valeurs_modeles_colonnes WHERE modele_id=?", (modele_id,))
            conn.commit()
            conn.close()
            self.refresh_list()

    def voir_liste_choix(self, modele_id):
        choix = get_choix_pour_colonne(modele_id)
        txt = "\n".join(choix) if choix else "(Aucun choix enregistrÃ©)"
        top = tk.Toplevel(self)
        top.title("Liste des choix")
        top.geometry("350x300")
        tk.Label(top, text="Valeurs possibles :", font=("Arial", 10, "bold")).pack(pady=8)
        text = tk.Text(top, height=15, width=40)
        text.pack(padx=8, pady=8)
        text.insert("1.0", txt)
        text.config(state="disabled")
        tk.Button(top, text="Fermer", command=top.destroy).pack(pady=8)

class ModeleColonneDialog(tk.Toplevel):
    def __init__(self, master, modele_id=None, callback=None):
        super().__init__(master)
        self.callback = callback
        self.modele_id = modele_id
        self.title("Ajout/modification modÃ¨le colonne")
        self.geometry("400x240")
        self.nom_var = tk.StringVar()
        self.type_var = tk.StringVar(value="TEXT")
        self.valeurs_var = tk.StringVar()
        if modele_id:
            self.load_colonne(modele_id)
        tk.Label(self, text="Name colonne :").pack()
        tk.Entry(self, textvariable=self.nom_var).pack(fill="x", padx=8)
        tk.Label(self, text="Type :").pack()
        ttk.Combobox(self, textvariable=self.type_var, values=["TEXT", "INTEGER", "REAL"]).pack(fill="x", padx=8)
        tk.Label(self, text="Valeurs possibles (sÃ©parÃ©es par ;) :").pack()
        tk.Entry(self, textvariable=self.valeurs_var).pack(fill="x", padx=8)
        btns = tk.Frame(self)
        btns.pack(fill="x", pady=8)
        tk.Button(btns, text="Valider", command=self.valider).pack(side="left", padx=6)
        tk.Button(btns, text="Annuler", command=self.destroy).pack(side="right", padx=6)

    def load_colonne(self, modele_id):
        conn = get_connection()
        c = conn.execute("SELECT * FROM colonnes_modeles WHERE id=?", (modele_id,)).fetchone()
        self.nom_var.set(c["name"])
        self.type_var.set(c["type_modele"])
        choix = get_choix_pour_colonne(modele_id)
        self.valeurs_var.set(";".join(choix))
        conn.close()

    def valider(self):
        name = self.nom_var.get().strip()
        typ = self.type_var.get()
        valeurs = [v.strip() for v in self.valeurs_var.get().split(";") if v.strip()]
        if not name:
            messagebox.showerror("Erreur", "Name requis")
            return
        ajouter_modele_colonne(name, typ, valeurs)
        if self.callback:
            self.callback()
        self.destroy()

# FenÃªtre dâ€™ajout de colonne avec menu dÃ©roulant pour les modÃ¨les connus
def ask_add_custom_column(parent):
    create_tables_if_needed()
    colonnes = get_colonnes_connues()
    noms_colonnes = [c["name"] for c in colonnes]
    dlg = AddCustomColumnDialog(parent, noms_colonnes, colonnes)
    parent.wait_window(dlg)
    return dlg.result if hasattr(dlg, "result") else None

class AddCustomColumnDialog(tk.Toplevel):
    def __init__(self, master, noms_colonnes, colonnes):
        super().__init__(master)
        self.title("Ajouter une colonne")
        self.geometry("400x250")
        self.result = None
        self.colonnes = colonnes
        self.nom_var = tk.StringVar()
        self.type_var = tk.StringVar(value="TEXT")
        self.choix_var = tk.StringVar()
        self.choix_values = []
        self.choice_combobox = None
        self.selected_modele_colonne = None

        tk.Label(self, text="Name de colonne :").pack(anchor="w")
        self.combo_nom = ttk.Combobox(self, textvariable=self.nom_var, values=noms_colonnes)
        self.combo_nom.pack(fill="x", padx=8, pady=2)
        self.combo_nom.bind("<<ComboboxSelected>>", self.on_nom_selected)
        self.combo_nom.bind("<KeyRelease>", self.on_nom_typed)

        tk.Label(self, text="Type :").pack(anchor="w")
        self.combo_type = ttk.Combobox(self, textvariable=self.type_var, values=["TEXT", "INTEGER", "REAL"])
        self.combo_type.pack(fill="x", padx=8, pady=2)

        self.choix_frame = tk.Frame(self)
        self.choix_frame.pack(fill="x", padx=4, pady=4)

        btns = tk.Frame(self)
        btns.pack(fill="x", pady=8)
        tk.Button(btns, text="Valider", command=self.on_validate).pack(side="left", padx=6)
        tk.Button(btns, text="Annuler", command=self.destroy).pack(side="right", padx=6)
        tk.Button(btns, text="GÃ©rer les modÃ¨les", command=lambda: GestionModelColonnes(self)).pack(side="right", padx=6)

    def clear_choix(self):
        for w in self.choix_frame.winfo_children():
            w.destroy()
        self.choix_values = []
        self.choice_combobox = None
        self.selected_modele_colonne = None

    def on_nom_selected(self, event=None):
        name = self.nom_var.get()
        self.clear_choix()
        col = next((c for c in self.colonnes if c["name"] == name), None)
        if col:
            self.type_var.set(col["type_modele"])
            self.selected_modele_colonne = col["name"]  # Correction : mÃ©morise le modÃ¨le de colonne sÃ©lectionnÃ©
            choix = get_choix_pour_colonne(col["id"])
            if choix:
                tk.Label(self.choix_frame, text="Valeur Ã  choisir :", font=("Arial", 10, "bold")).pack(anchor="w")
                self.choice_combobox = ttk.Combobox(self.choix_frame, values=choix, textvariable=self.choix_var)
                self.choice_combobox.pack(fill="x", padx=6, pady=2)
                self.choix_values = choix
        else:
            self.type_var.set("TEXT")
            self.selected_modele_colonne = None

    def on_nom_typed(self, event=None):
        # Si saisie libre (name non connu), effacer champ choix
        if self.nom_var.get() not in [c["name"] for c in self.colonnes]:
            self.clear_choix()
            self.type_var.set("TEXT")
            self.selected_modele_colonne = None

    def on_validate(self):
        name = self.nom_var.get().strip()
        typ = self.type_var.get().strip()
        valeur_choisie = self.choix_var.get().strip() if self.choice_combobox else None
        if not name:
            messagebox.showerror("Erreur", "Name de colonne requis")
            return
        result = {"name": name, "type": typ}
        # Correction : toujours transmettre le modele_colonne si c'est un modÃ¨le connu
        if self.selected_modele_colonne:
            result["modele_colonne"] = self.selected_modele_colonne
        else:
            result["modele_colonne"] = None
        if self.choice_combobox and valeur_choisie:
            result["valeur_choisie"] = valeur_choisie
        self.result = result
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/mouvements_stock.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
from db.db import get_connection
import pandas as pd

class MouvementsStockModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Historique des mouvements de stock")
        self.top.geometry("1000x550")
        self.create_table()
        self.refresh_mouvements()

    def create_table(self):
        columns = ("id", "date", "name", "type", "quantite", "prix_achat_total", "prix_unitaire", "date_peremption", "commentaire")
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings")
        for col, text, w in zip(
            columns,
            ["ID", "Date", "Article", "Type", "QuantitÃ©", "Prix total", "Prix unitaire", "Date pÃ©remption", "Commentaire"],
            [40, 100, 160, 70, 80, 90, 90, 110, 220]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True)
        vsb = ttk.Scrollbar(self.top, orient="vertical", command=self.tree.yview)
        vsb.pack(side='right', fill='y')
        self.tree.configure(yscroll=vsb.set)
        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=8)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=10)

    def refresh_mouvements(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        df = pd.read_sql_query("""
            SELECT m.id, m.date, s.name, m.type, m.quantite, m.prix_achat_total, m.prix_unitaire, m.date_peremption, m.commentaire
            FROM mouvements_stock m
            LEFT JOIN stock s ON m.stock_id = s.id
            ORDER BY m.date DESC, m.id DESC
        """, conn)
        for _, row in df.iterrows():
            self.tree.insert(
                "", "end",
                values=(
                    row["id"], row["date"], row["name"], row["type"], row["quantite"],
                    f"{row['prix_achat_total']:.2f}" if pd.notnull(row['prix_achat_total']) else "",
                    f"{row['prix_unitaire']:.2f}" if pd.notnull(row['prix_unitaire']) else "",
                    row["date_peremption"] if pd.notnull(row["date_peremption"]) else "",
                    row["commentaire"] if pd.notnull(row["commentaire"]) else ""
                )
            )
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/retrocessions_ecoles.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
from db.db import get_connection

class RetrocessionsEcolesModule(tk.Toplevel):
    def __init__(self, master=None):
        super().__init__(master)
        self.title("RÃ©trocessions aux Ã©coles")
        self.geometry("560x420")
        self.resizable(False, False)
        self.create_widgets()
        self.refresh_list()

    def create_widgets(self):
        frame = tk.Frame(self)
        frame.pack(fill=tk.BOTH, expand=True, padx=12, pady=10)

        self.tree = ttk.Treeview(frame, columns=("id", "date", "ecole", "montant", "commentaire"), show="headings", selectmode="browse")
        for col, txt, w in zip(
            ("id", "date", "ecole", "montant", "commentaire"),
            ["ID", "Date", "Ã‰cole", "Montant (â‚¬)", "Commentaire"],
            [40, 90, 140, 100, 160]
        ):
            self.tree.heading(col, text=txt)
            self.tree.column(col, width=w)
        self.tree.pack(fill=tk.BOTH, expand=True, pady=6)

        btns = tk.Frame(frame)
        btns.pack(fill=tk.X, pady=10)
        tk.Button(btns, text="Ajouter", command=self.add_retro).pack(side=tk.LEFT, padx=6)
        tk.Button(btns, text="Modifier", command=self.edit_retro).pack(side=tk.LEFT, padx=6)
        tk.Button(btns, text="Supprimer", command=self.delete_retro).pack(side=tk.LEFT, padx=6)
        tk.Button(btns, text="Fermer", command=self.destroy).pack(side=tk.RIGHT, padx=6)

    def refresh_list(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        rows = conn.execute(
            "SELECT id, date, ecole, montant, commentaire FROM retrocessions_ecoles ORDER BY date DESC"
        ).fetchall()
        for r in rows:
            self.tree.insert("", "end", values=(r["id"], r["date"], r["ecole"], f"{r['montant']:.2f}", r["commentaire"]))
        conn.close()

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez une ligne.")
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_retro(self):
        self.edit_retro_form()

    def edit_retro(self):
        cid = self.get_selected_id()
        if not cid:
            return
        conn = get_connection()
        old = conn.execute("SELECT * FROM retrocessions_ecoles WHERE id=?", (cid,)).fetchone()
        conn.close()
        if not old:
            return
        self.edit_retro_form(old)

    def edit_retro_form(self, data=None):
        win = tk.Toplevel(self)
        win.title("RÃ©trocession" + (" - Modifier" if data else " - Ajouter"))
        win.geometry("350x290")
        win.grab_set()

        tk.Label(win, text="Date (YYYY-MM-DD)").pack(pady=(16,2))
        date_var = tk.StringVar(value=data["date"] if data else "")
        tk.Entry(win, textvariable=date_var).pack()

        tk.Label(win, text="Ã‰cole").pack(pady=(12,2))
        ecole_var = tk.StringVar(value=data["ecole"] if data else "")
        tk.Entry(win, textvariable=ecole_var).pack()

        tk.Label(win, text="Montant (â‚¬)").pack(pady=(12,2))
        montant_var = tk.StringVar(value=f"{data['montant']:.2f}" if data else "")
        tk.Entry(win, textvariable=montant_var).pack()

        tk.Label(win, text="Commentaire").pack(pady=(12,2))
        comm_var = tk.StringVar(value=data["commentaire"] if data else "")
        tk.Entry(win, textvariable=comm_var).pack()

        def valider():
            date = date_var.get().strip()
            ecole = ecole_var.get().strip()
            montant = montant_var.get().replace(",", ".").strip()
            commentaire = comm_var.get().strip()
            try:
                montant_float = float(montant)
            except Exception:
                messagebox.showerror("Erreur", "Montant invalide.")
                return
            if not (date and ecole):
                messagebox.showerror("Erreur", "Date et Ã©cole obligatoires.")
                return
            conn = get_connection()
            if data:
                conn.execute("UPDATE retrocessions_ecoles SET date=?, ecole=?, montant=?, commentaire=? WHERE id=?",
                             (date, ecole, montant_float, commentaire, data["id"]))
            else:
                conn.execute("INSERT INTO retrocessions_ecoles (date, ecole, montant, commentaire) VALUES (?, ?, ?, ?)",
                             (date, ecole, montant_float, commentaire))
            conn.commit()
            conn.close()
            win.destroy()
            self.refresh_list()

        tk.Button(win, text="Valider", command=valider).pack(pady=16)
        tk.Button(win, text="Annuler", command=win.destroy).pack()
        win.wait_window()

    def delete_retro(self):
        cid = self.get_selected_id()
        if not cid:
            return
        if not messagebox.askyesno("Supprimer", "Supprimer cette rÃ©trocession ?"):
            return
        conn = get_connection()
        conn.execute("DELETE FROM retrocessions_ecoles WHERE id=?", (cid,))
        conn.commit()
        conn.close()
        self.refresh_list()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/solde_ouverture.py ===

```python
import tkinter as tk
from tkinter import messagebox
from db.db import get_connection

class SoldeOuvertureDialog(tk.Toplevel):
    def __init__(self, master, on_save=None):
        super().__init__(master)
        self.title("Solde d'ouverture bancaire")
        self.geometry("380x180")
        self.resizable(False, False)
        self.on_save = on_save

        tk.Label(self, text="Solde d'ouverture bancaire en dÃ©but d'exercice :", font=("Arial", 12)).pack(pady=16)
        self.solde_var = tk.StringVar()
        tk.Entry(self, textvariable=self.solde_var, font=("Arial", 14), width=16, justify="center").pack(pady=6)

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=16)
        tk.Button(btn_frame, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=20)
        tk.Button(btn_frame, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=20)

        self.load_solde()

    def load_solde(self):
        conn = get_connection()
        row = conn.execute("SELECT solde_report FROM config ORDER BY id DESC LIMIT 1").fetchone()
        conn.close()
        if row and row[0] is not None:
            self.solde_var.set(f"{row[0]:.2f}")
        else:
            self.solde_var.set("0.00")

    def save(self):
        val = self.solde_var.get().replace(",", ".").strip()
        try:
            float_val = float(val)
        except Exception:
            messagebox.showerror("Erreur", "Veuillez saisir un montant valide.")
            return
        conn = get_connection()
        conn.execute("UPDATE config SET solde_report=? WHERE id=(SELECT MAX(id) FROM config)", (float_val,))
        conn.commit()
        conn.close()
        messagebox.showinfo("OK", "Solde d'ouverture mis Ã  jour.")
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/stock.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
import pandas as pd
from db.db import get_connection

class StockModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Gestion du Stock")
        self.top.geometry("1050x600")
        self.create_table()
        self.create_buttons()
        self.refresh_stock()

    def create_table(self):
        columns = ("id", "name", "categorie", "quantite", "seuil_alerte", "date_peremption", "lot", "commentaire")
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings")
        for col, text, w in zip(
            columns,
            ["ID", "Name", "CatÃ©gorie", "QuantitÃ©", "Seuil alerte", "Date pÃ©remption", "Lot", "Commentaire"],
            [40, 160, 120, 80, 95, 100, 95, 220]
        ):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=w, anchor="center")
        self.tree.pack(fill=tk.BOTH, expand=True)
        vsb = ttk.Scrollbar(self.top, orient="vertical", command=self.tree.yview)
        vsb.pack(side='right', fill='y')
        self.tree.configure(yscroll=vsb.set)

    def create_buttons(self):
        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=8)
        tk.Button(btn_frame, text="Ajouter article", command=self.add_stock).pack(side=tk.LEFT, padx=7)
        tk.Button(btn_frame, text="Modifier", command=self.edit_stock).pack(side=tk.LEFT, padx=7)
        tk.Button(btn_frame, text="Supprimer", command=self.delete_stock).pack(side=tk.LEFT, padx=7)
        tk.Button(btn_frame, text="Mouvement stock", command=self.open_mouvements).pack(side=tk.LEFT, padx=7)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=7)

    def refresh_stock(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        conn = get_connection()
        df = pd.read_sql_query("""
            SELECT s.id, s.name, c.name as categorie, s.quantite, s.seuil_alerte, s.date_peremption, s.lot, s.commentaire
            FROM stock s
            LEFT JOIN categories c ON s.categorie_id = c.id
            ORDER BY s.name
        """, conn)
        self.df = df
        for idx, (_, row) in enumerate(df.iterrows()):
            self.tree.insert(
                "", "end",
                values=(
                    row["id"], row["name"], row["categorie"], row["quantite"],
                    row["seuil_alerte"], row["date_peremption"], row["lot"], row["commentaire"]
                )
            )

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            return None
        return self.tree.item(sel[0])["values"][0]

    def add_stock(self):
        StockDialog(self.top, on_save=self.refresh_stock)

    def edit_stock(self):
        sid = self.get_selected_id()
        if not sid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un article Ã  modifier.")
            return
        row = self.df[self.df['id'] == sid].iloc[0]
        StockDialog(self.top, stock=row, on_save=self.refresh_stock)

    def delete_stock(self):
        sid = self.get_selected_id()
        if not sid:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un article Ã  supprimer.")
            return
        if not messagebox.askyesno("Confirmer", "ÃŠtes-vous sÃ»r de vouloir supprimer cet article ?"):
            return
        confirm = simpledialog.askstring("Confirmation", "Retapez SUPPRIMER pour confirmer la suppression de l'article :", parent=self.top)
        if (confirm or "").strip().upper() != "SUPPRIMER":
            messagebox.showinfo("AnnulÃ©", "Suppression annulÃ©e.")
            return
        conn = get_connection()
        conn.execute("DELETE FROM stock WHERE id=?", (sid,))
        conn.commit()
        conn.close()
        self.refresh_stock()

    def open_mouvements(self):
        from modules.mouvements_stock import MouvementsStockModule
        MouvementsStockModule(self.top)

class StockDialog(tk.Toplevel):
    def __init__(self, master, stock=None, on_save=None):
        super().__init__(master)
        self.title("Article" if stock is None else "Modifier article")
        self.stock = stock
        self.on_save = on_save
        self.geometry("420x440")
        self.resizable(False, False)

        self.nom_var = tk.StringVar()
        self.cat_var = tk.StringVar()
        self.qte_var = tk.IntVar()
        self.seuil_var = tk.IntVar()
        self.date_peremp_var = tk.StringVar()
        self.lot_var = tk.StringVar()
        self.comment_var = tk.StringVar()

        tk.Label(self, text="Name :").pack(pady=5)
        tk.Entry(self, textvariable=self.nom_var, width=30).pack()
        tk.Label(self, text="CatÃ©gorie :").pack(pady=5)
        self.cat_cb = ttk.Combobox(self, textvariable=self.cat_var, state="readonly", width=25)
        self.cat_cb.pack()
        self.cat_cb["values"] = self.get_categories()
        tk.Label(self, text="QuantitÃ© :").pack(pady=5)
        tk.Entry(self, textvariable=self.qte_var, width=12).pack()
        tk.Label(self, text="Seuil alerte :").pack(pady=5)
        tk.Entry(self, textvariable=self.seuil_var, width=12).pack()
        tk.Label(self, text="Date pÃ©remption :").pack(pady=5)
        tk.Entry(self, textvariable=self.date_peremp_var, width=15).pack()
        tk.Label(self, text="Lot :").pack(pady=5)
        tk.Entry(self, textvariable=self.lot_var, width=18).pack()
        tk.Label(self, text="Commentaire :").pack(pady=5)
        tk.Entry(self, textvariable=self.comment_var, width=38).pack()

        tk.Button(self, text="Enregistrer", command=self.save).pack(side=tk.LEFT, padx=36, pady=17)
        tk.Button(self, text="Annuler", command=self.destroy).pack(side=tk.RIGHT, padx=36, pady=17)

        if self.stock is not None:
            self.load_stock()

    def get_categories(self):
        conn = get_connection()
        cats = conn.execute("SELECT name FROM categories ORDER BY name").fetchall()
        conn.close()
        return [c["name"] for c in cats]

    def load_stock(self):
        s = self.stock
        self.nom_var.set(s["name"])
        self.cat_var.set(s["categorie"])
        self.qte_var.set(s["quantite"])
        self.seuil_var.set(s["seuil_alerte"])
        self.date_peremp_var.set(s["date_peremption"])
        self.lot_var.set(s["lot"])
        self.comment_var.set(s["commentaire"])

    def save(self):
        name = self.nom_var.get().strip()
        cat = self.cat_var.get().strip()
        qte = self.qte_var.get()
        seuil = self.seuil_var.get()
        datep = self.date_peremp_var.get().strip()
        lot = self.lot_var.get().strip()
        comment = self.comment_var.get().strip()
        if not name:
            messagebox.showerror("Erreur", "Name obligatoire.")
            return
        conn = get_connection()
        cat_id = None
        if cat:
            row = conn.execute("SELECT id FROM categories WHERE name=?", (cat,)).fetchone()
            if row:
                cat_id = row["id"]
        if self.stock is not None:
            conn.execute(
                "UPDATE stock SET name=?, categorie_id=?, quantite=?, seuil_alerte=?, date_peremption=?, lot=?, commentaire=? WHERE id=?",
                (name, cat_id, qte, seuil, datep, lot, comment, self.stock["id"])
            )
        else:
            conn.execute(
                "INSERT INTO stock (name, categorie_id, quantite, seuil_alerte, date_peremption, lot, commentaire) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (name, cat_id, qte, seuil, datep, lot, comment)
            )
        conn.commit()
        conn.close()
        if self.on_save:
            self.on_save()
        self.destroy()
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/stock_inventaire.py ===

```python
import tkinter as tk
from tkinter import ttk, messagebox
import pandas as pd
from db.db import get_connection, DataSource, get_df_or_sql
from dialogs.inventaire_dialog import InventaireDialog

class StockInventaireModule:
    def __init__(self, master, visualisation_mode=False):
        self.master = master
        self.visualisation_mode = visualisation_mode
        self.top = tk.Toplevel(master)
        self.top.title("Inventaire rapide du stock")
        self.top.geometry("950x500")
        self.create_table()
        self.create_buttons()
        self.load_stock()

    def create_table(self):
        columns = ("id", "name", "categorie", "quantite", "nouvelle_quantite")
        self.tree = ttk.Treeview(self.top, columns=columns, show="headings")
        for col, w in zip(columns, [45, 180, 130, 90, 110]):
            self.tree.heading(col, text=col.capitalize())
            self.tree.column(col, width=w)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)

    def create_buttons(self):
        btn_frame = tk.Frame(self.top)
        btn_frame.pack(fill=tk.X, pady=8)
        tk.Button(btn_frame, text="Inventorier", command=self.inventorier, state=tk.DISABLED if self.visualisation_mode else tk.NORMAL).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_frame, text="Fermer", command=self.top.destroy).pack(side=tk.RIGHT, padx=10)

    def load_stock(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        if DataSource.is_visualisation:
            df = get_df_or_sql("stock")
            cat_df = get_df_or_sql("categories")
            df = df.merge(cat_df, left_on="categorie_id", right_on="id", how="left", suffixes=('', '_cat'))
            df['categorie'] = df['nom_cat'].fillna('')
        else:
            conn = get_connection()
            query = """
                SELECT s.id, s.name, c.name as categorie, s.quantite
                FROM stock s
                LEFT JOIN categories c ON s.categorie_id = c.id
                ORDER BY s.name
            """
            df = pd.read_sql_query(query, conn)
            conn.close()
        for _, row in df.iterrows():
            self.tree.insert("", "end", values=(row["id"], row["name"], row.get("categorie", ""), row["quantite"], ""))

    def get_selected_id(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un article.")
            return None
        return self.tree.item(sel[0])["values"][0]

    def inventorier(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("SÃ©lection", "SÃ©lectionnez un article Ã  inventorier.")
            return
        item = self.tree.item(sel[0])
        stock_id = item["values"][0]
        name = item["values"][1]
        quantite = item["values"][3]
        dialog = InventaireDialog(self.top, name, quantite)
        self.top.wait_window(dialog)
        if dialog.result is not None:
            nouvelle_qte = dialog.result
            try:
                nouvelle_qte = int(nouvelle_qte)
            except Exception:
                messagebox.showerror("Erreur", "QuantitÃ© invalide.")
                return
            conn = get_connection()
            conn.execute("UPDATE stock SET quantite=? WHERE id=?", (nouvelle_qte, stock_id))
            conn.commit()
            conn.close()
            self.load_stock()
            messagebox.showinfo("Inventaire", f"QuantitÃ© de Â«Â {name}Â Â» mise Ã  jour.")
```


# ===== FICHIER SUIVANT =====

# === Fichier: modules/stock_stats.py ===

```python
import tkinter as tk
from tkinter import ttk
import pandas as pd
from db.db import get_connection

class StockStatsModule:
    def __init__(self, master):
        self.top = tk.Toplevel(master)
        self.top.title("Statistiques du Stock")
        self.top.geometry("850x480")
        self.show_stats()

    def show_stats(self):
        conn = get_connection()
        df = pd.read_sql_query("""
            SELECT c.name as categorie, COUNT(s.id) as nb_articles, SUM(s.quantite) as total_qte
            FROM stock s
            LEFT JOIN categories c ON s.categorie_id = c.id
            GROUP BY c.name
            ORDER BY c.name
        """, conn)
        conn.close()

        tree = ttk.Treeview(self.top, columns=("categorie", "nb_articles", "total_qte"), show="headings")
        tree.heading("categorie", text="CatÃ©gorie")
        tree.heading("nb_articles", text="Nb buvette_articles")
        tree.heading("total_qte", text="QuantitÃ© totale")
        tree.column("categorie", width=200)
        tree.column("nb_articles", width=100, anchor="center")
        tree.column("total_qte", width=120, anchor="center")
        tree.pack(fill=tk.BOTH, expand=True, padx=12, pady=18)

        for _, row in df.iterrows():
            tree.insert("", "end", values=(row["categorie"], row["nb_articles"], row["total_qte"]))

        tk.Button(self.top, text="Fermer", command=self.top.destroy).pack(pady=10)
```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/analyze_modules_columns.py ===

```python
#!/usr/bin/env python3
"""
Script d'analyse stricte des modules pour dÃ©tecter les tables et colonnes utilisÃ©es.

Ce script parcourt le code Python du projet (modules/, ui/, scripts/, lib/)
et extrait UNIQUEMENT les identifiants SQL valides des requÃªtes SQL pour
produire un rapport dÃ©taillÃ© des schÃ©mas attendus par le code.

Contraintes:
- Utilise un regex strict ^[A-Za-z_][A-Za-z0-9_]*$ pour valider les identifiants SQL
- N'extrait QUE depuis les patterns SQL: INSERT INTO, UPDATE SET, SELECT FROM
- Ignore les tokens de code, appels de fonction, texte UI
- GÃ©nÃ¨re des rapports UTF-8
- Collecte les identifiants invalides pour rapport

Usage:
    python scripts/analyze_modules_columns.py
    
Sortie:
    reports/SQL_SCHEMA_HINTS.md - Rapport lisible avec tables et colonnes dÃ©tectÃ©es
    db/schema_hints.yaml - Manifest machine-readable avec colonnes attendues et types infÃ©rÃ©s
"""

import os
import re
import sys
from collections import defaultdict
from pathlib import Path
from typing import Dict, Set, List, Tuple

# Force UTF-8 encoding for stdout/stderr
try:
    sys.stdout.reconfigure(encoding='utf-8')
    sys.stderr.reconfigure(encoding='utf-8')
except Exception:
    pass

# Valid SQL identifier pattern: starts with letter or underscore, followed by letters, digits, or underscores
SQL_IDENTIFIER_PATTERN = re.compile(r'^[A-Za-z_][A-Za-z0-9_]*$')


class StrictSQLAnalyzer:
    """Analyseur strict de code Python pour extraire UNIQUEMENT les identifiants SQL valides."""
    
    def __init__(self, repo_root):
        self.repo_root = Path(repo_root)
        self.table_columns = defaultdict(lambda: {
            "columns": set(),
            "files": set(),
            "column_types": {}
        })
        self.skipped_identifiers = defaultdict(set)  # Track invalid identifiers
        
        # Patterns pour infÃ©rer les types de colonnes
        self.type_patterns = {
            'REAL': [
                r'(prix|montant|solde|total|cout|tarif|taux|valeur)(_\w+)?$',
                r'(disponible|contenance|quantite)(_\w+)?$',
            ],
            'INTEGER': [
                r'^id(_\w+)?$',
                r'(_id|_count|seuil)$',
                r'^(stock|nombre|count)(_\w+)?$',
            ],
            'TEXT': [
                r'(nom|name|prenom|email|adresse|ville|pays)(_\w+)?$',
                r'(commentaire|description|libelle|categorie)(_\w+)?$',
                r'(type|statut|mode|reference|numero|lot)(_\w+)?$',
                r'(fournisseur|donateur|ecole|banque)(_\w+)?$',
                r'(lieu|unite|facture|motif)(_\w+)?$',
            ],
            'DATE': [
                r'date(_\w+)?$',
            ],
        }
    
    def is_valid_sql_identifier(self, identifier: str) -> bool:
        """VÃ©rifie si un identifiant est un identifiant SQL valide."""
        if not identifier:
            return False
        return SQL_IDENTIFIER_PATTERN.match(identifier) is not None
    
    def infer_column_type(self, column_name: str) -> str:
        """InfÃ¨re le type SQL d'une colonne basÃ© sur son nom."""
        column_lower = column_name.lower()
        
        # Test patterns for each type
        for sql_type, patterns in self.type_patterns.items():
            for pattern in patterns:
                if re.search(pattern, column_lower, re.IGNORECASE):
                    return sql_type
        
        # Default to TEXT if no pattern matches
        return 'TEXT'
    
    def add_table_column(self, table: str, column: str, filepath: str):
        """
        Ajoute une colonne Ã  une table aprÃ¨s validation stricte.
        
        Args:
            table: Nom de la table
            column: Nom de la colonne
            filepath: Fichier source
        """
        # Validate table name
        if not self.is_valid_sql_identifier(table):
            self.skipped_identifiers[filepath].add(f"table:{table}")
            return
        
        # Validate column name
        if not self.is_valid_sql_identifier(column):
            self.skipped_identifiers[filepath].add(f"column:{column} (table:{table})")
            return
        
        # Add to tracking
        self.table_columns[table]["columns"].add(column)
        self.table_columns[table]["files"].add(filepath)
        
        # Infer type if not already set
        if column not in self.table_columns[table]["column_types"]:
            self.table_columns[table]["column_types"][column] = self.infer_column_type(column)
    
    def analyze_file(self, filepath: Path):
        """Analyse un fichier Python pour extraire les rÃ©fÃ©rences SQL strictes."""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            print(f"Warning: Could not read {filepath}: {e}")
            return
        
        relative_path = str(filepath.relative_to(self.repo_root))
        
        # Extract SQL references using strict patterns
        self._extract_insert_statements(content, relative_path)
        self._extract_update_statements(content, relative_path)
        self._extract_select_statements(content, relative_path)
        self._extract_create_table_statements(content, relative_path)
    
    def _extract_insert_statements(self, content: str, filepath: str):
        """Extrait les colonnes depuis INSERT INTO statements."""
        # Pattern: INSERT INTO table_name (col1, col2, col3)
        pattern = r'INSERT\s+INTO\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(([^)]+)\)'
        
        for match in re.finditer(pattern, content, re.IGNORECASE):
            table = match.group(1)
            columns_str = match.group(2)
            
            # Extract individual column names
            columns = [col.strip() for col in columns_str.split(',')]
            
            for col in columns:
                # Remove any whitespace and validate
                col = col.strip()
                if col:
                    self.add_table_column(table, col, filepath)
    
    def _extract_update_statements(self, content: str, filepath: str):
        """Extrait les colonnes depuis UPDATE statements."""
        # Pattern: UPDATE table_name SET col1=?, col2=?
        pattern = r'UPDATE\s+([A-Za-z_][A-Za-z0-9_]*)\s+SET\s+([^;]+?)(?:WHERE|;|$)'
        
        for match in re.finditer(pattern, content, re.IGNORECASE | re.DOTALL):
            table = match.group(1)
            set_clause = match.group(2)
            
            # Extract column names from SET clause (before = sign)
            col_pattern = r'([A-Za-z_][A-Za-z0-9_]*)\s*='
            for col_match in re.finditer(col_pattern, set_clause):
                col = col_match.group(1)
                self.add_table_column(table, col, filepath)
    
    def _extract_select_statements(self, content: str, filepath: str):
        """Extrait les tables depuis SELECT statements (colonnes depuis liste explicite)."""
        # Pattern: SELECT col1, col2 FROM table_name
        # or SELECT * FROM table_name
        pattern = r'SELECT\s+([\w\s,.*()]+?)\s+FROM\s+([A-Za-z_][A-Za-z0-9_]*)'
        
        for match in re.finditer(pattern, content, re.IGNORECASE):
            columns_str = match.group(1).strip()
            table = match.group(2)
            
            # Register the table (even with SELECT *)
            self.table_columns[table]["files"].add(filepath)
            
            # If not SELECT *, try to extract column names
            if '*' not in columns_str:
                # Extract column names (simple identifier extraction)
                col_pattern = r'\b([A-Za-z_][A-Za-z0-9_]*)\b'
                for col_match in re.finditer(col_pattern, columns_str):
                    col = col_match.group(1)
                    # Skip SQL keywords that might appear
                    if col.upper() not in ('AS', 'FROM', 'SELECT', 'DISTINCT', 'COUNT', 'MAX', 'MIN', 'SUM', 'AVG'):
                        self.add_table_column(table, col, filepath)
    
    def _extract_create_table_statements(self, content: str, filepath: str):
        """Extrait les colonnes depuis CREATE TABLE statements."""
        # Pattern: CREATE TABLE [IF NOT EXISTS] table_name (columns...)
        pattern = r'CREATE\s+TABLE(?:\s+IF\s+NOT\s+EXISTS)?\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(([^;]+)\)'
        
        for match in re.finditer(pattern, content, re.IGNORECASE | re.DOTALL):
            table = match.group(1)
            columns_def = match.group(2)
            
            # Register table
            self.table_columns[table]["files"].add(filepath)
            
            # Parse column definitions
            # Split by comma, but be careful of constraints
            for line in columns_def.split(','):
                line = line.strip()
                if not line:
                    continue
                
                # Skip constraint definitions
                if line.upper().startswith(('PRIMARY', 'FOREIGN', 'UNIQUE', 'CHECK', 'CONSTRAINT')):
                    continue
                
                # Extract column name (first word) and type (second word)
                parts = line.split()
                if parts:
                    col_name = parts[0].strip()
                    
                    # Extract type if present
                    col_type = None
                    if len(parts) > 1:
                        type_str = parts[1].upper()
                        if 'INTEGER' in type_str or 'INT' in type_str:
                            col_type = 'INTEGER'
                        elif 'REAL' in type_str or 'FLOAT' in type_str or 'DOUBLE' in type_str:
                            col_type = 'REAL'
                        elif 'TEXT' in type_str or 'VARCHAR' in type_str or 'CHAR' in type_str:
                            col_type = 'TEXT'
                        elif 'DATE' in type_str or 'TIME' in type_str:
                            col_type = 'TEXT'  # SQLite stores dates as TEXT
                    
                    # Add column (validation happens in add_table_column)
                    if self.is_valid_sql_identifier(col_name):
                        self.add_table_column(table, col_name, filepath)
                        # Use explicit type from CREATE TABLE if available
                        if col_type:
                            self.table_columns[table]["column_types"][col_name] = col_type
    
    def scan_directories(self, dirs: List[str]):
        """Parcourt les rÃ©pertoires et analyse tous les fichiers Python."""
        for directory in dirs:
            dir_path = self.repo_root / directory
            if not dir_path.exists():
                print(f"Warning: Directory {directory} does not exist")
                continue
            
            print(f"Scanning {directory}...")
            for py_file in dir_path.rglob("*.py"):
                self.analyze_file(py_file)
    
    def generate_yaml_manifest(self, output_file: Path):
        """GÃ©nÃ¨re un manifest YAML simple avec colonnes et types infÃ©rÃ©s."""
        
        with open(output_file, 'w', encoding='utf-8') as f:
            # Write header
            f.write("# Schema Hints for Database Migration\n")
            f.write("# Generated by analyze_modules_columns.py\n")
            f.write("#\n")
            f.write("# This file contains expected columns extracted from SQL queries in the code.\n")
            f.write("# You can manually add overrides or aliases in the 'manual_overrides' section.\n")
            f.write("#\n")
            f.write("# Format:\n")
            f.write("#   tables:\n")
            f.write("#     table_name:\n")
            f.write("#       expected_columns:\n")
            f.write("#         column_name:\n")
            f.write("#           type: TEXT|INTEGER|REAL|DATE\n")
            f.write("#           inferred: true|false\n")
            f.write("#\n")
            f.write("# Manual overrides example:\n")
            f.write("#   manual_overrides:\n")
            f.write("#     table_name:\n")
            f.write("#       column_aliases:\n")
            f.write("#         old_name: new_name\n")
            f.write("#       forced_types:\n")
            f.write("#         column_name: REAL\n")
            f.write("\n")
            
            f.write("schema_version: \"1.0\"\n")
            f.write("generated_by: \"analyze_modules_columns.py\"\n")
            f.write("\ntables:\n")
            
            # Write tables
            for table in sorted(self.table_columns.keys()):
                info = self.table_columns[table]
                
                if not info["columns"]:
                    continue
                
                f.write(f"  {table}:\n")
                f.write(f"    expected_columns:\n")
                
                # Write columns
                for col in sorted(info["columns"]):
                    col_type = info["column_types"].get(col, 'TEXT')
                    f.write(f"      {col}:\n")
                    f.write(f"        type: {col_type}\n")
                    f.write(f"        inferred: true\n")
            
            # Add placeholder for manual overrides
            f.write("\n# Manual overrides (edit this section to add custom mappings)\n")
            f.write("manual_overrides: {}\n")
        
        print(f"YAML manifest generated: {output_file}")
    
    def generate_report(self, output_file: Path):
        """GÃ©nÃ¨re un rapport Markdown des tables et colonnes dÃ©tectÃ©es."""
        
        sorted_tables = sorted(self.table_columns.keys())
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Analyse SQL - Tables et Colonnes Detectees\n\n")
            f.write("Ce rapport liste toutes les tables et colonnes referencees dans le code Python.\n")
            f.write("Il sert de reference pour les migrations et la maintenance du schema de base de donnees.\n\n")
            f.write(f"**Nombre total de tables detectees:** {len(sorted_tables)}\n\n")
            
            f.write("## Resume par Table\n\n")
            for table in sorted_tables:
                info = self.table_columns[table]
                col_count = len(info["columns"])
                file_count = len(info["files"])
                f.write(f"- **{table}**: {col_count} colonnes, referencee dans {file_count} fichier(s)\n")
            
            f.write("\n## Details des Tables et Colonnes\n\n")
            
            for table in sorted_tables:
                info = self.table_columns[table]
                f.write(f"### Table: `{table}`\n\n")
                
                if info["columns"]:
                    f.write("**Colonnes detectees:**\n\n")
                    sorted_cols = sorted(info["columns"])
                    for col in sorted_cols:
                        col_type = info["column_types"].get(col, 'TEXT')
                        f.write(f"- `{col}` (type infere: {col_type})\n")
                else:
                    f.write("*Aucune colonne specifique detectee (possiblement SELECT \\*)*\n")
                
                f.write(f"\n**Referencee dans les fichiers:**\n\n")
                sorted_files = sorted(info["files"])
                for filepath in sorted_files:
                    f.write(f"- `{filepath}`\n")
                
                f.write("\n---\n\n")
            
            # Add skipped identifiers section
            if self.skipped_identifiers:
                f.write("\n## Identifiants Invalides Ignores\n\n")
                f.write("Les identifiants suivants ont ete trouves dans le code mais ne correspondent pas\n")
                f.write("au pattern SQL valide (^[A-Za-z_][A-Za-z0-9_]*$) et ont ete ignores:\n\n")
                
                for filepath in sorted(self.skipped_identifiers.keys()):
                    skipped = self.skipped_identifiers[filepath]
                    if skipped:
                        f.write(f"**Fichier: `{filepath}`**\n\n")
                        for item in sorted(skipped):
                            f.write(f"- {item}\n")
                        f.write("\n")
        
        print(f"Report generated: {output_file}")


def main():
    """Point d'entrÃ©e principal du script."""
    # DÃ©tecter la racine du projet
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent
    
    print("=" * 60)
    print("SQL Schema Analyzer - Strict SQL Identifier Extraction")
    print("=" * 60)
    print(f"Repository root: {repo_root}")
    print()
    
    # CrÃ©er l'analyseur
    analyzer = StrictSQLAnalyzer(repo_root)
    
    # RÃ©pertoires Ã  scanner
    directories = ["modules", "ui", "scripts", "lib", "db"]
    
    # Scanner les rÃ©pertoires
    analyzer.scan_directories(directories)
    
    print()
    print(f"Analysis complete. Found {len(analyzer.table_columns)} tables.")
    
    # GÃ©nÃ©rer le rapport Markdown
    report_dir = repo_root / "reports"
    report_dir.mkdir(exist_ok=True)
    output_file = report_dir / "SQL_SCHEMA_HINTS.md"
    
    analyzer.generate_report(output_file)
    
    # GÃ©nÃ©rer le manifest YAML
    db_dir = repo_root / "db"
    db_dir.mkdir(exist_ok=True)
    yaml_file = db_dir / "schema_hints.yaml"
    
    analyzer.generate_yaml_manifest(yaml_file)
    
    print()
    print("=" * 60)
    print(f"Report saved to: {output_file}")
    print(f"YAML manifest saved to: {yaml_file}")
    print("=" * 60)


if __name__ == "__main__":
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/analyze_modules_columns_old.py ===

```python
#!/usr/bin/env python3
"""
Script d'analyse des modules pour dÃ©tecter les tables et colonnes utilisÃ©es.

Ce script parcourt le code Python du projet (modules/, ui/, scripts/, lib/)
et extrait toutes les requÃªtes SQL et rÃ©fÃ©rences aux tables/colonnes pour
produire un rapport dÃ©taillÃ© des schÃ©mas attendus par le code.

Usage:
    python scripts/analyze_modules_columns.py
    
Sortie:
    reports/SQL_SCHEMA_HINTS.md - Rapport lisible avec tables et colonnes dÃ©tectÃ©es
    db/schema_hints.yaml - Manifest machine-readable avec colonnes attendues et types infÃ©rÃ©s
"""

import os
import re
import sys
from collections import defaultdict
from pathlib import Path
import yaml


class SQLAnalyzer:
    """Analyseur de code Python pour extraire les rÃ©fÃ©rences SQL."""
    
    # Common false positives to filter out (Python/Tkinter keywords, UI elements, etc.)
    # This can be extended as needed when new false positives are discovered
    FALSE_POSITIVE_COLUMNS = {
        'padx', 'pady', 'row', 'column', 'text', 'values', 'state', 'side', 'fill', 
        'expand', 'width', 'height', 'command', 'textvariable', 'title', 'header',
        'filetypes', 'defaultextension', 'filepath', 'conn', 'cursor', 'df', 'params',
        'table', 'before', 'after', 'table_matches', 'var', 'on_save', 'CREATE',
    }
    
    # False positive table names to filter out
    FALSE_POSITIVE_TABLES = {'CREATE', 'for', 'tree', 'sqlite_master'}
    
    def __init__(self, repo_root):
        self.repo_root = Path(repo_root)
        self.table_columns = defaultdict(lambda: {"columns": set(), "files": set(), "column_types": {}})
        
        # Patterns pour extraire les requÃªtes SQL
        self.sql_patterns = [
            # SELECT queries
            r'SELECT\s+(?:\*|[\w,.\s*()]+)\s+FROM\s+(\w+)',
            # INSERT INTO
            r'INSERT\s+INTO\s+(\w+)\s*\(([^)]+)\)',
            # UPDATE queries
            r'UPDATE\s+(\w+)\s+SET\s+([^;]+)',
            # ALTER TABLE
            r'ALTER\s+TABLE\s+(\w+)\s+ADD\s+COLUMN\s+(\w+)',
            # CREATE TABLE
            r'CREATE\s+TABLE(?:\s+IF\s+NOT\s+EXISTS)?\s+(\w+)\s*\(([^;]+)\)',
            # PRAGMA table_info
            r'PRAGMA\s+table_info\s*\(\s*(\w+)\s*\)',
        ]
        
        # Pattern pour les rÃ©fÃ©rences de colonnes dans WHERE, SET, etc.
        self.column_ref_pattern = r'\b(\w+)\s*=\s*[?:]'
        
        # Patterns pour infÃ©rer les types de colonnes
        self.type_patterns = {
            'REAL': [
                r'(prix|montant|solde|total|cout|tarif|taux)(_\w+)?$',
                r'(disponible|valeur)(_\w+)?$',
            ],
            'INTEGER': [
                r'(quantite|stock|nombre|count|seuil)(_\w+)?$',
                r'^id(_\w+)?$',
                r'(_id|_count)$',
            ],
            'TEXT': [
                r'(nom|name|prenom|email|adresse|ville|pays)(_\w+)?$',
                r'(commentaire|description|libelle|categorie)(_\w+)?$',
                r'(type|statut|mode|reference|numero)(_\w+)?$',
            ],
            'DATE': [
                r'date(_\w+)?$',
            ],
        }
        
    def infer_column_type(self, column_name):
        """InfÃ¨re le type SQL d'une colonne basÃ© sur son nom."""
        column_lower = column_name.lower()
        
        # Test patterns for each type
        for sql_type, patterns in self.type_patterns.items():
            for pattern in patterns:
                if re.search(pattern, column_lower, re.IGNORECASE):
                    return sql_type
        
        # Default to TEXT if no pattern matches
        return 'TEXT'
    
    def analyze_file(self, filepath):
        """Analyse un fichier Python pour extraire les rÃ©fÃ©rences SQL."""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            print(f"Warning: Could not read {filepath}: {e}")
            return
        
        relative_path = str(filepath.relative_to(self.repo_root))
        
        # Recherche de requÃªtes SQL (souvent dans des chaÃ®nes multi-lignes ou simples)
        # On cherche les patterns SQL dans le contenu
        self._extract_sql_references(content, relative_path)
        
        # Recherche de rÃ©fÃ©rences dictionary-style (row["column"], row.get("column"))
        self._extract_dict_references(content, relative_path)
    
    def _add_column_to_table(self, table, column, infer_type=True):
        """Ajoute une colonne Ã  une table et infÃ¨re son type si nÃ©cessaire."""
        # Skip if no column name provided
        if not column:
            return
        
        # Filter out false positives
        if column.lower() in self.FALSE_POSITIVE_COLUMNS:
            return
        
        # Skip if already exists
        if column in self.table_columns[table]["columns"]:
            return
        
        # Add the column
        self.table_columns[table]["columns"].add(column)
        if infer_type and column not in self.table_columns[table]["column_types"]:
            self.table_columns[table]["column_types"][column] = self.infer_column_type(column)
    
    def _extract_dict_references(self, content, filepath):
        """Extrait les rÃ©fÃ©rences dictionary-style (row["column"], row.get("column"))."""
        
        # Pattern pour row["column"] ou row['column']
        for match in re.finditer(r'row\s*\[\s*["\'](\w+)["\']\s*\]', content, re.IGNORECASE):
            column = match.group(1)
            # Essayer de trouver la table associÃ©e dans le contexte
            before = content[max(0, match.start()-500):match.start()]
            table_matches = list(re.finditer(r'FROM\s+(\w+)', before, re.IGNORECASE))
            if table_matches:
                table = table_matches[-1].group(1)
                self._add_column_to_table(table, column)
        
        # Pattern pour row.get("column") ou row.get('column')
        for match in re.finditer(r'row\.get\s*\(\s*["\'](\w+)["\']\s*[,\)]', content, re.IGNORECASE):
            column = match.group(1)
            before = content[max(0, match.start()-500):match.start()]
            table_matches = list(re.finditer(r'FROM\s+(\w+)', before, re.IGNORECASE))
            if table_matches:
                table = table_matches[-1].group(1)
                self._add_column_to_table(table, column)
    
    def _extract_sql_references(self, content, filepath):
        """Extrait les rÃ©fÃ©rences SQL du contenu du fichier."""
        
        # SELECT FROM
        for match in re.finditer(r'SELECT\s+(?:\*|[\w,.\s*()]+)\s+FROM\s+(\w+)', content, re.IGNORECASE):
            table = match.group(1)
            self.table_columns[table]["files"].add(filepath)
            # Essayer d'extraire les colonnes du SELECT
            select_part = content[match.start():match.end()]
            if '*' not in select_part:
                cols = re.findall(r'SELECT\s+([\w,.\s*()]+)\s+FROM', select_part, re.IGNORECASE)
                if cols:
                    for col in cols[0].split(','):
                        col = col.strip().split()[0].split('(')[0].split(')')[0]
                        if col and col != '*' and not col.upper() in ('AS', 'FROM', 'SELECT'):
                            self._add_column_to_table(table, col)
        
        # INSERT INTO
        for match in re.finditer(r'INSERT\s+INTO\s+(\w+)\s*\(([^)]+)\)', content, re.IGNORECASE):
            table = match.group(1)
            columns = match.group(2)
            self.table_columns[table]["files"].add(filepath)
            for col in columns.split(','):
                col = col.strip()
                if col:
                    self._add_column_to_table(table, col)
        
        # UPDATE SET
        for match in re.finditer(r'UPDATE\s+(\w+)\s+SET\s+([^;]+?)(?:WHERE|;|$)', content, re.IGNORECASE | re.DOTALL):
            table = match.group(1)
            set_clause = match.group(2)
            self.table_columns[table]["files"].add(filepath)
            # Extraire les colonnes du SET
            for col_match in re.finditer(r'(\w+)\s*=', set_clause):
                col = col_match.group(1)
                self._add_column_to_table(table, col)
        
        # ALTER TABLE ADD COLUMN
        for match in re.finditer(r'ALTER\s+TABLE\s+(\w+)\s+ADD\s+COLUMN\s+(\w+)', content, re.IGNORECASE):
            table = match.group(1)
            column = match.group(2)
            self.table_columns[table]["files"].add(filepath)
            self._add_column_to_table(table, column)
        
        # CREATE TABLE
        for match in re.finditer(r'CREATE\s+TABLE(?:\s+IF\s+NOT\s+EXISTS)?\s+(\w+)\s*\(([^;]+)\)', content, re.IGNORECASE | re.DOTALL):
            table = match.group(1)
            columns_def = match.group(2)
            self.table_columns[table]["files"].add(filepath)
            # Extraire les noms de colonnes (premiÃ¨re partie avant le type)
            for line in columns_def.split(','):
                line = line.strip()
                if line and not line.upper().startswith(('PRIMARY', 'FOREIGN', 'UNIQUE', 'CHECK', 'CONSTRAINT')):
                    parts = line.split()
                    if parts:
                        col_name = parts[0].strip()
                        # Extract type if present (second part typically)
                        col_type = None
                        if len(parts) > 1:
                            type_str = parts[1].upper()
                            if 'INTEGER' in type_str or 'INT' in type_str:
                                col_type = 'INTEGER'
                            elif 'REAL' in type_str or 'FLOAT' in type_str or 'DOUBLE' in type_str:
                                col_type = 'REAL'
                            elif 'TEXT' in type_str or 'VARCHAR' in type_str or 'CHAR' in type_str:
                                col_type = 'TEXT'
                            elif 'DATE' in type_str or 'TIME' in type_str:
                                col_type = 'TEXT'  # SQLite stores dates as TEXT
                        
                        if col_name:
                            self._add_column_to_table(table, col_name, infer_type=False)
                            # Use explicit type from CREATE TABLE if available
                            if col_type and col_name not in self.table_columns[table]["column_types"]:
                                self.table_columns[table]["column_types"][col_name] = col_type
                            elif col_name not in self.table_columns[table]["column_types"]:
                                # Infer if not explicitly defined
                                self.table_columns[table]["column_types"][col_name] = self.infer_column_type(col_name)
        
        # PRAGMA table_info
        for match in re.finditer(r'PRAGMA\s+table_info\s*\(\s*["\']?(\w+)["\']?\s*\)', content, re.IGNORECASE):
            table = match.group(1)
            self.table_columns[table]["files"].add(filepath)
        
        # RÃ©fÃ©rences de colonnes dans WHERE et autres clauses
        for match in re.finditer(r'WHERE\s+([^;]+?)(?:ORDER|GROUP|LIMIT|$)', content, re.IGNORECASE):
            where_clause = match.group(1)
            # Chercher les tables mentionnÃ©es avant ce WHERE
            before = content[:match.start()]
            table_matches = list(re.finditer(r'FROM\s+(\w+)', before, re.IGNORECASE))
            if table_matches:
                table = table_matches[-1].group(1)
                for col_match in re.finditer(r'(\w+)\s*[=<>!]', where_clause):
                    col = col_match.group(1)
                    if col and not col.upper() in ('AND', 'OR', 'NOT', 'IN', 'IS', 'NULL', 'LIKE'):
                        self._add_column_to_table(table, col)
    
    def scan_directories(self, dirs):
        """Parcourt les rÃ©pertoires et analyse tous les fichiers Python."""
        for directory in dirs:
            dir_path = self.repo_root / directory
            if not dir_path.exists():
                print(f"Warning: Directory {directory} does not exist")
                continue
            
            print(f"Scanning {directory}...")
            for py_file in dir_path.rglob("*.py"):
                self.analyze_file(py_file)
    
    def generate_yaml_manifest(self, output_file):
        """GÃ©nÃ¨re un manifest YAML machine-readable avec colonnes et types infÃ©rÃ©s."""
        
        # PrÃ©parer les donnÃ©es pour YAML
        manifest = {
            "schema_version": "1.0",
            "generated_by": "analyze_modules_columns.py",
            "tables": {}
        }
        
        for table, info in self.table_columns.items():
            # Skip false positive tables
            if table in self.FALSE_POSITIVE_TABLES:
                continue
                
            if not info["columns"]:
                continue
            
            # Only include tables with at least some reasonable columns (not all false positives)
            valid_columns = [col for col in info["columns"] if col.lower() not in self.FALSE_POSITIVE_COLUMNS]
            
            if not valid_columns:
                continue
                
            manifest["tables"][table] = {
                "expected_columns": {}
            }
            
            # Ajouter chaque colonne avec son type infÃ©rÃ©
            for col in sorted(info["columns"]):
                col_type = info["column_types"].get(col, 'TEXT')
                manifest["tables"][table]["expected_columns"][col] = {
                    "type": col_type,
                    "inferred": col not in info.get("explicit_types", set())
                }
        
        # Ã‰crire le fichier YAML
        with open(output_file, 'w', encoding='utf-8') as f:
            yaml.dump(manifest, f, default_flow_style=False, allow_unicode=True, sort_keys=True)
        
        print(f"YAML manifest generated: {output_file}")
    
    def generate_report(self, output_file):
        """GÃ©nÃ¨re un rapport Markdown des tables et colonnes dÃ©tectÃ©es."""
        
        # Trier les tables par ordre alphabÃ©tique
        sorted_tables = sorted(self.table_columns.keys())
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Analyse SQL - Tables et Colonnes DÃ©tectÃ©es\n\n")
            f.write("Ce rapport liste toutes les tables et colonnes rÃ©fÃ©rencÃ©es dans le code Python.\n")
            f.write("Il sert de rÃ©fÃ©rence pour les migrations et la maintenance du schÃ©ma de base de donnÃ©es.\n\n")
            f.write(f"**Nombre total de tables dÃ©tectÃ©es:** {len(sorted_tables)}\n\n")
            
            f.write("## RÃ©sumÃ© par Table\n\n")
            for table in sorted_tables:
                info = self.table_columns[table]
                col_count = len(info["columns"])
                file_count = len(info["files"])
                f.write(f"- **{table}**: {col_count} colonnes, rÃ©fÃ©rencÃ©e dans {file_count} fichier(s)\n")
            
            f.write("\n## DÃ©tails des Tables et Colonnes\n\n")
            
            for table in sorted_tables:
                info = self.table_columns[table]
                f.write(f"### Table: `{table}`\n\n")
                
                if info["columns"]:
                    f.write("**Colonnes dÃ©tectÃ©es:**\n\n")
                    sorted_cols = sorted(info["columns"])
                    for col in sorted_cols:
                        col_type = info["column_types"].get(col, 'TEXT')
                        f.write(f"- `{col}` (type infÃ©rÃ©: {col_type})\n")
                else:
                    f.write("*Aucune colonne spÃ©cifique dÃ©tectÃ©e (possiblement SELECT \\*)*\n")
                
                f.write(f"\n**RÃ©fÃ©rencÃ©e dans les fichiers:**\n\n")
                sorted_files = sorted(info["files"])
                for filepath in sorted_files:
                    f.write(f"- `{filepath}`\n")
                
                f.write("\n---\n\n")
        
        print(f"Report generated: {output_file}")


def main():
    """Point d'entrÃ©e principal du script."""
    # DÃ©tecter la racine du projet
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent
    
    print("=" * 60)
    print("SQL Schema Analyzer - Module Column Detection")
    print("=" * 60)
    print(f"Repository root: {repo_root}")
    print()
    
    # CrÃ©er l'analyseur
    analyzer = SQLAnalyzer(repo_root)
    
    # RÃ©pertoires Ã  scanner
    directories = ["modules", "ui", "scripts", "lib", "db"]
    
    # Scanner les rÃ©pertoires
    analyzer.scan_directories(directories)
    
    print()
    print(f"Analysis complete. Found {len(analyzer.table_columns)} tables.")
    
    # GÃ©nÃ©rer le rapport Markdown
    report_dir = repo_root / "reports"
    report_dir.mkdir(exist_ok=True)
    output_file = report_dir / "SQL_SCHEMA_HINTS.md"
    
    analyzer.generate_report(output_file)
    
    # GÃ©nÃ©rer le manifest YAML
    db_dir = repo_root / "db"
    db_dir.mkdir(exist_ok=True)
    yaml_file = db_dir / "schema_hints.yaml"
    
    analyzer.generate_yaml_manifest(yaml_file)
    
    print()
    print("=" * 60)
    print(f"Report saved to: {output_file}")
    print(f"YAML manifest saved to: {yaml_file}")
    print("=" * 60)


if __name__ == "__main__":
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/audit_db_usage.py ===

```python
#!/usr/bin/env python3
"""
Database Usage Audit Script

Scans the codebase for:
- sqlite3 usage patterns
- fetch/execute patterns
- row.get usages
- positional indexing (row[0], row[1], etc.)
- Generate reports in reports/SQL_ACCESS_MAP.md and reports/TODOs.md

This script helps identify areas where sqlite3.Row objects are used with .get()
method (which causes AttributeError) and need to be converted to dicts.
"""

import os
import re
import sys
from pathlib import Path
from typing import List, Dict, Tuple, Set
from datetime import datetime


class DBUsageAuditor:
    """Auditor for database access patterns in Python codebase."""
    
    def __init__(self, root_dir: str):
        self.root_dir = Path(root_dir)
        self.results = {
            'sqlite3_imports': [],
            'get_connection_calls': [],
            'fetch_patterns': [],
            'row_get_usage': [],
            'positional_indexing': [],
            'execute_patterns': [],
            'connection_patterns': [],
        }
        
    def scan_file(self, filepath: Path) -> Dict:
        """Scan a single Python file for DB usage patterns."""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
                lines = content.split('\n')
        except (UnicodeDecodeError, PermissionError) as e:
            return {}
        
        rel_path = filepath.relative_to(self.root_dir)
        file_results = {}
        
        # Pattern: import sqlite3
        if re.search(r'import\s+sqlite3', content):
            self.results['sqlite3_imports'].append({
                'file': str(rel_path),
                'line': self._find_line_number(lines, r'import\s+sqlite3')
            })
        
        # Pattern: get_connection()
        for match in re.finditer(r'(\w+\.)?get_connection\(\)', content):
            line_num = self._get_line_number(content, match.start())
            self.results['get_connection_calls'].append({
                'file': str(rel_path),
                'line': line_num,
                'code': lines[line_num - 1].strip() if line_num <= len(lines) else ''
            })
        
        # Pattern: fetchone(), fetchall(), fetchmany()
        for pattern in [r'\.fetchone\(\)', r'\.fetchall\(\)', r'\.fetchmany\(']:
            for match in re.finditer(pattern, content):
                line_num = self._get_line_number(content, match.start())
                self.results['fetch_patterns'].append({
                    'file': str(rel_path),
                    'line': line_num,
                    'pattern': match.group(),
                    'code': lines[line_num - 1].strip() if line_num <= len(lines) else ''
                })
        
        # Pattern: row.get( or row.get('
        for match in re.finditer(r'(\w+)\.get\(["\']', content):
            line_num = self._get_line_number(content, match.start())
            var_name = match.group(1)
            # Check if this might be a row variable
            if var_name in ['row', 'r', 'res', 'result', 'item', 'data'] or 'row' in var_name.lower():
                self.results['row_get_usage'].append({
                    'file': str(rel_path),
                    'line': line_num,
                    'variable': var_name,
                    'code': lines[line_num - 1].strip() if line_num <= len(lines) else ''
                })
        
        # Pattern: row[0], row[1], etc. (positional indexing)
        for match in re.finditer(r'(\w+)\[(\d+)\]', content):
            line_num = self._get_line_number(content, match.start())
            var_name = match.group(1)
            index = match.group(2)
            # Check if this might be a row variable
            if var_name in ['row', 'r', 'res', 'result', 'item', 'data'] or 'row' in var_name.lower():
                self.results['positional_indexing'].append({
                    'file': str(rel_path),
                    'line': line_num,
                    'variable': var_name,
                    'index': index,
                    'code': lines[line_num - 1].strip() if line_num <= len(lines) else ''
                })
        
        # Pattern: .execute(
        for match in re.finditer(r'\.execute\(', content):
            line_num = self._get_line_number(content, match.start())
            # Get the full statement (might span multiple lines)
            code_snippet = self._get_code_snippet(lines, line_num - 1, 3)
            self.results['execute_patterns'].append({
                'file': str(rel_path),
                'line': line_num,
                'code': code_snippet
            })
        
        # Pattern: sqlite3.connect(
        for match in re.finditer(r'sqlite3\.connect\(', content):
            line_num = self._get_line_number(content, match.start())
            self.results['connection_patterns'].append({
                'file': str(rel_path),
                'line': line_num,
                'code': lines[line_num - 1].strip() if line_num <= len(lines) else ''
            })
        
        return file_results
    
    def _find_line_number(self, lines: List[str], pattern: str) -> int:
        """Find the first line number matching a pattern."""
        for i, line in enumerate(lines, 1):
            if re.search(pattern, line):
                return i
        return 0
    
    def _get_line_number(self, content: str, char_pos: int) -> int:
        """Get line number from character position."""
        return content[:char_pos].count('\n') + 1
    
    def _get_code_snippet(self, lines: List[str], start_line: int, num_lines: int = 1) -> str:
        """Get a snippet of code from multiple lines."""
        end_line = min(start_line + num_lines, len(lines))
        return ' '.join(lines[start_line:end_line]).strip()
    
    def scan_directory(self, directory: Path = None):
        """Recursively scan directory for Python files."""
        if directory is None:
            directory = self.root_dir
        
        # Directories to skip
        skip_dirs = {'.git', '__pycache__', 'venv', 'env', '.pytest_cache', 'node_modules', 'dist', 'build'}
        
        for item in directory.iterdir():
            if item.is_dir():
                if item.name not in skip_dirs:
                    self.scan_directory(item)
            elif item.suffix == '.py':
                self.scan_file(item)
    
    def generate_sql_access_map(self) -> str:
        """Generate SQL_ACCESS_MAP.md report."""
        report = []
        report.append("# SQL Access Map\n")
        report.append(f"Generated: {datetime.now().isoformat()}\n")
        report.append("This report maps all database access patterns in the codebase.\n")
        
        report.append("\n## Summary\n")
        report.append(f"- sqlite3 imports: {len(self.results['sqlite3_imports'])}\n")
        report.append(f"- get_connection() calls: {len(self.results['get_connection_calls'])}\n")
        report.append(f"- fetch patterns: {len(self.results['fetch_patterns'])}\n")
        report.append(f"- row.get() usage: {len(self.results['row_get_usage'])}\n")
        report.append(f"- Positional indexing: {len(self.results['positional_indexing'])}\n")
        report.append(f"- execute() calls: {len(self.results['execute_patterns'])}\n")
        report.append(f"- sqlite3.connect() calls: {len(self.results['connection_patterns'])}\n")
        
        # sqlite3 imports
        if self.results['sqlite3_imports']:
            report.append("\n## SQLite3 Imports\n")
            for item in self.results['sqlite3_imports']:
                report.append(f"- `{item['file']}:{item['line']}`\n")
        
        # get_connection calls
        if self.results['get_connection_calls']:
            report.append("\n## get_connection() Calls\n")
            files_with_calls = {}
            for item in self.results['get_connection_calls']:
                file = item['file']
                if file not in files_with_calls:
                    files_with_calls[file] = []
                files_with_calls[file].append(item)
            
            for file, calls in sorted(files_with_calls.items()):
                report.append(f"\n### {file}\n")
                for call in calls:
                    report.append(f"- Line {call['line']}: `{call['code']}`\n")
        
        # Fetch patterns
        if self.results['fetch_patterns']:
            report.append("\n## Fetch Patterns\n")
            files_with_fetches = {}
            for item in self.results['fetch_patterns']:
                file = item['file']
                if file not in files_with_fetches:
                    files_with_fetches[file] = []
                files_with_fetches[file].append(item)
            
            for file, fetches in sorted(files_with_fetches.items()):
                report.append(f"\n### {file}\n")
                for fetch in fetches:
                    report.append(f"- Line {fetch['line']} `{fetch['pattern']}`: `{fetch['code']}`\n")
        
        # Row.get usage (CRITICAL - these will crash)
        if self.results['row_get_usage']:
            report.append("\n## âš ï¸ CRITICAL: row.get() Usage (Will Crash!)\n")
            report.append("These locations use .get() on sqlite3.Row objects, which will cause AttributeError.\n")
            report.append("These MUST be fixed by converting rows to dicts first.\n")
            files_with_get = {}
            for item in self.results['row_get_usage']:
                file = item['file']
                if file not in files_with_get:
                    files_with_get[file] = []
                files_with_get[file].append(item)
            
            for file, gets in sorted(files_with_get.items()):
                report.append(f"\n### {file}\n")
                for get in gets:
                    report.append(f"- Line {get['line']} (var: `{get['variable']}`): `{get['code']}`\n")
        
        # Positional indexing
        if self.results['positional_indexing']:
            report.append("\n## Positional Indexing (row[0], row[1], ...)\n")
            report.append("These use positional access and should continue to work.\n")
            files_with_pos = {}
            for item in self.results['positional_indexing']:
                file = item['file']
                if file not in files_with_pos:
                    files_with_pos[file] = []
                files_with_pos[file].append(item)
            
            for file, positions in sorted(files_with_pos.items()):
                report.append(f"\n### {file}\n")
                unique_lines = {}
                for pos in positions:
                    line_key = f"{pos['line']}"
                    if line_key not in unique_lines:
                        unique_lines[line_key] = pos
                
                for pos in unique_lines.values():
                    report.append(f"- Line {pos['line']}: `{pos['code']}`\n")
        
        return ''.join(report)
    
    def generate_todos(self) -> str:
        """Generate TODOs.md report with action items."""
        report = []
        report.append("# Database Access TODOs\n")
        report.append(f"Generated: {datetime.now().isoformat()}\n")
        report.append("\nThis report lists action items for fixing database access issues.\n")
        
        # Critical fixes needed
        if self.results['row_get_usage']:
            report.append("\n## ðŸ”´ CRITICAL: Fix row.get() Usage\n")
            report.append("Priority: **HIGH** - These will cause AttributeError crashes\n")
            report.append("\nAction: Convert sqlite3.Row to dict before using .get()\n")
            report.append("Solution: Use `_row_to_dict(row)` or `_rows_to_dicts(rows)` from modules/db_row_utils.py\n")
            
            for item in self.results['row_get_usage']:
                report.append(f"\n- [ ] {item['file']}:{item['line']}\n")
                report.append(f"  ```python\n  {item['code']}\n  ```\n")
        
        # Direct sqlite3.connect usage
        if self.results['connection_patterns']:
            report.append("\n## ðŸŸ¡ RECOMMENDED: Standardize Connection Handling\n")
            report.append("Priority: **MEDIUM** - Should use centralized connection management\n")
            report.append("\nAction: Use db.get_connection() or modules.db_api.get_connection() instead of direct sqlite3.connect()\n")
            report.append("Benefit: Automatic WAL mode, busy timeout, and consistent error handling\n")
            
            for item in self.results['connection_patterns']:
                report.append(f"\n- [ ] {item['file']}:{item['line']}\n")
                report.append(f"  ```python\n  {item['code']}\n  ```\n")
        
        # Fetch patterns without conversion
        fetch_files = set(item['file'] for item in self.results['fetch_patterns'])
        get_files = set(item['file'] for item in self.results['row_get_usage'])
        
        # Files with fetch but no documented .get() issues might still be at risk
        at_risk_files = fetch_files - get_files
        if at_risk_files:
            report.append("\n## ðŸŸ¢ LOW PRIORITY: Review Fetch Patterns\n")
            report.append("These files use fetch patterns but don't show .get() usage in this scan.\n")
            report.append("Review to ensure they don't need dict conversion.\n")
            for file in sorted(at_risk_files):
                report.append(f"- [ ] {file}\n")
        
        return ''.join(report)


def main():
    """Main entry point for the audit script."""
    # Find root directory
    script_dir = Path(__file__).parent
    root_dir = script_dir.parent
    
    print("=" * 70)
    print("Database Usage Audit Tool")
    print("=" * 70)
    print(f"\nScanning directory: {root_dir}")
    print("This may take a moment...\n")
    
    # Create auditor and scan
    auditor = DBUsageAuditor(root_dir)
    auditor.scan_directory()
    
    # Create reports directory if it doesn't exist
    reports_dir = root_dir / 'reports'
    reports_dir.mkdir(exist_ok=True)
    
    # Generate and write reports
    print("Generating SQL_ACCESS_MAP.md...")
    sql_map = auditor.generate_sql_access_map()
    sql_map_path = reports_dir / 'SQL_ACCESS_MAP.md'
    with open(sql_map_path, 'w', encoding='utf-8') as f:
        f.write(sql_map)
    print(f"âœ“ Written to {sql_map_path}")
    
    print("\nGenerating TODOs.md...")
    todos = auditor.generate_todos()
    todos_path = reports_dir / 'TODOs.md'
    with open(todos_path, 'w', encoding='utf-8') as f:
        f.write(todos)
    print(f"âœ“ Written to {todos_path}")
    
    print("\n" + "=" * 70)
    print("Audit Complete!")
    print("=" * 70)
    print(f"\nSummary:")
    print(f"  - row.get() issues found: {len(auditor.results['row_get_usage'])}")
    print(f"  - Direct sqlite3.connect() calls: {len(auditor.results['connection_patterns'])}")
    print(f"  - Total fetch patterns: {len(auditor.results['fetch_patterns'])}")
    print(f"\nReview the reports in {reports_dir}/ for details.")
    
    # Return exit code based on critical issues
    if auditor.results['row_get_usage']:
        print("\nâš ï¸  CRITICAL issues found! See TODOs.md for action items.")
        return 1
    else:
        print("\nâœ“ No critical issues found.")
        return 0


if __name__ == '__main__':
    sys.exit(main())

```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/auto_fix_buvette_rows.py ===

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Auto-fix script for sqlite3.Row to dict conversions in buvette/inventory modules.

This script heuristically scans modules/ and ui/ directories for patterns where:
- rows = cursor.fetchall() or row = cursor.fetchone() are used
- followed by .get() calls on those rows

For each matching file it:
1. Creates a backup copy <file>.bak
2. Injects imports: from modules.db_row_utils import _row_to_dict, _rows_to_dicts
3. Injects conversions after fetchone/fetchall calls
4. Writes a patch diff file <file>.fix.diff for reviewer
5. Applies the changes to the working file

Note: This script is designed to be safe and non-destructive. It always creates
backups before modifying files and generates diff files for human review.
"""

import difflib
import os
import re
import sys
import shutil
from pathlib import Path
from datetime import datetime


def find_python_files(base_dir, subdirs=None):
    """Find all Python files in specified subdirectories."""
    if subdirs is None:
        subdirs = ['modules', 'ui']
    
    python_files = []
    for subdir in subdirs:
        search_path = os.path.join(base_dir, subdir)
        if os.path.exists(search_path):
            for root, _, files in os.walk(search_path):
                for file in files:
                    if file.endswith('.py'):
                        python_files.append(os.path.join(root, file))
    
    return python_files


def has_fetchall_or_fetchone(content):
    """Check if file contains fetchall() or fetchone() calls."""
    return bool(re.search(r'\.(fetchall|fetchone)\(\)', content))


def has_get_usage(content):
    """Check if file uses .get() method on potential row objects."""
    # Look for patterns like: row.get(, row_var.get(, rows[i].get(, etc.
    return bool(re.search(r'(row|ligne|line|result)[\w]*\.get\(', content))


def needs_db_row_utils_import(content):
    """Check if file needs the db_row_utils import."""
    has_import = re.search(r'from modules\.db_row_utils import', content)
    return not has_import


def inject_import(content):
    """Inject the db_row_utils import after other module imports."""
    # Find the last import statement
    lines = content.split('\n')
    last_import_idx = -1
    
    for idx, line in enumerate(lines):
        if line.strip().startswith(('import ', 'from ')):
            last_import_idx = idx
    
    if last_import_idx >= 0:
        # Insert after the last import
        import_line = 'from modules.db_row_utils import _row_to_dict, _rows_to_dicts'
        lines.insert(last_import_idx + 1, import_line)
        return '\n'.join(lines)
    else:
        # No imports found, insert at top after docstring
        # Find end of docstring if present
        insert_idx = 0
        if content.startswith('"""') or content.startswith("'''"):
            delimiter = '"""' if content.startswith('"""') else "'''"
            end_idx = content.find(delimiter, 3)
            if end_idx > 0:
                insert_idx = content[:end_idx + 3].count('\n')
        
        lines = content.split('\n')
        import_line = 'from modules.db_row_utils import _row_to_dict, _rows_to_dicts'
        lines.insert(insert_idx, import_line)
        lines.insert(insert_idx + 1, '')
        return '\n'.join(lines)


def inject_conversions(content):
    """
    Inject row/rows conversion calls after fetchone/fetchall.
    
    Pattern detection:
    - rows = cursor.fetchall() -> add: rows = _rows_to_dicts(rows)
    - row = cursor.fetchone() -> add: row = _row_to_dict(row)
    """
    lines = content.split('\n')
    new_lines = []
    i = 0
    
    while i < len(lines):
        line = lines[i]
        new_lines.append(line)
        
        # Match patterns like: variable = something.fetchall()
        fetchall_match = re.search(r'(\w+)\s*=\s*.*\.fetchall\(\)', line)
        if fetchall_match:
            var_name = fetchall_match.group(1)
            indent = len(line) - len(line.lstrip())
            conversion = ' ' * indent + f'{var_name} = _rows_to_dicts({var_name})'
            new_lines.append(conversion)
        
        # Match patterns like: variable = something.fetchone()
        fetchone_match = re.search(r'(\w+)\s*=\s*.*\.fetchone\(\)', line)
        if fetchone_match:
            var_name = fetchone_match.group(1)
            indent = len(line) - len(line.lstrip())
            conversion = ' ' * indent + f'{var_name} = _row_to_dict({var_name})'
            new_lines.append(conversion)
        
        i += 1
    
    return '\n'.join(new_lines)


def create_diff(original_content, modified_content, filename):
    """Create a unified diff string."""
    original_lines = original_content.splitlines(keepends=True)
    modified_lines = modified_content.splitlines(keepends=True)
    
    diff = difflib.unified_diff(
        original_lines,
        modified_lines,
        fromfile=f'{filename}.orig',
        tofile=f'{filename}.fixed',
        lineterm=''
    )
    
    return ''.join(diff)


def process_file(filepath, dry_run=False):
    """
    Process a single file: create backup, inject conversions, create diff.
    
    Returns:
        tuple: (was_modified, message)
    """
    try:
        # Read the file
        with open(filepath, 'r', encoding='utf-8') as f:
            original_content = f.read()
        
        # Check if this file needs processing
        has_fetch = has_fetchall_or_fetchone(original_content)
        has_get = has_get_usage(original_content)
        
        if not (has_fetch and has_get):
            return False, "No fetch+get pattern detected"
        
        # Start with original content
        modified_content = original_content
        
        # Inject import if needed
        if needs_db_row_utils_import(modified_content):
            modified_content = inject_import(modified_content)
        
        # Inject conversions
        modified_content = inject_conversions(modified_content)
        
        # Check if anything actually changed
        if modified_content == original_content:
            return False, "No changes after processing"
        
        if dry_run:
            return True, "Would be modified (dry run)"
        
        # Create backup
        backup_path = filepath + '.bak'
        shutil.copy2(filepath, backup_path)
        
        # Write modified file
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(modified_content)
        
        # Create diff file
        diff_content = create_diff(original_content, modified_content, os.path.basename(filepath))
        diff_path = filepath + '.fix.diff'
        with open(diff_path, 'w', encoding='utf-8') as f:
            f.write(diff_content)
        
        return True, f"Modified (backup: {backup_path}, diff: {diff_path})"
    
    except Exception as e:
        return False, f"Error: {e}"


def main():
    """Main function to run the auto-fix script."""
    # Determine base directory (repository root)
    script_dir = os.path.dirname(os.path.abspath(__file__))
    base_dir = os.path.dirname(script_dir)
    
    print("=" * 80)
    print("SQLite3 Row to Dict Auto-Fix Script")
    print("=" * 80)
    print(f"Base directory: {base_dir}")
    print(f"Timestamp: {datetime.now().isoformat()}")
    print()
    
    # Check for dry-run mode
    dry_run = '--dry-run' in sys.argv or '-n' in sys.argv
    if dry_run:
        print("âš  DRY RUN MODE - No files will be modified")
        print()
    
    # Find all Python files in modules/ and ui/
    python_files = find_python_files(base_dir)
    print(f"Found {len(python_files)} Python files in modules/ and ui/")
    print()
    
    # Process each file
    modified_count = 0
    skipped_count = 0
    error_count = 0
    
    for filepath in sorted(python_files):
        rel_path = os.path.relpath(filepath, base_dir)
        was_modified, message = process_file(filepath, dry_run)
        
        if was_modified:
            print(f"âœ“ {rel_path}: {message}")
            modified_count += 1
        elif 'Error' in message:
            print(f"âœ— {rel_path}: {message}")
            error_count += 1
        else:
            # Skip silently or with verbose flag
            if '--verbose' in sys.argv or '-v' in sys.argv:
                print(f"- {rel_path}: {message}")
            skipped_count += 1
    
    # Print summary
    print()
    print("=" * 80)
    print("Summary")
    print("=" * 80)
    print(f"Modified: {modified_count}")
    print(f"Skipped:  {skipped_count}")
    print(f"Errors:   {error_count}")
    print()
    
    if not dry_run and modified_count > 0:
        print("âš  Important:")
        print("  1. Review all .fix.diff files before committing")
        print("  2. Test the changes thoroughly")
        print("  3. Backups are available as .bak files")
        print("  4. To rollback, restore from .bak files")
        print()
    
    return 0 if error_count == 0 else 1


if __name__ == '__main__':
    sys.exit(main())

```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/check_buvette.py ===

```python
#!/usr/bin/env python3
"""
Script de vÃ©rification du module buvette.
Ce script exÃ©cute une sÃ©rie de vÃ©rifications automatisÃ©es pour identifier
les problÃ¨mes dans le code du module buvette avant d'appliquer les corrections.

VÃ©rifications effectuÃ©es:
1. ExÃ©cution des tests unitaires (pytest)
2. Recherche de patterns problÃ©matiques dans le code
3. VÃ©rification de la cohÃ©rence entre le schÃ©ma DB et le code

CrÃ©Ã© dans le cadre de la PR de corrections du module buvette.
"""

import os
import sys
import re
import subprocess
from pathlib import Path

# Couleurs pour le terminal
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def print_header(text):
    print(f"\n{Colors.HEADER}{Colors.BOLD}{'='*80}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{text.center(80)}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{'='*80}{Colors.ENDC}\n")

def print_section(text):
    print(f"\n{Colors.OKBLUE}{Colors.BOLD}--- {text} ---{Colors.ENDC}")

def print_ok(text):
    print(f"{Colors.OKGREEN}âœ“ {text}{Colors.ENDC}")

def print_warning(text):
    print(f"{Colors.WARNING}âš  {text}{Colors.ENDC}")

def print_error(text):
    print(f"{Colors.FAIL}âœ— {text}{Colors.ENDC}")

def run_tests():
    """ExÃ©cute les tests unitaires avec pytest."""
    print_section("ExÃ©cution des tests unitaires")
    
    # VÃ©rifier si pytest est installÃ©
    try:
        result = subprocess.run(
            ["python", "-m", "pytest", "--version"],
            capture_output=True,
            text=True,
            timeout=10
        )
        if result.returncode != 0:
            print_warning("pytest n'est pas installÃ©. Installation en cours...")
            subprocess.run(["pip", "install", "-q", "pytest"], check=True)
    except Exception as e:
        print_error(f"Impossible de vÃ©rifier/installer pytest: {e}")
        return False
    
    # ExÃ©cuter les tests
    try:
        result = subprocess.run(
            ["python", "-m", "pytest", "tests/test_buvette_inventaire.py", "-v", "--tb=short"],
            capture_output=True,
            text=True,
            timeout=60
        )
        print(result.stdout)
        if result.stderr:
            print(result.stderr)
        
        if result.returncode == 0:
            print_ok("Tous les tests sont passÃ©s")
            return True
        else:
            print_error("Certains tests ont Ã©chouÃ©")
            return False
    except subprocess.TimeoutExpired:
        print_error("Timeout lors de l'exÃ©cution des tests")
        return False
    except Exception as e:
        print_error(f"Erreur lors de l'exÃ©cution des tests: {e}")
        return False

def check_database_schema():
    """VÃ©rifie le schÃ©ma de la base de donnÃ©es."""
    print_section("VÃ©rification du schÃ©ma de base de donnÃ©es")
    
    db_file = Path("db/db.py")
    if not db_file.exists():
        print_error(f"Fichier {db_file} non trouvÃ©")
        return []
    
    issues = []
    content = db_file.read_text()
    
    # VÃ©rifier la dÃ©finition de buvette_mouvements
    if 'date_mouvement DATE' in content:
        print_ok("Colonne 'date_mouvement' trouvÃ©e dans le schÃ©ma")
    else:
        issues.append("Colonne 'date_mouvement' non trouvÃ©e dans buvette_mouvements")
        print_error(issues[-1])
    
    if 'type_mouvement TEXT' in content:
        print_ok("Colonne 'type_mouvement' trouvÃ©e dans le schÃ©ma")
    else:
        issues.append("Colonne 'type_mouvement' non trouvÃ©e dans buvette_mouvements")
        print_error(issues[-1])
    
    if 'motif TEXT' in content:
        print_ok("Colonne 'motif' trouvÃ©e dans le schÃ©ma (pas 'commentaire')")
    
    return issues

def check_buvette_db_file():
    """VÃ©rifie les patterns problÃ©matiques dans modules/buvette_db.py."""
    print_section("VÃ©rification de modules/buvette_db.py")
    
    db_file = Path("modules/buvette_db.py")
    if not db_file.exists():
        print_error(f"Fichier {db_file} non trouvÃ©")
        return []
    
    issues = []
    content = db_file.read_text()
    lines = content.split('\n')
    
    # Pattern 1: INSERT avec 'date' au lieu de 'date_mouvement'
    insert_pattern = re.compile(r'INSERT\s+INTO\s+buvette_mouvements\s*\([^)]*\bdate\b[^)]*\)', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if insert_pattern.search(line):
            issues.append(f"Ligne {i}: INSERT utilise 'date' au lieu de 'date_mouvement'")
            print_error(issues[-1])
    
    # Pattern 2: UPDATE avec 'date=' au lieu de 'date_mouvement='
    update_pattern = re.compile(r'UPDATE\s+buvette_mouvements\s+SET[^W]*\bdate\s*=', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if update_pattern.search(line):
            issues.append(f"Ligne {i}: UPDATE utilise 'date=' au lieu de 'date_mouvement='")
            print_error(issues[-1])
    
    # Pattern 3: UPDATE avec 'type=' au lieu de 'type_mouvement='
    update_type_pattern = re.compile(r'UPDATE\s+buvette_mouvements\s+SET[^W]*\btype\s*=', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if update_type_pattern.search(line):
            issues.append(f"Ligne {i}: UPDATE utilise 'type=' au lieu de 'type_mouvement='")
            print_error(issues[-1])
    
    # Pattern 4: SELECT sans alias AS date, AS type
    select_mouvements = re.compile(r'def\s+list_mouvements\(\):', re.IGNORECASE)
    found_list_mouvements = False
    for i, line in enumerate(lines, 1):
        if select_mouvements.search(line):
            found_list_mouvements = True
            # VÃ©rifier les 20 lignes suivantes pour les alias
            check_lines = '\n'.join(lines[i:min(i+20, len(lines))])
            if 'AS date' not in check_lines or 'AS type' not in check_lines:
                issues.append(f"Fonction list_mouvements (ligne {i}): manque les alias AS date/AS type")
                print_error(issues[-1])
            else:
                print_ok("list_mouvements contient les alias AS date/AS type")
            break
    
    if not found_list_mouvements:
        issues.append("Fonction list_mouvements non trouvÃ©e")
        print_error(issues[-1])
    
    # Pattern 5: get_mouvement_by_id sans alias
    select_mouvement_by_id = re.compile(r'def\s+get_mouvement_by_id\(', re.IGNORECASE)
    found_get_mouvement = False
    for i, line in enumerate(lines, 1):
        if select_mouvement_by_id.search(line):
            found_get_mouvement = True
            check_lines = '\n'.join(lines[i:min(i+20, len(lines))])
            if 'AS date' not in check_lines or 'AS type' not in check_lines:
                issues.append(f"Fonction get_mouvement_by_id (ligne {i}): manque les alias AS date/AS type")
                print_error(issues[-1])
            else:
                print_ok("get_mouvement_by_id contient les alias AS date/AS type")
            break
    
    if not found_get_mouvement:
        issues.append("Fonction get_mouvement_by_id non trouvÃ©e")
        print_error(issues[-1])
    
    if not issues:
        print_ok("Aucun problÃ¨me trouvÃ© dans buvette_db.py")
    
    return issues

def check_buvette_ui_file():
    """VÃ©rifie les patterns problÃ©matiques dans modules/buvette.py."""
    print_section("VÃ©rification de modules/buvette.py")
    
    ui_file = Path("modules/buvette.py")
    if not ui_file.exists():
        print_error(f"Fichier {ui_file} non trouvÃ©")
        return []
    
    issues = []
    content = ui_file.read_text()
    lines = content.split('\n')
    
    # Pattern 1: InventaireDialog sans columnconfigure
    inventaire_dialog_pattern = re.compile(r'class\s+InventaireDialog\(', re.IGNORECASE)
    found_inventaire = False
    for i, line in enumerate(lines, 1):
        if inventaire_dialog_pattern.search(line):
            found_inventaire = True
            # VÃ©rifier les 50 lignes suivantes
            check_lines = '\n'.join(lines[i:min(i+50, len(lines))])
            if 'columnconfigure' not in check_lines:
                issues.append(f"InventaireDialog (ligne {i}): manque columnconfigure(1, weight=1)")
                print_error(issues[-1])
            else:
                print_ok("InventaireDialog contient columnconfigure")
            
            if 'sticky=' not in check_lines or 'sticky="ew"' not in check_lines:
                issues.append(f"InventaireDialog (ligne {i}): les Entry/Combobox devraient avoir sticky='ew'")
                print_warning(issues[-1])
            break
    
    # Pattern 2: LignesInventaireDialog affiche article_id au lieu de article_name
    lignes_refresh = re.compile(r'def\s+refresh_lignes\(self\):', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if lignes_refresh.search(line):
            check_lines = '\n'.join(lines[i:min(i+20, len(lines))])
            if 'article_id' in check_lines and 'values=' in check_lines:
                if 'article_name' not in check_lines:
                    issues.append(f"LignesInventaireDialog.refresh_lignes (ligne {i}): affiche article_id au lieu de article_name")
                    print_error(issues[-1])
                else:
                    print_ok("refresh_lignes utilise article_name")
            break
    
    # Pattern 3: LigneInventaireDialog utilise Entry pour article_id
    ligne_dialog = re.compile(r'class\s+LigneInventaireDialog\(', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if ligne_dialog.search(line):
            check_lines = '\n'.join(lines[i:min(i+50, len(lines))])
            if 'article_id_var' in check_lines and 'tk.Entry' in check_lines:
                if 'Combobox' not in check_lines or 'list_articles_names' not in check_lines:
                    issues.append(f"LigneInventaireDialog (ligne {i}): devrait utiliser Combobox au lieu de Entry pour article")
                    print_error(issues[-1])
                else:
                    print_ok("LigneInventaireDialog utilise Combobox")
            break
    
    # Pattern 4: MouvementDialog utilise Entry pour article_id
    mouvement_dialog = re.compile(r'class\s+MouvementDialog\(', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if mouvement_dialog.search(line):
            check_lines = '\n'.join(lines[i:min(i+50, len(lines))])
            if 'article_id_var' in check_lines and 'tk.Entry' in check_lines:
                if 'Combobox' not in check_lines or 'list_articles_names' not in check_lines:
                    issues.append(f"MouvementDialog (ligne {i}): devrait utiliser Combobox au lieu de Entry pour article")
                    print_error(issues[-1])
                else:
                    print_ok("MouvementDialog utilise Combobox")
            break
    
    # Pattern 5: refresh_bilan sans protection contre None
    bilan_pattern = re.compile(r'def\s+refresh_bilan\(self\):', re.IGNORECASE)
    for i, line in enumerate(lines, 1):
        if bilan_pattern.search(line):
            check_lines = '\n'.join(lines[i:min(i+30, len(lines))])
            # VÃ©rifier si sum() est protÃ©gÃ©
            if 'sum(' in check_lines:
                if 'or 0' not in check_lines and 'if' not in check_lines:
                    issues.append(f"refresh_bilan (ligne {i}): sum() devrait Ãªtre protÃ©gÃ© contre None")
                    print_warning(issues[-1])
                else:
                    print_ok("refresh_bilan protÃ¨ge les agrÃ©gations")
            break
    
    if not issues:
        print_ok("Aucun problÃ¨me trouvÃ© dans buvette.py")
    
    return issues

def check_file_structure():
    """VÃ©rifie la structure des fichiers du projet."""
    print_section("VÃ©rification de la structure des fichiers")
    
    required_files = [
        "db/db.py",
        "modules/buvette_db.py",
        "modules/buvette.py",
        "modules/buvette_inventaire_db.py",
        "tests/test_buvette_inventaire.py"
    ]
    
    missing = []
    for file in required_files:
        if Path(file).exists():
            print_ok(f"Fichier trouvÃ©: {file}")
        else:
            missing.append(file)
            print_error(f"Fichier manquant: {file}")
    
    return missing

def generate_summary(all_issues):
    """GÃ©nÃ¨re un rÃ©sumÃ© des problÃ¨mes trouvÃ©s."""
    print_header("RÃ‰SUMÃ‰ DES VÃ‰RIFICATIONS")
    
    total_issues = sum(len(issues) for issues in all_issues.values())
    
    if total_issues == 0:
        print_ok("âœ“ Aucun problÃ¨me dÃ©tectÃ© ! Le module buvette est conforme.")
    else:
        print_error(f"âœ— {total_issues} problÃ¨me(s) dÃ©tectÃ©(s) nÃ©cessitant une correction:")
        
        for category, issues in all_issues.items():
            if issues:
                print(f"\n{Colors.WARNING}{category}:{Colors.ENDC}")
                for issue in issues:
                    print(f"  - {issue}")
    
    return total_issues

def main():
    """Fonction principale du script de vÃ©rification."""
    print_header("SCRIPT DE VÃ‰RIFICATION DU MODULE BUVETTE")
    print("Ce script identifie les incohÃ©rences et problÃ¨mes dans le module buvette")
    print("avant d'appliquer les corrections.\n")
    
    # Changer vers le rÃ©pertoire racine du projet
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    os.chdir(project_root)
    print(f"RÃ©pertoire de travail: {os.getcwd()}\n")
    
    all_issues = {}
    
    # 1. VÃ©rifier la structure des fichiers
    missing_files = check_file_structure()
    if missing_files:
        all_issues["Fichiers manquants"] = missing_files
    
    # 2. VÃ©rifier le schÃ©ma de base de donnÃ©es
    schema_issues = check_database_schema()
    if schema_issues:
        all_issues["SchÃ©ma de base de donnÃ©es"] = schema_issues
    
    # 3. VÃ©rifier buvette_db.py
    db_issues = check_buvette_db_file()
    if db_issues:
        all_issues["modules/buvette_db.py"] = db_issues
    
    # 4. VÃ©rifier buvette.py
    ui_issues = check_buvette_ui_file()
    if ui_issues:
        all_issues["modules/buvette.py"] = ui_issues
    
    # 5. ExÃ©cuter les tests
    tests_passed = run_tests()
    if not tests_passed:
        all_issues["Tests unitaires"] = ["Certains tests ont Ã©chouÃ©"]
    
    # 6. GÃ©nÃ©rer le rÃ©sumÃ©
    total_issues = generate_summary(all_issues)
    
    # Retourner un code de sortie appropriÃ©
    return 0 if total_issues == 0 else 1

if __name__ == "__main__":
    sys.exit(main())

```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/collect_inventory_error_reports.py ===

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Inventory Error Report Collector

This script lists recent inventory error reports and prints previews of their content.
Error reports are generated by modules/inventory_lines_dialog.py when inventory
loading fails.

Usage:
    python scripts/collect_inventory_error_reports.py

The script will:
1. Find all reports/inventory_error_*.txt files
2. Sort them by timestamp (newest first)
3. Display a preview of each report

Note: Error reports are not committed to the repository (excluded in .gitignore).
"""

import os
import glob
import itertools
from datetime import datetime


def collect_and_preview_reports(reports_dir="reports", max_preview_lines=30):
    """
    Collect and preview inventory error reports.
    
    Args:
        reports_dir: Directory containing error reports (default: "reports")
        max_preview_lines: Maximum number of lines to show per report (default: 30)
    """
    # Resolve reports directory path
    script_dir = os.path.dirname(os.path.abspath(__file__))
    repo_root = os.path.dirname(script_dir)
    reports_path = os.path.join(repo_root, reports_dir)
    
    # Check if reports directory exists
    if not os.path.exists(reports_path):
        print(f"Reports directory not found: {reports_path}")
        print("No error reports have been generated yet.")
        return
    
    # Find all inventory error reports
    report_pattern = os.path.join(reports_path, "inventory_error_*.txt")
    report_files = glob.glob(report_pattern)
    
    if not report_files:
        print(f"No inventory error reports found in: {reports_path}")
        print("This is good news - no errors have been reported!")
        return
    
    # Sort reports by modification time (newest first)
    report_files.sort(key=lambda f: os.path.getmtime(f), reverse=True)
    
    print("=" * 80)
    print(f"INVENTORY ERROR REPORT SUMMARY")
    print("=" * 80)
    print(f"Reports directory: {reports_path}")
    print(f"Total reports found: {len(report_files)}")
    print("=" * 80)
    print()
    
    # Display each report
    for idx, report_file in enumerate(report_files, start=1):
        filename = os.path.basename(report_file)
        file_size = os.path.getsize(report_file)
        file_mtime = datetime.fromtimestamp(os.path.getmtime(report_file))
        
        print(f"\n{'=' * 80}")
        print(f"REPORT {idx}/{len(report_files)}: {filename}")
        print(f"Modified: {file_mtime.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Size: {file_size} bytes")
        print(f"{'=' * 80}")
        
        # Read and display preview
        try:
            with open(report_file, 'r', encoding='utf-8') as f:
                # Use islice to read only needed lines for memory efficiency
                preview_lines = list(itertools.islice(f, max_preview_lines))
                
                print('\n'.join(line.rstrip() for line in preview_lines))
                
                # Check if there are more lines by trying to read one more
                next_line = f.readline()
                if next_line:
                    print(f"\n... (more lines, file continues)")
                    print(f"\nFull report: {report_file}")
        
        except Exception as e:
            print(f"Error reading report: {e}")
    
    print("\n" + "=" * 80)
    print("END OF REPORT SUMMARY")
    print("=" * 80)


def main():
    """Main entry point for the script."""
    print("Inventory Error Report Collector")
    print("=" * 80)
    print()
    
    collect_and_preview_reports()
    
    print("\n")
    print("Note: These reports help diagnose inventory loading issues.")
    print("See docs/DIAGNOSTICS_INVENTORY.md for more information.")


if __name__ == "__main__":
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/compat_yaml.py ===

```python
#!/usr/bin/env python3
"""
Compatibility YAML loader for schema_hints.yaml.

This module provides a simple YAML loader that tries to use PyYAML if available,
but falls back to a simple parser that can handle the specific format used by
the schema hints file.

Usage:
    from scripts.compat_yaml import load_hints
    
    hints = load_hints('db/schema_hints.yaml')
"""

import re
from pathlib import Path
from typing import Dict, Any, Optional


def load_hints(path: str) -> Optional[Dict[str, Any]]:
    """
    Load schema hints from a YAML file.
    
    Tries to use PyYAML if available, otherwise uses a simple parser
    for the specific format produced by analyze_modules_columns.py.
    
    Args:
        path: Path to the schema_hints.yaml file
        
    Returns:
        Dictionary containing the parsed hints, or None if loading fails
    """
    path_obj = Path(path)
    
    if not path_obj.exists():
        return None
    
    # Try PyYAML first
    try:
        import yaml
        with open(path_obj, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except ImportError:
        pass
    except Exception as e:
        print(f"Warning: PyYAML failed to load {path}: {e}")
    
    # Fall back to simple parser
    try:
        return _simple_yaml_parser(path_obj)
    except Exception as e:
        print(f"Error: Failed to parse {path}: {e}")
        return None


def _simple_yaml_parser(path: Path) -> Dict[str, Any]:
    """
    Simple YAML parser for the specific format used by schema_hints.yaml.
    
    Expected format:
        schema_version: "1.0"
        generated_by: "analyzer"
        tables:
          table_name:
            expected_columns:
              column_name:
                type: "TEXT"
                inferred: true
    
    Args:
        path: Path to the YAML file
        
    Returns:
        Parsed dictionary
    """
    with open(path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    result = {}
    current_dict = result
    stack = [(result, 0)]  # Stack of (dict, indent_level)
    
    for line in content.split('\n'):
        # Skip comments and empty lines
        stripped = line.strip()
        if not stripped or stripped.startswith('#'):
            continue
        
        # Calculate indentation level (spaces, assuming 2-space indent)
        indent = len(line) - len(line.lstrip())
        
        # Parse key-value pairs
        if ':' in line:
            parts = line.split(':', 1)
            key = parts[0].strip()
            value_str = parts[1].strip() if len(parts) > 1 else ''
            
            # Adjust stack based on indentation
            while stack and stack[-1][1] >= indent:
                stack.pop()
            
            # Parse value
            if value_str:
                # Simple value (string, number, boolean)
                value = _parse_value(value_str)
                if stack:
                    stack[-1][0][key] = value
            else:
                # Nested dictionary
                new_dict = {}
                if stack:
                    stack[-1][0][key] = new_dict
                stack.append((new_dict, indent))
    
    return result


def _parse_value(value_str: str) -> Any:
    """
    Parse a simple YAML value.
    
    Args:
        value_str: String representation of the value
        
    Returns:
        Parsed value (str, int, float, bool, or None)
    """
    # Remove quotes if present
    value_str = value_str.strip()
    
    if value_str.startswith('"') and value_str.endswith('"'):
        return value_str[1:-1]
    if value_str.startswith("'") and value_str.endswith("'"):
        return value_str[1:-1]
    
    # Boolean
    if value_str.lower() == 'true':
        return True
    if value_str.lower() == 'false':
        return False
    
    # None/null
    if value_str.lower() in ('null', 'none', '~'):
        return None
    
    # Number
    try:
        if '.' in value_str:
            return float(value_str)
        return int(value_str)
    except ValueError:
        pass
    
    # Default to string
    return value_str


if __name__ == "__main__":
    # Test the loader
    import sys
    
    if len(sys.argv) > 1:
        test_path = sys.argv[1]
    else:
        # Default test path
        repo_root = Path(__file__).parent.parent
        test_path = repo_root / "db" / "schema_hints.yaml"
    
    print(f"Testing YAML loader with: {test_path}")
    hints = load_hints(str(test_path))
    
    if hints:
        print(f"\nSuccessfully loaded hints!")
        print(f"Schema version: {hints.get('schema_version')}")
        print(f"Generated by: {hints.get('generated_by')}")
        
        if 'tables' in hints:
            print(f"\nFound {len(hints['tables'])} tables:")
            for table_name in sorted(hints['tables'].keys())[:5]:
                cols = hints['tables'][table_name].get('expected_columns', {})
                print(f"  - {table_name}: {len(cols)} columns")
            
            if len(hints['tables']) > 5:
                print(f"  ... and {len(hints['tables']) - 5} more tables")
    else:
        print("Failed to load hints")
        sys.exit(1)

```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/db_diagnostics.py ===

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Database Diagnostics Script

This script performs health checks on the SQLite database to diagnose
issues related to:
- Database locks
- WAL mode configuration
- Connection settings
- Table integrity
- Common sqlite3.Row conversion issues

Usage:
    python scripts/db_diagnostics.py [--db-path PATH] [--output REPORT_FILE]
    
Example:
    python scripts/db_diagnostics.py
    python scripts/db_diagnostics.py --db-path association.db --output reports/db_health.txt
"""

import sqlite3
import sys
import os
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Tuple, Any

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from db.db import get_db_file, get_connection
from utils.app_logger import get_logger

logger = get_logger("db_diagnostics")


class DBDiagnostics:
    """Database diagnostics and health check utility."""
    
    def __init__(self, db_path: str = None):
        """
        Initialize diagnostics.
        
        Args:
            db_path: Path to database file (optional, uses default if not provided)
        """
        self.db_path = db_path or get_db_file()
        self.results = {
            'timestamp': datetime.now().isoformat(),
            'db_path': self.db_path,
            'checks': {},
            'errors': [],
            'warnings': []
        }
    
    def check_file_exists(self) -> bool:
        """Check if database file exists."""
        exists = os.path.exists(self.db_path)
        self.results['checks']['file_exists'] = exists
        if not exists:
            self.results['errors'].append(f"Database file not found: {self.db_path}")
        return exists
    
    def check_file_permissions(self) -> bool:
        """Check if database file is readable and writable."""
        try:
            readable = os.access(self.db_path, os.R_OK)
            writable = os.access(self.db_path, os.W_OK)
            
            self.results['checks']['file_readable'] = readable
            self.results['checks']['file_writable'] = writable
            
            if not readable:
                self.results['errors'].append("Database file is not readable")
            if not writable:
                self.results['warnings'].append("Database file is not writable")
            
            return readable and writable
        except Exception as e:
            self.results['errors'].append(f"Error checking file permissions: {e}")
            return False
    
    def check_wal_mode(self) -> Tuple[bool, str]:
        """Check if WAL mode is enabled."""
        try:
            conn = sqlite3.connect(self.db_path, timeout=5)
            cursor = conn.cursor()
            cursor.execute("PRAGMA journal_mode;")
            mode = cursor.fetchone()[0]
            conn.close()
            
            is_wal = mode.upper() == 'WAL'
            self.results['checks']['wal_mode'] = mode
            
            if not is_wal:
                self.results['warnings'].append(
                    f"WAL mode not enabled (current: {mode}). "
                    "Consider running scripts/enable_wal.py"
                )
            
            return is_wal, mode
        except Exception as e:
            self.results['errors'].append(f"Error checking WAL mode: {e}")
            return False, "unknown"
    
    def check_busy_timeout(self) -> int:
        """Check busy timeout configuration."""
        try:
            conn = sqlite3.connect(self.db_path, timeout=5)
            cursor = conn.cursor()
            cursor.execute("PRAGMA busy_timeout;")
            timeout = cursor.fetchone()[0]
            conn.close()
            
            self.results['checks']['busy_timeout'] = timeout
            
            if timeout < 5000:
                self.results['warnings'].append(
                    f"Busy timeout is low ({timeout}ms). "
                    "Recommended: 5000ms or higher to reduce lock errors"
                )
            
            return timeout
        except Exception as e:
            self.results['errors'].append(f"Error checking busy timeout: {e}")
            return 0
    
    def check_database_integrity(self) -> bool:
        """Run SQLite integrity check."""
        try:
            conn = sqlite3.connect(self.db_path, timeout=5)
            cursor = conn.cursor()
            cursor.execute("PRAGMA integrity_check;")
            result = cursor.fetchone()[0]
            conn.close()
            
            is_ok = result.lower() == 'ok'
            self.results['checks']['integrity_check'] = result
            
            if not is_ok:
                self.results['errors'].append(f"Database integrity check failed: {result}")
            
            return is_ok
        except Exception as e:
            self.results['errors'].append(f"Error running integrity check: {e}")
            return False
    
    def check_connection(self) -> bool:
        """Test basic database connection."""
        try:
            conn = get_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT 1;")
            cursor.fetchone()
            conn.close()
            
            self.results['checks']['connection_test'] = "OK"
            return True
        except Exception as e:
            self.results['errors'].append(f"Connection test failed: {e}")
            self.results['checks']['connection_test'] = f"FAILED: {e}"
            return False
    
    def check_row_factory(self) -> bool:
        """Check if row_factory is properly configured."""
        try:
            conn = get_connection()
            has_row_factory = conn.row_factory is not None
            factory_type = type(conn.row_factory).__name__ if has_row_factory else "None"
            conn.close()
            
            self.results['checks']['row_factory'] = factory_type
            
            if not has_row_factory:
                self.results['warnings'].append(
                    "No row_factory configured. Consider using sqlite3.Row for named access"
                )
            
            return has_row_factory
        except Exception as e:
            self.results['errors'].append(f"Error checking row_factory: {e}")
            return False
    
    def list_tables(self) -> List[str]:
        """List all tables in the database."""
        try:
            conn = sqlite3.connect(self.db_path, timeout=5)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT name FROM sqlite_master 
                WHERE type='table' 
                ORDER BY name;
            """)
            tables = [row[0] for row in cursor.fetchall()]
            conn.close()
            
            self.results['checks']['table_count'] = len(tables)
            self.results['checks']['tables'] = tables
            
            return tables
        except Exception as e:
            self.results['errors'].append(f"Error listing tables: {e}")
            return []
    
    def check_table_sizes(self) -> Dict[str, int]:
        """Get row counts for all tables."""
        tables = self.list_tables()
        sizes = {}
        
        try:
            conn = sqlite3.connect(self.db_path, timeout=5)
            cursor = conn.cursor()
            
            for table in tables:
                try:
                    # Use identifier quoting to prevent SQL injection
                    # sqlite_master returns trusted table names, but use quoting for safety
                    quoted_table = f'"{table}"'
                    cursor.execute(f"SELECT COUNT(*) FROM {quoted_table};")
                    count = cursor.fetchone()[0]
                    sizes[table] = count
                except Exception as e:
                    sizes[table] = f"Error: {e}"
            
            conn.close()
            self.results['checks']['table_sizes'] = sizes
            
            return sizes
        except Exception as e:
            self.results['errors'].append(f"Error checking table sizes: {e}")
            return {}
    
    def run_all_checks(self) -> Dict[str, Any]:
        """Run all diagnostic checks."""
        print("Running database diagnostics...\n")
        
        # Basic file checks
        print("1. Checking database file...")
        if not self.check_file_exists():
            return self.results
        self.check_file_permissions()
        
        # Configuration checks
        print("2. Checking database configuration...")
        self.check_wal_mode()
        self.check_busy_timeout()
        self.check_row_factory()
        
        # Connection tests
        print("3. Testing database connection...")
        self.check_connection()
        
        # Integrity checks
        print("4. Running integrity check...")
        self.check_database_integrity()
        
        # Table information
        print("5. Gathering table information...")
        self.list_tables()
        self.check_table_sizes()
        
        print("\nDiagnostics complete!\n")
        return self.results
    
    def generate_report(self, output_file: str = None) -> str:
        """
        Generate a human-readable report.
        
        Args:
            output_file: Optional file path to write report to
            
        Returns:
            str: Report text
        """
        lines = []
        lines.append("=" * 80)
        lines.append("DATABASE DIAGNOSTICS REPORT")
        lines.append("=" * 80)
        lines.append(f"Timestamp: {self.results['timestamp']}")
        lines.append(f"Database: {self.results['db_path']}")
        lines.append("")
        
        # Summary
        error_count = len(self.results['errors'])
        warning_count = len(self.results['warnings'])
        
        lines.append("SUMMARY")
        lines.append("-" * 80)
        if error_count == 0 and warning_count == 0:
            lines.append("âœ“ All checks passed!")
        else:
            if error_count > 0:
                lines.append(f"âœ— {error_count} error(s) found")
            if warning_count > 0:
                lines.append(f"âš  {warning_count} warning(s) found")
        lines.append("")
        
        # Errors
        if self.results['errors']:
            lines.append("ERRORS")
            lines.append("-" * 80)
            for error in self.results['errors']:
                lines.append(f"âœ— {error}")
            lines.append("")
        
        # Warnings
        if self.results['warnings']:
            lines.append("WARNINGS")
            lines.append("-" * 80)
            for warning in self.results['warnings']:
                lines.append(f"âš  {warning}")
            lines.append("")
        
        # Detailed checks
        lines.append("DETAILED CHECKS")
        lines.append("-" * 80)
        checks = self.results['checks']
        
        for key, value in checks.items():
            if key == 'tables':
                lines.append(f"Tables: {', '.join(value) if value else 'None'}")
            elif key == 'table_sizes':
                lines.append("Table Sizes:")
                for table, size in value.items():
                    lines.append(f"  - {table}: {size} rows")
            else:
                lines.append(f"{key}: {value}")
        
        lines.append("")
        lines.append("=" * 80)
        
        report = '\n'.join(lines)
        
        # Write to file if requested
        if output_file:
            try:
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write(report)
                print(f"\nReport written to: {output_file}")
            except Exception as e:
                print(f"\nError writing report: {e}")
        
        return report


def main():
    """Main entry point."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Run database diagnostics and health checks"
    )
    parser.add_argument(
        '--db-path',
        help='Path to database file (optional, uses default if not provided)'
    )
    parser.add_argument(
        '--output',
        help='Output file for report (optional, prints to stdout if not provided)'
    )
    
    args = parser.parse_args()
    
    # Run diagnostics
    diagnostics = DBDiagnostics(db_path=args.db_path)
    diagnostics.run_all_checks()
    
    # Generate and display report
    report = diagnostics.generate_report(output_file=args.output)
    print(report)
    
    # Exit with error code if errors found
    if diagnostics.results['errors']:
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == '__main__':
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/enable_wal.py ===

```python
#!/usr/bin/env python3
"""
Utility script to enable WAL (Write-Ahead Logging) mode on a SQLite database.

WAL mode provides better concurrency and reduces database locking issues.
This script can be used to enable WAL mode on any existing database.

Usage:
    python scripts/enable_wal.py [database_path]
    
If no database path is provided, it will use the default application database.
"""

import sqlite3
import os
import sys

# Add parent directory to path to import db module
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from db.db import get_db_file

# Import timeout constant for consistency
try:
    from lib.db_articles import DEFAULT_TIMEOUT
except ImportError:
    DEFAULT_TIMEOUT = 30.0  # Fallback if import fails

def enable_wal(db_path):
    """
    Enable WAL mode on the specified database.
    
    Args:
        db_path: Path to the SQLite database file
        
    Returns:
        bool: True if successful, False otherwise
    """
    if not os.path.exists(db_path):
        print(f"âœ— Error: Database file not found at {db_path}")
        return False
    
    print(f"Database: {db_path}")
    
    try:
        conn = sqlite3.connect(db_path, timeout=DEFAULT_TIMEOUT)
        cursor = conn.cursor()
        
        # Check current journal mode
        cursor.execute("PRAGMA journal_mode;")
        current_mode = cursor.fetchone()[0]
        print(f"Current journal mode: {current_mode}")
        
        if current_mode.upper() == "WAL":
            print("âœ“ WAL mode is already enabled")
            conn.close()
            return True
        
        # Enable WAL mode
        print("â†’ Enabling WAL mode...")
        cursor.execute("PRAGMA journal_mode=WAL;")
        result = cursor.fetchone()[0]
        
        if result.upper() == "WAL":
            print(f"âœ“ Successfully enabled WAL mode")
        else:
            print(f"âš  Warning: Expected WAL but got {result}")
        
        # Set synchronous to NORMAL for better performance
        print("â†’ Setting synchronous mode to NORMAL...")
        cursor.execute("PRAGMA synchronous=NORMAL;")
        print("âœ“ Synchronous mode set to NORMAL")
        
        # Display additional info
        cursor.execute("PRAGMA synchronous;")
        sync_mode = cursor.fetchone()[0]
        print(f"  Synchronous level: {sync_mode}")
        
        conn.close()
        print("\nâœ“ Database optimized for better concurrency")
        return True
        
    except sqlite3.OperationalError as e:
        error_msg = str(e).lower()
        if "database is locked" in error_msg:
            print(f"âœ— Error: Database is currently locked by another process")
            print("  Please close all applications using the database and try again")
        else:
            print(f"âœ— SQLite error: {e}")
        return False
        
    except Exception as e:
        print(f"âœ— Unexpected error: {e}")
        return False

def main():
    """Main entry point for the script."""
    print("=" * 70)
    print("SQLite WAL Mode Enabler")
    print("=" * 70)
    print()
    
    # Determine database path
    if len(sys.argv) > 1:
        db_path = sys.argv[1]
    else:
        db_path = get_db_file()
        print(f"Using default database from configuration")
    
    success = enable_wal(db_path)
    
    print()
    print("=" * 70)
    if success:
        print("âœ“ OPERATION COMPLETED SUCCESSFULLY")
        print("=" * 70)
        sys.exit(0)
    else:
        print("âœ— OPERATION FAILED")
        print("=" * 70)
        sys.exit(1)

if __name__ == "__main__":
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/migrate_add_purchase_price.py ===

```python
#!/usr/bin/env python3
"""
Migration script to add purchase_price column to buvette_articles table.
This script is idempotent - it can be run multiple times safely.

Features:
- Automatic database backup before migration
- Table existence detection with clear error messages
- Adds purchase_price column if missing
- Enables WAL mode for better concurrency
- Transaction-based operations with error handling
"""

import sqlite3
import os
import sys
import shutil
from datetime import datetime

# Add parent directory to path to import db module
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from db.db import get_db_file

# Import timeout constant for consistency
try:
    from lib.db_articles import DEFAULT_TIMEOUT
except ImportError:
    DEFAULT_TIMEOUT = 30.0  # Fallback if import fails

def backup_database(db_path):
    """
    Create a backup of the database file.
    
    Args:
        db_path: Path to the database file
        
    Returns:
        str: Path to the backup file
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = f"{db_path}.{timestamp}.bak"
    
    try:
        shutil.copy2(db_path, backup_path)
        print(f"âœ“ Database backup created: {backup_path}")
        return backup_path
    except Exception as e:
        print(f"âœ— Error creating backup: {e}")
        raise

def enable_wal_mode(conn):
    """
    Enable WAL (Write-Ahead Logging) mode for better concurrency.
    
    Args:
        conn: SQLite connection
    """
    try:
        cursor = conn.cursor()
        cursor.execute("PRAGMA journal_mode=WAL;")
        result = cursor.fetchone()
        print(f"âœ“ WAL mode enabled: {result[0]}")
        
        cursor.execute("PRAGMA synchronous=NORMAL;")
        print(f"âœ“ Synchronous mode set to NORMAL for better performance")
    except Exception as e:
        print(f"âš  Warning: Could not enable WAL mode: {e}")

def migrate_add_purchase_price():
    """
    Add purchase_price column to buvette_articles if it doesn't exist.
    This is a non-destructive migration with automatic backup.
    """
    db_path = get_db_file()
    
    # Check if database file exists
    if not os.path.exists(db_path):
        print(f"âœ— Error: Database file not found at {db_path}")
        print("  Please ensure the database has been initialized.")
        return False
    
    print(f"Database location: {db_path}")
    
    # Create backup
    try:
        backup_path = backup_database(db_path)
    except Exception as e:
        print(f"âœ— Failed to create backup. Migration aborted for safety.")
        return False
    
    conn = None
    try:
        # Connect with a reasonable timeout
        conn = sqlite3.connect(db_path, timeout=DEFAULT_TIMEOUT)
        cursor = conn.cursor()
        
        # Begin transaction
        cursor.execute("BEGIN TRANSACTION;")
        
        # Check if buvette_articles table exists
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='buvette_articles'
        """)
        table_exists = cursor.fetchone()
        
        if not table_exists:
            print("âœ— Error: Table 'buvette_articles' does not exist.")
            print("  Please initialize the database first using init_db.py")
            conn.rollback()
            conn.close()
            return False
        
        print("âœ“ Table 'buvette_articles' found")
        
        # Check if the column already exists
        cursor.execute("PRAGMA table_info(buvette_articles)")
        columns = [row[1] for row in cursor.fetchall()]
        
        if "purchase_price" in columns:
            print("âœ“ Column 'purchase_price' already exists in buvette_articles table.")
            conn.rollback()  # No changes needed
            conn.close()
            print("\nâœ“ No migration needed - database is already up to date")
            return True
        
        # Add the column
        print("â†’ Adding 'purchase_price' column to buvette_articles table...")
        cursor.execute("ALTER TABLE buvette_articles ADD COLUMN purchase_price REAL")
        
        # Commit the transaction
        conn.commit()
        print("âœ“ Successfully added 'purchase_price' column")
        
        # Enable WAL mode for better concurrency
        print("\nâ†’ Optimizing database for better concurrency...")
        enable_wal_mode(conn)
        
        conn.close()
        
        print(f"\nâœ“ Migration completed successfully!")
        print(f"  Backup saved at: {backup_path}")
        print(f"  To rollback, restore from: {backup_path}")
        
        return True
        
    except sqlite3.OperationalError as e:
        error_msg = str(e).lower()
        if "database is locked" in error_msg:
            print(f"âœ— Error: Database is currently locked by another process")
            print("  Please close all applications using the database and try again")
        elif "no such table" in error_msg:
            print(f"âœ— Error: Table 'buvette_articles' does not exist")
            print("  Please initialize the database first")
        else:
            print(f"âœ— SQLite error: {e}")
        
        if conn:
            try:
                conn.rollback()
                conn.close()
            except:
                pass
        return False
        
    except Exception as e:
        print(f"âœ— Unexpected error during migration: {e}")
        if conn:
            try:
                conn.rollback()
                conn.close()
            except:
                pass
        return False

if __name__ == "__main__":
    print("=" * 70)
    print("Database Migration: Add purchase_price column")
    print("=" * 70)
    print()
    
    success = migrate_add_purchase_price()
    
    print()
    print("=" * 70)
    if success:
        print("âœ“ MIGRATION COMPLETED SUCCESSFULLY")
        print("=" * 70)
        sys.exit(0)
    else:
        print("âœ— MIGRATION FAILED")
        print("=" * 70)
        sys.exit(1)

```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/migration.py ===

```python
"""
Script de migration pour la base de donnÃ©es Log-Interactif-treso.
- Permet de mettre Ã  jour ou migrer le schÃ©ma de la base SQLite.
- Ã€ lancer manuellement en cas de mise Ã  jour de structure.

Usage :
    python scripts/migration.py
"""

import sqlite3
import sys
import os

DB_PATH = os.environ.get("DB_PATH", "./data/database.db")

MIGRATIONS = [
    # Exemple : Ajout d'une colonne 'description' Ã  la table events
    {
        "desc": "Ajout colonne 'description' Ã  events si absente",
        "sql": [
            "ALTER TABLE events ADD COLUMN description TEXT"
        ],
        "check": "PRAGMA table_info(events);",
        "trigger": lambda columns: not any(c[1]=="description" for c in columns)
    },
    # Ajout du prix d'achat unitaire pour les articles de buvette
    {
        "desc": "Ajout colonne 'purchase_price' Ã  buvette_articles si absente",
        "sql": [
            "ALTER TABLE buvette_articles ADD COLUMN purchase_price REAL"
        ],
        "check": "PRAGMA table_info(buvette_articles);",
        "trigger": lambda columns: not any(c[1]=="purchase_price" for c in columns)
    },
    # Ajouter d'autres migrations ici sous forme de dict
    # ...
]

def get_columns(conn, table):
    return conn.execute(f"PRAGMA table_info({table});").fetchall()

def run_migrations(conn):
    for mig in MIGRATIONS:
        print(f"> VÃ©rification : {mig['desc']}")
        check = mig["check"].split("(")[1].split(")")[0]
        columns = get_columns(conn, check)
        if mig["trigger"](columns):
            print(f"  - Migration nÃ©cessaire, exÃ©cution SQL : {mig['sql'][0]}")
            for sql in mig["sql"]:
                try:
                    conn.execute(sql)
                    print(f"    âœ“ {sql}")
                except Exception as e:
                    print(f"    âš ï¸  Erreur : {e}")
        else:
            print("  - DÃ©jÃ  Ã  jour, rien Ã  faire.")

def main():
    if not os.path.exists(DB_PATH):
        print(f"Base introuvable : {DB_PATH}")
        sys.exit(1)
    conn = sqlite3.connect(DB_PATH)
    try:
        run_migrations(conn)
        conn.commit()
        print("âœ… Migration terminÃ©e.")
    finally:
        conn.close()

if __name__ == "__main__":
    main()
```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/project_audit.py ===

```python
#!/usr/bin/env python3
"""
Project Audit Script for V2 - Logiciel Tresorerie Interactifs

This script performs a comprehensive audit of the codebase to detect:
- Sensitive files (databases, logs, environment files)
- Large files (>5 MB by default)
- Circular imports
- Orphan modules (rarely imported)
- TODO/FIXME/XXX comments
- Missing or unused dependencies
- Missing tests

The script generates a PROJECT_AUDIT.md report with findings and recommendations.

Usage:
    python scripts/project_audit.py [--output OUTPUT] [--max-size-MB SIZE]

Examples:
    python scripts/project_audit.py
    python scripts/project_audit.py --output PROJECT_AUDIT.md --max-size-MB 5
"""

import os
import sys
import ast
import argparse
from pathlib import Path
from collections import defaultdict
from typing import Dict, List, Set, Tuple, Optional
import re


class ProjectAuditor:
    """Audits a Python project for various issues and generates a report."""
    
    def __init__(self, root_dir: str, max_size_mb: float = 5.0):
        """
        Initialize the auditor.
        
        Args:
            root_dir: Root directory of the project
            max_size_mb: Maximum file size in MB before flagging as large
        """
        self.root_dir = Path(root_dir).resolve()
        self.max_size_bytes = int(max_size_mb * 1024 * 1024)
        
        # Results storage
        self.sensitive_files = {
            'databases': [],
            'logs': [],
            'env_files': [],
        }
        self.large_files = []
        self.import_graph = defaultdict(set)  # module -> set of imported modules
        self.circular_imports = []
        self.orphan_modules = []
        self.todos = []
        self.python_files = []
        self.modules_without_docstring = []
        self.modules_without_main = []
        self.parse_errors = []
        
        # Dependencies analysis
        self.requirements = set()
        self.imported_packages = set()
        
    def scan_files(self):
        """Scan the repository for files to analyze."""
        print("ðŸ” Scanning repository files...")
        
        for root, dirs, files in os.walk(self.root_dir):
            # Skip hidden directories and virtual environments
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['venv', '__pycache__', 'node_modules']]
            
            rel_root = Path(root).relative_to(self.root_dir)
            
            for file in files:
                file_path = Path(root) / file
                rel_path = file_path.relative_to(self.root_dir)
                
                # Check file size
                try:
                    file_size = file_path.stat().st_size
                    if file_size > self.max_size_bytes:
                        self.large_files.append({
                            'path': str(rel_path),
                            'size_mb': file_size / (1024 * 1024)
                        })
                except OSError:
                    pass
                
                # Categorize sensitive files
                if file.endswith(('.db', '.sqlite', '.sqlite3')):
                    self.sensitive_files['databases'].append(str(rel_path))
                elif file.endswith('.log'):
                    self.sensitive_files['logs'].append(str(rel_path))
                elif file in ['.env', 'env', '.env.local', '.env.production'] or file.startswith('env.'):
                    self.sensitive_files['env_files'].append(str(rel_path))
                
                # Track Python files for analysis
                if file.endswith('.py'):
                    self.python_files.append(file_path)
    
    def analyze_python_files(self):
        """Analyze Python files for imports, TODOs, and other issues."""
        print("ðŸ Analyzing Python files...")
        
        for py_file in self.python_files:
            rel_path = py_file.relative_to(self.root_dir)
            
            try:
                with open(py_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # Parse AST
                try:
                    tree = ast.parse(content, filename=str(py_file))
                    self._analyze_ast(tree, py_file, rel_path)
                except SyntaxError as e:
                    self.parse_errors.append({
                        'file': str(rel_path),
                        'error': str(e)
                    })
                
                # Search for TODO/FIXME/XXX comments
                self._find_todos(content, rel_path)
                
            except Exception as e:
                self.parse_errors.append({
                    'file': str(rel_path),
                    'error': f"Failed to read file: {str(e)}"
                })
    
    def _analyze_ast(self, tree: ast.AST, file_path: Path, rel_path: Path):
        """Analyze the AST of a Python file."""
        module_name = self._get_module_name(rel_path)
        
        # Check for module docstring
        has_docstring = (isinstance(tree.body, list) and 
                        len(tree.body) > 0 and 
                        isinstance(tree.body[0], ast.Expr) and 
                        isinstance(tree.body[0].value, (ast.Str, ast.Constant)))
        
        if not has_docstring:
            self.modules_without_docstring.append(str(rel_path))
        
        # Check for main function or if __name__ == "__main__"
        has_main = False
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef) and node.name in ['main', '__main__']:
                has_main = True
                break
            if isinstance(node, ast.If):
                # Check for if __name__ == "__main__"
                if isinstance(node.test, ast.Compare):
                    if hasattr(node.test.left, 'id') and node.test.left.id == '__name__':
                        has_main = True
                        break
        
        if not has_main and str(rel_path) not in ['__init__.py', 'setup.py', 'conftest.py']:
            self.modules_without_main.append(str(rel_path))
        
        # Extract imports
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imported_module = alias.name.split('.')[0]
                    self.import_graph[module_name].add(imported_module)
                    self.imported_packages.add(imported_module)
            
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imported_module = node.module.split('.')[0]
                    self.import_graph[module_name].add(imported_module)
                    self.imported_packages.add(imported_module)
    
    def _get_module_name(self, rel_path: Path) -> str:
        """Convert a file path to a module name."""
        parts = list(rel_path.parts)
        if parts[-1] == '__init__.py':
            parts = parts[:-1]
        else:
            parts[-1] = parts[-1][:-3]  # Remove .py extension
        return '.'.join(parts) if parts else 'root'
    
    def _find_todos(self, content: str, rel_path: Path):
        """Find TODO/FIXME/XXX comments in the content."""
        lines = content.split('\n')
        patterns = [r'#\s*(TODO|FIXME|XXX)', r'"""\s*(TODO|FIXME|XXX)', r"'''\s*(TODO|FIXME|XXX)"]
        
        for line_num, line in enumerate(lines, 1):
            for pattern in patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    self.todos.append({
                        'file': str(rel_path),
                        'line': line_num,
                        'text': line.strip()
                    })
                    break
    
    def detect_circular_imports(self):
        """Detect circular imports in the import graph."""
        print("ðŸ”„ Detecting circular imports...")
        
        visited = set()
        rec_stack = set()
        
        def has_cycle(node, path):
            visited.add(node)
            rec_stack.add(node)
            
            for neighbor in self.import_graph.get(node, []):
                if neighbor not in visited:
                    if has_cycle(neighbor, path + [neighbor]):
                        return True
                elif neighbor in rec_stack:
                    # Found a cycle
                    cycle_start = path.index(neighbor) if neighbor in path else 0
                    cycle = path[cycle_start:] + [neighbor]
                    if cycle not in self.circular_imports:
                        self.circular_imports.append(cycle)
                    return True
            
            rec_stack.remove(node)
            return False
        
        for node in list(self.import_graph.keys()):
            if node not in visited:
                has_cycle(node, [node])
    
    def identify_orphan_modules(self):
        """Identify modules that are rarely or never imported."""
        print("ðŸ” Identifying orphan modules...")
        
        # Count how many times each module is imported
        import_count = defaultdict(int)
        
        for module, imports in self.import_graph.items():
            for imported in imports:
                # Only count internal modules (not external packages)
                if '.' in imported or imported in [self._get_module_name(Path(pf).relative_to(self.root_dir)) for pf in self.python_files]:
                    import_count[imported] += 1
        
        # Find modules with 0-1 imports (potential orphans)
        all_modules = [self._get_module_name(Path(pf).relative_to(self.root_dir)) for pf in self.python_files]
        
        for module in all_modules:
            if import_count[module] <= 1 and module not in ['main', 'root', '__main__']:
                # Exclude common entry points and test files
                if not module.startswith('test_') and 'test' not in module:
                    self.orphan_modules.append({
                        'module': module,
                        'import_count': import_count[module]
                    })
    
    def analyze_dependencies(self):
        """Analyze dependencies from requirements.txt."""
        print("ðŸ“¦ Analyzing dependencies...")
        
        req_file = self.root_dir / 'requirements.txt'
        if req_file.exists():
            try:
                with open(req_file, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            # Extract package name (before ==, >=, etc.)
                            pkg_name = re.split(r'[=><!\[]', line)[0].strip()
                            # Normalize package names (e.g., python-docx -> docx)
                            self.requirements.add(pkg_name.lower().replace('-', '_'))
                            self.requirements.add(pkg_name.lower().replace('_', '-'))
                            self.requirements.add(pkg_name.lower())
            except Exception as e:
                print(f"Warning: Could not read requirements.txt: {e}")
    
    def count_tests(self) -> Dict[str, int]:
        """Count test files and test functions."""
        print("ðŸ§ª Counting tests...")
        
        test_dir = self.root_dir / 'tests'
        test_count = {'files': 0, 'functions': 0}
        
        if not test_dir.exists():
            return test_count
        
        for py_file in test_dir.rglob('*.py'):
            if py_file.name.startswith('test_') or py_file.name.endswith('_test.py'):
                test_count['files'] += 1
                
                try:
                    with open(py_file, 'r', encoding='utf-8') as f:
                        tree = ast.parse(f.read())
                        for node in ast.walk(tree):
                            if isinstance(node, ast.FunctionDef) and node.name.startswith('test_'):
                                test_count['functions'] += 1
                except:
                    pass
        
        return test_count
    
    def generate_report(self, output_file: str):
        """Generate the audit report in Markdown format."""
        print(f"ðŸ“ Generating report: {output_file}")
        
        report = []
        report.append("# PROJECT AUDIT REPORT")
        report.append("")
        report.append("*Generated automatically by `scripts/project_audit.py`*")
        report.append("")
        report.append("---")
        report.append("")
        
        # Executive Summary
        report.append("## ðŸ“Š Executive Summary")
        report.append("")
        
        total_issues = (
            len(self.sensitive_files['databases']) +
            len(self.sensitive_files['logs']) +
            len(self.sensitive_files['env_files']) +
            len(self.large_files) +
            len(self.circular_imports) +
            len(self.orphan_modules) +
            len(self.todos)
        )
        
        report.append(f"- **Total Python files analyzed**: {len(self.python_files)}")
        report.append(f"- **Total issues detected**: {total_issues}")
        report.append(f"- **Sensitive files found**: {len(self.sensitive_files['databases']) + len(self.sensitive_files['logs']) + len(self.sensitive_files['env_files'])}")
        report.append(f"- **Large files (>{self.max_size_bytes / (1024*1024):.0f} MB)**: {len(self.large_files)}")
        report.append(f"- **Circular imports detected**: {len(self.circular_imports)}")
        report.append(f"- **Potential orphan modules**: {len(self.orphan_modules)}")
        report.append(f"- **TODO/FIXME/XXX comments**: {len(self.todos)}")
        report.append("")
        
        # Sensitive Files
        report.append("## ðŸ”’ Security & Sensitive Files")
        report.append("")
        
        if self.sensitive_files['databases']:
            report.append("### Database Files")
            report.append("")
            report.append("âš ï¸ **Warning**: Database files should NOT be committed to the repository!")
            report.append("")
            for db_file in self.sensitive_files['databases']:
                report.append(f"- `{db_file}`")
            report.append("")
        
        if self.sensitive_files['logs']:
            report.append("### Log Files")
            report.append("")
            report.append("âš ï¸ **Warning**: Log files should NOT be committed to the repository!")
            report.append("")
            for log_file in self.sensitive_files['logs']:
                report.append(f"- `{log_file}`")
            report.append("")
        
        if self.sensitive_files['env_files']:
            report.append("### Environment Files")
            report.append("")
            report.append("âš ï¸ **Warning**: Environment files may contain sensitive information!")
            report.append("")
            for env_file in self.sensitive_files['env_files']:
                report.append(f"- `{env_file}`")
            report.append("")
        
        # Large Files
        if self.large_files:
            report.append("## ðŸ“¦ Large Files")
            report.append("")
            report.append(f"Files larger than {self.max_size_bytes / (1024*1024):.0f} MB:")
            report.append("")
            for lf in sorted(self.large_files, key=lambda x: x['size_mb'], reverse=True):
                report.append(f"- `{lf['path']}` - **{lf['size_mb']:.2f} MB**")
            report.append("")
        
        # Circular Imports
        if self.circular_imports:
            report.append("## ðŸ”„ Circular Import Issues")
            report.append("")
            report.append("âš ï¸ **Warning**: Circular imports can cause import errors and make code harder to maintain!")
            report.append("")
            for i, cycle in enumerate(self.circular_imports, 1):
                report.append(f"### Cycle {i}")
                report.append("")
                report.append(" â†’ ".join(cycle))
                report.append("")
        
        # Orphan Modules
        if self.orphan_modules:
            report.append("## ðŸ” Potential Orphan Modules")
            report.append("")
            report.append("Modules that are rarely or never imported by other modules:")
            report.append("")
            for orphan in sorted(self.orphan_modules, key=lambda x: x['import_count']):
                report.append(f"- `{orphan['module']}` (imported {orphan['import_count']} time(s))")
            report.append("")
        
        # Parse Errors
        if self.parse_errors:
            report.append("## âš ï¸ Parse Errors")
            report.append("")
            report.append("Files that could not be parsed:")
            report.append("")
            for error in self.parse_errors:
                report.append(f"- `{error['file']}`: {error['error']}")
            report.append("")
        
        # Modules without docstrings
        if self.modules_without_docstring:
            report.append("## ðŸ“ Code Quality: Missing Module Docstrings")
            report.append("")
            report.append(f"Found {len(self.modules_without_docstring)} Python file(s) without module-level docstrings:")
            report.append("")
            for module in sorted(self.modules_without_docstring)[:10]:
                report.append(f"- `{module}`")
            if len(self.modules_without_docstring) > 10:
                report.append(f"- ... and {len(self.modules_without_docstring) - 10} more")
            report.append("")
        
        # Dependencies Analysis
        report.append("## ðŸ“¦ Dependencies Analysis")
        report.append("")
        
        # Compare requirements with imports
        missing_in_requirements = []
        unused_in_requirements = []
        
        # Standard library modules to exclude
        stdlib_modules = {
            'os', 'sys', 're', 'json', 'csv', 'datetime', 'time', 'math', 'random',
            'collections', 'itertools', 'functools', 'pathlib', 'argparse', 'logging',
            'unittest', 'sqlite3', 'ast', 'io', 'typing', 'tkinter', 'threading',
            'subprocess', 'shutil', 'zipfile', 'tempfile', 'copy', 'pickle', 'hashlib'
        }
        
        for pkg in self.imported_packages:
            if pkg not in stdlib_modules and pkg not in self.requirements:
                # Check if it's an internal module
                if not any(pkg in str(pf) for pf in self.python_files):
                    missing_in_requirements.append(pkg)
        
        for req in self.requirements:
            found = False
            for pkg in self.imported_packages:
                if req in pkg or pkg in req or req.replace('_', '-') == pkg.replace('_', '-'):
                    found = True
                    break
            if not found:
                unused_in_requirements.append(req)
        
        if missing_in_requirements:
            report.append("### Potentially Missing from requirements.txt")
            report.append("")
            for pkg in sorted(set(missing_in_requirements)):
                report.append(f"- `{pkg}`")
            report.append("")
        
        if unused_in_requirements:
            report.append("### Potentially Unused in requirements.txt")
            report.append("")
            report.append("âš ï¸ Note: This is a heuristic check and may have false positives")
            report.append("")
            for pkg in sorted(set(unused_in_requirements)):
                report.append(f"- `{pkg}`")
            report.append("")
        
        # Test Coverage
        report.append("## ðŸ§ª Test Coverage")
        report.append("")
        
        test_stats = self.count_tests()
        report.append(f"- **Test files**: {test_stats['files']}")
        report.append(f"- **Test functions**: {test_stats['functions']}")
        report.append("")
        
        if test_stats['files'] == 0:
            report.append("âš ï¸ **Warning**: No test files found! Consider adding tests to ensure code quality.")
            report.append("")
        elif test_stats['functions'] < 10:
            report.append("âš ï¸ **Warning**: Low test coverage. Consider adding more tests.")
            report.append("")
        
        # TODOs
        if self.todos:
            report.append("## ðŸ“ TODO/FIXME/XXX Comments")
            report.append("")
            report.append(f"Found {len(self.todos)} TODO/FIXME/XXX comment(s):")
            report.append("")
            
            # Show first 20 TODOs
            for todo in self.todos[:20]:
                report.append(f"- `{todo['file']}:{todo['line']}` - {todo['text']}")
            
            if len(self.todos) > 20:
                report.append(f"- ... and {len(self.todos) - 20} more")
            report.append("")
        
        # Recommendations
        report.append("## ðŸ’¡ Recommendations")
        report.append("")
        
        # High Priority
        report.append("### ðŸ”´ High Priority")
        report.append("")
        
        if self.sensitive_files['databases']:
            report.append("1. **Remove database files from repository**")
            report.append("   ```bash")
            report.append("   # Remove from git tracking")
            for db_file in self.sensitive_files['databases']:
                report.append(f"   git rm --cached {db_file}")
            report.append("")
            report.append("   # Add to .gitignore")
            report.append("   echo '*.db' >> .gitignore")
            report.append("   echo '*.sqlite' >> .gitignore")
            report.append("   echo '*.sqlite3' >> .gitignore")
            report.append("   ```")
            report.append("")
        
        if self.sensitive_files['logs']:
            report.append("2. **Remove log files from repository**")
            report.append("   ```bash")
            report.append("   # Remove from git tracking")
            for log_file in self.sensitive_files['logs']:
                report.append(f"   git rm --cached {log_file}")
            report.append("")
            report.append("   # Add to .gitignore")
            report.append("   echo '*.log' >> .gitignore")
            report.append("   echo 'logs/' >> .gitignore")
            report.append("   ```")
            report.append("")
        
        if self.sensitive_files['env_files']:
            report.append("3. **Secure environment files**")
            report.append("   - Review environment files for sensitive information")
            report.append("   - Ensure `.env` files are in `.gitignore`")
            report.append("   - Use `env.example` as a template without sensitive data")
            report.append("")
        
        # Medium Priority
        report.append("### ðŸŸ¡ Medium Priority")
        report.append("")
        
        if self.circular_imports:
            report.append("1. **Refactor circular imports**")
            report.append("   - Review the circular import cycles listed above")
            report.append("   - Consider restructuring code to remove circular dependencies")
            report.append("   - Use dependency injection or move shared code to a common module")
            report.append("")
        
        if self.large_files:
            report.append("2. **Handle large files**")
            report.append("   - Consider using Git LFS for large binary files")
            report.append("   - Move large data files outside the repository")
            report.append("   ```bash")
            report.append("   # Install and use Git LFS")
            report.append("   git lfs install")
            report.append("   git lfs track '*.db'")
            report.append("   ```")
            report.append("")
        
        if test_stats['files'] < 5:
            report.append("3. **Improve test coverage**")
            report.append("   - Add unit tests for critical modules")
            report.append("   - Aim for at least 70% code coverage")
            report.append("   - Use pytest and coverage tools")
            report.append("   ```bash")
            report.append("   pip install pytest pytest-cov")
            report.append("   pytest --cov=. --cov-report=html")
            report.append("   ```")
            report.append("")
        
        # Low Priority
        report.append("### ðŸŸ¢ Low Priority")
        report.append("")
        
        if self.orphan_modules:
            report.append("1. **Review orphan modules**")
            report.append("   - Check if orphan modules are actually unused")
            report.append("   - Remove unused code or document why it's kept")
            report.append("")
        
        if self.todos:
            report.append("2. **Address TODO/FIXME comments**")
            report.append("   - Create issues for important TODOs")
            report.append("   - Remove or complete outdated TODOs")
            report.append("")
        
        if self.modules_without_docstring:
            report.append("3. **Add module docstrings**")
            report.append("   - Document the purpose of each module")
            report.append("   - Follow PEP 257 docstring conventions")
            report.append("")
        
        # How to Run
        report.append("## ðŸš€ How to Run This Audit Locally")
        report.append("")
        report.append("### Prerequisites")
        report.append("")
        report.append("- Python 3.8 or higher")
        report.append("")
        report.append("### Steps")
        report.append("")
        report.append("```bash")
        report.append("# Clone the repository")
        report.append("git clone <repository-url>")
        report.append("cd V2---Logiciel-Tresorerie-interactifs")
        report.append("")
        report.append("# Create and activate virtual environment (optional but recommended)")
        report.append("python -m venv venv")
        report.append("")
        report.append("# On Windows:")
        report.append(".\\venv\\Scripts\\Activate.ps1")
        report.append("# On Linux/Mac:")
        report.append("source venv/bin/activate")
        report.append("")
        report.append("# Install dependencies")
        report.append("pip install -r requirements.txt")
        report.append("")
        report.append("# Run the audit")
        report.append("python scripts/project_audit.py --output PROJECT_AUDIT.md")
        report.append("")
        report.append("# With custom max file size (default is 5 MB)")
        report.append("python scripts/project_audit.py --max-size-MB 10")
        report.append("```")
        report.append("")
        
        report.append("---")
        report.append("")
        report.append(f"*Report generated from: `{self.root_dir}`*")
        report.append("")
        
        # Write report to file
        output_path = self.root_dir / output_file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(report))
        
        print(f"âœ… Report generated: {output_path}")
    
    def print_summary(self):
        """Print a summary to console."""
        print("\n" + "="*60)
        print("PROJECT AUDIT SUMMARY")
        print("="*60)
        print(f"Total Python files: {len(self.python_files)}")
        print(f"Sensitive files: {len(self.sensitive_files['databases']) + len(self.sensitive_files['logs']) + len(self.sensitive_files['env_files'])}")
        print(f"  - Databases: {len(self.sensitive_files['databases'])}")
        print(f"  - Logs: {len(self.sensitive_files['logs'])}")
        print(f"  - Environment: {len(self.sensitive_files['env_files'])}")
        print(f"Large files: {len(self.large_files)}")
        print(f"Circular imports: {len(self.circular_imports)}")
        print(f"Orphan modules: {len(self.orphan_modules)}")
        print(f"TODO/FIXME/XXX: {len(self.todos)}")
        print(f"Parse errors: {len(self.parse_errors)}")
        print("="*60)
        print()
    
    def run_audit(self, output_file: str):
        """Run the complete audit process."""
        print("\nðŸ” Starting project audit...")
        print(f"ðŸ“ Root directory: {self.root_dir}")
        print(f"ðŸ“ Max file size: {self.max_size_bytes / (1024*1024):.1f} MB")
        print()
        
        self.scan_files()
        self.analyze_python_files()
        self.detect_circular_imports()
        self.identify_orphan_modules()
        self.analyze_dependencies()
        
        self.generate_report(output_file)
        self.print_summary()
        
        print(f"âœ… Audit complete! Report saved to: {output_file}")


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description="Audit a Python project for potential issues",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/project_audit.py
  python scripts/project_audit.py --output PROJECT_AUDIT.md --max-size-MB 10

The script will analyze the project and generate a detailed report.
        """
    )
    
    parser.add_argument(
        '--output',
        default='PROJECT_AUDIT.md',
        help='Output file for the audit report (default: PROJECT_AUDIT.md)'
    )
    
    parser.add_argument(
        '--max-size-MB',
        type=float,
        default=5.0,
        help='Maximum file size in MB before flagging as large (default: 5.0)'
    )
    
    args = parser.parse_args()
    
    # Get the root directory (parent of scripts/)
    script_dir = Path(__file__).parent
    root_dir = script_dir.parent
    
    try:
        auditor = ProjectAuditor(root_dir, args.max_size_MB)
        auditor.run_audit(args.output)
        return 0
    except Exception as e:
        print(f"âŒ Error during audit: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())

```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/update_db_structure.py ===

```python
#!/usr/bin/env python3
"""
Script de mise Ã  jour sÃ»re de la structure de base de donnÃ©es.

Ce script compare le schÃ©ma attendu (extrait du code ou du rapport d'analyse)
avec le schÃ©ma rÃ©el de la base de donnÃ©es et effectue des migrations sÃ»res
pour ajouter les colonnes manquantes.

FonctionnalitÃ©s:
- DÃ©tection automatique des colonnes manquantes
- Sauvegarde timestampÃ©e avant toute modification
- Transactions avec rollback en cas d'erreur
- Restauration automatique de la sauvegarde si Ã©chec
- Activation WAL mode et optimisation des pragmas
- Rapport dÃ©taillÃ© de migration

Usage:
    python scripts/update_db_structure.py [--db-path path/to/database.db]
"""

import sqlite3
import os
import sys
import shutil
import argparse
import traceback
import subprocess
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple, Set, Optional
from difflib import SequenceMatcher

# Force UTF-8 encoding for stdout/stderr on Windows to avoid encoding errors
try:
    sys.stdout.reconfigure(encoding='utf-8')
    sys.stderr.reconfigure(encoding='utf-8')
except Exception:
    pass

# Try to import compat_yaml for loading hints
try:
    from scripts.compat_yaml import load_hints
except ImportError:
    # Fallback if running from scripts/ directory
    try:
        from compat_yaml import load_hints
    except ImportError:
        load_hints = None

# Valid SQL identifier pattern
SQL_IDENTIFIER_PATTERN = re.compile(r'^[A-Za-z_][A-Za-z0-9_]*$')


# SchÃ©ma de rÃ©fÃ©rence basÃ© sur l'analyse du code et init_db.py
# Format: {table_name: {column_name: (type, default_value)}}
REFERENCE_SCHEMA = {
    "config": {
        "id": ("INTEGER", None),
        "exercice": ("TEXT", "''"),
        "date": ("TEXT", "''"),
        "but_asso": ("TEXT", "''"),
        "cloture": ("INTEGER", "0"),
        "solde_report": ("REAL", "0.0"),
        "disponible_banque": ("REAL", "0.0"),
    },
    "comptes": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "solde": ("REAL", "0.0"),
    },
    "membres": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "prenom": ("TEXT", "''"),
        "email": ("TEXT", "''"),
        "classe": ("TEXT", "''"),
        "cotisation": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "telephone": ("TEXT", "''"),
        "statut": ("TEXT", "''"),
        "date_adhesion": ("TEXT", "''"),
    },
    "events": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "date": ("TEXT", "''"),
        "lieu": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "description": ("TEXT", "''"),
    },
    "event_modules": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "nom_module": ("TEXT", "''"),
        "id_col_total": ("INTEGER", None),
    },
    "event_module_fields": {
        "id": ("INTEGER", None),
        "module_id": ("INTEGER", "0"),
        "nom_champ": ("TEXT", "''"),
        "type_champ": ("TEXT", "''"),
        "prix_unitaire": ("REAL", None),
        "modele_colonne": ("TEXT", None),
    },
    "event_module_data": {
        "module_id": ("INTEGER", "0"),
        "row_index": ("INTEGER", "0"),
        "field_id": ("INTEGER", "0"),
        "valeur": ("TEXT", "''"),
    },
    "event_payments": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "type": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "event_caisses": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "nom_caisse": ("TEXT", "''"),
        "montant_initial": ("REAL", "0.0"),
        "montant_final": ("REAL", "0.0"),
    },
    "event_caisse_details": {
        "id": ("INTEGER", None),
        "caisse_id": ("INTEGER", "0"),
        "type": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "description": ("TEXT", "''"),
    },
    "event_recettes": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "categorie": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "event_depenses": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "categorie": ("TEXT", "''"),
        "fournisseur": ("TEXT", "''"),
        "date_depense": ("TEXT", "''"),
        "paye_par": ("TEXT", "''"),
        "membre_id": ("INTEGER", None),
        "statut_remboursement": ("TEXT", "''"),
        "statut_reglement": ("TEXT", "''"),
        "moyen_paiement": ("TEXT", "''"),
        "numero_cheque": ("TEXT", "''"),
        "numero_facture": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "module_id": ("INTEGER", None),
    },
    "dons_subventions": {
        "id": ("INTEGER", None),
        "donateur": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "depenses_regulieres": {
        "id": ("INTEGER", None),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "categorie": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "fournisseur": ("TEXT", "''"),
        "date_depense": ("TEXT", "''"),
        "paye_par": ("TEXT", "''"),
        "membre_id": ("INTEGER", None),
        "statut_remboursement": ("TEXT", "''"),
        "statut_reglement": ("TEXT", "''"),
        "moyen_paiement": ("TEXT", "''"),
        "numero_cheque": ("TEXT", "''"),
        "numero_facture": ("TEXT", "''"),
        "module_id": ("INTEGER", None),
    },
    "depenses_diverses": {
        "id": ("INTEGER", None),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "categorie": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "fournisseur": ("TEXT", "''"),
        "date_depense": ("TEXT", "''"),
        "paye_par": ("TEXT", "''"),
        "membre_id": ("INTEGER", None),
        "statut_remboursement": ("TEXT", "''"),
        "statut_reglement": ("TEXT", "''"),
        "moyen_paiement": ("TEXT", "''"),
        "numero_cheque": ("TEXT", "''"),
        "numero_facture": ("TEXT", "''"),
        "module_id": ("INTEGER", None),
    },
    "categories": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "parent_id": ("INTEGER", None),
    },
    "stock": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "categorie_id": ("INTEGER", None),
        "quantite": ("INTEGER", "0"),
        "seuil_alerte": ("INTEGER", "0"),
        "date_peremption": ("TEXT", "''"),
        "lot": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "inventaires": {
        "id": ("INTEGER", None),
        "date": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "inventaire_lignes": {
        "id": ("INTEGER", None),
        "inventaire_id": ("INTEGER", "0"),
        "stock_id": ("INTEGER", "0"),
        "quantite": ("INTEGER", "0"),
        "ecart": ("INTEGER", "0"),
    },
    "mouvements_stock": {
        "id": ("INTEGER", None),
        "stock_id": ("INTEGER", "0"),
        "date": ("TEXT", "''"),
        "type": ("TEXT", "''"),
        "quantite": ("INTEGER", "0"),
        "commentaire": ("TEXT", "''"),
    },
    "fournisseurs": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
    },
    "colonnes_modeles": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "type_modele": ("TEXT", "''"),
    },
    "valeurs_modeles_colonnes": {
        "id": ("INTEGER", None),
        "modele_id": ("INTEGER", "0"),
        "valeur": ("TEXT", "''"),
    },
    "depots_retraits_banque": {
        "id": ("INTEGER", None),
        "date": ("TEXT", "''"),
        "type": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "reference": ("TEXT", "''"),
        "banque": ("TEXT", "''"),
        "pointe": ("INTEGER", "0"),
        "commentaire": ("TEXT", "''"),
    },
    "historique_clotures": {
        "id": ("INTEGER", None),
        "date_cloture": ("TEXT", "''"),
    },
    "retrocessions_ecoles": {
        "id": ("INTEGER", None),
        "date": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "ecole": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "buvette_articles": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "categorie": ("TEXT", "''"),
        "unite": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "contenance": ("REAL", None),
        "stock": ("INTEGER", "0"),
        "purchase_price": ("REAL", None),
    },
    "buvette_achats": {
        "id": ("INTEGER", None),
        "article_id": ("INTEGER", "0"),
        "date_achat": ("TEXT", "''"),
        "quantite": ("REAL", "0.0"),
        "prix_unitaire": ("REAL", "0.0"),
        "fournisseur": ("TEXT", "''"),
        "facture": ("TEXT", "''"),
        "exercice": ("TEXT", "''"),
    },
    "buvette_inventaires": {
        "id": ("INTEGER", None),
        "date_inventaire": ("TEXT", "''"),
        "event_id": ("INTEGER", None),
        "type_inventaire": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "buvette_inventaire_lignes": {
        "id": ("INTEGER", None),
        "inventaire_id": ("INTEGER", "0"),
        "article_id": ("INTEGER", "0"),
        "quantite": ("REAL", "0.0"),
        "commentaire": ("TEXT", "''"),
    },
    "buvette_mouvements": {
        "id": ("INTEGER", None),
        "date_mouvement": ("TEXT", "''"),
        "article_id": ("INTEGER", "0"),
        "type_mouvement": ("TEXT", "''"),
        "quantite": ("REAL", "0.0"),
        "motif": ("TEXT", "''"),
        "event_id": ("INTEGER", None),
    },
    "buvette_recettes": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
    },
}


class DatabaseMigrator:
    """Gestionnaire de migration de base de donnÃ©es."""
    
    # SQL reserved words that need quoting (subset of most common ones)
    SQL_RESERVED_WORDS = {
        'add', 'all', 'alter', 'and', 'as', 'asc', 'between', 'by', 'case', 'check',
        'column', 'constraint', 'create', 'cross', 'default', 'delete', 'desc',
        'distinct', 'drop', 'else', 'end', 'exists', 'foreign', 'from', 'full',
        'group', 'having', 'in', 'index', 'inner', 'insert', 'into', 'is', 'join',
        'key', 'left', 'like', 'limit', 'not', 'null', 'on', 'or', 'order', 'outer',
        'primary', 'references', 'right', 'select', 'set', 'table', 'then', 'to',
        'union', 'unique', 'update', 'values', 'when', 'where'
    }
    
    def __init__(self, db_path: str, use_yaml_hints: bool = True, fuzzy_threshold: float = 0.75):
        self.db_path = db_path
        self.backup_path = None
        self.migration_log = []
        self.errors = []
        self.report_path = None
        self.use_yaml_hints = use_yaml_hints
        self.schema_hints = None
        self.column_mappings = {}  # Track old_name -> new_name mappings
        self.fuzzy_threshold = fuzzy_threshold  # Configurable fuzzy matching threshold
        self.skipped_invalid_names = []  # Track invalid column names skipped
    
    def log(self, message: str, level: str = "INFO"):
        """Ajoute un message au log de migration."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {level}: {message}"
        self.migration_log.append(log_entry)
        # Ensure we print without non-ASCII characters that might cause issues
        try:
            print(log_entry)
        except UnicodeEncodeError:
            # Fallback to ASCII-safe printing
            print(log_entry.encode('ascii', errors='replace').decode('ascii'))
    
    def is_valid_sql_identifier(self, identifier: str) -> bool:
        """Validate if an identifier is a valid SQL identifier."""
        if not identifier:
            return False
        return SQL_IDENTIFIER_PATTERN.match(identifier) is not None
    
    def load_schema_hints(self, yaml_path: Optional[str] = None) -> bool:
        """Charge le fichier schema_hints.yaml ou le gÃ©nÃ¨re s'il n'existe pas."""
        if yaml_path is None:
            repo_root = Path(__file__).parent.parent
            yaml_path = repo_root / "db" / "schema_hints.yaml"
        else:
            yaml_path = Path(yaml_path)
        
        if not yaml_path.exists():
            self.log(f"Schema hints file not found at {yaml_path}", "WARNING")
            self.log("Attempting to generate schema hints by running analyze_modules_columns.py...")
            
            try:
                # Run the analyze script to generate the YAML
                script_path = Path(__file__).parent / "analyze_modules_columns.py"
                result = subprocess.run(
                    [sys.executable, str(script_path)],
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                
                if result.returncode != 0:
                    self.log(f"Failed to generate schema hints: {result.stderr}", "ERROR")
                    return False
                
                self.log("Schema hints generated successfully")
            except Exception as e:
                self.log(f"Error generating schema hints: {e}", "ERROR")
                return False
        
        try:
            # Use compat_yaml loader if available
            if load_hints:
                self.schema_hints = load_hints(str(yaml_path))
                if self.schema_hints:
                    self.log(f"Loaded schema hints from {yaml_path} (using compat_yaml)")
                    return True
                else:
                    self.log(f"Failed to load schema hints using compat_yaml", "WARNING")
                    return False
            else:
                # Fallback to direct YAML loading (requires PyYAML)
                try:
                    import yaml
                    with open(yaml_path, 'r', encoding='utf-8') as f:
                        self.schema_hints = yaml.safe_load(f)
                    self.log(f"Loaded schema hints from {yaml_path} (using PyYAML)")
                    return True
                except ImportError:
                    self.log("Neither compat_yaml nor PyYAML available for loading hints", "ERROR")
                    return False
        except Exception as e:
            self.log(f"Error loading schema hints: {e}", "WARNING")
            return False
    
    def fuzzy_match_column(self, target_col: str, existing_cols: Set[str], threshold: Optional[float] = None) -> Optional[str]:
        """
        Trouve une colonne existante qui correspond au nom cible (fuzzy/case-insensitive).
        
        Args:
            target_col: Nom de colonne recherchÃ©
            existing_cols: Ensemble des colonnes existantes dans la table
            threshold: Seuil de similaritÃ© (0.0 Ã  1.0), uses instance default if None
        
        Returns:
            Nom de la colonne correspondante ou None
        """
        if threshold is None:
            threshold = self.fuzzy_threshold
        
        target_lower = target_col.lower()
        
        # 1. Exact match (case-insensitive)
        for col in existing_cols:
            if col.lower() == target_lower:
                return col
        
        # 2. Fuzzy match with SequenceMatcher
        best_match = None
        best_score = 0.0
        
        for col in existing_cols:
            # Calculate similarity ratio
            ratio = SequenceMatcher(None, target_lower, col.lower()).ratio()
            
            if ratio > best_score and ratio >= threshold:
                best_score = ratio
                best_match = col
        
        return best_match
    
    def quote_identifier(self, identifier: str) -> str:
        """
        Quote SQL identifier if it's a reserved word or contains special characters.
        
        Args:
            identifier: Column or table name
            
        Returns:
            Quoted identifier if needed, otherwise original
        """
        # Quote if it's a reserved word
        if identifier.lower() in self.SQL_RESERVED_WORDS:
            return f'"{identifier}"'
        
        # Quote if it contains special characters
        if not identifier.replace('_', '').isalnum():
            return f'"{identifier}"'
        
        return identifier
    
    def get_column_type_from_hints(self, table: str, column: str) -> Optional[str]:
        """RÃ©cupÃ¨re le type d'une colonne depuis les hints YAML."""
        if not self.schema_hints or "tables" not in self.schema_hints:
            return None
        
        if table not in self.schema_hints["tables"]:
            return None
        
        table_info = self.schema_hints["tables"][table]
        if "expected_columns" not in table_info:
            return None
        
        if column not in table_info["expected_columns"]:
            return None
        
        return table_info["expected_columns"][column].get("type", "TEXT")
    
    def create_backup(self) -> bool:
        """CrÃ©e une sauvegarde timestampÃ©e de la base de donnÃ©es."""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.backup_path = f"{self.db_path}.{timestamp}.bak"
            
            self.log(f"Creating backup: {self.backup_path}")
            shutil.copy2(self.db_path, self.backup_path)
            self.log(f"Backup created successfully: {self.backup_path}")
            return True
        except Exception as e:
            self.log(f"Failed to create backup: {e}", "ERROR")
            self.errors.append(f"Backup error: {e}")
            return False
    
    def restore_backup(self) -> bool:
        """Restaure la base de donnÃ©es depuis la sauvegarde."""
        if not self.backup_path or not os.path.exists(self.backup_path):
            self.log("No backup available to restore", "ERROR")
            return False
        
        try:
            self.log(f"Restoring from backup: {self.backup_path}")
            shutil.copy2(self.backup_path, self.db_path)
            self.log("Database restored successfully")
            return True
        except Exception as e:
            self.log(f"Failed to restore backup: {e}", "ERROR")
            self.errors.append(f"Restore error: {e}")
            return False
    
    def get_existing_schema(self, conn: sqlite3.Connection) -> Dict[str, Set[str]]:
        """RÃ©cupÃ¨re le schÃ©ma actuel de la base de donnÃ©es."""
        schema = {}
        
        cursor = conn.cursor()
        
        # Obtenir toutes les tables
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = [row[0] for row in cursor.fetchall()]
        
        for table in tables:
            # Obtenir les colonnes de chaque table
            cursor.execute(f"PRAGMA table_info({table})")
            columns = set(row[1] for row in cursor.fetchall())
            schema[table] = columns
        
        return schema
    
    def check_rename_column_support(self, conn: sqlite3.Connection) -> bool:
        """VÃ©rifie si SQLite supporte ALTER TABLE RENAME COLUMN (version 3.25.0+)."""
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT sqlite_version()")
            version = cursor.fetchone()[0]
            
            # Parse version (e.g., "3.35.5")
            major, minor, patch = map(int, version.split('.'))
            
            # RENAME COLUMN supported since 3.25.0
            supports_rename = (major > 3) or (major == 3 and minor >= 25)
            
            self.log(f"SQLite version: {version}, RENAME COLUMN support: {supports_rename}")
            return supports_rename
        except Exception as e:
            self.log(f"Could not determine SQLite version: {e}", "WARNING")
            return False
    
    def detect_missing_columns(self, existing_schema: Dict[str, Set[str]]) -> Dict[str, List[Tuple[str, str, str, Optional[str]]]]:
        """
        DÃ©tecte les colonnes manquantes par rapport au schÃ©ma de rÃ©fÃ©rence.
        
        Returns:
            Dict mapping table -> List of (col_name, col_type, default_value, fuzzy_match)
            where fuzzy_match is the name of an existing column that closely matches, or None
        """
        missing = {}
        
        # Combine REFERENCE_SCHEMA and YAML hints
        expected_schema = {}
        
        # Start with REFERENCE_SCHEMA
        for table, columns in REFERENCE_SCHEMA.items():
            expected_schema[table] = {}
            for col_name, (col_type, default_value) in columns.items():
                expected_schema[table][col_name] = (col_type, default_value)
        
        # Add columns from YAML hints if available
        if self.schema_hints and "tables" in self.schema_hints:
            for table, table_info in self.schema_hints["tables"].items():
                if "expected_columns" not in table_info:
                    continue
                
                if table not in expected_schema:
                    expected_schema[table] = {}
                
                for col_name, col_info in table_info["expected_columns"].items():
                    if col_name not in expected_schema[table]:
                        col_type = col_info.get("type", "TEXT")
                        # Infer default based on type
                        if col_type == "INTEGER":
                            default_value = "0"
                        elif col_type == "REAL":
                            default_value = "0.0"
                        else:
                            default_value = "''"
                        
                        expected_schema[table][col_name] = (col_type, default_value)
        
        # Now check for missing columns
        for table, expected_columns in expected_schema.items():
            if table not in existing_schema:
                self.log(f"Table '{table}' does not exist (will not be created automatically)", "WARNING")
                continue
            
            existing_cols = existing_schema[table]
            table_missing = []
            
            for col_name, (col_type, default_value) in expected_columns.items():
                # Validate column name before processing
                if not self.is_valid_sql_identifier(col_name):
                    self.log(f"SKIPPING invalid column name '{col_name}' in table '{table}' (does not match SQL identifier pattern)", "WARNING")
                    self.skipped_invalid_names.append(f"{table}.{col_name}")
                    continue
                
                if col_name not in existing_cols:
                    # Try fuzzy matching to find a similar column
                    fuzzy_match = self.fuzzy_match_column(col_name, existing_cols, threshold=0.75)
                    
                    if fuzzy_match:
                        self.log(f"Column '{col_name}' not found in '{table}', but found similar column '{fuzzy_match}'", "INFO")
                    
                    table_missing.append((col_name, col_type, default_value, fuzzy_match))
            
            if table_missing:
                missing[table] = table_missing
        
        return missing
    
    def apply_migrations(self, conn: sqlite3.Connection, missing_columns: Dict[str, List[Tuple[str, str, str, Optional[str]]]]) -> bool:
        """Applique les migrations pour ajouter les colonnes manquantes."""
        if not missing_columns:
            self.log("No missing columns detected. Database is up to date.")
            return True
        
        self.log(f"Found missing columns in {len(missing_columns)} table(s)")
        
        # Check if RENAME COLUMN is supported
        supports_rename = self.check_rename_column_support(conn)
        
        try:
            cursor = conn.cursor()
            
            # SQLite ne supporte pas toujours les transactions pour ALTER TABLE,
            # mais on utilise BEGIN pour grouper les opÃ©rations
            cursor.execute("BEGIN TRANSACTION")
            
            for table, columns in missing_columns.items():
                self.log(f"Processing table '{table}': {len(columns)} column(s) to add")
                
                for col_name, col_type, default_value, fuzzy_match in columns:
                    # Case 1: Fuzzy match found - try to rename or copy
                    if fuzzy_match:
                        self.log(f"  Column '{col_name}' has fuzzy match '{fuzzy_match}'")
                        
                        if supports_rename and fuzzy_match.lower() != col_name.lower():
                            # Try to rename the column
                            rename_sql = f"ALTER TABLE {table} RENAME COLUMN {fuzzy_match} TO {col_name}"
                            
                            try:
                                self.log(f"  Attempting to rename '{fuzzy_match}' to '{col_name}'...")
                                cursor.execute(rename_sql)
                                self.log(f"  [OK] Successfully renamed column '{fuzzy_match}' to '{col_name}'")
                                self.column_mappings[f"{table}.{fuzzy_match}"] = f"{table}.{col_name}"
                                continue
                            except sqlite3.OperationalError as e:
                                self.log(f"  [WARNING] RENAME failed: {e}. Will try ADD + COPY instead.", "WARNING")
                        
                        # If rename not supported or failed, do ADD + COPY
                        quoted_col = self.quote_identifier(col_name)
                        
                        if default_value is None:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type}"
                        else:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type} DEFAULT {default_value}"
                        
                        try:
                            self.log(f"  Adding new column '{col_name}' ({col_type})")
                            cursor.execute(alter_sql)
                            
                            # Copy data from fuzzy_match column to new column
                            # Quote identifiers in case they're reserved words
                            quoted_new = self.quote_identifier(col_name)
                            quoted_old = self.quote_identifier(fuzzy_match)
                            copy_sql = f"UPDATE {table} SET {quoted_new} = {quoted_old}"
                            self.log(f"  Copying data from '{fuzzy_match}' to '{col_name}'...")
                            cursor.execute(copy_sql)
                            
                            self.log(f"  [OK] Added column '{col_name}' and copied data from '{fuzzy_match}'")
                            self.column_mappings[f"{table}.{fuzzy_match}"] = f"{table}.{col_name} (copied)"
                            
                        except sqlite3.OperationalError as e:
                            error_msg = str(e).lower()
                            if "duplicate" in error_msg and "column" in error_msg:
                                self.log(f"  [WARNING] Column '{col_name}' already exists", "WARNING")
                            else:
                                raise
                    
                    # Case 2: No fuzzy match - just add the column
                    else:
                        # Quote column name if it's a reserved word
                        quoted_col = self.quote_identifier(col_name)
                        
                        if default_value is None:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type}"
                        else:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type} DEFAULT {default_value}"
                        
                        try:
                            self.log(f"  Adding column: {col_name} ({col_type})")
                            cursor.execute(alter_sql)
                            self.log(f"  [OK] Successfully added column '{col_name}' to table '{table}'")
                        except sqlite3.OperationalError as e:
                            error_msg = str(e).lower()
                            if "duplicate" in error_msg and "column" in error_msg:
                                self.log(f"  [WARNING] Column '{col_name}' already exists in table '{table}'", "WARNING")
                            else:
                                raise
            
            # Commit toutes les modifications
            conn.commit()
            self.log("All migrations applied successfully")
            return True
            
        except Exception as e:
            self.log(f"Migration failed: {e}", "ERROR")
            self.errors.append(f"Migration error: {e}")
            
            try:
                conn.rollback()
                self.log("Transaction rolled back")
            except Exception as rb_error:
                self.log(f"Rollback failed: {rb_error}", "ERROR")
            
            return False
    
    def optimize_database(self, conn: sqlite3.Connection):
        """Optimise la base de donnÃ©es (WAL mode, pragmas)."""
        try:
            cursor = conn.cursor()
            
            # Activer le mode WAL (Write-Ahead Logging)
            self.log("Enabling WAL mode...")
            try:
                cursor.execute("PRAGMA journal_mode=WAL")
                result = cursor.fetchone()
                self.log(f"Journal mode set to: {result[0]}")
            except Exception as e:
                self.log(f"Could not enable WAL mode: {e}", "WARNING")
            
            # DÃ©finir synchronous Ã  NORMAL pour de meilleures performances
            self.log("Setting synchronous mode to NORMAL...")
            try:
                cursor.execute("PRAGMA synchronous=NORMAL")
                self.log("Synchronous mode set to NORMAL")
            except Exception as e:
                self.log(f"Could not set synchronous mode: {e}", "WARNING")
            
            # Analyser la base de donnÃ©es pour optimiser les requÃªtes
            self.log("Running ANALYZE...")
            try:
                cursor.execute("ANALYZE")
                self.log("Database analysis complete")
            except Exception as e:
                self.log(f"Could not analyze database: {e}", "WARNING")
            
        except Exception as e:
            self.log(f"Database optimization warning: {e}", "WARNING")
    
    def generate_report(self, output_file: str, missing_columns: Dict[str, List[Tuple[str, str, str, Optional[str]]]], success: bool):
        """GÃ©nÃ¨re un rapport dÃ©taillÃ© de la migration."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # CrÃ©er le rÃ©pertoire reports s'il n'existe pas
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Database Migration Report\n\n")
            f.write(f"**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"**Database:** {self.db_path}\n")
            f.write(f"**Status:** {'SUCCESS' if success else 'FAILED'}\n")
            
            if self.backup_path:
                f.write(f"**Backup:** {self.backup_path}\n")
            
            # Environment information
            f.write("\n## Environment\n\n")
            f.write(f"- Python version: {sys.version.split()[0]}\n")
            f.write(f"- Platform: {sys.platform}\n")
            f.write(f"- Script: {__file__}\n")
            try:
                import sqlite3
                f.write(f"- SQLite version: {sqlite3.sqlite_version}\n")
            except:
                pass
            
            f.write("\n## Summary\n\n")
            
            if not missing_columns:
                f.write("No missing columns detected. Database schema is up to date.\n")
            else:
                total_columns = sum(len(cols) for cols in missing_columns.values())
                f.write(f"- Tables requiring updates: {len(missing_columns)}\n")
                f.write(f"- Total columns to add: {total_columns}\n")
                
                if success:
                    f.write("\n[OK] All columns were successfully added.\n")
                else:
                    f.write("\n[FAILED] Migration failed. Changes have been rolled back.\n")
                
                f.write("\n## Changes Applied\n\n")
                for table, columns in missing_columns.items():
                    f.write(f"### Table: `{table}`\n\n")
                    for col_name, col_type, default_value, fuzzy_match in columns:
                        default_str = f" DEFAULT {default_value}" if default_value else ""
                        status_icon = "[OK]" if success else "[FAILED]"
                        
                        if fuzzy_match:
                            mapping_key = f"{table}.{fuzzy_match}"
                            if mapping_key in self.column_mappings:
                                mapping_action = self.column_mappings[mapping_key]
                                f.write(f"- {status_icon} Column: `{col_name}` ({col_type}{default_str}) - Mapped from `{fuzzy_match}` ({mapping_action})\n")
                            else:
                                f.write(f"- {status_icon} Column: `{col_name}` ({col_type}{default_str}) - Fuzzy match: `{fuzzy_match}`\n")
                        else:
                            f.write(f"- {status_icon} Column: `{col_name}` ({col_type}{default_str})\n")
                    f.write("\n")
                
                # Add column mapping summary if any mappings were made
                if self.column_mappings:
                    f.write("\n## Column Mappings\n\n")
                    f.write("The following columns were renamed or had their data copied:\n\n")
                    for old_ref, new_ref in self.column_mappings.items():
                        f.write(f"- `{old_ref}` â†’ `{new_ref}`\n")
                    f.write("\n")
            
            # Add skipped invalid names section
            if self.skipped_invalid_names:
                f.write("\n## Skipped Invalid Identifiers\n\n")
                f.write("The following column names were skipped because they do not match\n")
                f.write("the valid SQL identifier pattern (^[A-Za-z_][A-Za-z0-9_]*$):\n\n")
                for skipped in self.skipped_invalid_names:
                    f.write(f"- `{skipped}`\n")
                f.write("\n")
            
            if self.errors:
                f.write("\n## Errors\n\n")
                for error in self.errors:
                    f.write(f"- [ERROR] {error}\n")
                
                f.write("\n### Recovery Actions\n\n")
                if self.backup_path and os.path.exists(self.backup_path):
                    f.write(f"[OK] Database was restored from backup: {self.backup_path}\n")
                else:
                    f.write("[WARNING] No backup was available for restore.\n")
            
            f.write("\n## Migration Log\n\n")
            f.write("```\n")
            for log_entry in self.migration_log:
                f.write(f"{log_entry}\n")
            f.write("```\n")
            
            if not success:
                f.write("\n## Recommended Actions\n\n")
                f.write("1. Review the errors listed above\n")
                f.write("2. Check database file permissions\n")
                f.write("3. Ensure no other processes are accessing the database\n")
                f.write("4. If the issue persists, please report it with this file\n")
        
        self.log(f"Report generated: {output_file}")
    
    def run_migration(self) -> bool:
        """ExÃ©cute le processus complet de migration."""
        self.log("=" * 60)
        self.log("Database Structure Update - Smart Migration with Fuzzy Matching")
        self.log("=" * 60)
        self.log(f"Database: {self.db_path}")
        
        if not os.path.exists(self.db_path):
            self.log(f"Database file not found: {self.db_path}", "ERROR")
            return False
        
        # Ã‰tape 0: Charger les schema hints si activÃ©
        if self.use_yaml_hints:
            self.load_schema_hints()
        
        # Ã‰tape 1: CrÃ©er une sauvegarde
        if not self.create_backup():
            self.log("Migration aborted: could not create backup", "ERROR")
            return False
        
        success = False
        missing_columns = {}
        
        try:
            # Ã‰tape 2: Analyser le schÃ©ma existant
            self.log("Analyzing current database schema...")
            conn = sqlite3.connect(self.db_path, timeout=30)
            conn.row_factory = sqlite3.Row
            
            existing_schema = self.get_existing_schema(conn)
            self.log(f"Found {len(existing_schema)} tables in database")
            
            # Ã‰tape 3: DÃ©tecter les colonnes manquantes
            self.log("Detecting missing columns...")
            missing_columns = self.detect_missing_columns(existing_schema)
            
            if not missing_columns:
                self.log("[SUCCESS] Database schema is up to date!")
                success = True
            else:
                # Ã‰tape 4: Appliquer les migrations
                self.log("Applying migrations...")
                success = self.apply_migrations(conn, missing_columns)
                
                if success:
                    self.log("[SUCCESS] Migrations completed successfully!")
                    
                    # Ã‰tape 5: Optimiser la base de donnÃ©es
                    self.log("Optimizing database...")
                    self.optimize_database(conn)
                else:
                    self.log("[FAILED] Migration failed, restoring backup...", "ERROR")
                    conn.close()
                    self.restore_backup()
            
            conn.close()
            
        except Exception as e:
            error_trace = traceback.format_exc()
            self.log(f"Unexpected error during migration: {e}", "ERROR")
            self.errors.append(f"Unexpected error: {e}\n{error_trace}")
            
            # Restaurer la sauvegarde en cas d'erreur
            self.log("Restoring backup due to error...", "ERROR")
            self.restore_backup()
            success = False
        
        # GÃ©nÃ©rer le rapport dans le rÃ©pertoire reports/
        report_dir = Path(__file__).parent.parent / "reports"
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        status_suffix = "success" if success else "failed"
        report_file = report_dir / f"migration_report_{status_suffix}_{timestamp}.md"
        self.report_path = str(report_file)
        self.generate_report(self.report_path, missing_columns, success)
        
        self.log("=" * 60)
        if success:
            self.log("Migration completed successfully!")
        else:
            self.log("Migration failed. Check the report for details.", "ERROR")
        self.log("=" * 60)
        
        return success


def get_latest_migration_report(reports_dir: Optional[str] = None) -> Optional[str]:
    """
    RÃ©cupÃ¨re le chemin du dernier rapport de migration gÃ©nÃ©rÃ©.
    
    Args:
        reports_dir: RÃ©pertoire des rapports (dÃ©faut: reports/ Ã  la racine du projet)
        
    Returns:
        Chemin du dernier rapport ou None si aucun rapport trouvÃ©
    """
    if reports_dir is None:
        reports_dir = Path(__file__).parent.parent / "reports"
    else:
        reports_dir = Path(reports_dir)
    
    if not reports_dir.exists():
        return None
    
    # Trouver tous les rapports de migration
    reports = list(reports_dir.glob("migration_report_*.md"))
    
    if not reports:
        return None
    
    # Retourner le plus rÃ©cent
    latest_report = max(reports, key=lambda p: p.stat().st_mtime)
    return str(latest_report)


def main():
    """Point d'entrÃ©e principal."""
    parser = argparse.ArgumentParser(description="Smart database structure migration tool with fuzzy column matching")
    parser.add_argument(
        "--db-path",
        default="association.db",
        help="Path to the database file (default: association.db)"
    )
    parser.add_argument(
        "--no-yaml-hints",
        action="store_true",
        help="Disable loading schema hints from YAML (use only REFERENCE_SCHEMA)"
    )
    
    args = parser.parse_args()
    
    migrator = DatabaseMigrator(args.db_path, use_yaml_hints=not args.no_yaml_hints)
    success = migrator.run_migration()
    
    # Afficher le chemin du rapport pour que l'appelant puisse le rÃ©cupÃ©rer
    if migrator.report_path:
        print(f"\nREPORT_PATH:{migrator.report_path}")
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: scripts/update_db_structure_old.py ===

```python
#!/usr/bin/env python3
"""
Script de mise Ã  jour sÃ»re de la structure de base de donnÃ©es.

Ce script compare le schÃ©ma attendu (extrait du code ou du rapport d'analyse)
avec le schÃ©ma rÃ©el de la base de donnÃ©es et effectue des migrations sÃ»res
pour ajouter les colonnes manquantes.

FonctionnalitÃ©s:
- DÃ©tection automatique des colonnes manquantes
- Sauvegarde timestampÃ©e avant toute modification
- Transactions avec rollback en cas d'erreur
- Restauration automatique de la sauvegarde si Ã©chec
- Activation WAL mode et optimisation des pragmas
- Rapport dÃ©taillÃ© de migration

Usage:
    python scripts/update_db_structure.py [--db-path path/to/database.db]
"""

import sqlite3
import os
import sys
import shutil
import argparse
import traceback
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple, Set, Optional
import yaml
from difflib import SequenceMatcher

# Force UTF-8 encoding for stdout/stderr on Windows to avoid encoding errors
try:
    sys.stdout.reconfigure(encoding='utf-8')
    sys.stderr.reconfigure(encoding='utf-8')
except Exception:
    pass


# SchÃ©ma de rÃ©fÃ©rence basÃ© sur l'analyse du code et init_db.py
# Format: {table_name: {column_name: (type, default_value)}}
REFERENCE_SCHEMA = {
    "config": {
        "id": ("INTEGER", None),
        "exercice": ("TEXT", "''"),
        "date": ("TEXT", "''"),
        "but_asso": ("TEXT", "''"),
        "cloture": ("INTEGER", "0"),
        "solde_report": ("REAL", "0.0"),
        "disponible_banque": ("REAL", "0.0"),
    },
    "comptes": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "solde": ("REAL", "0.0"),
    },
    "membres": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "prenom": ("TEXT", "''"),
        "email": ("TEXT", "''"),
        "classe": ("TEXT", "''"),
        "cotisation": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "telephone": ("TEXT", "''"),
        "statut": ("TEXT", "''"),
        "date_adhesion": ("TEXT", "''"),
    },
    "events": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "date": ("TEXT", "''"),
        "lieu": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "description": ("TEXT", "''"),
    },
    "event_modules": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "nom_module": ("TEXT", "''"),
        "id_col_total": ("INTEGER", None),
    },
    "event_module_fields": {
        "id": ("INTEGER", None),
        "module_id": ("INTEGER", "0"),
        "nom_champ": ("TEXT", "''"),
        "type_champ": ("TEXT", "''"),
        "prix_unitaire": ("REAL", None),
        "modele_colonne": ("TEXT", None),
    },
    "event_module_data": {
        "module_id": ("INTEGER", "0"),
        "row_index": ("INTEGER", "0"),
        "field_id": ("INTEGER", "0"),
        "valeur": ("TEXT", "''"),
    },
    "event_payments": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "type": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "event_caisses": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "nom_caisse": ("TEXT", "''"),
        "montant_initial": ("REAL", "0.0"),
        "montant_final": ("REAL", "0.0"),
    },
    "event_caisse_details": {
        "id": ("INTEGER", None),
        "caisse_id": ("INTEGER", "0"),
        "type": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "description": ("TEXT", "''"),
    },
    "event_recettes": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "categorie": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "event_depenses": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "categorie": ("TEXT", "''"),
        "fournisseur": ("TEXT", "''"),
        "date_depense": ("TEXT", "''"),
        "paye_par": ("TEXT", "''"),
        "membre_id": ("INTEGER", None),
        "statut_remboursement": ("TEXT", "''"),
        "statut_reglement": ("TEXT", "''"),
        "moyen_paiement": ("TEXT", "''"),
        "numero_cheque": ("TEXT", "''"),
        "numero_facture": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "module_id": ("INTEGER", None),
    },
    "dons_subventions": {
        "id": ("INTEGER", None),
        "donateur": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "depenses_regulieres": {
        "id": ("INTEGER", None),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "categorie": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "fournisseur": ("TEXT", "''"),
        "date_depense": ("TEXT", "''"),
        "paye_par": ("TEXT", "''"),
        "membre_id": ("INTEGER", None),
        "statut_remboursement": ("TEXT", "''"),
        "statut_reglement": ("TEXT", "''"),
        "moyen_paiement": ("TEXT", "''"),
        "numero_cheque": ("TEXT", "''"),
        "numero_facture": ("TEXT", "''"),
        "module_id": ("INTEGER", None),
    },
    "depenses_diverses": {
        "id": ("INTEGER", None),
        "libelle": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
        "categorie": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "fournisseur": ("TEXT", "''"),
        "date_depense": ("TEXT", "''"),
        "paye_par": ("TEXT", "''"),
        "membre_id": ("INTEGER", None),
        "statut_remboursement": ("TEXT", "''"),
        "statut_reglement": ("TEXT", "''"),
        "moyen_paiement": ("TEXT", "''"),
        "numero_cheque": ("TEXT", "''"),
        "numero_facture": ("TEXT", "''"),
        "module_id": ("INTEGER", None),
    },
    "categories": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "parent_id": ("INTEGER", None),
    },
    "stock": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "categorie_id": ("INTEGER", None),
        "quantite": ("INTEGER", "0"),
        "seuil_alerte": ("INTEGER", "0"),
        "date_peremption": ("TEXT", "''"),
        "lot": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "inventaires": {
        "id": ("INTEGER", None),
        "date": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "inventaire_lignes": {
        "id": ("INTEGER", None),
        "inventaire_id": ("INTEGER", "0"),
        "stock_id": ("INTEGER", "0"),
        "quantite": ("INTEGER", "0"),
        "ecart": ("INTEGER", "0"),
    },
    "mouvements_stock": {
        "id": ("INTEGER", None),
        "stock_id": ("INTEGER", "0"),
        "date": ("TEXT", "''"),
        "type": ("TEXT", "''"),
        "quantite": ("INTEGER", "0"),
        "commentaire": ("TEXT", "''"),
    },
    "fournisseurs": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
    },
    "colonnes_modeles": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "type_modele": ("TEXT", "''"),
    },
    "valeurs_modeles_colonnes": {
        "id": ("INTEGER", None),
        "modele_id": ("INTEGER", "0"),
        "valeur": ("TEXT", "''"),
    },
    "depots_retraits_banque": {
        "id": ("INTEGER", None),
        "date": ("TEXT", "''"),
        "type": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "reference": ("TEXT", "''"),
        "banque": ("TEXT", "''"),
        "pointe": ("INTEGER", "0"),
        "commentaire": ("TEXT", "''"),
    },
    "historique_clotures": {
        "id": ("INTEGER", None),
        "date_cloture": ("TEXT", "''"),
    },
    "retrocessions_ecoles": {
        "id": ("INTEGER", None),
        "date": ("TEXT", "''"),
        "montant": ("REAL", "0.0"),
        "ecole": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "buvette_articles": {
        "id": ("INTEGER", None),
        "name": ("TEXT", "''"),
        "categorie": ("TEXT", "''"),
        "unite": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
        "contenance": ("REAL", None),
        "stock": ("INTEGER", "0"),
        "purchase_price": ("REAL", None),
    },
    "buvette_achats": {
        "id": ("INTEGER", None),
        "article_id": ("INTEGER", "0"),
        "date_achat": ("TEXT", "''"),
        "quantite": ("REAL", "0.0"),
        "prix_unitaire": ("REAL", "0.0"),
        "fournisseur": ("TEXT", "''"),
        "facture": ("TEXT", "''"),
        "exercice": ("TEXT", "''"),
    },
    "buvette_inventaires": {
        "id": ("INTEGER", None),
        "date_inventaire": ("TEXT", "''"),
        "event_id": ("INTEGER", None),
        "type_inventaire": ("TEXT", "''"),
        "commentaire": ("TEXT", "''"),
    },
    "buvette_inventaire_lignes": {
        "id": ("INTEGER", None),
        "inventaire_id": ("INTEGER", "0"),
        "article_id": ("INTEGER", "0"),
        "quantite": ("REAL", "0.0"),
        "commentaire": ("TEXT", "''"),
    },
    "buvette_mouvements": {
        "id": ("INTEGER", None),
        "date_mouvement": ("TEXT", "''"),
        "article_id": ("INTEGER", "0"),
        "type_mouvement": ("TEXT", "''"),
        "quantite": ("REAL", "0.0"),
        "motif": ("TEXT", "''"),
        "event_id": ("INTEGER", None),
    },
    "buvette_recettes": {
        "id": ("INTEGER", None),
        "event_id": ("INTEGER", "0"),
        "montant": ("REAL", "0.0"),
        "date": ("TEXT", "''"),
    },
}


class DatabaseMigrator:
    """Gestionnaire de migration de base de donnÃ©es."""
    
    # SQL reserved words that need quoting (subset of most common ones)
    SQL_RESERVED_WORDS = {
        'add', 'all', 'alter', 'and', 'as', 'asc', 'between', 'by', 'case', 'check',
        'column', 'constraint', 'create', 'cross', 'default', 'delete', 'desc',
        'distinct', 'drop', 'else', 'end', 'exists', 'foreign', 'from', 'full',
        'group', 'having', 'in', 'index', 'inner', 'insert', 'into', 'is', 'join',
        'key', 'left', 'like', 'limit', 'not', 'null', 'on', 'or', 'order', 'outer',
        'primary', 'references', 'right', 'select', 'set', 'table', 'then', 'to',
        'union', 'unique', 'update', 'values', 'when', 'where'
    }
    
    def __init__(self, db_path: str, use_yaml_hints: bool = True, fuzzy_threshold: float = 0.75):
        self.db_path = db_path
        self.backup_path = None
        self.migration_log = []
        self.errors = []
        self.report_path = None
        self.use_yaml_hints = use_yaml_hints
        self.schema_hints = None
        self.column_mappings = {}  # Track old_name -> new_name mappings
        self.fuzzy_threshold = fuzzy_threshold  # Configurable fuzzy matching threshold
    
    def log(self, message: str, level: str = "INFO"):
        """Ajoute un message au log de migration."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {level}: {message}"
        self.migration_log.append(log_entry)
        print(log_entry)
    
    def load_schema_hints(self, yaml_path: Optional[str] = None) -> bool:
        """Charge le fichier schema_hints.yaml ou le gÃ©nÃ¨re s'il n'existe pas."""
        if yaml_path is None:
            repo_root = Path(__file__).parent.parent
            yaml_path = repo_root / "db" / "schema_hints.yaml"
        else:
            yaml_path = Path(yaml_path)
        
        if not yaml_path.exists():
            self.log(f"Schema hints file not found at {yaml_path}", "WARNING")
            self.log("Attempting to generate schema hints by running analyze_modules_columns.py...")
            
            try:
                # Run the analyze script to generate the YAML
                script_path = Path(__file__).parent / "analyze_modules_columns.py"
                result = subprocess.run(
                    [sys.executable, str(script_path)],
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                
                if result.returncode != 0:
                    self.log(f"Failed to generate schema hints: {result.stderr}", "ERROR")
                    return False
                
                self.log("Schema hints generated successfully")
            except Exception as e:
                self.log(f"Error generating schema hints: {e}", "ERROR")
                return False
        
        try:
            with open(yaml_path, 'r', encoding='utf-8') as f:
                self.schema_hints = yaml.safe_load(f)
            
            self.log(f"Loaded schema hints from {yaml_path}")
            return True
        except Exception as e:
            self.log(f"Error loading schema hints: {e}", "WARNING")
            return False
    
    def fuzzy_match_column(self, target_col: str, existing_cols: Set[str], threshold: Optional[float] = None) -> Optional[str]:
        """
        Trouve une colonne existante qui correspond au nom cible (fuzzy/case-insensitive).
        
        Args:
            target_col: Nom de colonne recherchÃ©
            existing_cols: Ensemble des colonnes existantes dans la table
            threshold: Seuil de similaritÃ© (0.0 Ã  1.0), uses instance default if None
        
        Returns:
            Nom de la colonne correspondante ou None
        """
        if threshold is None:
            threshold = self.fuzzy_threshold
        
        target_lower = target_col.lower()
        
        # 1. Exact match (case-insensitive)
        for col in existing_cols:
            if col.lower() == target_lower:
                return col
        
        # 2. Fuzzy match with SequenceMatcher
        best_match = None
        best_score = 0.0
        
        for col in existing_cols:
            # Calculate similarity ratio
            ratio = SequenceMatcher(None, target_lower, col.lower()).ratio()
            
            if ratio > best_score and ratio >= threshold:
                best_score = ratio
                best_match = col
        
        return best_match
    
    def quote_identifier(self, identifier: str) -> str:
        """
        Quote SQL identifier if it's a reserved word or contains special characters.
        
        Args:
            identifier: Column or table name
            
        Returns:
            Quoted identifier if needed, otherwise original
        """
        # Quote if it's a reserved word
        if identifier.lower() in self.SQL_RESERVED_WORDS:
            return f'"{identifier}"'
        
        # Quote if it contains special characters
        if not identifier.replace('_', '').isalnum():
            return f'"{identifier}"'
        
        return identifier
    
    def get_column_type_from_hints(self, table: str, column: str) -> Optional[str]:
        """RÃ©cupÃ¨re le type d'une colonne depuis les hints YAML."""
        if not self.schema_hints or "tables" not in self.schema_hints:
            return None
        
        if table not in self.schema_hints["tables"]:
            return None
        
        table_info = self.schema_hints["tables"][table]
        if "expected_columns" not in table_info:
            return None
        
        if column not in table_info["expected_columns"]:
            return None
        
        return table_info["expected_columns"][column].get("type", "TEXT")
    
    def create_backup(self) -> bool:
        """CrÃ©e une sauvegarde timestampÃ©e de la base de donnÃ©es."""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.backup_path = f"{self.db_path}.{timestamp}.bak"
            
            self.log(f"Creating backup: {self.backup_path}")
            shutil.copy2(self.db_path, self.backup_path)
            self.log(f"Backup created successfully: {self.backup_path}")
            return True
        except Exception as e:
            self.log(f"Failed to create backup: {e}", "ERROR")
            self.errors.append(f"Backup error: {e}")
            return False
    
    def restore_backup(self) -> bool:
        """Restaure la base de donnÃ©es depuis la sauvegarde."""
        if not self.backup_path or not os.path.exists(self.backup_path):
            self.log("No backup available to restore", "ERROR")
            return False
        
        try:
            self.log(f"Restoring from backup: {self.backup_path}")
            shutil.copy2(self.backup_path, self.db_path)
            self.log("Database restored successfully")
            return True
        except Exception as e:
            self.log(f"Failed to restore backup: {e}", "ERROR")
            self.errors.append(f"Restore error: {e}")
            return False
    
    def get_existing_schema(self, conn: sqlite3.Connection) -> Dict[str, Set[str]]:
        """RÃ©cupÃ¨re le schÃ©ma actuel de la base de donnÃ©es."""
        schema = {}
        
        cursor = conn.cursor()
        
        # Obtenir toutes les tables
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = [row[0] for row in cursor.fetchall()]
        
        for table in tables:
            # Obtenir les colonnes de chaque table
            cursor.execute(f"PRAGMA table_info({table})")
            columns = set(row[1] for row in cursor.fetchall())
            schema[table] = columns
        
        return schema
    
    def check_rename_column_support(self, conn: sqlite3.Connection) -> bool:
        """VÃ©rifie si SQLite supporte ALTER TABLE RENAME COLUMN (version 3.25.0+)."""
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT sqlite_version()")
            version = cursor.fetchone()[0]
            
            # Parse version (e.g., "3.35.5")
            major, minor, patch = map(int, version.split('.'))
            
            # RENAME COLUMN supported since 3.25.0
            supports_rename = (major > 3) or (major == 3 and minor >= 25)
            
            self.log(f"SQLite version: {version}, RENAME COLUMN support: {supports_rename}")
            return supports_rename
        except Exception as e:
            self.log(f"Could not determine SQLite version: {e}", "WARNING")
            return False
    
    def detect_missing_columns(self, existing_schema: Dict[str, Set[str]]) -> Dict[str, List[Tuple[str, str, str, Optional[str]]]]:
        """
        DÃ©tecte les colonnes manquantes par rapport au schÃ©ma de rÃ©fÃ©rence.
        
        Returns:
            Dict mapping table -> List of (col_name, col_type, default_value, fuzzy_match)
            where fuzzy_match is the name of an existing column that closely matches, or None
        """
        missing = {}
        
        # Combine REFERENCE_SCHEMA and YAML hints
        expected_schema = {}
        
        # Start with REFERENCE_SCHEMA
        for table, columns in REFERENCE_SCHEMA.items():
            expected_schema[table] = {}
            for col_name, (col_type, default_value) in columns.items():
                expected_schema[table][col_name] = (col_type, default_value)
        
        # Add columns from YAML hints if available
        if self.schema_hints and "tables" in self.schema_hints:
            for table, table_info in self.schema_hints["tables"].items():
                if "expected_columns" not in table_info:
                    continue
                
                if table not in expected_schema:
                    expected_schema[table] = {}
                
                for col_name, col_info in table_info["expected_columns"].items():
                    if col_name not in expected_schema[table]:
                        col_type = col_info.get("type", "TEXT")
                        # Infer default based on type
                        if col_type == "INTEGER":
                            default_value = "0"
                        elif col_type == "REAL":
                            default_value = "0.0"
                        else:
                            default_value = "''"
                        
                        expected_schema[table][col_name] = (col_type, default_value)
        
        # Now check for missing columns
        for table, expected_columns in expected_schema.items():
            if table not in existing_schema:
                self.log(f"Table '{table}' does not exist (will not be created automatically)", "WARNING")
                continue
            
            existing_cols = existing_schema[table]
            table_missing = []
            
            for col_name, (col_type, default_value) in expected_columns.items():
                if col_name not in existing_cols:
                    # Try fuzzy matching to find a similar column
                    fuzzy_match = self.fuzzy_match_column(col_name, existing_cols, threshold=0.75)
                    
                    if fuzzy_match:
                        self.log(f"Column '{col_name}' not found in '{table}', but found similar column '{fuzzy_match}'", "INFO")
                    
                    table_missing.append((col_name, col_type, default_value, fuzzy_match))
            
            if table_missing:
                missing[table] = table_missing
        
        return missing
    
    def apply_migrations(self, conn: sqlite3.Connection, missing_columns: Dict[str, List[Tuple[str, str, str, Optional[str]]]]) -> bool:
        """Applique les migrations pour ajouter les colonnes manquantes."""
        if not missing_columns:
            self.log("No missing columns detected. Database is up to date.")
            return True
        
        self.log(f"Found missing columns in {len(missing_columns)} table(s)")
        
        # Check if RENAME COLUMN is supported
        supports_rename = self.check_rename_column_support(conn)
        
        try:
            cursor = conn.cursor()
            
            # SQLite ne supporte pas toujours les transactions pour ALTER TABLE,
            # mais on utilise BEGIN pour grouper les opÃ©rations
            cursor.execute("BEGIN TRANSACTION")
            
            for table, columns in missing_columns.items():
                self.log(f"Processing table '{table}': {len(columns)} column(s) to add")
                
                for col_name, col_type, default_value, fuzzy_match in columns:
                    # Case 1: Fuzzy match found - try to rename or copy
                    if fuzzy_match:
                        self.log(f"  Column '{col_name}' has fuzzy match '{fuzzy_match}'")
                        
                        if supports_rename and fuzzy_match.lower() != col_name.lower():
                            # Try to rename the column
                            rename_sql = f"ALTER TABLE {table} RENAME COLUMN {fuzzy_match} TO {col_name}"
                            
                            try:
                                self.log(f"  Attempting to rename '{fuzzy_match}' to '{col_name}'...")
                                cursor.execute(rename_sql)
                                self.log(f"  [OK] Successfully renamed column '{fuzzy_match}' to '{col_name}'")
                                self.column_mappings[f"{table}.{fuzzy_match}"] = f"{table}.{col_name}"
                                continue
                            except sqlite3.OperationalError as e:
                                self.log(f"  [WARNING] RENAME failed: {e}. Will try ADD + COPY instead.", "WARNING")
                        
                        # If rename not supported or failed, do ADD + COPY
                        quoted_col = self.quote_identifier(col_name)
                        
                        if default_value is None:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type}"
                        else:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type} DEFAULT {default_value}"
                        
                        try:
                            self.log(f"  Adding new column '{col_name}' ({col_type})")
                            cursor.execute(alter_sql)
                            
                            # Copy data from fuzzy_match column to new column
                            # Quote identifiers in case they're reserved words
                            quoted_new = self.quote_identifier(col_name)
                            quoted_old = self.quote_identifier(fuzzy_match)
                            copy_sql = f"UPDATE {table} SET {quoted_new} = {quoted_old}"
                            self.log(f"  Copying data from '{fuzzy_match}' to '{col_name}'...")
                            cursor.execute(copy_sql)
                            
                            self.log(f"  [OK] Added column '{col_name}' and copied data from '{fuzzy_match}'")
                            self.column_mappings[f"{table}.{fuzzy_match}"] = f"{table}.{col_name} (copied)"
                            
                        except sqlite3.OperationalError as e:
                            error_msg = str(e).lower()
                            if "duplicate" in error_msg and "column" in error_msg:
                                self.log(f"  [WARNING] Column '{col_name}' already exists", "WARNING")
                            else:
                                raise
                    
                    # Case 2: No fuzzy match - just add the column
                    else:
                        # Quote column name if it's a reserved word
                        quoted_col = self.quote_identifier(col_name)
                        
                        if default_value is None:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type}"
                        else:
                            alter_sql = f"ALTER TABLE {table} ADD COLUMN {quoted_col} {col_type} DEFAULT {default_value}"
                        
                        try:
                            self.log(f"  Adding column: {col_name} ({col_type})")
                            cursor.execute(alter_sql)
                            self.log(f"  [OK] Successfully added column '{col_name}' to table '{table}'")
                        except sqlite3.OperationalError as e:
                            error_msg = str(e).lower()
                            if "duplicate" in error_msg and "column" in error_msg:
                                self.log(f"  [WARNING] Column '{col_name}' already exists in table '{table}'", "WARNING")
                            else:
                                raise
            
            # Commit toutes les modifications
            conn.commit()
            self.log("All migrations applied successfully")
            return True
            
        except Exception as e:
            self.log(f"Migration failed: {e}", "ERROR")
            self.errors.append(f"Migration error: {e}")
            
            try:
                conn.rollback()
                self.log("Transaction rolled back")
            except Exception as rb_error:
                self.log(f"Rollback failed: {rb_error}", "ERROR")
            
            return False
    
    def optimize_database(self, conn: sqlite3.Connection):
        """Optimise la base de donnÃ©es (WAL mode, pragmas)."""
        try:
            cursor = conn.cursor()
            
            # Activer le mode WAL (Write-Ahead Logging)
            self.log("Enabling WAL mode...")
            try:
                cursor.execute("PRAGMA journal_mode=WAL")
                result = cursor.fetchone()
                self.log(f"Journal mode set to: {result[0]}")
            except Exception as e:
                self.log(f"Could not enable WAL mode: {e}", "WARNING")
            
            # DÃ©finir synchronous Ã  NORMAL pour de meilleures performances
            self.log("Setting synchronous mode to NORMAL...")
            try:
                cursor.execute("PRAGMA synchronous=NORMAL")
                self.log("Synchronous mode set to NORMAL")
            except Exception as e:
                self.log(f"Could not set synchronous mode: {e}", "WARNING")
            
            # Analyser la base de donnÃ©es pour optimiser les requÃªtes
            self.log("Running ANALYZE...")
            try:
                cursor.execute("ANALYZE")
                self.log("Database analysis complete")
            except Exception as e:
                self.log(f"Could not analyze database: {e}", "WARNING")
            
        except Exception as e:
            self.log(f"Database optimization warning: {e}", "WARNING")
    
    def generate_report(self, output_file: str, missing_columns: Dict[str, List[Tuple[str, str, str, Optional[str]]]], success: bool):
        """GÃ©nÃ¨re un rapport dÃ©taillÃ© de la migration."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # CrÃ©er le rÃ©pertoire reports s'il n'existe pas
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Database Migration Report\n\n")
            f.write(f"**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"**Database:** {self.db_path}\n")
            f.write(f"**Status:** {'SUCCESS' if success else 'FAILED'}\n")
            
            if self.backup_path:
                f.write(f"**Backup:** {self.backup_path}\n")
            
            f.write("\n## Summary\n\n")
            
            if not missing_columns:
                f.write("No missing columns detected. Database schema is up to date.\n")
            else:
                total_columns = sum(len(cols) for cols in missing_columns.values())
                f.write(f"- Tables requiring updates: {len(missing_columns)}\n")
                f.write(f"- Total columns to add: {total_columns}\n")
                
                if success:
                    f.write("\n[OK] All columns were successfully added.\n")
                else:
                    f.write("\n[FAILED] Migration failed. Changes have been rolled back.\n")
                
                f.write("\n## Changes Applied\n\n")
                for table, columns in missing_columns.items():
                    f.write(f"### Table: `{table}`\n\n")
                    for col_name, col_type, default_value, fuzzy_match in columns:
                        default_str = f" DEFAULT {default_value}" if default_value else ""
                        status_icon = "[OK]" if success else "[FAILED]"
                        
                        if fuzzy_match:
                            mapping_key = f"{table}.{fuzzy_match}"
                            if mapping_key in self.column_mappings:
                                mapping_action = self.column_mappings[mapping_key]
                                f.write(f"- {status_icon} Column: `{col_name}` ({col_type}{default_str}) - Mapped from `{fuzzy_match}` ({mapping_action})\n")
                            else:
                                f.write(f"- {status_icon} Column: `{col_name}` ({col_type}{default_str}) - Fuzzy match: `{fuzzy_match}`\n")
                        else:
                            f.write(f"- {status_icon} Column: `{col_name}` ({col_type}{default_str})\n")
                    f.write("\n")
                
                # Add column mapping summary if any mappings were made
                if self.column_mappings:
                    f.write("\n## Column Mappings\n\n")
                    f.write("The following columns were renamed or had their data copied:\n\n")
                    for old_ref, new_ref in self.column_mappings.items():
                        f.write(f"- `{old_ref}` â†’ `{new_ref}`\n")
                    f.write("\n")
            
            if self.errors:
                f.write("\n## Errors\n\n")
                for error in self.errors:
                    f.write(f"- [ERROR] {error}\n")
                
                f.write("\n### Recovery Actions\n\n")
                if self.backup_path and os.path.exists(self.backup_path):
                    f.write(f"[OK] Database was restored from backup: {self.backup_path}\n")
                else:
                    f.write("[WARNING] No backup was available for restore.\n")
            
            f.write("\n## Migration Log\n\n")
            f.write("```\n")
            for log_entry in self.migration_log:
                f.write(f"{log_entry}\n")
            f.write("```\n")
            
            if not success:
                f.write("\n## Recommended Actions\n\n")
                f.write("1. Review the errors listed above\n")
                f.write("2. Check database file permissions\n")
                f.write("3. Ensure no other processes are accessing the database\n")
                f.write("4. If the issue persists, please report it with this file\n")
        
        self.log(f"Report generated: {output_file}")
    
    def run_migration(self) -> bool:
        """ExÃ©cute le processus complet de migration."""
        self.log("=" * 60)
        self.log("Database Structure Update - Smart Migration with Fuzzy Matching")
        self.log("=" * 60)
        self.log(f"Database: {self.db_path}")
        
        if not os.path.exists(self.db_path):
            self.log(f"Database file not found: {self.db_path}", "ERROR")
            return False
        
        # Ã‰tape 0: Charger les schema hints si activÃ©
        if self.use_yaml_hints:
            self.load_schema_hints()
        
        # Ã‰tape 1: CrÃ©er une sauvegarde
        if not self.create_backup():
            self.log("Migration aborted: could not create backup", "ERROR")
            return False
        
        success = False
        missing_columns = {}
        
        try:
            # Ã‰tape 2: Analyser le schÃ©ma existant
            self.log("Analyzing current database schema...")
            conn = sqlite3.connect(self.db_path, timeout=30)
            conn.row_factory = sqlite3.Row
            
            existing_schema = self.get_existing_schema(conn)
            self.log(f"Found {len(existing_schema)} tables in database")
            
            # Ã‰tape 3: DÃ©tecter les colonnes manquantes
            self.log("Detecting missing columns...")
            missing_columns = self.detect_missing_columns(existing_schema)
            
            if not missing_columns:
                self.log("[SUCCESS] Database schema is up to date!")
                success = True
            else:
                # Ã‰tape 4: Appliquer les migrations
                self.log("Applying migrations...")
                success = self.apply_migrations(conn, missing_columns)
                
                if success:
                    self.log("[SUCCESS] Migrations completed successfully!")
                    
                    # Ã‰tape 5: Optimiser la base de donnÃ©es
                    self.log("Optimizing database...")
                    self.optimize_database(conn)
                else:
                    self.log("[FAILED] Migration failed, restoring backup...", "ERROR")
                    conn.close()
                    self.restore_backup()
            
            conn.close()
            
        except Exception as e:
            error_trace = traceback.format_exc()
            self.log(f"Unexpected error during migration: {e}", "ERROR")
            self.errors.append(f"Unexpected error: {e}\n{error_trace}")
            
            # Restaurer la sauvegarde en cas d'erreur
            self.log("Restoring backup due to error...", "ERROR")
            self.restore_backup()
            success = False
        
        # GÃ©nÃ©rer le rapport dans le rÃ©pertoire reports/
        report_dir = Path(__file__).parent.parent / "reports"
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        status_suffix = "success" if success else "failed"
        report_file = report_dir / f"migration_report_{status_suffix}_{timestamp}.md"
        self.report_path = str(report_file)
        self.generate_report(self.report_path, missing_columns, success)
        
        self.log("=" * 60)
        if success:
            self.log("Migration completed successfully!")
        else:
            self.log("Migration failed. Check the report for details.", "ERROR")
        self.log("=" * 60)
        
        return success


def get_latest_migration_report(reports_dir: Optional[str] = None) -> Optional[str]:
    """
    RÃ©cupÃ¨re le chemin du dernier rapport de migration gÃ©nÃ©rÃ©.
    
    Args:
        reports_dir: RÃ©pertoire des rapports (dÃ©faut: reports/ Ã  la racine du projet)
        
    Returns:
        Chemin du dernier rapport ou None si aucun rapport trouvÃ©
    """
    if reports_dir is None:
        reports_dir = Path(__file__).parent.parent / "reports"
    else:
        reports_dir = Path(reports_dir)
    
    if not reports_dir.exists():
        return None
    
    # Trouver tous les rapports de migration
    reports = list(reports_dir.glob("migration_report_*.md"))
    
    if not reports:
        return None
    
    # Retourner le plus rÃ©cent
    latest_report = max(reports, key=lambda p: p.stat().st_mtime)
    return str(latest_report)


def main():
    """Point d'entrÃ©e principal."""
    parser = argparse.ArgumentParser(description="Smart database structure migration tool with fuzzy column matching")
    parser.add_argument(
        "--db-path",
        default="association.db",
        help="Path to the database file (default: association.db)"
    )
    parser.add_argument(
        "--no-yaml-hints",
        action="store_true",
        help="Disable loading schema hints from YAML (use only REFERENCE_SCHEMA)"
    )
    
    args = parser.parse_args()
    
    migrator = DatabaseMigrator(args.db_path, use_yaml_hints=not args.no_yaml_hints)
    success = migrator.run_migration()
    
    # Afficher le chemin du rapport pour que l'appelant puisse le rÃ©cupÃ©rer
    if migrator.report_path:
        print(f"\nREPORT_PATH:{migrator.report_path}")
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: tests/test_analyze_modules.py ===

```python
"""
Tests for the analyze_modules_columns script.
"""

import os
import sys
import tempfile
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from scripts.analyze_modules_columns import StrictSQLAnalyzer


def test_sql_analyzer_initialization():
    """Test StrictSQLAnalyzer initialization."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        assert analyzer.repo_root == Path(tmpdir)
        assert len(analyzer.table_columns) == 0


def test_extract_select_queries():
    """Test extraction of SELECT queries."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        content = """
        conn.execute("SELECT id, name, email FROM membres WHERE id = ?", (mid,))
        conn.execute("SELECT * FROM events ORDER BY date DESC")
        """
        
        analyzer._extract_select_statements(content, "test.py")
        
        assert "membres" in analyzer.table_columns
        assert "events" in analyzer.table_columns
        assert "id" in analyzer.table_columns["membres"]["columns"]
        assert "name" in analyzer.table_columns["membres"]["columns"]
        assert "email" in analyzer.table_columns["membres"]["columns"]


def test_extract_insert_queries():
    """Test extraction of INSERT queries."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        content = """
        INSERT INTO members (name, prenom, email) VALUES (?, ?, ?)
        """
        
        analyzer._extract_insert_statements(content, "test.py")
        
        assert "members" in analyzer.table_columns
        assert "name" in analyzer.table_columns["members"]["columns"]
        assert "prenom" in analyzer.table_columns["members"]["columns"]
        assert "email" in analyzer.table_columns["members"]["columns"]


def test_extract_update_queries():
    """Test extraction of UPDATE queries."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        content = """
        UPDATE config SET exercice=?, date=?, disponible_banque=? WHERE id=1
        """
        
        analyzer._extract_update_statements(content, "test.py")
        
        assert "config" in analyzer.table_columns
        assert "exercice" in analyzer.table_columns["config"]["columns"]
        assert "date" in analyzer.table_columns["config"]["columns"]
        assert "disponible_banque" in analyzer.table_columns["config"]["columns"]


def test_extract_alter_table():
    """Test extraction of ALTER TABLE statements - not in StrictSQLAnalyzer scope."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        # StrictSQLAnalyzer focuses on INSERT/UPDATE/SELECT/CREATE TABLE
        # ALTER TABLE is not extracted as it doesn't define expected schema
        content = """
        ALTER TABLE buvette_articles ADD COLUMN stock INTEGER DEFAULT 0
        """
        
        # This test is skipped as ALTER TABLE is not in scope
        pass


def test_extract_create_table():
    """Test extraction of CREATE TABLE statements."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        content = """
        CREATE TABLE IF NOT EXISTS events (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            date TEXT NOT NULL,
            lieu TEXT,
            commentaire TEXT
        )
        """
        
        analyzer._extract_create_table_statements(content, "test.py")
        
        assert "events" in analyzer.table_columns
        assert "id" in analyzer.table_columns["events"]["columns"]
        assert "name" in analyzer.table_columns["events"]["columns"]
        assert "date" in analyzer.table_columns["events"]["columns"]
        assert "lieu" in analyzer.table_columns["events"]["columns"]
        assert "commentaire" in analyzer.table_columns["events"]["columns"]


def test_analyze_file():
    """Test analyzing a complete Python file."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        # Create a test Python file
        test_file = Path(tmpdir) / "test_module.py"
        test_file.write_text("""
import sqlite3

def get_members():
    conn = sqlite3.connect("test.db")
    cursor = conn.execute("SELECT id, name, email FROM membres")
    return cursor.fetchall()

def add_member(name, email):
    conn = sqlite3.connect("test.db")
    conn.execute("INSERT INTO membres (name, email) VALUES (?, ?)", (name, email))
    conn.commit()
""")
        
        analyzer.analyze_file(test_file)
        
        assert "membres" in analyzer.table_columns
        assert "id" in analyzer.table_columns["membres"]["columns"]
        assert "name" in analyzer.table_columns["membres"]["columns"]
        assert "email" in analyzer.table_columns["membres"]["columns"]
        assert "test_module.py" in analyzer.table_columns["membres"]["files"]


def test_generate_report():
    """Test report generation."""
    with tempfile.TemporaryDirectory() as tmpdir:
        analyzer = StrictSQLAnalyzer(tmpdir)
        
        # Add some test data
        analyzer.table_columns["test_table"]["columns"].add("col1")
        analyzer.table_columns["test_table"]["columns"].add("col2")
        analyzer.table_columns["test_table"]["files"].add("test.py")
        
        output_file = Path(tmpdir) / "report.md"
        analyzer.generate_report(str(output_file))
        
        assert output_file.exists()
        content = output_file.read_text()
        assert "# Analyse SQL" in content
        assert "test_table" in content
        assert "col1" in content
        assert "col2" in content
        assert "test.py" in content


if __name__ == "__main__":
    # Run tests
    test_sql_analyzer_initialization()
    print("âœ“ test_sql_analyzer_initialization")
    
    test_extract_select_queries()
    print("âœ“ test_extract_select_queries")
    
    test_extract_insert_queries()
    print("âœ“ test_extract_insert_queries")
    
    test_extract_update_queries()
    print("âœ“ test_extract_update_queries")
    
    test_extract_alter_table()
    print("âœ“ test_extract_alter_table")
    
    test_extract_create_table()
    print("âœ“ test_extract_create_table")
    
    test_analyze_file()
    print("âœ“ test_analyze_file")
    
    test_generate_report()
    print("âœ“ test_generate_report")
    
    print("\nAll tests passed!")

```


# ===== FICHIER SUIVANT =====

# === Fichier: tests/test_buvette_inventaire.py ===

```python
import unittest
import sqlite3
import os
import sys

# Mock tkinter before any imports that might use it
sys.modules['tkinter'] = type(sys)('tkinter')
sys.modules['tkinter.messagebox'] = type(sys)('messagebox')

# Add parent directory to path to import modules
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Simple database helper functions to avoid WAL mode issues
def get_test_connection(db_file):
    """Create a simple connection without WAL mode for testing."""
    conn = sqlite3.connect(db_file)
    conn.row_factory = sqlite3.Row
    return conn


class TestBuvetteInventaire(unittest.TestCase):
    """Test suite for buvette inventaire database operations."""
    
    def setUp(self):
        """Set up a fresh test database before each test."""
        self.test_db = f"/tmp/test_buvette_inventaire_{id(self)}.db"
        
        # Create the tables
        conn = get_test_connection(self.test_db)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                date TEXT NOT NULL
            )
        """)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_inventaires (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date_inventaire DATE,
                event_id INTEGER,
                type_inventaire TEXT CHECK(type_inventaire IN ('avant', 'apres', 'hors_evenement')),
                commentaire TEXT,
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        """)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                unite TEXT,
                contenance TEXT,
                commentaire TEXT
            )
        """)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_inventaire_lignes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                inventaire_id INTEGER,
                article_id INTEGER,
                quantite INTEGER,
                commentaire TEXT,
                FOREIGN KEY (inventaire_id) REFERENCES buvette_inventaires(id),
                FOREIGN KEY (article_id) REFERENCES buvette_articles(id)
            )
        """)
        conn.commit()
        conn.close()
    
    def tearDown(self):
        """Clean up test database after each test."""
        if os.path.exists(self.test_db):
            os.remove(self.test_db)
        # Clean up any WAL files
        for ext in ['-wal', '-shm']:
            wal_file = self.test_db + ext
            if os.path.exists(wal_file):
                try:
                    os.remove(wal_file)
                except:
                    pass
    
    def test_insert_inventaire_with_valid_type_hors_evenement(self):
        """Test inserting an inventory with type 'hors_evenement' does not raise IntegrityError."""
        conn = get_test_connection(self.test_db)
        cur = conn.cursor()
        cur.execute("""
            INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
            VALUES (?, ?, ?, ?)
        """, ('2025-01-15', None, 'hors_evenement', 'Test inventory'))
        inv_id = cur.lastrowid
        conn.commit()
        
        self.assertIsNotNone(inv_id)
        self.assertGreater(inv_id, 0)
        
        # Verify it was inserted correctly
        cur.execute("SELECT * FROM buvette_inventaires WHERE id=?", (inv_id,))
        inv = cur.fetchone()
        conn.close()
        
        self.assertIsNotNone(inv)
        self.assertEqual(inv['date_inventaire'], '2025-01-15')
        self.assertEqual(inv['type_inventaire'], 'hors_evenement')
        self.assertEqual(inv['commentaire'], 'Test inventory')
        self.assertIsNone(inv['event_id'])
    
    def test_insert_inventaire_with_valid_type_avant(self):
        """Test inserting an inventory with type 'avant'."""
        conn = get_test_connection(self.test_db)
        cur = conn.cursor()
        cur.execute("""
            INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
            VALUES (?, ?, ?, ?)
        """, ('2025-01-16', None, 'avant', 'Before event'))
        inv_id = cur.lastrowid
        conn.commit()
        
        cur.execute("SELECT * FROM buvette_inventaires WHERE id=?", (inv_id,))
        inv = cur.fetchone()
        conn.close()
        
        self.assertEqual(inv['type_inventaire'], 'avant')
    
    def test_insert_inventaire_with_valid_type_apres(self):
        """Test inserting an inventory with type 'apres'."""
        conn = get_test_connection(self.test_db)
        cur = conn.cursor()
        cur.execute("""
            INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
            VALUES (?, ?, ?, ?)
        """, ('2025-01-17', None, 'apres', 'After event'))
        inv_id = cur.lastrowid
        conn.commit()
        
        cur.execute("SELECT * FROM buvette_inventaires WHERE id=?", (inv_id,))
        inv = cur.fetchone()
        conn.close()
        
        self.assertEqual(inv['type_inventaire'], 'apres')
    
    def test_insert_inventaire_with_invalid_type_raises_error(self):
        """Test that inserting an inventory with invalid type raises IntegrityError."""
        conn = get_test_connection(self.test_db)
        with self.assertRaises(sqlite3.IntegrityError) as context:
            conn.execute("""
                INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
                VALUES (?, ?, ?, ?)
            """, ('2025-01-18', None, 'invalid_type', 'Should fail'))
            conn.commit()
        conn.close()
        
        self.assertIn('CHECK constraint', str(context.exception))
    
    def test_update_inventaire_with_valid_type(self):
        """Test updating an inventory with a valid type."""
        conn = get_test_connection(self.test_db)
        cur = conn.cursor()
        
        # First insert an inventory
        cur.execute("""
            INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
            VALUES (?, ?, ?, ?)
        """, ('2025-01-20', None, 'hors_evenement', 'Original'))
        inv_id = cur.lastrowid
        conn.commit()
        
        # Update it
        cur.execute("""
            UPDATE buvette_inventaires SET date_inventaire=?, event_id=?, type_inventaire=?, commentaire=?
            WHERE id=?
        """, ('2025-01-21', None, 'avant', 'Updated', inv_id))
        conn.commit()
        
        # Verify the update
        cur.execute("SELECT * FROM buvette_inventaires WHERE id=?", (inv_id,))
        inv = cur.fetchone()
        conn.close()
        
        self.assertEqual(inv['date_inventaire'], '2025-01-21')
        self.assertEqual(inv['type_inventaire'], 'avant')
        self.assertEqual(inv['commentaire'], 'Updated')
    
    def test_update_inventaire_with_invalid_type_raises_error(self):
        """Test that updating an inventory with invalid type raises IntegrityError."""
        conn = get_test_connection(self.test_db)
        cur = conn.cursor()
        
        # First insert an inventory
        cur.execute("""
            INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
            VALUES (?, ?, ?, ?)
        """, ('2025-01-22', None, 'hors_evenement', 'Original'))
        inv_id = cur.lastrowid
        conn.commit()
        
        # Try to update with invalid type
        with self.assertRaises(sqlite3.IntegrityError) as context:
            cur.execute("""
                UPDATE buvette_inventaires SET date_inventaire=?, event_id=?, type_inventaire=?, commentaire=?
                WHERE id=?
            """, ('2025-01-23', None, 'invalid_update', 'Should fail', inv_id))
            conn.commit()
        
        conn.close()
        self.assertIn('CHECK constraint', str(context.exception))
    
    def test_list_inventaires(self):
        """Test listing all inventories."""
        conn = get_test_connection(self.test_db)
        cur = conn.cursor()
        
        # Insert multiple inventories
        for date, type_inv, comment in [
            ('2025-01-24', 'hors_evenement', 'First'),
            ('2025-01-25', 'avant', 'Second'),
            ('2025-01-26', 'apres', 'Third')
        ]:
            cur.execute("""
                INSERT INTO buvette_inventaires (date_inventaire, event_id, type_inventaire, commentaire)
                VALUES (?, ?, ?, ?)
            """, (date, None, type_inv, comment))
        conn.commit()
        
        # List them
        cur.execute("SELECT * FROM buvette_inventaires ORDER BY date_inventaire DESC")
        inventaires = cur.fetchall()
        conn.close()
        
        self.assertEqual(len(inventaires), 3)


if __name__ == "__main__":
    unittest.main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: tests/test_buvette_purchase_price.py ===

```python
"""
Tests pour la fonctionnalitÃ© du prix d'achat dans le module buvette.

Ce fichier teste:
- La crÃ©ation de la colonne purchase_price (migration)
- L'insertion d'articles avec purchase_price
- La mise Ã  jour d'articles avec purchase_price
- La rÃ©cupÃ©ration d'articles avec purchase_price
"""

import unittest
import sqlite3
import os


def get_test_connection(db_file):
    """Create a simple connection without WAL mode for testing."""
    conn = sqlite3.connect(db_file)
    conn.row_factory = sqlite3.Row
    return conn


class TestBuvettePurchasePrice(unittest.TestCase):
    """Test suite for buvette purchase price management."""
    
    def setUp(self):
        """Set up a fresh test database before each test."""
        self.test_db = f"/tmp/test_buvette_purchase_price_{id(self)}.db"
        
        # Create the tables with purchase_price column
        conn = get_test_connection(self.test_db)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                unite TEXT,
                contenance TEXT,
                commentaire TEXT,
                stock INTEGER DEFAULT 0,
                purchase_price REAL
            )
        """)
        conn.commit()
        conn.close()
    
    def tearDown(self):
        """Clean up test database after each test."""
        if os.path.exists(self.test_db):
            os.remove(self.test_db)
    
    def test_table_has_purchase_price_column(self):
        """Test that buvette_articles table has purchase_price column."""
        conn = get_test_connection(self.test_db)
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns = [row[1] for row in cursor.fetchall()]
        conn.close()
        
        self.assertIn('purchase_price', columns, "purchase_price column should exist")
    
    def test_insert_article_with_purchase_price(self):
        """Test inserting an article with a purchase price."""
        conn = get_test_connection(self.test_db)
        conn.execute("""
            INSERT INTO buvette_articles 
            (name, categorie, unite, commentaire, contenance, purchase_price)
            VALUES (?, ?, ?, ?, ?, ?)
        """, ("Coca-Cola", "Boisson", "canette", "Test", "0.33L", 1.50))
        conn.commit()
        
        # Retrieve the article
        cursor = conn.execute("SELECT * FROM buvette_articles WHERE name = ?", ("Coca-Cola",))
        article = cursor.fetchone()
        conn.close()
        
        self.assertIsNotNone(article, "Article should be inserted")
        self.assertEqual(article['purchase_price'], 1.50, "Purchase price should be 1.50")
    
    def test_insert_article_without_purchase_price(self):
        """Test inserting an article without a purchase price (NULL)."""
        conn = get_test_connection(self.test_db)
        conn.execute("""
            INSERT INTO buvette_articles 
            (name, categorie, unite, commentaire, contenance)
            VALUES (?, ?, ?, ?, ?)
        """, ("Fanta", "Boisson", "canette", "Test", "0.33L"))
        conn.commit()
        
        # Retrieve the article
        cursor = conn.execute("SELECT * FROM buvette_articles WHERE name = ?", ("Fanta",))
        article = cursor.fetchone()
        conn.close()
        
        self.assertIsNotNone(article, "Article should be inserted")
        self.assertIsNone(article['purchase_price'], "Purchase price should be NULL")
    
    def test_update_article_purchase_price(self):
        """Test updating an article's purchase price."""
        conn = get_test_connection(self.test_db)
        
        # Insert article
        conn.execute("""
            INSERT INTO buvette_articles 
            (name, categorie, unite, commentaire, contenance, purchase_price)
            VALUES (?, ?, ?, ?, ?, ?)
        """, ("Sprite", "Boisson", "canette", "Test", "0.33L", 1.25))
        conn.commit()
        
        # Get the article ID
        cursor = conn.execute("SELECT id FROM buvette_articles WHERE name = ?", ("Sprite",))
        article_id = cursor.fetchone()['id']
        
        # Update purchase price
        conn.execute("""
            UPDATE buvette_articles 
            SET purchase_price = ? 
            WHERE id = ?
        """, (1.75, article_id))
        conn.commit()
        
        # Verify update
        cursor = conn.execute("SELECT purchase_price FROM buvette_articles WHERE id = ?", (article_id,))
        updated_price = cursor.fetchone()['purchase_price']
        conn.close()
        
        self.assertEqual(updated_price, 1.75, "Purchase price should be updated to 1.75")
    
    def test_migration_adds_purchase_price_column(self):
        """Test that migration adds purchase_price column to existing table."""
        # Create a database with old schema (without purchase_price)
        old_db = f"/tmp/test_migration_{id(self)}.db"
        conn = get_test_connection(old_db)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                unite TEXT,
                contenance TEXT,
                commentaire TEXT,
                stock INTEGER DEFAULT 0
            )
        """)
        
        # Insert test data
        conn.execute("""
            INSERT INTO buvette_articles 
            (name, categorie, unite, commentaire, contenance, stock)
            VALUES (?, ?, ?, ?, ?, ?)
        """, ("Pepsi", "Boisson", "canette", "Old data", "0.33L", 5))
        conn.commit()
        
        # Verify purchase_price column doesn't exist
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns_before = [row[1] for row in cursor.fetchall()]
        self.assertNotIn('purchase_price', columns_before, "purchase_price should not exist before migration")
        
        # Run migration
        conn.execute("ALTER TABLE buvette_articles ADD COLUMN purchase_price REAL")
        conn.commit()
        
        # Verify purchase_price column exists
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns_after = [row[1] for row in cursor.fetchall()]
        self.assertIn('purchase_price', columns_after, "purchase_price should exist after migration")
        
        # Verify old data is preserved
        cursor = conn.execute("SELECT name, stock, purchase_price FROM buvette_articles WHERE name = ?", ("Pepsi",))
        article = cursor.fetchone()
        conn.close()
        
        self.assertEqual(article['name'], "Pepsi", "Article name should be preserved")
        self.assertEqual(article['stock'], 5, "Article stock should be preserved")
        self.assertIsNone(article['purchase_price'], "Purchase price should be NULL for old data")
        
        # Cleanup
        os.remove(old_db)


if __name__ == '__main__':
    unittest.main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: tests/test_buvette_stock.py ===

```python
"""
Tests pour la fonctionnalitÃ© de gestion du stock dans le module buvette.

Ce fichier teste:
- La crÃ©ation de la colonne stock (migration non destructive)
- La fonction set_article_stock
- La fonction get_article_stock
- L'intÃ©gration avec les lignes d'inventaire
"""

import unittest
import sqlite3
import os
import sys

# Add parent directory to path to import modules
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))


def get_test_connection(db_file):
    """Create a simple connection without WAL mode for testing."""
    conn = sqlite3.connect(db_file)
    conn.row_factory = sqlite3.Row
    return conn


class TestBuvetteStock(unittest.TestCase):
    """Test suite for buvette stock management."""
    
    def setUp(self):
        """Set up a fresh test database before each test."""
        self.test_db = f"/tmp/test_buvette_stock_{id(self)}.db"
        
        # Create the tables
        conn = get_test_connection(self.test_db)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                unite TEXT,
                contenance TEXT,
                commentaire TEXT,
                stock INTEGER DEFAULT 0
            )
        """)
        conn.commit()
        conn.close()
    
    def tearDown(self):
        """Clean up test database after each test."""
        if os.path.exists(self.test_db):
            os.remove(self.test_db)
    
    def test_stock_column_exists_in_new_table(self):
        """Test that stock column exists in newly created table."""
        conn = get_test_connection(self.test_db)
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns = [row[1] for row in cursor.fetchall()]
        conn.close()
        
        self.assertIn('stock', columns)
    
    def test_insert_article_with_default_stock(self):
        """Test that new articles have stock defaulting to 0."""
        conn = get_test_connection(self.test_db)
        conn.execute("""
            INSERT INTO buvette_articles (name, categorie, unite, contenance, commentaire)
            VALUES (?, ?, ?, ?, ?)
        """, ('Coca-Cola', 'Boissons', 'bouteille', '1L', 'Test'))
        conn.commit()
        
        cursor = conn.execute("SELECT stock FROM buvette_articles WHERE name=?", ('Coca-Cola',))
        row = cursor.fetchone()
        conn.close()
        
        self.assertIsNotNone(row)
        self.assertEqual(row['stock'], 0)
    
    def test_insert_article_with_explicit_stock(self):
        """Test inserting an article with explicit stock value."""
        conn = get_test_connection(self.test_db)
        conn.execute("""
            INSERT INTO buvette_articles (name, categorie, unite, contenance, commentaire, stock)
            VALUES (?, ?, ?, ?, ?, ?)
        """, ('Pepsi', 'Boissons', 'canette', '0.33L', 'Test', 50))
        conn.commit()
        
        cursor = conn.execute("SELECT stock FROM buvette_articles WHERE name=?", ('Pepsi',))
        row = cursor.fetchone()
        conn.close()
        
        self.assertEqual(row['stock'], 50)
    
    def test_update_article_stock(self):
        """Test updating the stock of an article."""
        conn = get_test_connection(self.test_db)
        
        # Insert an article
        conn.execute("""
            INSERT INTO buvette_articles (name, categorie, unite, contenance, commentaire, stock)
            VALUES (?, ?, ?, ?, ?, ?)
        """, ('Fanta', 'Boissons', 'bouteille', '1.5L', 'Test', 10))
        conn.commit()
        
        # Get the article ID
        cursor = conn.execute("SELECT id FROM buvette_articles WHERE name=?", ('Fanta',))
        article_id = cursor.fetchone()['id']
        
        # Update the stock
        conn.execute("UPDATE buvette_articles SET stock=? WHERE id=?", (25, article_id))
        conn.commit()
        
        # Verify the update
        cursor = conn.execute("SELECT stock FROM buvette_articles WHERE id=?", (article_id,))
        row = cursor.fetchone()
        conn.close()
        
        self.assertEqual(row['stock'], 25)
    
    def test_stock_column_migration_on_existing_table(self):
        """Test adding stock column to an existing table without it."""
        # Create a table without stock column
        test_db2 = f"/tmp/test_migration_{id(self)}.db"
        conn = get_test_connection(test_db2)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                unite TEXT,
                contenance TEXT,
                commentaire TEXT
            )
        """)
        conn.commit()
        
        # Insert an article without stock
        conn.execute("""
            INSERT INTO buvette_articles (name, categorie, unite, contenance, commentaire)
            VALUES (?, ?, ?, ?, ?)
        """, ('Sprite', 'Boissons', 'bouteille', '1L', 'Test'))
        conn.commit()
        
        # Add stock column (simulating migration)
        cursor = conn.execute("PRAGMA table_info(buvette_articles)")
        columns = [row[1] for row in cursor.fetchall()]
        
        if 'stock' not in columns:
            conn.execute("ALTER TABLE buvette_articles ADD COLUMN stock INTEGER DEFAULT 0")
            conn.commit()
        
        # Verify the column was added and default value is applied
        cursor = conn.execute("SELECT stock FROM buvette_articles WHERE name=?", ('Sprite',))
        row = cursor.fetchone()
        conn.close()
        
        # Clean up
        if os.path.exists(test_db2):
            os.remove(test_db2)
        
        self.assertIsNotNone(row)
        self.assertEqual(row['stock'], 0)


if __name__ == "__main__":
    unittest.main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: tests/test_database_migration.py ===

```python
"""
Tests for the database migration script.
"""

import os
import sys
import sqlite3
import tempfile
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from scripts.update_db_structure import DatabaseMigrator, REFERENCE_SCHEMA, get_latest_migration_report


def create_test_database(db_path, missing_columns=True):
    """Create a test database with or without missing columns."""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    if missing_columns:
        # Create tables with some columns missing
        cursor.execute("""
            CREATE TABLE config (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                exercice TEXT,
                date TEXT
            )
        """)
        
        cursor.execute("""
            CREATE TABLE membres (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                prenom TEXT
            )
        """)
    else:
        # Create complete tables
        cursor.execute("""
            CREATE TABLE config (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                exercice TEXT,
                date TEXT,
                but_asso TEXT DEFAULT '',
                cloture INTEGER DEFAULT 0,
                solde_report REAL DEFAULT 0.0,
                disponible_banque REAL DEFAULT 0.0
            )
        """)
        
        cursor.execute("""
            CREATE TABLE membres (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                prenom TEXT,
                email TEXT DEFAULT '',
                classe TEXT DEFAULT '',
                cotisation TEXT DEFAULT '',
                commentaire TEXT DEFAULT '',
                telephone TEXT DEFAULT '',
                statut TEXT DEFAULT '',
                date_adhesion TEXT DEFAULT ''
            )
        """)
    
    conn.commit()
    conn.close()


def test_database_migrator_initialization():
    """Test DatabaseMigrator initialization."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path)
        migrator = DatabaseMigrator(db_path)
        
        assert migrator.db_path == db_path
        assert migrator.backup_path is None
        assert len(migrator.migration_log) == 0
        assert len(migrator.errors) == 0
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_create_backup():
    """Test backup creation."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path)
        migrator = DatabaseMigrator(db_path)
        
        result = migrator.create_backup()
        
        assert result is True
        assert migrator.backup_path is not None
        assert os.path.exists(migrator.backup_path)
        assert migrator.backup_path.endswith(".bak")
        
        # Clean up backup
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_get_existing_schema():
    """Test schema retrieval."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path)
        migrator = DatabaseMigrator(db_path)
        
        conn = sqlite3.connect(db_path)
        schema = migrator.get_existing_schema(conn)
        conn.close()
        
        assert "config" in schema
        assert "membres" in schema
        assert "id" in schema["config"]
        assert "exercice" in schema["config"]
        assert "date" in schema["config"]
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_detect_missing_columns():
    """Test detection of missing columns."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=True)
        migrator = DatabaseMigrator(db_path)
        
        conn = sqlite3.connect(db_path)
        existing_schema = migrator.get_existing_schema(conn)
        conn.close()
        
        missing = migrator.detect_missing_columns(existing_schema)
        
        assert "config" in missing
        assert "membres" in missing
        
        # Check that we detected the missing columns in config
        config_missing_cols = [col[0] for col in missing["config"]]
        assert "but_asso" in config_missing_cols
        assert "cloture" in config_missing_cols
        assert "solde_report" in config_missing_cols
        assert "disponible_banque" in config_missing_cols
        
        # Check that we detected the missing columns in membres
        membres_missing_cols = [col[0] for col in missing["membres"]]
        assert "email" in membres_missing_cols
        assert "classe" in membres_missing_cols
        assert "cotisation" in membres_missing_cols
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_apply_migrations():
    """Test applying migrations."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=True)
        migrator = DatabaseMigrator(db_path)
        
        conn = sqlite3.connect(db_path)
        existing_schema = migrator.get_existing_schema(conn)
        missing = migrator.detect_missing_columns(existing_schema)
        
        result = migrator.apply_migrations(conn, missing)
        
        assert result is True
        
        # Verify columns were added
        cursor = conn.cursor()
        cursor.execute("PRAGMA table_info(config)")
        config_cols = {row[1] for row in cursor.fetchall()}
        
        assert "but_asso" in config_cols
        assert "cloture" in config_cols
        assert "solde_report" in config_cols
        assert "disponible_banque" in config_cols
        
        cursor.execute("PRAGMA table_info(membres)")
        membres_cols = {row[1] for row in cursor.fetchall()}
        
        assert "email" in membres_cols
        assert "classe" in membres_cols
        assert "cotisation" in membres_cols
        
        conn.close()
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_migration_with_data_preservation():
    """Test that migration preserves existing data."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=True)
        
        # Insert some test data
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("INSERT INTO config (exercice, date) VALUES (?, ?)", ("2024-2025", "2024-09-01"))
        cursor.execute("INSERT INTO membres (name, prenom) VALUES (?, ?)", ("Dupont", "Jean"))
        cursor.execute("INSERT INTO membres (name, prenom) VALUES (?, ?)", ("Martin", "Marie"))
        conn.commit()
        conn.close()
        
        # Run migration
        migrator = DatabaseMigrator(db_path)
        migrator.create_backup()
        
        conn = sqlite3.connect(db_path)
        existing_schema = migrator.get_existing_schema(conn)
        missing = migrator.detect_missing_columns(existing_schema)
        migrator.apply_migrations(conn, missing)
        
        # Verify data is still there
        cursor = conn.cursor()
        cursor.execute("SELECT exercice, date, but_asso FROM config")
        row = cursor.fetchone()
        assert row[0] == "2024-2025"
        assert row[1] == "2024-09-01"
        # New column should have default value
        assert row[2] == ""
        
        cursor.execute("SELECT name, prenom, email FROM membres")
        rows = cursor.fetchall()
        assert len(rows) == 2
        assert rows[0][0] == "Dupont"
        assert rows[0][1] == "Jean"
        assert rows[0][2] == ""  # Default value for new column
        
        conn.close()
        
        # Clean up backup
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_no_migration_needed():
    """Test when no migration is needed."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=False)
        migrator = DatabaseMigrator(db_path)
        
        conn = sqlite3.connect(db_path)
        existing_schema = migrator.get_existing_schema(conn)
        missing = migrator.detect_missing_columns(existing_schema)
        
        # Should find no missing columns for these two tables
        if "config" in missing:
            assert len(missing["config"]) == 0
        if "membres" in missing:
            assert len(missing["membres"]) == 0
        
        conn.close()
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_generate_report():
    """Test report generation."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=True)
        migrator = DatabaseMigrator(db_path)
        
        conn = sqlite3.connect(db_path)
        existing_schema = migrator.get_existing_schema(conn)
        missing = migrator.detect_missing_columns(existing_schema)
        conn.close()
        
        with tempfile.NamedTemporaryFile(suffix=".md", delete=False) as report_tmp:
            report_path = report_tmp.name
        
        migrator.generate_report(report_path, missing, True)
        
        assert os.path.exists(report_path)
        
        with open(report_path, 'r') as f:
            content = f.read()
        
        assert "# Database Migration Report" in content
        assert "SUCCESS" in content
        assert "config" in content
        assert "membres" in content
        
        os.unlink(report_path)
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_report_path_in_reports_directory():
    """Test that report is created in the reports directory."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=True)
        migrator = DatabaseMigrator(db_path)
        
        # Run the migration
        success = migrator.run_migration()
        
        assert success is True
        assert migrator.report_path is not None
        
        # Verify the report is in the reports directory
        assert "reports" in migrator.report_path
        assert "migration_report_success_" in migrator.report_path
        assert os.path.exists(migrator.report_path)
        
        # Clean up
        if os.path.exists(migrator.report_path):
            os.unlink(migrator.report_path)
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_failed_migration_report():
    """Test that a failed migration generates an error report."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    # Constants for file permissions
    READ_ONLY_PERMISSIONS = 0o444
    READ_WRITE_PERMISSIONS = 0o644
    
    try:
        create_test_database(db_path, missing_columns=True)
        
        # Make the database read-only to force a migration failure
        os.chmod(db_path, READ_ONLY_PERMISSIONS)
        
        migrator = DatabaseMigrator(db_path)
        success = migrator.run_migration()
        
        # Restore write permissions for cleanup
        os.chmod(db_path, READ_WRITE_PERMISSIONS)
        
        # Migration should fail
        assert success is False
        assert len(migrator.errors) > 0
        assert migrator.report_path is not None
        
        # Verify the report is marked as failed
        assert "migration_report_failed_" in migrator.report_path
        
        # Verify report content contains error information
        if os.path.exists(migrator.report_path):
            with open(migrator.report_path, 'r') as f:
                content = f.read()
            
            assert "FAILED" in content
            assert "## Errors" in content
            assert "## Recommended Actions" in content
            
            # Clean up report
            os.unlink(migrator.report_path)
        
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
    finally:
        if os.path.exists(db_path):
            try:
                os.chmod(db_path, READ_WRITE_PERMISSIONS)
                os.unlink(db_path)
            except Exception:
                pass


def test_report_contains_all_required_sections():
    """Test that generated reports contain all required sections."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database(db_path, missing_columns=True)
        migrator = DatabaseMigrator(db_path)
        
        success = migrator.run_migration()
        
        assert migrator.report_path is not None
        assert os.path.exists(migrator.report_path)
        
        with open(migrator.report_path, 'r') as f:
            content = f.read()
        
        # Check required sections
        assert "# Database Migration Report" in content
        assert "**Date:**" in content
        assert "**Database:**" in content
        assert "**Status:**" in content
        assert "## Summary" in content
        assert "## Changes Applied" in content
        assert "## Migration Log" in content
        
        # Clean up
        os.unlink(migrator.report_path)
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


if __name__ == "__main__":
    # Run tests
    test_database_migrator_initialization()
    print("âœ“ test_database_migrator_initialization")
    
    test_create_backup()
    print("âœ“ test_create_backup")
    
    test_get_existing_schema()
    print("âœ“ test_get_existing_schema")
    
    test_detect_missing_columns()
    print("âœ“ test_detect_missing_columns")
    
    test_apply_migrations()
    print("âœ“ test_apply_migrations")
    
    test_migration_with_data_preservation()
    print("âœ“ test_migration_with_data_preservation")
    
    test_no_migration_needed()
    print("âœ“ test_no_migration_needed")
    
    test_generate_report()
    print("âœ“ test_generate_report")
    
    test_report_path_in_reports_directory()
    print("âœ“ test_report_path_in_reports_directory")
    
    test_failed_migration_report()
    print("âœ“ test_failed_migration_report")
    
    test_report_contains_all_required_sections()
    print("âœ“ test_report_contains_all_required_sections")
    
    print("\nAll tests passed!")

```


# ===== FICHIER SUIVANT =====

# === Fichier: tests/test_db_api_retry.py ===

```python
# -*- coding: utf-8 -*-
"""
Tests for db_api retry logic and error handling.
"""

import pytest
import sqlite3
import time
import tempfile
import os
from unittest.mock import patch, MagicMock
import sys
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from modules.db_api import execute, get_connection, query_one, query_all
from db.db import set_db_file


@pytest.fixture
def temp_db():
    """Create a temporary database for testing."""
    fd, path = tempfile.mkstemp(suffix='.db')
    os.close(fd)
    
    # Set up the database
    set_db_file(path)
    conn = sqlite3.connect(path)
    conn.execute("""
        CREATE TABLE test_table (
            id INTEGER PRIMARY KEY,
            name TEXT,
            value INTEGER
        )
    """)
    conn.execute("INSERT INTO test_table (name, value) VALUES ('test1', 100)")
    conn.execute("INSERT INTO test_table (name, value) VALUES ('test2', 200)")
    conn.commit()
    conn.close()
    
    yield path
    
    # Cleanup
    try:
        os.unlink(path)
    except (OSError, FileNotFoundError):
        # Ignore cleanup errors
        pass


class TestDBApiRetry:
    """Test retry logic in db_api module."""
    
    def test_execute_success_no_retry(self, temp_db):
        """Test that execute works on first attempt when no lock."""
        rows = execute(
            "UPDATE test_table SET value = ? WHERE name = ?",
            (150, 'test1')
        )
        
        assert rows == 1
        
        # Verify the update
        result = query_one("SELECT value FROM test_table WHERE name = ?", ('test1',))
        assert result['value'] == 150
    
    def test_execute_insert(self, temp_db):
        """Test execute with INSERT."""
        rows = execute(
            "INSERT INTO test_table (name, value) VALUES (?, ?)",
            ('test3', 300)
        )
        
        assert rows == 1
        
        # Verify the insert
        result = query_one("SELECT * FROM test_table WHERE name = ?", ('test3',))
        assert result is not None
        assert result['name'] == 'test3'
        assert result['value'] == 300
    
    def test_execute_delete(self, temp_db):
        """Test execute with DELETE."""
        rows = execute("DELETE FROM test_table WHERE name = ?", ('test1',))
        
        assert rows == 1
        
        # Verify the delete
        result = query_one("SELECT * FROM test_table WHERE name = ?", ('test1',))
        assert result is None
    
    def test_execute_without_commit(self, temp_db):
        """Test execute with commit=False."""
        # Note: This is tricky to test as connection is auto-closed
        # Just verify the function accepts the parameter
        rows = execute(
            "UPDATE test_table SET value = ? WHERE name = ?",
            (175, 'test2'),
            commit=True
        )
        
        assert rows == 1
    
    def test_execute_with_custom_retries(self, temp_db):
        """Test that custom retry count is accepted."""
        # This mainly tests the API, not the actual retry behavior
        rows = execute(
            "UPDATE test_table SET value = ? WHERE name = ?",
            (125, 'test1'),
            retries=5,
            retry_delay=0.1
        )
        
        assert rows == 1
    
    @patch('modules.db_api.get_connection')
    def test_execute_retries_on_lock_error(self, mock_get_connection):
        """Test that execute retries on database lock errors."""
        # Create a mock connection that raises OperationalError twice, then succeeds
        attempt_count = [0]
        
        def create_connection():
            conn = MagicMock()
            cursor = MagicMock()
            
            def execute_side_effect(*args, **kwargs):
                attempt_count[0] += 1
                if attempt_count[0] <= 2:
                    # First two attempts fail with lock error
                    raise sqlite3.OperationalError("database is locked")
                # Third attempt succeeds
                return None
            
            cursor.execute.side_effect = execute_side_effect
            cursor.rowcount = 1
            conn.cursor.return_value = cursor
            conn.commit = MagicMock()
            conn.rollback = MagicMock()
            conn.close = MagicMock()
            
            return conn
        
        mock_get_connection.side_effect = create_connection
        
        # Execute should retry and succeed
        start_time = time.time()
        rows = execute(
            "UPDATE test_table SET value = ? WHERE name = ?",
            (200, 'test'),
            retries=3,
            retry_delay=0.1
        )
        elapsed = time.time() - start_time
        
        # Should have succeeded after retries
        assert rows == 1
        assert attempt_count[0] == 3
        
        # Should have taken at least the retry delays (0.1 + 0.2 = 0.3s)
        assert elapsed >= 0.3
    
    @patch('modules.db_api.get_connection')
    def test_execute_fails_after_max_retries(self, mock_get_connection):
        """Test that execute fails after exhausting all retries."""
        def create_failing_connection():
            conn = MagicMock()
            cursor = MagicMock()
            cursor.execute.side_effect = sqlite3.OperationalError("database is locked")
            conn.cursor.return_value = cursor
            conn.close = MagicMock()
            return conn
        
        mock_get_connection.side_effect = create_failing_connection
        
        # Should raise OperationalError after all retries
        with pytest.raises(sqlite3.OperationalError, match="database is locked"):
            execute(
                "UPDATE test_table SET value = ?",
                (300,),
                retries=2,
                retry_delay=0.05
            )
    
    @patch('modules.db_api.get_connection')
    def test_execute_non_lock_error_no_retry(self, mock_get_connection):
        """Test that non-lock errors don't trigger retries."""
        attempt_count = [0]
        
        def create_connection():
            attempt_count[0] += 1
            conn = MagicMock()
            cursor = MagicMock()
            # Raise a non-lock error
            cursor.execute.side_effect = sqlite3.IntegrityError("UNIQUE constraint failed")
            conn.cursor.return_value = cursor
            conn.rollback = MagicMock()
            conn.close = MagicMock()
            return conn
        
        mock_get_connection.side_effect = create_connection
        
        # Should fail immediately without retries
        with pytest.raises(sqlite3.IntegrityError, match="UNIQUE constraint"):
            execute("INSERT INTO test_table VALUES (1, 'dup')", retries=3)
        
        # Should have only tried once (no retries for non-lock errors)
        assert attempt_count[0] == 1
    
    def test_query_one_returns_dict(self, temp_db):
        """Test that query_one returns a dictionary."""
        result = query_one("SELECT * FROM test_table WHERE name = ?", ('test1',))
        
        assert result is not None
        assert isinstance(result, dict)
        assert 'name' in result
        assert 'value' in result
        assert result.get('name') == 'test1'
        assert result.get('value') == 100
    
    def test_query_all_returns_list_of_dicts(self, temp_db):
        """Test that query_all returns a list of dictionaries."""
        results = query_all("SELECT * FROM test_table ORDER BY name")
        
        assert isinstance(results, list)
        assert len(results) == 2
        assert all(isinstance(r, dict) for r in results)
        
        assert results[0].get('name') == 'test1'
        assert results[1].get('name') == 'test2'
    
    def test_query_one_returns_none_for_no_results(self, temp_db):
        """Test that query_one returns None when no results."""
        result = query_one("SELECT * FROM test_table WHERE name = ?", ('nonexistent',))
        assert result is None
    
    def test_query_all_returns_empty_list_for_no_results(self, temp_db):
        """Test that query_all returns empty list when no results."""
        results = query_all("SELECT * FROM test_table WHERE name = ?", ('nonexistent',))
        assert results == []


if __name__ == '__main__':
    pytest.main([__file__, '-v'])

```


# ===== FICHIER SUIVANT =====

# === Fichier: tests/test_db_row_utils.py ===

```python
"""
Tests for modules/db_row_utils.py

This test suite validates the _row_to_dict and _rows_to_dicts utility functions.
"""

import unittest
import sqlite3
import tempfile
import os
from modules.db_row_utils import _row_to_dict, _rows_to_dicts


class TestDbRowUtils(unittest.TestCase):
    """Test suite for db_row_utils module."""
    
    def setUp(self):
        """Set up a temporary test database."""
        self.db_fd, self.db_path = tempfile.mkstemp()
        self.conn = sqlite3.connect(self.db_path)
        self.conn.row_factory = sqlite3.Row
        
        # Create test table
        cursor = self.conn.cursor()
        cursor.execute("""
            CREATE TABLE test_table (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                optional_field TEXT,
                number_field INTEGER
            )
        """)
        
        # Insert test data
        cursor.execute(
            "INSERT INTO test_table (name, optional_field, number_field) VALUES (?, ?, ?)",
            ("Test Item 1", "Optional Value", 42)
        )
        cursor.execute(
            "INSERT INTO test_table (name, optional_field, number_field) VALUES (?, ?, ?)",
            ("Test Item 2", None, 100)
        )
        cursor.execute(
            "INSERT INTO test_table (name, number_field) VALUES (?, ?)",
            ("Test Item 3", 200)
        )
        
        self.conn.commit()
    
    def tearDown(self):
        """Clean up the test database."""
        self.conn.close()
        os.close(self.db_fd)
        os.unlink(self.db_path)
    
    def test_row_to_dict_basic(self):
        """Test basic conversion of sqlite3.Row to dict."""
        cursor = self.conn.cursor()
        row = cursor.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Convert to dict
        result = _row_to_dict(row)
        
        # Verify it's a dict
        self.assertIsInstance(result, dict)
        
        # Verify keys and values
        self.assertEqual(result["id"], 1)
        self.assertEqual(result["name"], "Test Item 1")
        self.assertEqual(result["optional_field"], "Optional Value")
        self.assertEqual(result["number_field"], 42)
    
    def test_row_to_dict_with_get_method(self):
        """Test that converted dict supports .get() method."""
        cursor = self.conn.cursor()
        row = cursor.execute("SELECT * FROM test_table WHERE id=2").fetchone()
        
        # Convert to dict
        result = _row_to_dict(row)
        
        # Test .get() with default value
        self.assertEqual(result.get("name"), "Test Item 2")
        # When a field is explicitly NULL in DB, .get() returns None (not the default)
        # because the key exists in the dict, just with None value
        self.assertIsNone(result.get("optional_field"))
        self.assertIsNone(result.get("optional_field", "default"))  # Key exists, value is None
        # For truly nonexistent keys, default is returned
        self.assertEqual(result.get("nonexistent_field", "default"), "default")
    
    def test_row_to_dict_with_none_input(self):
        """Test that _row_to_dict returns None when input is None."""
        result = _row_to_dict(None)
        self.assertIsNone(result)
    
    def test_row_to_dict_with_dict_input(self):
        """Test that _row_to_dict handles dict input (idempotent)."""
        input_dict = {"id": 1, "name": "Test", "value": 42}
        result = _row_to_dict(input_dict)
        
        # Should return the same dict
        self.assertEqual(result, input_dict)
    
    def test_rows_to_dicts_batch_conversion(self):
        """Test batch conversion of multiple rows."""
        cursor = self.conn.cursor()
        rows = cursor.execute("SELECT * FROM test_table ORDER BY id").fetchall()
        
        # Convert all rows
        results = _rows_to_dicts(rows)
        
        # Verify count
        self.assertEqual(len(results), 3)
        
        # Verify all are dicts
        for result in results:
            self.assertIsInstance(result, dict)
        
        # Verify data
        self.assertEqual(results[0]["name"], "Test Item 1")
        self.assertEqual(results[1]["name"], "Test Item 2")
        self.assertEqual(results[2]["name"], "Test Item 3")
        
        # Test .get() on converted dicts
        self.assertEqual(results[0].get("optional_field"), "Optional Value")
        # When field is NULL in DB, .get() returns None (not default) because key exists
        self.assertIsNone(results[1].get("optional_field", "N/A"))
        # Use "or" operator for NULL-coalescing behavior
        self.assertEqual(results[1].get("optional_field") or "N/A", "N/A")
    
    def test_rows_to_dicts_empty_list(self):
        """Test _rows_to_dicts with empty list."""
        result = _rows_to_dicts([])
        self.assertEqual(result, [])
    
    def test_rows_to_dicts_filters_none(self):
        """Test that _rows_to_dicts filters out None values."""
        cursor = self.conn.cursor()
        row1 = cursor.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        row2 = cursor.execute("SELECT * FROM test_table WHERE id=2").fetchone()
        
        # Mix in a None value
        mixed_rows = [row1, None, row2]
        
        # Convert - should filter out None
        results = _rows_to_dicts(mixed_rows)
        
        # Should only have 2 results
        self.assertEqual(len(results), 2)
        self.assertEqual(results[0]["id"], 1)
        self.assertEqual(results[1]["id"], 2)
    
    def test_sqlite_row_bracket_access_still_works(self):
        """Test that original sqlite3.Row bracket access still works before conversion."""
        cursor = self.conn.cursor()
        row = cursor.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Before conversion, bracket access should work
        self.assertEqual(row["name"], "Test Item 1")
        self.assertEqual(row["id"], 1)
    
    def test_sqlite_row_lacks_get_method(self):
        """Verify that sqlite3.Row does not have .get() method."""
        cursor = self.conn.cursor()
        row = cursor.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Confirm Row doesn't have .get() method
        self.assertFalse(hasattr(row, "get") or callable(getattr(row, "get", None)))
    
    def test_conversion_enables_get_method(self):
        """Verify that conversion enables .get() method that was missing."""
        cursor = self.conn.cursor()
        row = cursor.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Convert to dict
        row_dict = _row_to_dict(row)
        
        # Now .get() should work
        self.assertTrue(hasattr(row_dict, "get"))
        self.assertTrue(callable(row_dict.get))
        
        # And it should work as expected
        self.assertEqual(row_dict.get("name"), "Test Item 1")
        self.assertEqual(row_dict.get("nonexistent", "default"), "default")


if __name__ == "__main__":
    unittest.main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: tests/test_inventory_lines_loader.py ===

```python
"""
Tests for modules/inventory_lines_dialog.py

This test suite validates the load_inventory_lines function and error reporting.
"""

import unittest
import sqlite3
import tempfile
import os
import glob
from modules.inventory_lines_dialog import load_inventory_lines, _write_error_report


class TestInventoryLinesLoader(unittest.TestCase):
    """Test suite for inventory_lines_dialog module."""
    
    def setUp(self):
        """Set up a temporary test database with inventory structure."""
        self.db_fd, self.db_path = tempfile.mkstemp()
        self.conn = sqlite3.connect(self.db_path)
        self.conn.row_factory = sqlite3.Row
        
        # Create tables
        cursor = self.conn.cursor()
        
        # Create buvette_inventaires table
        cursor.execute("""
            CREATE TABLE buvette_inventaires (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date_inventaire TEXT NOT NULL,
                event_id INTEGER,
                type_inventaire TEXT NOT NULL,
                commentaire TEXT
            )
        """)
        
        # Create buvette_inventaire_lignes table
        cursor.execute("""
            CREATE TABLE buvette_inventaire_lignes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                inventaire_id INTEGER NOT NULL,
                article_id INTEGER NOT NULL,
                quantite INTEGER NOT NULL,
                commentaire TEXT,
                FOREIGN KEY (inventaire_id) REFERENCES buvette_inventaires(id)
            )
        """)
        
        # Create buvette_articles table for JOIN
        cursor.execute("""
            CREATE TABLE buvette_articles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                categorie TEXT,
                stock INTEGER DEFAULT 0
            )
        """)
        
        # Insert test data
        cursor.execute(
            "INSERT INTO buvette_inventaires (date_inventaire, type_inventaire, commentaire) VALUES (?, ?, ?)",
            ("2024-01-15", "hors_evenement", "Test inventory")
        )
        inventaire_id = cursor.lastrowid
        self.test_inventaire_id = inventaire_id
        
        # Insert articles
        cursor.execute("INSERT INTO buvette_articles (name, categorie, stock) VALUES (?, ?, ?)", ("Coca", "Boisson", 10))
        article1_id = cursor.lastrowid
        cursor.execute("INSERT INTO buvette_articles (name, categorie, stock) VALUES (?, ?, ?)", ("Sprite", "Boisson", 5))
        article2_id = cursor.lastrowid
        
        # Insert inventory lines
        cursor.execute(
            "INSERT INTO buvette_inventaire_lignes (inventaire_id, article_id, quantite) VALUES (?, ?, ?)",
            (inventaire_id, article1_id, 8)
        )
        cursor.execute(
            "INSERT INTO buvette_inventaire_lignes (inventaire_id, article_id, quantite) VALUES (?, ?, ?)",
            (inventaire_id, article2_id, 3)
        )
        
        self.conn.commit()
        
        # Store original DB path for mocking
        self.original_db_path = None
    
    def tearDown(self):
        """Clean up the test database."""
        self.conn.close()
        os.close(self.db_fd)
        os.unlink(self.db_path)
        
        # Clean up any error reports generated during tests
        reports_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "reports")
        if os.path.exists(reports_dir):
            error_reports = glob.glob(os.path.join(reports_dir, "inventory_error_*.txt"))
            for report in error_reports:
                try:
                    os.unlink(report)
                except (OSError, IOError) as e:
                    # Log but don't fail test if cleanup fails
                    print(f"Warning: Could not remove test report {report}: {e}")
    
    def test_load_inventory_lines_returns_dicts(self):
        """Test that load_inventory_lines returns a list of dicts."""
        # Temporarily patch the db module to use our test database
        import modules.buvette_inventaire_db as db_module
        original_get_conn = db_module.get_conn
        
        def mock_get_conn():
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            return conn
        
        try:
            db_module.get_conn = mock_get_conn
            
            # Load inventory lines
            lines = load_inventory_lines(self.test_inventaire_id)
            
            # Verify results
            self.assertIsInstance(lines, list)
            self.assertEqual(len(lines), 2)
            
            # Verify all items are dicts
            for line in lines:
                self.assertIsInstance(line, dict)
                
            # Verify .get() method works
            self.assertEqual(lines[0].get("article_id"), 1)
            self.assertEqual(lines[0].get("quantite"), 8)
            self.assertEqual(lines[1].get("article_id"), 2)
            self.assertEqual(lines[1].get("quantite"), 3)
            
        finally:
            db_module.get_conn = original_get_conn
    
    def test_load_inventory_lines_empty(self):
        """Test loading inventory with no lines."""
        import modules.buvette_inventaire_db as db_module
        original_get_conn = db_module.get_conn
        
        def mock_get_conn():
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            return conn
        
        try:
            db_module.get_conn = mock_get_conn
            
            # Create empty inventory
            cursor = self.conn.cursor()
            cursor.execute(
                "INSERT INTO buvette_inventaires (date_inventaire, type_inventaire) VALUES (?, ?)",
                ("2024-01-20", "hors_evenement")
            )
            empty_inv_id = cursor.lastrowid
            self.conn.commit()
            
            # Load empty inventory
            lines = load_inventory_lines(empty_inv_id)
            
            # Should return empty list
            self.assertEqual(lines, [])
            
        finally:
            db_module.get_conn = original_get_conn
    
    def test_write_error_report(self):
        """Test that error reports are written correctly."""
        # Create a test error
        test_error = ValueError("Test error for reporting")
        
        # Write error report
        _write_error_report(inventaire_id=999, error=test_error, raw_rows=None)
        
        # Check that report was created
        reports_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "reports")
        self.assertTrue(os.path.exists(reports_dir))
        
        # Find the most recent error report
        error_reports = sorted(glob.glob(os.path.join(reports_dir, "inventory_error_*.txt")))
        self.assertGreater(len(error_reports), 0, "Error report should have been created")
        
        # Read the report
        latest_report = error_reports[-1]
        with open(latest_report, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Verify content
        self.assertIn("INVENTORY LOADING ERROR REPORT", content)
        self.assertIn("Inventaire ID: 999", content)
        self.assertIn("ValueError", content)
        self.assertIn("Test error for reporting", content)
        self.assertIn("RECOMMENDED ACTIONS", content)
    
    def test_load_inventory_lines_handles_errors(self):
        """Test that load_inventory_lines properly handles and reports errors."""
        import modules.buvette_inventaire_db as db_module
        original_get_conn = db_module.get_conn
        
        def mock_get_conn_error():
            raise sqlite3.OperationalError("Database is locked")
        
        try:
            db_module.get_conn = mock_get_conn_error
            
            # Attempt to load - should raise error
            with self.assertRaises(sqlite3.OperationalError):
                load_inventory_lines(self.test_inventaire_id)
            
            # Check that error report was created
            reports_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "reports")
            error_reports = glob.glob(os.path.join(reports_dir, "inventory_error_*.txt"))
            self.assertGreater(len(error_reports), 0, "Error report should have been created on failure")
            
        finally:
            db_module.get_conn = original_get_conn


if __name__ == "__main__":
    unittest.main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: tests/test_row_to_dict_conversion.py ===

```python
"""
Test that sqlite3.Row to dict conversion works correctly.

This test validates that the fix for the 'sqlite3.Row' object has no attribute 'get'
error is working correctly by testing the conversion utilities.
"""

import unittest
import sqlite3
import tempfile
import os
from utils.db_helpers import row_to_dict, rows_to_dicts, row_get_safe


class TestRowToDictConversion(unittest.TestCase):
    """Test sqlite3.Row to dict conversion helpers."""
    
    def setUp(self):
        """Create a temporary database for testing."""
        self.db_fd, self.db_path = tempfile.mkstemp(suffix=".db")
        self.conn = sqlite3.connect(self.db_path)
        self.conn.row_factory = sqlite3.Row
        
        # Create test table
        self.conn.execute("""
            CREATE TABLE test_table (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                optional_field TEXT,
                nullable_field TEXT
            )
        """)
        
        # Insert test data
        self.conn.execute("""
            INSERT INTO test_table (id, name, optional_field, nullable_field)
            VALUES (1, 'test1', 'value1', NULL)
        """)
        self.conn.execute("""
            INSERT INTO test_table (id, name, optional_field, nullable_field)
            VALUES (2, 'test2', NULL, 'value2')
        """)
        self.conn.commit()
    
    def tearDown(self):
        """Clean up temporary database."""
        self.conn.close()
        os.close(self.db_fd)
        os.remove(self.db_path)
    
    def test_row_to_dict_basic(self):
        """Test that row_to_dict converts sqlite3.Row to dict."""
        row = self.conn.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Verify it's a Row object
        self.assertIsInstance(row, sqlite3.Row)
        
        # Convert to dict
        row_dict = row_to_dict(row)
        
        # Verify conversion
        self.assertIsInstance(row_dict, dict)
        self.assertEqual(row_dict['id'], 1)
        self.assertEqual(row_dict['name'], 'test1')
        self.assertEqual(row_dict['optional_field'], 'value1')
        self.assertIsNone(row_dict['nullable_field'])
    
    def test_row_to_dict_with_get_method(self):
        """Test that converted dict supports .get() method with default values."""
        row = self.conn.execute("SELECT * FROM test_table WHERE id=2").fetchone()
        row_dict = row_to_dict(row)
        
        # Test .get() with existing key
        self.assertEqual(row_dict.get('name'), 'test2')
        
        # Test .get() with missing key and default
        self.assertEqual(row_dict.get('nonexistent', 'default'), 'default')
        
        # Test .get() with None value
        self.assertIsNone(row_dict.get('optional_field'))
        self.assertEqual(row_dict.get('optional_field', 'default'), None)
    
    def test_row_to_dict_with_none_input(self):
        """Test that row_to_dict handles None input gracefully."""
        result = row_to_dict(None)
        self.assertIsNone(result)
    
    def test_rows_to_dicts_batch_conversion(self):
        """Test that rows_to_dicts converts multiple rows."""
        rows = self.conn.execute("SELECT * FROM test_table").fetchall()
        
        # Verify they're Row objects
        self.assertTrue(all(isinstance(r, sqlite3.Row) for r in rows))
        
        # Convert to dicts
        dicts = rows_to_dicts(rows)
        
        # Verify conversion
        self.assertEqual(len(dicts), 2)
        self.assertTrue(all(isinstance(d, dict) for d in dicts))
        self.assertEqual(dicts[0]['id'], 1)
        self.assertEqual(dicts[1]['id'], 2)
    
    def test_conversion_pattern_consistency(self):
        """Test that the conversion pattern works consistently."""
        row = self.conn.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Test the pattern used in the fix
        row_dict = row_to_dict(row)
        
        self.assertIsInstance(row_dict, dict)
        self.assertEqual(row_dict['id'], 1)
        self.assertEqual(row_dict.get('name'), 'test1')
        
        # Test that the same pattern works for None
        none_dict = row_to_dict(None)
        self.assertIsNone(none_dict)
    
    def test_row_get_safe_helper(self):
        """Test that row_get_safe provides .get()-like interface on Row objects."""
        row = self.conn.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Test with existing column
        self.assertEqual(row_get_safe(row, 'name'), 'test1')
        
        # Test with missing column and default
        self.assertEqual(row_get_safe(row, 'nonexistent', 'default'), 'default')
        
        # Test with None value
        self.assertIsNone(row_get_safe(row, 'nullable_field'))
        self.assertIsNone(row_get_safe(row, 'nullable_field', 'default'))
    
    def test_sqlite_row_does_not_have_get_method(self):
        """Verify that sqlite3.Row indeed lacks the .get() method."""
        row = self.conn.execute("SELECT * FROM test_table WHERE id=1").fetchone()
        
        # Verify that calling .get() on Row raises AttributeError
        with self.assertRaises(AttributeError) as ctx:
            row.get('name')
        
        self.assertIn("'sqlite3.Row' object has no attribute 'get'", str(ctx.exception))


if __name__ == '__main__':
    unittest.main()

```


# ===== FICHIER SUIVANT =====

# === Fichier: tests/test_smart_migration.py ===

```python
"""
Tests for smart migration features: fuzzy matching, YAML hints, and column renaming.
"""

import os
import sys
import sqlite3
import tempfile
import yaml
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from scripts.update_db_structure import DatabaseMigrator


def create_test_database_with_typo(db_path):
    """Create a test database with a column name typo (e.g., 'prnom' instead of 'prenom')."""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    cursor.execute("""
        CREATE TABLE membres (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            prnom TEXT,
            emial TEXT
        )
    """)
    
    # Insert test data
    cursor.execute("INSERT INTO membres (name, prnom, emial) VALUES (?, ?, ?)", 
                   ("Dupont", "Jean", "jean@example.com"))
    
    conn.commit()
    conn.close()


def create_yaml_hints(yaml_path):
    """Create a test YAML hints file."""
    hints = {
        "schema_version": "1.0",
        "generated_by": "test",
        "tables": {
            "membres": {
                "expected_columns": {
                    "id": {"type": "INTEGER", "inferred": False},
                    "name": {"type": "TEXT", "inferred": False},
                    "prenom": {"type": "TEXT", "inferred": True},
                    "email": {"type": "TEXT", "inferred": True},
                    "telephone": {"type": "TEXT", "inferred": True},
                }
            }
        }
    }
    
    with open(yaml_path, 'w', encoding='utf-8') as f:
        yaml.dump(hints, f, default_flow_style=False, allow_unicode=True)


def test_fuzzy_column_matching():
    """Test fuzzy matching of column names."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database_with_typo(db_path)
        migrator = DatabaseMigrator(db_path, use_yaml_hints=False)
        
        # Test fuzzy match
        existing_cols = {"id", "name", "prnom", "emial"}
        
        # Should find "prnom" for "prenom"
        match = migrator.fuzzy_match_column("prenom", existing_cols)
        assert match == "prnom", f"Expected 'prnom', got {match}"
        
        # Should find "emial" for "email"
        match = migrator.fuzzy_match_column("email", existing_cols)
        assert match == "emial", f"Expected 'emial', got {match}"
        
        # Should not match unrelated columns
        match = migrator.fuzzy_match_column("telephone", existing_cols)
        assert match is None, f"Expected None, got {match}"
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_case_insensitive_matching():
    """Test case-insensitive column matching."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE test_table (
                ID INTEGER PRIMARY KEY,
                Name TEXT,
                EMail TEXT
            )
        """)
        conn.commit()
        conn.close()
        
        migrator = DatabaseMigrator(db_path, use_yaml_hints=False)
        existing_cols = {"ID", "Name", "EMail"}
        
        # Should find exact match (case-insensitive)
        match = migrator.fuzzy_match_column("id", existing_cols)
        assert match == "ID"
        
        match = migrator.fuzzy_match_column("name", existing_cols)
        assert match == "Name"
        
        match = migrator.fuzzy_match_column("email", existing_cols)
        assert match == "EMail"
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_yaml_hints_loading():
    """Test loading schema hints from YAML."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    with tempfile.NamedTemporaryFile(suffix=".yaml", delete=False, mode='w') as yaml_tmp:
        yaml_path = yaml_tmp.name
    
    try:
        create_test_database_with_typo(db_path)
        create_yaml_hints(yaml_path)
        
        migrator = DatabaseMigrator(db_path, use_yaml_hints=True)
        success = migrator.load_schema_hints(yaml_path)
        
        assert success is True
        assert migrator.schema_hints is not None
        assert "tables" in migrator.schema_hints
        assert "membres" in migrator.schema_hints["tables"]
        
        # Test getting column type from hints
        col_type = migrator.get_column_type_from_hints("membres", "email")
        assert col_type == "TEXT"
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)
        if os.path.exists(yaml_path):
            os.unlink(yaml_path)


def test_column_rename_support_check():
    """Test checking SQLite RENAME COLUMN support."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        create_test_database_with_typo(db_path)
        migrator = DatabaseMigrator(db_path, use_yaml_hints=False)
        
        conn = sqlite3.connect(db_path)
        supports_rename = migrator.check_rename_column_support(conn)
        conn.close()
        
        # Modern SQLite should support RENAME COLUMN
        assert isinstance(supports_rename, bool)
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_migration_with_fuzzy_match_and_rename():
    """Test migration with fuzzy matching and column renaming."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    with tempfile.NamedTemporaryFile(suffix=".yaml", delete=False, mode='w') as yaml_tmp:
        yaml_path = yaml_tmp.name
    
    try:
        create_test_database_with_typo(db_path)
        create_yaml_hints(yaml_path)
        
        migrator = DatabaseMigrator(db_path, use_yaml_hints=True)
        migrator.load_schema_hints(yaml_path)
        migrator.create_backup()
        
        conn = sqlite3.connect(db_path)
        
        # Check SQLite version for RENAME support
        supports_rename = migrator.check_rename_column_support(conn)
        
        existing_schema = migrator.get_existing_schema(conn)
        missing = migrator.detect_missing_columns(existing_schema)
        
        # Should detect missing columns with fuzzy matches
        assert "membres" in missing
        
        # Find the entries for prenom and email
        membres_missing = missing["membres"]
        prenom_entry = next((e for e in membres_missing if e[0] == "prenom"), None)
        email_entry = next((e for e in membres_missing if e[0] == "email"), None)
        
        assert prenom_entry is not None, "prenom should be detected as missing"
        assert prenom_entry[3] == "prnom", "Should find 'prnom' as fuzzy match for 'prenom'"
        
        assert email_entry is not None, "email should be detected as missing"
        assert email_entry[3] == "emial", "Should find 'emial' as fuzzy match for 'email'"
        
        # Apply migrations
        success = migrator.apply_migrations(conn, missing)
        assert success is True
        
        # Verify the result
        cursor = conn.cursor()
        cursor.execute("PRAGMA table_info(membres)")
        columns = {row[1] for row in cursor.fetchall()}
        
        # Should have correct column names now
        assert "prenom" in columns or "prnom" in columns
        assert "email" in columns or "emial" in columns
        
        # If rename was supported, old names should be gone
        if supports_rename:
            assert "prenom" in columns, "prenom should exist after rename"
            assert "email" in columns, "email should exist after rename"
        
        # Verify data preservation
        cursor.execute("SELECT name FROM membres WHERE id = 1")
        row = cursor.fetchone()
        assert row[0] == "Dupont", "Data should be preserved"
        
        conn.close()
        
        # Clean up backup
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)
        if os.path.exists(yaml_path):
            os.unlink(yaml_path)


def test_migration_without_yaml_hints():
    """Test that migration still works without YAML hints (using only REFERENCE_SCHEMA)."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE config (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                exercice TEXT
            )
        """)
        conn.commit()
        conn.close()
        
        # Run migration without YAML hints
        migrator = DatabaseMigrator(db_path, use_yaml_hints=False)
        success = migrator.run_migration()
        
        # Should still work using REFERENCE_SCHEMA
        assert success is True
        
        # Verify columns were added
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("PRAGMA table_info(config)")
        columns = {row[1] for row in cursor.fetchall()}
        conn.close()
        
        # Should have added missing columns from REFERENCE_SCHEMA
        assert "date" in columns
        assert "but_asso" in columns
        
        # Clean up
        if migrator.backup_path and os.path.exists(migrator.backup_path):
            os.unlink(migrator.backup_path)
        if migrator.report_path and os.path.exists(migrator.report_path):
            os.unlink(migrator.report_path)
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_type_inference():
    """Test that column types are correctly inferred from YAML hints."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    with tempfile.NamedTemporaryFile(suffix=".yaml", delete=False, mode='w') as yaml_tmp:
        yaml_path = yaml_tmp.name
    
    try:
        # Create a minimal database
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("CREATE TABLE test_table (id INTEGER PRIMARY KEY)")
        conn.commit()
        conn.close()
        
        # Create YAML with various types
        hints = {
            "schema_version": "1.0",
            "tables": {
                "test_table": {
                    "expected_columns": {
                        "id": {"type": "INTEGER", "inferred": False},
                        "montant": {"type": "REAL", "inferred": True},
                        "quantite": {"type": "INTEGER", "inferred": True},
                        "description": {"type": "TEXT", "inferred": True},
                    }
                }
            }
        }
        
        with open(yaml_path, 'w', encoding='utf-8') as f:
            yaml.dump(hints, f)
        
        migrator = DatabaseMigrator(db_path, use_yaml_hints=True)
        migrator.load_schema_hints(yaml_path)
        
        # Check type retrieval
        assert migrator.get_column_type_from_hints("test_table", "montant") == "REAL"
        assert migrator.get_column_type_from_hints("test_table", "quantite") == "INTEGER"
        assert migrator.get_column_type_from_hints("test_table", "description") == "TEXT"
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)
        if os.path.exists(yaml_path):
            os.unlink(yaml_path)


if __name__ == "__main__":
    # Run tests
    test_fuzzy_column_matching()
    print("âœ“ test_fuzzy_column_matching")
    
    test_case_insensitive_matching()
    print("âœ“ test_case_insensitive_matching")
    
    test_yaml_hints_loading()
    print("âœ“ test_yaml_hints_loading")
    
    test_column_rename_support_check()
    print("âœ“ test_column_rename_support_check")
    
    test_migration_with_fuzzy_match_and_rename()
    print("âœ“ test_migration_with_fuzzy_match_and_rename")
    
    test_migration_without_yaml_hints()
    print("âœ“ test_migration_without_yaml_hints")
    
    test_type_inference()
    print("âœ“ test_type_inference")
    
    print("\nAll smart migration tests passed!")

```


# ===== FICHIER SUIVANT =====

# === Fichier: tests/test_startup_schema_check.py ===

```python
"""
Tests for the startup_schema_check module.
"""

import os
import sys
import sqlite3
import tempfile
from pathlib import Path
from unittest.mock import MagicMock

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

# Mock tkinter before importing startup_schema_check
sys.modules['tkinter'] = MagicMock()

from ui.startup_schema_check import (
    get_expected_schema,
    get_real_schema,
    detect_missing_columns
)


def test_get_expected_schema():
    """Test that expected schema is loaded from REFERENCE_SCHEMA."""
    expected = get_expected_schema()
    
    # Should contain tables from REFERENCE_SCHEMA
    assert isinstance(expected, dict)
    assert len(expected) > 0
    
    # Check some known tables exist
    if "events" in expected:
        assert isinstance(expected["events"], set)
        assert "id" in expected["events"]
        assert "name" in expected["events"]


def test_get_real_schema_with_database():
    """Test reading real schema from a database."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        # Create a test database
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE test_table (
                id INTEGER PRIMARY KEY,
                name TEXT,
                email TEXT
            )
        """)
        conn.commit()
        conn.close()
        
        # Get the schema
        schema = get_real_schema(db_path)
        
        assert "test_table" in schema
        assert "id" in schema["test_table"]
        assert "name" in schema["test_table"]
        assert "email" in schema["test_table"]
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


def test_get_real_schema_nonexistent_database():
    """Test that get_real_schema handles nonexistent databases."""
    schema = get_real_schema("/nonexistent/database.db")
    assert schema == {}


def test_detect_missing_columns_no_missing():
    """Test when no columns are missing."""
    expected = {
        "users": {"id", "name", "email"}
    }
    real = {
        "users": {"id", "name", "email", "created_at"}
    }
    
    missing = detect_missing_columns(expected, real)
    
    # No missing columns (real has all expected columns and more)
    assert "users" not in missing or len(missing["users"]) == 0


def test_detect_missing_columns_with_missing():
    """Test when columns are missing."""
    expected = {
        "users": {"id", "name", "email", "phone"}
    }
    real = {
        "users": {"id", "name"}
    }
    
    missing = detect_missing_columns(expected, real)
    
    assert "users" in missing
    assert "email" in missing["users"]
    assert "phone" in missing["users"]


def test_detect_missing_columns_table_not_exists():
    """Test when entire table doesn't exist in real schema."""
    expected = {
        "users": {"id", "name"},
        "products": {"id", "title"}
    }
    real = {
        "users": {"id", "name"}
    }
    
    missing = detect_missing_columns(expected, real)
    
    # products table doesn't exist, so should not be in missing
    # (update_db_structure doesn't create tables)
    assert "products" not in missing


def test_detect_missing_columns_complex():
    """Test with multiple tables and various missing columns."""
    expected = {
        "config": {"id", "exercice", "date", "but_asso"},
        "membres": {"id", "name", "email", "phone"},
        "events": {"id", "name", "date"}
    }
    real = {
        "config": {"id", "exercice"},  # Missing: date, but_asso
        "membres": {"id", "name"},     # Missing: email, phone
        "events": {"id", "name", "date"}  # Complete
    }
    
    missing = detect_missing_columns(expected, real)
    
    assert "config" in missing
    assert set(missing["config"]) == {"date", "but_asso"}
    
    assert "membres" in missing
    assert set(missing["membres"]) == {"email", "phone"}
    
    # events is complete
    assert "events" not in missing or len(missing["events"]) == 0


def test_integration_with_test_database():
    """Integration test with a real test database."""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
        db_path = tmp.name
    
    try:
        # Create a test database with missing columns
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE events (
                id INTEGER PRIMARY KEY,
                name TEXT,
                date TEXT
            )
        """)
        conn.commit()
        conn.close()
        
        # Get expected schema (will include 'description' for events)
        expected = get_expected_schema()
        
        # Get real schema
        real = get_real_schema(db_path)
        
        # Detect missing columns
        missing = detect_missing_columns(expected, real)
        
        # Should detect that 'description' is missing if it's in REFERENCE_SCHEMA
        if "events" in expected and "description" in expected["events"]:
            assert "events" in missing
            assert "description" in missing["events"]
        
    finally:
        if os.path.exists(db_path):
            os.unlink(db_path)


if __name__ == "__main__":
    # Run tests
    test_get_expected_schema()
    print("âœ“ test_get_expected_schema")
    
    test_get_real_schema_with_database()
    print("âœ“ test_get_real_schema_with_database")
    
    test_get_real_schema_nonexistent_database()
    print("âœ“ test_get_real_schema_nonexistent_database")
    
    test_detect_missing_columns_no_missing()
    print("âœ“ test_detect_missing_columns_no_missing")
    
    test_detect_missing_columns_with_missing()
    print("âœ“ test_detect_missing_columns_with_missing")
    
    test_detect_missing_columns_table_not_exists()
    print("âœ“ test_detect_missing_columns_table_not_exists")
    
    test_detect_missing_columns_complex()
    print("âœ“ test_detect_missing_columns_complex")
    
    test_integration_with_test_database()
    print("âœ“ test_integration_with_test_database")
    
    print("\nAll tests passed!")

```


# ===== FICHIER SUIVANT =====

# === Fichier: tests/test_utils.py ===

```python
import unittest
from utils.validation import is_email, is_number, is_integer, is_required

class TestValidation(unittest.TestCase):
    def test_is_email(self):
        self.assertTrue(is_email("test@ex.com"))
        self.assertFalse(is_email("toto"))
        self.assertFalse(is_email("a@b"))
    def test_is_number(self):
        self.assertTrue(is_number("3.14"))
        self.assertTrue(is_number("12"))
        self.assertFalse(is_number("abc"))
    def test_is_integer(self):
        self.assertTrue(is_integer("10"))
        self.assertTrue(is_integer(5))
        self.assertFalse(is_integer("5.7"))
    def test_is_required(self):
        self.assertTrue(is_required("a"))
        self.assertFalse(is_required(""))
        self.assertFalse(is_required(None))

if __name__ == "__main__":
    unittest.main()
```
